cmd/examples/config-single/main.go:51:		cmds.WithShort("Minimal custom layer with single config file"),
cmd/examples/config-single/main.go:52:		cmds.WithLayersList(demoSection),
cmd/examples/config-single/main.go:90:			SkipCommandSettingsLayer: true,
cmd/examples/config-single/main.go:100:	// validate command: checks the config file against layer definitions
cmd/examples/config-single/main.go:103:		Short: "Validate the config file for known layers, parameters, and types",
cmd/examples/config-single/main.go:108:			// Recreate layers like the main command
cmd/examples/config-single/main.go:125:			// Validate top-level layers and parameters
cmd/examples/config-single/main.go:126:			for layerSlug, v := range raw {
cmd/examples/config-single/main.go:127:				layer, ok := demoCmd.Description().Layers.Get(layerSlug)
cmd/examples/config-single/main.go:129:					issues = append(issues, fmt.Sprintf("unknown layer: %s", layerSlug))
cmd/examples/config-single/main.go:134:					issues = append(issues, fmt.Sprintf("layer %s must be an object", layerSlug))
cmd/examples/config-single/main.go:137:				pds := layer.GetDefinitions()
cmd/examples/config-single/main.go:138:				// Build set of known parameter names
cmd/examples/config-single/main.go:145:						issues = append(issues, fmt.Sprintf("unknown parameter in layer %s: %s", layerSlug, key))
cmd/examples/config-single/main.go:150:						issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))
cmd/examples/refactor-new-packages/main.go:19:// AppSettings maps to the app section parameters
cmd/examples/refactor-new-packages/main.go:26:// OutputSettings maps to the output section parameters
cmd/examples/refactor-new-packages/main.go:99:		schema.WithDescription("Default parameters"),
cmd/examples/refactor-new-packages/main.go:198:			// AppName enables env prefix DEMO_<LAYER_PREFIX+FLAG>
cmd/examples/new-api-build-first-command/main.go:154:			ShortHelpLayers: []string{schema.DefaultSlug},
pkg/codegen/glazed.go:16:func ParameterDefinitionToDict(p *fields.Definition) (jen.Code, error) {
pkg/codegen/glazed.go:43:	d, err := p.CheckParameterDefaultValueValidity()
pkg/codegen/glazed.go:51:func FlagTypeToGoType(s *jen.Statement, parameterType fields.Type) *jen.Statement {
pkg/codegen/glazed.go:52:	switch parameterType {
pkg/codegen/glazed.go:87:		return s.Id(string(parameterType))
cmd/examples/config-pattern-mapper/main.go:49:	demoLayer, err := schema.NewSection(
cmd/examples/config-pattern-mapper/main.go:51:		"Demo Layer",
cmd/examples/config-pattern-mapper/main.go:64:	paramLayers := schema.NewSchema(schema.WithSections(demoLayer))
cmd/examples/config-pattern-mapper/main.go:78:		mapper, err := pm.NewConfigMapper(paramLayers, rules...)
cmd/examples/config-pattern-mapper/main.go:100:		mapper, err := pm.NewConfigMapper(paramLayers,
cmd/examples/config-pattern-mapper/main.go:103:				TargetLayer:     "demo",
cmd/examples/config-pattern-mapper/main.go:104:				TargetParameter: "api-key",
cmd/examples/config-pattern-mapper/main.go:108:				TargetLayer:     "demo",
cmd/examples/config-pattern-mapper/main.go:109:				TargetParameter: "threshold",
cmd/examples/config-pattern-mapper/main.go:133:		mapper, err := pm.NewConfigMapper(paramLayers,
cmd/examples/config-pattern-mapper/main.go:136:				TargetLayer:     "demo",
cmd/examples/config-pattern-mapper/main.go:137:				TargetParameter: "{env}-api-key",
cmd/examples/config-pattern-mapper/main.go:161:		mapper, err := pm.NewConfigMapper(paramLayers,
cmd/examples/config-pattern-mapper/main.go:164:				TargetLayer: "demo",
cmd/examples/config-pattern-mapper/main.go:166:					{Source: "api_key", TargetParameter: "api-key"},
cmd/examples/config-pattern-mapper/main.go:167:					{Source: "threshold", TargetParameter: "threshold"},
cmd/examples/config-pattern-mapper/main.go:168:					{Source: "timeout", TargetParameter: "timeout"},
cmd/examples/config-pattern-mapper/main.go:193:		mapper, err := pm.NewConfigMapper(paramLayers,
cmd/examples/config-pattern-mapper/main.go:196:				TargetLayer: "demo",
cmd/examples/config-pattern-mapper/main.go:199:					{Source: "api_key", TargetParameter: "{env}-api-key"},
cmd/examples/config-pattern-mapper/main.go:221:	// Example 5: Using with LoadParametersFromFile middleware
cmd/examples/config-pattern-mapper/main.go:222:	fmt.Println("=== Example 5: Integration with LoadParametersFromFile ===")
cmd/examples/config-pattern-mapper/main.go:224:		mapper, err := pm.NewConfigMapper(paramLayers,
cmd/examples/config-pattern-mapper/main.go:227:				TargetLayer:     "demo",
cmd/examples/config-pattern-mapper/main.go:228:				TargetParameter: "api-key",
cmd/examples/config-pattern-mapper/main.go:235:		// Use the pattern mapper with sources.FromFile (wraps LoadParametersFromFile)
cmd/examples/config-pattern-mapper/main.go:242:		fmt.Println("Pattern mapper can be used with LoadParametersFromFile middleware")
cmd/examples/config-pattern-mapper/main.go:249:		b := pm.NewConfigMapperBuilder(paramLayers).
cmd/examples/config-pattern-mapper/main.go:274:		b := pm.NewConfigMapperBuilder(paramLayers).
cmd/examples/config-pattern-mapper/main.go:301:		b := pm.NewConfigMapperBuilder(paramLayers).
cmd/examples/config-pattern-mapper/main.go:330:		mapper, err := pm.NewConfigMapper(paramLayers, rules...)
cmd/examples/config-pattern-mapper/mappings.yaml:3:    target_layer: "demo"
cmd/examples/config-pattern-mapper/mappings.yaml:6:        target_parameter: "{env}-api-key"
cmd/examples/config-overlay/main.go:37:	desc := cmds.NewCommandDescription("overlay", cmds.WithShort("Multiple config overlays"), cmds.WithLayersList(demo))
cmd/examples/config-overlay/main.go:80:			SkipCommandSettingsLayer: true,
cmd/examples/config-overlay/main.go:117:				for layerSlug, v := range raw {
cmd/examples/config-overlay/main.go:118:					layer, ok := overlayCmd.Description().Layers.Get(layerSlug)
cmd/examples/config-overlay/main.go:120:						issues = append(issues, fmt.Sprintf("%s: unknown layer %s", f, layerSlug))
cmd/examples/config-overlay/main.go:125:						issues = append(issues, fmt.Sprintf("%s: layer %s must be an object", f, layerSlug))
cmd/examples/config-overlay/main.go:128:					pds := layer.GetDefinitions()
cmd/examples/config-overlay/main.go:133:							issues = append(issues, fmt.Sprintf("%s: unknown parameter %s.%s", f, layerSlug, key))
cmd/examples/config-overlay/main.go:138:							issues = append(issues, fmt.Sprintf("%s: invalid value for %s.%s: %v", f, layerSlug, key, err))
CHANGELOG:10:- Parse Lua tables into Glazed parameter layers
cmd/examples/overlay-override/main.go:38:	desc := cmds.NewCommandDescription("overlay-override", cmds.WithShort("--config-file + <base>.override.yaml pattern"), cmds.WithLayersList(demo))
cmd/examples/appconfig-profiles/main.go:47:	redisLayer := mustSection(schema.NewSection(
cmd/examples/appconfig-profiles/main.go:107:			if err := parser.Register("redis", redisLayer, func(t *AppSettings) any { return &t.Redis }); err != nil {
cmd/examples/appconfig-profiles/main.go:129:	_ = addLayer(root, redisLayer)
cmd/examples/appconfig-profiles/main.go:130:	if psLayer, err := cli.NewProfileSettingsLayer(); err == nil {
cmd/examples/appconfig-profiles/main.go:131:		_ = addLayer(root, psLayer)
cmd/examples/appconfig-profiles/main.go:148:func addLayer(cmd *cobra.Command, layer schema.Section) error {
cmd/examples/appconfig-profiles/main.go:149:	cobraLayer, ok := layer.(schema.CobraSection)
cmd/examples/appconfig-profiles/main.go:151:		return errors.Errorf("layer %s is not a CobraSection", layer.GetSlug())
cmd/examples/appconfig-profiles/main.go:153:	return cobraLayer.AddLayerToCobraCommand(cmd)
README.md:8:Glazed is a comprehensive Go framework for building command-line applications that handle structured data elegantly. It provides a rich command system, flexible parameter management, multiple output formats, and an integrated help system.
README.md:76:### Parameter Layer System
README.md:77:Organize command parameters into reusable, composable layers:
README.md:81:- Type-safe parameter extraction
README.md:103:func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
README.md:114:    parsedLayers *values.Values,
README.md:135:## Parameter Layers
README.md:137:Organize command parameters into logical, reusable groups:
README.md:140:// Define layers for different concerns
README.md:141:func NewDatabaseLayer() *schema.Section {
README.md:150:// Use layers in command definitions
README.md:152:    cmds.WithLayersList(
README.md:153:        databaseLayer,
README.md:154:        loggingLayer, 
README.md:155:        glazedLayer,
README.md:161:- Reuse common parameter sets across commands
README.md:162:- Avoid parameter naming conflicts with prefixes
README.md:163:- Type-safe parameter extraction with structs
README.md:265:- [Parameter Layers Guide](pkg/doc/topics/layers-guide.md) - Layer system with examples
README.md:273:- Parameter layer usage
cmd/examples/middlewares-config-env/main.go:18:// DemoSettings maps to the demo layer parameters
cmd/examples/middlewares-config-env/main.go:59:		cmds.WithLayersList(glazedSection, demoSection),
cmd/examples/middlewares-config-env/main.go:100:			// AppName enables env prefix APP_<LAYER_PREFIX+FLAG>
pkg/appconfig/options.go:80:// WithValuesForLayers configures programmatic values for layers (optional).
pkg/appconfig/options.go:81:func WithValuesForLayers(values map[string]map[string]interface{}) ParserOption {
pkg/appconfig/options.go:176:// It does a mini "bootstrap parse" for the `profile-settings` layer to resolve:
pkg/appconfig/options.go:193:// must ensure those flags exist on the command (typically by adding the ProfileSettings layer
pkg/appconfig/options.go:222:				return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/appconfig/options.go:224:					psLayer, err := cli.NewProfileSettingsLayer()
pkg/appconfig/options.go:229:					bootstrapLayers := schema.NewSchema(schema.WithSections(psLayer))
pkg/appconfig/options.go:268:					if err := cmd_sources.Execute(bootstrapLayers, bootstrapParsed, bootstrapMiddlewares...); err != nil {
pkg/appconfig/options.go:291:					if err := next(layers_, parsedLayers); err != nil {
pkg/appconfig/options.go:295:					// 3) Apply profiles.yaml at the intended precedence layer.
pkg/appconfig/options.go:308:					return handler(layers_, parsedLayers)
pkg/lua/lua.go:19:func ParseNestedLuaTableToValues(L *lua.LState, luaTable *lua.LTable, parameterLayers *schema.Schema) (*values.Values, error) {
pkg/lua/lua.go:20:	parsedLayers := values.New()
pkg/lua/lua.go:25:			layerName := string(keyStr)
pkg/lua/lua.go:26:			layer, ok := parameterLayers.Get(layerName)
pkg/lua/lua.go:28:				conversionErrors = append(conversionErrors, fmt.Sprintf("layer '%s' not found", layerName))
pkg/lua/lua.go:33:				parsedLayer, err := ParseLuaTableToLayer(L, nestedTable, layer)
pkg/lua/lua.go:37:					parsedLayers.Set(layerName, parsedLayer)
pkg/lua/lua.go:40:				conversionErrors = append(conversionErrors, fmt.Sprintf("invalid value for layer '%s': expected table, got %s", layerName, value.Type()))
pkg/lua/lua.go:46:		return nil, fmt.Errorf("parameter conversion errors: %s", strings.Join(conversionErrors, "; "))
pkg/lua/lua.go:49:	return parsedLayers, nil
pkg/lua/lua.go:52:// ParseLuaTableToLayer parses a Lua table into a SectionValues
pkg/lua/lua.go:53:func ParseLuaTableToLayer(L *lua.LState, luaTable *lua.LTable, layer schema.Section) (*values.SectionValues, error) {
pkg/lua/lua.go:59:			paramDef, _ := layer.GetDefinitions().Get(string(keyStr))
pkg/lua/lua.go:61:				convertedValue, err := ParseParameterFromLua(L, value, paramDef)
pkg/lua/lua.go:72:		return nil, fmt.Errorf("parameter conversion errors: %s", strings.Join(conversionErrors, "; "))
pkg/lua/lua.go:75:	// Parse parameters using the layer's definitions
pkg/lua/lua.go:76:	parsedParams, err := layer.GetDefinitions().GatherParametersFromMap(params, true, fields.WithSource("lua"))
pkg/lua/lua.go:81:	// Create a parsed layer
pkg/lua/lua.go:82:	return values.NewSectionValues(layer, values.WithParameters(parsedParams))
pkg/lua/lua.go:86:func ParseLuaTableMiddleware(L *lua.LState, luaTable *lua.LTable, layerName string) sources.Middleware {
pkg/lua/lua.go:88:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/lua/lua.go:89:			// Look up the specific layer
pkg/lua/lua.go:90:			layer, ok := layers_.Get(layerName)
pkg/lua/lua.go:92:				return fmt.Errorf("layer '%s' not found", layerName)
pkg/lua/lua.go:95:			parsedLayer, err := ParseLuaTableToLayer(L, luaTable, layer)
pkg/lua/lua.go:100:			err = parsedLayers.GetOrCreate(layer).MergeParameters(parsedLayer)
pkg/lua/lua.go:105:			return next(layers_, parsedLayers)
pkg/lua/lua.go:113:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/lua/lua.go:114:			newValues, err := ParseNestedLuaTableToValues(L, luaTable, layers_)
pkg/lua/lua.go:119:			// Merge the new parsed layers with the existing ones
pkg/lua/lua.go:120:			err = parsedLayers.Merge(newValues)
pkg/lua/lua.go:125:			return next(layers_, parsedLayers)
pkg/lua/lua.go:130:// ParseParameterFromLua parses a Lua value into a Go value based on the parameter definition
pkg/lua/lua.go:131:func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error) {
pkg/lua/lua.go:137:		return nil, fmt.Errorf("invalid type for parameter '%s': expected string, got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:142:		return nil, fmt.Errorf("invalid type for parameter '%s': expected integer, got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:147:		return nil, fmt.Errorf("invalid type for parameter '%s': expected float, got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:152:		return nil, fmt.Errorf("invalid type for parameter '%s': expected boolean, got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:165:				return nil, fmt.Errorf("invalid types in string list for parameter '%s': %v", paramDef.Name, invalidTypes)
pkg/lua/lua.go:169:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (string list), got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:182:				return nil, fmt.Errorf("invalid types in integer list for parameter '%s': %v", paramDef.Name, invalidTypes)
pkg/lua/lua.go:186:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (integer list), got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:199:				return nil, fmt.Errorf("invalid types in float list for parameter '%s': %v", paramDef.Name, invalidTypes)
pkg/lua/lua.go:203:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (float list), got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:212:			return nil, fmt.Errorf("invalid choice '%s' for parameter '%s'", choice, paramDef.Name)
pkg/lua/lua.go:214:		return nil, fmt.Errorf("invalid type for parameter '%s': expected string (choice), got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:239:				return nil, fmt.Errorf("invalid types in choice list for parameter '%s': %v", paramDef.Name, invalidTypes)
pkg/lua/lua.go:242:				return nil, fmt.Errorf("invalid choices %v for parameter '%s'", invalidChoices, paramDef.Name)
pkg/lua/lua.go:246:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (choice list), got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:253:			return nil, fmt.Errorf("invalid date '%s' for parameter '%s': %v", v, paramDef.Name, err)
pkg/lua/lua.go:255:		return nil, fmt.Errorf("invalid type for parameter '%s': expected string (date), got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:266:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (key-value), got %s", paramDef.Name, value.Type())
pkg/lua/lua.go:276:		return nil, fmt.Errorf("parameter type '%s' for '%s' is not implemented for Lua conversion", paramDef.Type, paramDef.Name)
pkg/lua/lua.go:278:	return nil, fmt.Errorf("unsupported parameter type '%s' for '%s'", paramDef.Type, paramDef.Name)
pkg/lua/lua.go:419:func SectionValuesToLuaTable(L *lua.LState, parsedLayer *values.SectionValues) *lua.LTable {
pkg/lua/lua.go:420:	luaTable := L.CreateTable(0, len(parsedLayer.Parameters.ToMap()))
pkg/lua/lua.go:422:	parsedLayer.Parameters.ForEach(func(name string, param *fields.ParsedParameter) {
pkg/lua/lua.go:430:func ValuesToLuaTable(L *lua.LState, parsedLayers *values.Values) *lua.LTable {
pkg/lua/lua.go:431:	luaTable := L.CreateTable(0, parsedLayers.Len())
pkg/lua/lua.go:433:	parsedLayers.ForEach(func(layerName string, parsedLayer *values.SectionValues) {
pkg/lua/lua.go:434:		layerTable := SectionValuesToLuaTable(L, parsedLayer)
pkg/lua/lua.go:435:		luaTable.RawSetString(layerName, layerTable)
pkg/appconfig/parser_test.go:26:func newTestRedisLayer(defaultHost string) schema.Section {
pkg/appconfig/parser_test.go:27:	layer, err := schema.NewSection(
pkg/appconfig/parser_test.go:42:	return layer
pkg/appconfig/parser_test.go:46:	const redisSlug LayerSlug = "redis"
pkg/appconfig/parser_test.go:47:	layer := newTestRedisLayer("default")
pkg/appconfig/parser_test.go:52:		err = p.Register("", layer, func(t *testAppSettings) any { return &t.Redis })
pkg/appconfig/parser_test.go:56:	t.Run("nil layer", func(t *testing.T) {
pkg/appconfig/parser_test.go:66:		err = p.Register(redisSlug, layer, nil)
pkg/appconfig/parser_test.go:70:	t.Run("slug mismatch with layer.GetSlug", func(t *testing.T) {
pkg/appconfig/parser_test.go:73:		err = p.Register(LayerSlug("not-redis"), layer, func(t *testAppSettings) any { return &t.Redis })
pkg/appconfig/parser_test.go:80:		require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))
pkg/appconfig/parser_test.go:81:		err = p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis })
pkg/appconfig/parser_test.go:87:	const redisSlug LayerSlug = "redis"
pkg/appconfig/parser_test.go:88:	layer := newTestRedisLayer("default")
pkg/appconfig/parser_test.go:91:		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{
pkg/appconfig/parser_test.go:95:		require.NoError(t, p.Register(redisSlug, layer, func(_ *testAppSettings) any { return nil }))
pkg/appconfig/parser_test.go:102:		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{
pkg/appconfig/parser_test.go:106:		require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return t.Redis }))
pkg/appconfig/parser_test.go:113:		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{
pkg/appconfig/parser_test.go:117:		require.NoError(t, p.Register(redisSlug, layer, func(_ *testAppSettings) any {
pkg/appconfig/parser_test.go:128:	const redisSlug LayerSlug = "redis"
pkg/appconfig/parser_test.go:129:	layer := newTestRedisLayer("default")
pkg/appconfig/parser_test.go:135:	p, err := NewParser[app](WithValuesForLayers(map[string]map[string]interface{}{
pkg/appconfig/parser_test.go:139:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/parser_test.go:148:	const redisSlug LayerSlug = "redis"
pkg/appconfig/parser_test.go:149:	layer := newTestRedisLayer("from-default")
pkg/appconfig/parser_test.go:163:	require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))
pkg/appconfig/parser_test.go:171:	const redisSlug LayerSlug = "redis"
pkg/appconfig/parser_test.go:172:	layer := newTestRedisLayer("from-default")
pkg/appconfig/parser_test.go:186:			require.NoError(t, parser.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))
pkg/appconfig/parser_test.go:195:	// IMPORTANT: appconfig.Parser expects the layer flags to already be on the cobra command.
pkg/appconfig/parser_test.go:196:	cobraLayer, ok := layer.(schema.CobraSection)
pkg/appconfig/parser_test.go:197:	require.True(t, ok, "test layer must implement schema.CobraSection")
pkg/appconfig/parser_test.go:198:	require.NoError(t, cobraLayer.AddLayerToCobraCommand(rootCmd))
prompto/glazed/parameters-verbose:4:glaze help parameter-layers-and-parsed-layers 2>&1
prompto/glazed/parameters-verbose:8:glaze help parsing-parameters 2>&1
prompto/glazed/parameters-verbose:13:prompto get glazed/parameters
prompto/glazed/main.md:161:### Custom Help Layers
prompto/glazed/main.md:168:// Implement your custom help layer
pkg/appconfig/parser.go:13:	slug  LayerSlug
pkg/appconfig/parser.go:14:	layer schema.Section
pkg/appconfig/parser.go:18:// LayerSlug is a distinct type to encourage declaring layer slugs as constants.
pkg/appconfig/parser.go:22://	const RedisSlug appconfig.LayerSlug = "redis"
pkg/appconfig/parser.go:23:type LayerSlug string
pkg/appconfig/parser.go:26:// - callers register layers and bind them to sub-struct pointers inside T
pkg/appconfig/parser.go:52:// Register associates a layer slug and ParameterLayer with a binder that returns
pkg/appconfig/parser.go:57:// - layer must be non-nil
pkg/appconfig/parser.go:59:// - slug must match layer.GetSlug() (to avoid mismatches between registration keys and parsed layer keys)
pkg/appconfig/parser.go:60:func (p *Parser[T]) Register(slug LayerSlug, layer schema.Section, bind func(*T) any) error {
pkg/appconfig/parser.go:64:	if layer == nil {
pkg/appconfig/parser.go:65:		return errors.New("layer must not be nil")
pkg/appconfig/parser.go:70:	if layer.GetSlug() != string(slug) {
pkg/appconfig/parser.go:71:		return errors.Errorf("slug %q does not match layer.GetSlug() %q", string(slug), layer.GetSlug())
pkg/appconfig/parser.go:75:			return errors.Errorf("layer slug %q already registered", string(slug))
pkg/appconfig/parser.go:78:	p.regs = append(p.regs, registration[T]{slug: slug, layer: layer, bind: bind})
pkg/appconfig/parser.go:85:		return nil, errors.New("no layers registered")
pkg/appconfig/parser.go:88:	paramLayers := schema.NewSchema()
pkg/appconfig/parser.go:90:		paramLayers.Set(string(r.slug), r.layer)
pkg/appconfig/parser.go:104:	parsedLayers := values.New()
pkg/appconfig/parser.go:105:	if err := cmd_sources.Execute(paramLayers, parsedLayers, execMiddlewares...); err != nil {
pkg/appconfig/parser.go:106:		return nil, errors.Wrap(err, "failed to parse parameters")
pkg/appconfig/parser.go:113:			return nil, errors.Errorf("bind returned nil for layer %q", string(r.slug))
pkg/appconfig/parser.go:117:			return nil, errors.Errorf("bind for layer %q must return a non-nil pointer, got %T", string(r.slug), dst)
pkg/appconfig/parser.go:119:		if err := parsedLayers.InitializeStruct(string(r.slug), dst); err != nil {
pkg/appconfig/parser.go:120:			return nil, errors.Wrapf(err, "failed to initialize settings for layer %q", string(r.slug))
pkg/lua/cmds.go:21:// CallGlazedCommandFromLua executes a GlazeCommand with parameters from a Lua table
pkg/lua/cmds.go:23:	// Create parsed layers
pkg/lua/cmds.go:24:	parsedLayers := values.New()
pkg/lua/cmds.go:35:	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)
pkg/lua/cmds.go:40:	glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)
pkg/lua/cmds.go:42:		return nil, fmt.Errorf("glazed layer not found")
pkg/lua/cmds.go:44:	gp, err := settings.SetupTableProcessor(glazedLayer, middlewares2.WithTableMiddleware(&table.NullTableMiddleware{}))
pkg/lua/cmds.go:51:	// Run the command with the parsed layers
pkg/lua/cmds.go:52:	err = cmd.RunIntoGlazeProcessor(ctx, parsedLayers, gp)
pkg/lua/cmds.go:91:// CallGlazedBareCommandFromLua executes a BareCcommand with parameters from a Lua table
pkg/lua/cmds.go:93:	parsedLayers := values.New()
pkg/lua/cmds.go:100:	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)
pkg/lua/cmds.go:107:	// Run the command with the parsed layers
pkg/lua/cmds.go:108:	err = cmd.Run(ctx, parsedLayers)
pkg/lua/cmds.go:116:// CallGlazedWriterCommandFromLua executes a WriterCommand with parameters from a Lua table
pkg/lua/cmds.go:118:	parsedLayers := values.New()
pkg/lua/cmds.go:125:	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)
pkg/lua/cmds.go:135:	// Run the command with the parsed layers
pkg/lua/cmds.go:136:	err = cmd.RunIntoWriter(ctx, parsedLayers, &buf)
pkg/lua/cmds.go:244:	// Update the parameter information global name
pkg/lua/cmds.go:250:	// Create a table to hold all layers and their parameters
pkg/lua/cmds.go:251:	layersTable := L.CreateTable(0, desc.Layers.Len())
pkg/lua/cmds.go:253:	// Iterate through all layers
pkg/lua/cmds.go:254:	desc.Layers.ForEach(func(layerName string, layer schema.Section) {
pkg/lua/cmds.go:255:		layerTable := L.CreateTable(0, layer.GetDefinitions().Len())
pkg/lua/cmds.go:257:		// Add parameters for this layer
pkg/lua/cmds.go:258:		layer.GetDefinitions().ForEach(func(param *fields.Definition) {
pkg/lua/cmds.go:266:			layerTable.RawSetString(param.Name, paramInfo)
pkg/lua/cmds.go:269:		layersTable.RawSetString(layerName, layerTable)
pkg/lua/cmds.go:272:	// Set the global variable with the layers table
pkg/lua/cmds.go:273:	L.SetGlobal(paramsGlobalName, layersTable)
pkg/appconfig/doc.go:5:// deriving layers from structs. Instead, callers explicitly register Glazed
pkg/appconfig/doc.go:6:// ParameterLayers and bind them to fields inside a grouped settings struct T.
pkg/appconfig/profile_test.go:15:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:16:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:40:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/profile_test.go:48:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:49:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:75:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/profile_test.go:83:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:84:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:114:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/profile_test.go:122:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:123:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:151:			require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/profile_test.go:161:	psLayer, err := cli.NewProfileSettingsLayer()
pkg/appconfig/profile_test.go:163:	require.NoError(t, psLayer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))
pkg/appconfig/profile_test.go:165:	// Also add the redis layer flags (not strictly needed for this test, but keeps the pattern consistent).
pkg/appconfig/profile_test.go:166:	require.NoError(t, layer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))
pkg/appconfig/profile_test.go:173:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:174:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:208:			require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/profile_test.go:218:	require.NoError(t, layer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))
pkg/appconfig/profile_test.go:219:	psLayer, err := cli.NewProfileSettingsLayer()
pkg/appconfig/profile_test.go:221:	require.NoError(t, psLayer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))
pkg/appconfig/profile_test.go:228:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:229:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:247:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/profile_test.go:255:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:256:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:275:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
pkg/appconfig/profile_test.go:282:	const redisSlug LayerSlug = "redis"
pkg/appconfig/profile_test.go:283:	layer := newTestRedisLayer("from-default")
pkg/appconfig/profile_test.go:303:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))
prompto/glazed/create-yaml-command.md:38:   Parameters can be defined either as flags (with -- prefix) or positional arguments. Both use the same parameter definition structure, just with different usage patterns. Each entry describes one parameter with fields such as:
prompto/glazed/create-yaml-command.md:39:   - `name` (required): The parameter name.
prompto/glazed/create-yaml-command.md:40:   - `type` (required): The parameter type.
prompto/glazed/create-yaml-command.md:43:   - `required` (optional, boolean): Indicates if this parameter must be supplied.
prompto/glazed/create-yaml-command.md:51:   - For single numeric parameters, `type` can be `int` or `float`.  
prompto/glazed/create-yaml-command.md:52:   - For textual parameters, `type` can be `string`.  
prompto/glazed/create-yaml-command.md:54:   - Arguments are positional parameters that don't use -- prefix
prompto/glazed/create-yaml-command.md:83:- **flags** includes three parameters:
prompto/glazed/create-yaml-command.md:95:- name: <parameter-name>
prompto/glazed/create-yaml-command.md:96:  type: <parameter-type>
prompto/glazed/create-yaml-command.md:106:  Unique parameter name (e.g. `limit`, `from`, `status`), used at the command line as `--limit=...` or similar.
prompto/glazed/create-yaml-command.md:109:  Indicates how this parameter is interpreted. Common types:
prompto/glazed/create-yaml-command.md:124:  14. (Less common) **stringFromFile**, **objectFromFile**, **stringListFromFile**, **objectListFromFile**: Indicate the parameter is read from a file or multiple files. Typically used in advanced scenarios.
prompto/glazed/create-yaml-command.md:272:- Both flags and arguments use the same parameter definition structure
prompto/glazed/create-yaml-command.md:324:   - `name`: parameter/flag name
prompto/glazed/create-yaml-command.md:325:   - `type`: see typical parameter types (e.g., `string`, `int`, `bool`, `date`, etc.)
prompto/glazed/create-yaml-command.md:331:Use this structure whenever you define a new YAML command file. The system that loads it will parse these fields and make your parameters available under the indicated names.
prompto/glazed/create-yaml-command.md:345:2. **Flags (Parameters)**  
prompto/glazed/create-yaml-command.md:346:   - Under `flags:`, each item (e.g. `- name: name`, `type: stringList`, etc.) is turned into a `ParameterDefinition`.
prompto/glazed/create-yaml-command.md:357:   - The system aggregates these into a "default layer" of parameters.  
prompto/glazed/create-yaml-command.md:358:   - `required: false`, `default: ...`, and `help: ...` become `WithRequired(false)`, `WithDefault(...)`, `WithHelp(...)` in the `ParameterDefinition` construction.
prompto/glazed/create-yaml-command.md:360:Hence, the **top-level YAML keys**—`name`, `metadata`, `short`, `long`, and `flags`—**map to** the **fields and parameter layers** in a `CommandDescription` object. The `query:` would likewise be used by a specialized command that actually runs a SQL query, but the fundamental principle of turning flags into typed parameters remains the same.
pinocchio/glazed/create-template-command.yaml:66:  The types of parameters that can be used for flags are:
pinocchio/glazed/create-template-command.yaml:67:  - ParameterTypeString: "string"
pinocchio/glazed/create-template-command.yaml:68:  - ParameterTypeStringFromFile: "stringFromFile" -> string
pinocchio/glazed/create-template-command.yaml:69:  - ParameterTypeObjectListFromFile: "objectListFromFile" -> []interface{}
pinocchio/glazed/create-template-command.yaml:70:  - ParameterTypeObjectFromFile: "objectFromFile" -> interface{}
pinocchio/glazed/create-template-command.yaml:71:  - ParameterTypeKeyValue: "keyValue" -> map[string]interface{}
pinocchio/glazed/create-template-command.yaml:72:  - ParameterTypeInteger: "int"
pinocchio/glazed/create-template-command.yaml:73:  - ParameterTypeFloat: "float"
pinocchio/glazed/create-template-command.yaml:74:  - ParameterTypeBool: "bool"
pinocchio/glazed/create-template-command.yaml:75:  - ParameterTypeDate: "date"
pinocchio/glazed/create-template-command.yaml:76:  - ParameterTypeStringList: "stringList"
pinocchio/glazed/create-template-command.yaml:77:  - ParameterTypeIntegerList: "intList"
pinocchio/glazed/create-template-command.yaml:78:  - ParameterTypeFloatList: "floatList"
pinocchio/glazed/create-template-command.yaml:79:  - ParameterTypeChoice: "choice" -> string
pinocchio/glazed/create-template-command.yaml:80:  - ParameterTypeChoiceList: "choiceList" -> []string
prompto/glazed/definitions:3:prompto get glazed/parameter-types
prompto/glazed/definitions:5:for i in CommandDescription ParameterDefinition ParameterLayer; do
pkg/cli/cli.go:10:func NewCreateCommandSettingsLayer() (schema.Section, error) {
pkg/cli/cli.go:11:	createCommandSettingsLayer, err := schema.NewSection(
pkg/cli/cli.go:36:	return createCommandSettingsLayer, nil
pkg/cli/cli.go:52:func NewProfileSettingsLayer() (schema.Section, error) {
pkg/cli/cli.go:53:	profileSettingsLayer, err := schema.NewSection(
pkg/cli/cli.go:73:	return profileSettingsLayer, nil
pkg/cli/cli.go:79:	PrintParsedParameters  bool   `glazed:"print-parsed-parameters"`
pkg/cli/cli.go:80:	LoadParametersFromFile string `glazed:"load-parameters-from-file"`
pkg/cli/cli.go:87:func NewCommandSettingsLayer() (schema.Section, error) {
pkg/cli/cli.go:88:	glazedMinimalCommandLayer, err := schema.NewSection(
pkg/cli/cli.go:98:				"print-parsed-parameters",
pkg/cli/cli.go:100:				fields.WithHelp("Print the parsed parameters"),
pkg/cli/cli.go:102:			// Deprecated: legacy per-command parameter file injection (removed from default flow)
pkg/cli/cli.go:119:	return glazedMinimalCommandLayer, nil
pkg/doc/applications/03-user-store-command.md:27:- **Configuration via YAML**: Define commands and their parameters using YAML files for easy customization.
pkg/doc/applications/03-user-store-command.md:134:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/applications/03-user-store-command.md:135:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/applications/03-user-store-command.md:169:func (c *GenerateCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {
pkg/doc/applications/03-user-store-command.md:176:    if err := parsedLayers.InitializeStruct("default", settings); err != nil {
pkg/doc/applications/03-user-store-command.md:213:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/applications/03-user-store-command.md:214:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/applications/03-user-store-command.md:236:func (c *ListCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {
pkg/doc/applications/03-user-store-command.md:265:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/applications/03-user-store-command.md:266:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/applications/03-user-store-command.md:295:func (c *DeleteCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {
pkg/doc/applications/03-user-store-command.md:301:    if err := parsedLayers.InitializeStruct("default", settings); err != nil {
cmd/examples/config-pattern-mapper/README.md:7:The pattern mapper allows you to declaratively map config file structures to layer parameters using pattern matching rules, without writing custom Go functions.
cmd/examples/config-pattern-mapper/README.md:12:2. **Named Captures**: Extract values from config paths and use them in parameter names
cmd/examples/config-pattern-mapper/README.md:31:    TargetLayer: "demo",
cmd/examples/config-pattern-mapper/README.md:32:    TargetParameter: "api-key",
cmd/examples/config-pattern-mapper/README.md:40:    TargetLayer: "demo",
cmd/examples/config-pattern-mapper/README.md:41:    TargetParameter: "{env}-api-key",  // Uses captured value
cmd/examples/config-pattern-mapper/README.md:49:    TargetLayer: "demo",
cmd/examples/config-pattern-mapper/README.md:50:    TargetParameter: "api-key",
cmd/examples/config-pattern-mapper/README.md:58:    TargetLayer: "demo",
cmd/examples/config-pattern-mapper/README.md:60:        {Source: "api_key", TargetParameter: "api-key"},
cmd/examples/config-pattern-mapper/README.md:61:        {Source: "threshold", TargetParameter: "threshold"},
cmd/examples/config-pattern-mapper/README.md:91:mapper, err := patternmapper.NewConfigMapper(layers,
cmd/examples/config-pattern-mapper/README.md:94:        TargetLayer:     "demo",
cmd/examples/config-pattern-mapper/README.md:95:        TargetParameter: "api-key",
cmd/examples/config-pattern-mapper/README.md:102:b := patternmapper.NewConfigMapperBuilder(layers).
cmd/examples/config-pattern-mapper/README.md:116:    target_layer: "demo"
cmd/examples/config-pattern-mapper/README.md:119:        target_parameter: "{env}-api-key"
cmd/examples/config-pattern-mapper/README.md:122:mapper, err := patternmapper.LoadMapperFromFile(layers, "mappings.yaml")
pkg/cli/cliopatra/program.go:19:// Parameter describes a cliopatra parameter, which can be either a flag or an argument.
pkg/cli/cliopatra/program.go:26:type Parameter struct {
pkg/cli/cliopatra/program.go:42:func (p *Parameter) Clone() *Parameter {
pkg/cli/cliopatra/program.go:66:	Flags []*Parameter `yaml:"flags,omitempty"`
pkg/cli/cliopatra/program.go:67:	// Args is an ordered list of Parameters. The Flag field is ignored.
pkg/cli/cliopatra/program.go:68:	Args []*Parameter `yaml:"args,omitempty"`
pkg/cli/cliopatra/program.go:134:func WithFlags(flags ...*Parameter) ProgramOption {
pkg/cli/cliopatra/program.go:140:func WithAddFlags(flags ...*Parameter) ProgramOption {
pkg/cli/cliopatra/program.go:146:func WithReplaceFlags(flags ...*Parameter) ProgramOption {
pkg/cli/cliopatra/program.go:164:func WithArgs(args ...*Parameter) ProgramOption {
pkg/cli/cliopatra/program.go:170:func WithAddArgs(args ...*Parameter) ProgramOption {
pkg/cli/cliopatra/program.go:176:func WithReplaceArgs(args ...*Parameter) ProgramOption {
pkg/cli/cliopatra/program.go:248:	clone.Flags = make([]*Parameter, len(p.Flags))
pkg/cli/cliopatra/program.go:252:	clone.Args = make([]*Parameter, len(p.Args))
pkg/cli/cliopatra/program.go:319:	parsedLayers *values.Values,
pkg/cli/cliopatra/program.go:331:	ps := parsedLayers.GetAllParsedParameters()
pkg/cli/cliopatra/program.go:393:func (p *Program) ComputeArgs(ps *fields.ParsedParameters) ([]string, error) {
pkg/cli/cliopatra/program.go:420:		parsedParameter, ok := ps.Get(flag.Name)
pkg/cli/cliopatra/program.go:425:			value_, err = parsedParameter.RenderValue()
pkg/cli/cliopatra/capture.go:10:func getCliopatraParameters(
pkg/cli/cliopatra/capture.go:12:	ps *fields.ParsedParameters,
pkg/cli/cliopatra/capture.go:14:) []*Parameter {
pkg/cli/cliopatra/capture.go:15:	ret := []*Parameter{}
pkg/cli/cliopatra/capture.go:32:		param := &Parameter{
pkg/cli/cliopatra/capture.go:65:// the description and the parsed layers a glazed command.
pkg/cli/cliopatra/capture.go:67:// It will go over all the ParameterDefinition (from all layers, which now also include the default layers).
pkg/cli/cliopatra/capture.go:69:// of layered fields.
pkg/cli/cliopatra/capture.go:71:// Values in the parameter map that are not present under the form of a ParameterDefinition
pkg/cli/cliopatra/capture.go:76:	parsedLayers *values.Values,
pkg/cli/cliopatra/capture.go:84:	description.Layers.ForEach(func(_ string, layer schema.Section) {
pkg/cli/cliopatra/capture.go:85:		if layer.GetSlug() == "glazed-command" {
pkg/cli/cliopatra/capture.go:89:		parsedLayer, ok := parsedLayers.Get(layer.GetSlug())
pkg/cli/cliopatra/capture.go:95:		parameters_ := getCliopatraParameters(
pkg/cli/cliopatra/capture.go:96:			layer.GetDefinitions(),
pkg/cli/cliopatra/capture.go:97:			parsedLayer.Parameters,
pkg/cli/cliopatra/capture.go:98:			layer.GetPrefix())
pkg/cli/cliopatra/capture.go:99:		flags := []*Parameter{}
pkg/cli/cliopatra/capture.go:100:		arguments := []*Parameter{}
pkg/cli/cliopatra/capture.go:102:		for _, p := range parameters_ {
pkg/cli/cobra.go:28:type CobraRunFunc func(ctx context.Context, parsedLayers *values.Values) error
pkg/cli/cobra.go:51:		// Parse layers
pkg/cli/cobra.go:52:		parsedLayers, err := parser.Parse(cmd, args)
pkg/cli/cobra.go:62:		if minimalLayer, ok := parsedLayers.Get(CommandSettingsSlug); ok {
pkg/cli/cobra.go:63:			var printYAML, printParsedParameters_, printSchema bool
pkg/cli/cobra.go:64:			err = minimalLayer.InitializeStruct(commandSettings)
pkg/cli/cobra.go:67:			printParsedParameters_ = commandSettings.PrintParsedParameters
pkg/cli/cobra.go:70:			if printParsedParameters_ {
pkg/cli/cobra.go:71:				printParsedParameters(parsedLayers)
pkg/cli/cobra.go:91:		if createLayer, ok := parsedLayers.Get(CreateCommandSettingsSlug); ok {
pkg/cli/cobra.go:93:			err = createLayer.InitializeStruct(createSettings)
pkg/cli/cobra.go:103:					parsedLayers,
pkg/cli/cobra.go:149:				layers_ := s.Description().Layers.Clone()
pkg/cli/cobra.go:154:					Layers: layers_,
pkg/cli/cobra.go:187:			glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)
pkg/cli/cobra.go:189:				cobra.CheckErr(errors.New("glazed layer not found"))
pkg/cli/cobra.go:192:			gp, err := settings.SetupTableProcessor(glazedLayer)
pkg/cli/cobra.go:194:			_, err = settings.SetupProcessorOutput(gp, glazedLayer, os.Stdout)
pkg/cli/cobra.go:203:			err = glazeCmd.RunIntoGlazeProcessor(ctx, parsedLayers, gp)
pkg/cli/cobra.go:224:		err = runFunc(ctx, parsedLayers)
pkg/cli/cobra.go:251:	// If the command implements GlazeCommand, ensure a glazed parameter layer is present
pkg/cli/cobra.go:253:		originalLayers := description.Layers
pkg/cli/cobra.go:254:		glazedLayers := originalLayers.Clone()
pkg/cli/cobra.go:255:		if _, ok := glazedLayers.Get(settings.GlazedSlug); !ok {
pkg/cli/cobra.go:256:			glLayer, err := settings.NewGlazedParameterLayers()
pkg/cli/cobra.go:260:			glazedLayers.Set(settings.GlazedSlug, glLayer)
pkg/cli/cobra.go:264:		newDesc.Layers = glazedLayers
pkg/cli/cobra.go:277:	cobraParser, err := NewCobraParserFromLayers(description.Layers, &cfg.ParserCfg)
pkg/cli/cobra.go:384:	runFunc := func(ctx context.Context, parsedLayers *values.Values) error {
pkg/cli/cobra.go:386:			err := writerCmd.RunIntoWriter(ctx, parsedLayers, os.Stdout)
pkg/cli/cobra.go:396:			err := bareCmd.Run(ctx, parsedLayers)
pkg/cli/cobra.go:503:// WithCobraShortHelpLayers sets the layers shown in short help (deprecated)
pkg/cli/cobra.go:504:func WithCobraShortHelpLayers(layers ...string) CobraOption {
pkg/cli/cobra.go:506:		c.ParserCfg.ShortHelpLayers = layers
pkg/cli/cobra.go:544:// WithSkipCommandSettingsLayer hides the command settings layer flags (deprecated)
pkg/cli/cobra.go:545:func WithSkipCommandSettingsLayer() CobraOption {
pkg/cli/cobra.go:547:		c.ParserCfg.SkipCommandSettingsLayer = true
pkg/cli/cobra.go:551:// WithProfileSettingsLayer enables the profile settings layer (deprecated)
pkg/cli/cobra.go:552:func WithProfileSettingsLayer() CobraOption {
pkg/cli/cobra.go:554:		c.ParserCfg.EnableProfileSettingsLayer = true
pkg/cli/cobra.go:558:// WithCreateCommandSettingsLayer enables the create-command settings layer (deprecated)
pkg/cli/cobra.go:559:func WithCreateCommandSettingsLayer() CobraOption {
pkg/cli/cobra.go:561:		c.ParserCfg.EnableCreateCommandSettingsLayer = true
pkg/cli/cliopatra/capture_test.go:14:func makeParsedDefaultLayer(desc *cmds.CommandDescription, ps *fields.ParsedParameters) *values.Values {
pkg/cli/cliopatra/capture_test.go:15:	defaultLayer, ok := desc.GetLayer(schema.DefaultSlug)
pkg/cli/cliopatra/capture_test.go:22:		Layer:      defaultLayer,
pkg/cli/cliopatra/capture_test.go:23:		Parameters: ps,
pkg/cli/cliopatra/capture_test.go:38:		makeParsedDefaultLayer(desc, fields.NewParsedParameters(fields.WithParsedParameter(testPd, "test", "foobar"))),
pkg/cli/cliopatra/capture_test.go:61:	p := NewProgramFromCapture(d, makeParsedDefaultLayer(d, fields.NewParsedParameters(fields.WithParsedParameter(pdTest, "test", "foobar"))))
pkg/cli/cliopatra/capture_test.go:67:	p = NewProgramFromCapture(d, makeParsedDefaultLayer(d, fields.NewParsedParameters(fields.WithParsedParameter(pdTest, "test", "foobar2"))))
pkg/cli/cliopatra/capture_test.go:90:		makeParsedDefaultLayer(d, fields.NewParsedParameters(
pkg/cli/cliopatra/capture_test.go:91:			fields.WithParsedParameter(pd1, "test", "foobar"),
pkg/cli/cliopatra/capture_test.go:92:			fields.WithParsedParameter(pd2, "test2", "foobar2"),
pkg/cli/cliopatra/capture_test.go:117:		makeParsedDefaultLayer(d,
pkg/cli/cliopatra/capture_test.go:118:			fields.NewParsedParameters(
pkg/cli/cliopatra/capture_test.go:119:				fields.WithParsedParameter(pd, "test", "foobar"))))
pkg/cli/cliopatra/capture_test.go:147:		makeParsedDefaultLayer(d, fields.NewParsedParameters(
pkg/cli/cliopatra/capture_test.go:148:			fields.WithParsedParameter(pd1, "test", "foobar"),
pkg/cli/cliopatra/capture_test.go:149:			fields.WithParsedParameter(pd2, "test2", "foobar2"),
pkg/cli/cliopatra/capture_test.go:150:			fields.WithParsedParameter(pd3, "test3", "foobar3"),
pkg/cli/cliopatra/capture_test.go:151:			fields.WithParsedParameter(pd4, "test4", "foobar4"),
pkg/cli/cliopatra/capture_test.go:177:func TestSingleLayer(t *testing.T) {
pkg/cli/cliopatra/capture_test.go:179:	layer, err2 := schema.NewSection("test-layer", "test-layer",
pkg/cli/cliopatra/capture_test.go:187:		cmds.WithLayersList(
pkg/cli/cliopatra/capture_test.go:188:			layer,
pkg/cli/cliopatra/capture_test.go:193:	ret.Set("test-layer", &values.SectionValues{
pkg/cli/cliopatra/capture_test.go:194:		Layer: layer,
pkg/cli/cliopatra/capture_test.go:195:		Parameters: fields.NewParsedParameters(
pkg/cli/cliopatra/capture_test.go:196:			fields.WithParsedParameter(pd, "test", "foobar"))})
prompto/glazed/create-application-tutorial.md:10:### 1.1 Layer Design
prompto/glazed/create-application-tutorial.md:13:   - Each layer should handle one aspect of configuration (e.g., authentication, database, output formatting)
prompto/glazed/create-application-tutorial.md:14:   - Keep parameter definitions focused and cohesive
prompto/glazed/create-application-tutorial.md:15:   - Avoid mixing unrelated parameters in the same layer
prompto/glazed/create-application-tutorial.md:18:   - Use descriptive slugs that indicate the layer's purpose (e.g., "auth", "db", "output")
prompto/glazed/create-application-tutorial.md:19:   - Follow consistent naming patterns across layers
prompto/glazed/create-application-tutorial.md:20:   - Document the purpose of each layer
prompto/glazed/create-application-tutorial.md:22:3. **Parameter Organization**
prompto/glazed/create-application-tutorial.md:23:   - Group related parameters together
prompto/glazed/create-application-tutorial.md:24:   - Use clear, descriptive parameter names
prompto/glazed/create-application-tutorial.md:29:   - Design layers to be reusable across commands
prompto/glazed/create-application-tutorial.md:30:   - Extract common parameters into shared layers
prompto/glazed/create-application-tutorial.md:31:   - Use composition to combine layers
prompto/glazed/create-application-tutorial.md:54:   - Use whitelisting to control layer access
prompto/glazed/create-application-tutorial.md:120:      layers/            # Custom parameter layers
prompto/glazed/create-application-tutorial.md:121:        auth.go         # Authentication layer
prompto/glazed/create-application-tutorial.md:122:        db.go          # Database layer
prompto/glazed/create-application-tutorial.md:123:        output.go      # Output formatting layer
prompto/glazed/create-application-tutorial.md:125:        parse.go       # Parameter parsing
prompto/glazed/create-application-tutorial.md:134:1. **Layer Definition**
prompto/glazed/create-application-tutorial.md:136:   // Define focused, single-purpose layers
prompto/glazed/create-application-tutorial.md:141:   func NewAuthLayer() (schema.Section, error) {
prompto/glazed/create-application-tutorial.md:145:           // ... focused parameter definitions
prompto/glazed/create-application-tutorial.md:299:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
prompto/glazed/create-application-tutorial.md:303:    "myapp/pkg/layers"
prompto/glazed/create-application-tutorial.md:311:    layers.AppSettings
prompto/glazed/create-application-tutorial.md:321:        cli.WithCobraShortHelpLayers(layers.AppSlug),
prompto/glazed/create-application-tutorial.md:332:    // 1. Create glazed parameter layer
prompto/glazed/create-application-tutorial.md:333:    glazedParameterLayer, err := settings.NewGlazedParameterLayers()
prompto/glazed/create-application-tutorial.md:335:        return nil, fmt.Errorf("could not create Glazed parameter layer: %w", err)
prompto/glazed/create-application-tutorial.md:338:    // 2. Create app layer
prompto/glazed/create-application-tutorial.md:339:    appLayer, err := layers.NewAppParameterLayer()
prompto/glazed/create-application-tutorial.md:341:        return nil, fmt.Errorf("could not create App parameter layer: %w", err)
prompto/glazed/create-application-tutorial.md:344:    // 3. Combine layers
prompto/glazed/create-application-tutorial.md:345:    layers_ := schema.NewSchema(layers.WithLayers(
prompto/glazed/create-application-tutorial.md:346:        glazedParameterLayer,
prompto/glazed/create-application-tutorial.md:347:        appLayer,
prompto/glazed/create-application-tutorial.md:356:            cmds.WithLayers(layers_),
prompto/glazed/create-application-tutorial.md:363:    parsedLayers *values.Values,
prompto/glazed/create-application-tutorial.md:368:    if err := parsedLayers.InitializeStruct(layers.AppSlug, &s.AppSettings); err != nil {
pkg/cli/helpers.go:18:// the glazed processing layer.
pkg/cli/helpers.go:21:// abstraction to define your CLI applications, which allows you to use Layers and other nice features
pkg/cli/helpers.go:26:	gpl, err := settings.NewGlazedParameterLayers()
pkg/cli/helpers.go:31:	layers_ := schema.NewSchema(schema.WithSections(gpl))
pkg/cli/helpers.go:32:	parser, err := NewCobraParserFromLayers(layers_, &CobraParserConfig{
pkg/cli/helpers.go:38:	parsedLayers, err := parser.Parse(cmd, nil)
pkg/cli/helpers.go:43:	parsedLayer, ok := parsedLayers.Get(settings.GlazedSlug)
pkg/cli/helpers.go:45:		return nil, nil, errors.Errorf("layer %s not found", settings.GlazedSlug)
pkg/cli/helpers.go:48:	gp, err := settings.SetupTableProcessor(parsedLayer)
pkg/cli/helpers.go:51:	of, err := settings.SetupProcessorOutput(gp, parsedLayer, os.Stdout)
pkg/cli/helpers.go:58:// the glazed processing layer to their CLI flags.
pkg/cli/helpers.go:59:func AddGlazedProcessorFlagsToCobraCommand(cmd *cobra.Command, options ...settings.GlazeParameterLayerOption) error {
pkg/cli/helpers.go:60:	gpl, err := settings.NewGlazedParameterLayers(options...)
pkg/cli/helpers.go:65:	return gpl.AddLayerToCobraCommand(cmd)
pkg/cli/helpers.go:68:func printParsedParameters(parsedLayers *values.Values) {
pkg/cli/helpers.go:69:	layersMap := map[string]map[string]interface{}{}
pkg/cli/helpers.go:70:	parsedLayers.ForEach(func(layerName string, layer *values.SectionValues) {
pkg/cli/helpers.go:72:		layer.Parameters.ForEach(func(name string, parameter *fields.ParsedParameter) {
pkg/cli/helpers.go:74:				"value": parameter.Value,
pkg/cli/helpers.go:76:			logs := make([]map[string]interface{}, 0, len(parameter.Log))
pkg/cli/helpers.go:77:			for _, l := range parameter.Log {
pkg/cli/helpers.go:92:		layersMap[layerName] = params
pkg/cli/helpers.go:97:	err := encoder.Encode(layersMap)
pkg/cli/cobra-parser.go:20:// It is mostly used to add a "load from json" layer set in the GlazedCommandSettings.
pkg/cli/cobra-parser.go:22:	parsedCommandLayers *values.Values,
pkg/cli/cobra-parser.go:28:// the middlewares used in a Cobra command. It handles parsing parameters
pkg/cli/cobra-parser.go:30:// default values. The middlewares gather all these parameters into a
pkg/cli/cobra-parser.go:31:// ParsedParameters object.
pkg/cli/cobra-parser.go:33:// If the commandSettings specify parameters to be loaded from a file, this gets added as a middleware.
pkg/cli/cobra-parser.go:35:	parsedCommandLayers *values.Values,
pkg/cli/cobra-parser.go:40:	err := parsedCommandLayers.InitializeStruct(CommandSettingsSlug, commandSettings)
pkg/cli/cobra-parser.go:68:// This returns a CobraParser that can be used to parse the registered Layers
pkg/cli/cobra-parser.go:71:	Layers *schema.Schema
pkg/cli/cobra-parser.go:77:	// This hooks allows the implementor to specify additional ways of loading parameters
pkg/cli/cobra-parser.go:78:	// (for example, sqleton loads the dbt and sql connection parameters from env as well).
pkg/cli/cobra-parser.go:80:	// List of layers to be shown in short help, empty: always show all
pkg/cli/cobra-parser.go:81:	shortHelpLayers []string
pkg/cli/cobra-parser.go:82:	// skipCommandSettingsLayer controls whether the CommandSettingsLayer should be automatically added
pkg/cli/cobra-parser.go:83:	skipCommandSettingsLayer bool
pkg/cli/cobra-parser.go:84:	// enableProfileSettingsLayer controls whether the ProfileSettingsLayer should be added
pkg/cli/cobra-parser.go:85:	enableProfileSettingsLayer bool
pkg/cli/cobra-parser.go:86:	// enableCreateCommandSettingsLayer controls whether the CreateCommandSettingsLayer should be added
pkg/cli/cobra-parser.go:87:	enableCreateCommandSettingsLayer bool
pkg/cli/cobra-parser.go:93:	ShortHelpLayers                  []string
pkg/cli/cobra-parser.go:94:	SkipCommandSettingsLayer         bool
pkg/cli/cobra-parser.go:95:	EnableProfileSettingsLayer       bool
pkg/cli/cobra-parser.go:96:	EnableCreateCommandSettingsLayer bool
pkg/cli/cobra-parser.go:101:	ConfigFilesFunc func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]string, error)
pkg/cli/cobra-parser.go:115:// NewCobraParserFromLayers creates a new CobraParser instance from a
pkg/cli/cobra-parser.go:117:// parameters specified in the Layers CommandDescription to the cobra command.
pkg/cli/cobra-parser.go:118:func NewCobraParserFromLayers(
pkg/cli/cobra-parser.go:119:	paramLayers *schema.Schema,
pkg/cli/cobra-parser.go:124:		Layers:                           paramLayers,
pkg/cli/cobra-parser.go:126:		shortHelpLayers:                  []string{},
pkg/cli/cobra-parser.go:127:		skipCommandSettingsLayer:         false,
pkg/cli/cobra-parser.go:128:		enableProfileSettingsLayer:       false,
pkg/cli/cobra-parser.go:129:		enableCreateCommandSettingsLayer: false,
pkg/cli/cobra-parser.go:136:		ret.shortHelpLayers = cfg.ShortHelpLayers
pkg/cli/cobra-parser.go:137:		ret.skipCommandSettingsLayer = cfg.SkipCommandSettingsLayer
pkg/cli/cobra-parser.go:138:		ret.enableProfileSettingsLayer = cfg.EnableProfileSettingsLayer
pkg/cli/cobra-parser.go:139:		ret.enableCreateCommandSettingsLayer = cfg.EnableCreateCommandSettingsLayer
pkg/cli/cobra-parser.go:143:			ret.middlewaresFunc = func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]cmd_sources.Middleware, error) {
pkg/cli/cobra-parser.go:192:				// Wrap resolver to bind parsedCommandLayers captured earlier
pkg/cli/cobra-parser.go:194:					return resolver(parsedCommandLayers, cmd_, args_)
pkg/cli/cobra-parser.go:197:					cmd_sources.LoadParametersFromResolvedFilesForCobra(
pkg/cli/cobra-parser.go:215:	// Only add the glazed command layer if not explicitly skipped
pkg/cli/cobra-parser.go:216:	if !ret.skipCommandSettingsLayer {
pkg/cli/cobra-parser.go:217:		commandSettingsLayer, err := NewCommandSettingsLayer()
pkg/cli/cobra-parser.go:221:		ret.Layers.Set(commandSettingsLayer.GetSlug(), commandSettingsLayer)
pkg/cli/cobra-parser.go:224:	// Only add the profile settings layer if explicitly enabled
pkg/cli/cobra-parser.go:225:	if ret.enableProfileSettingsLayer {
pkg/cli/cobra-parser.go:226:		profileSettingsLayer, err := NewProfileSettingsLayer()
pkg/cli/cobra-parser.go:230:		ret.Layers.Set(profileSettingsLayer.GetSlug(), profileSettingsLayer)
pkg/cli/cobra-parser.go:233:	// Only add the create command settings layer if explicitly enabled
pkg/cli/cobra-parser.go:234:	if ret.enableCreateCommandSettingsLayer {
pkg/cli/cobra-parser.go:235:		createCommandSettingsLayer, err := NewCreateCommandSettingsLayer()
pkg/cli/cobra-parser.go:239:		ret.Layers.Set(createCommandSettingsLayer.GetSlug(), createCommandSettingsLayer)
pkg/cli/cobra-parser.go:246:	// NOTE(manuel, 2024-01-03) Maybe add some middleware functionality to whitelist/blacklist the Layers/parameters that get added to the CLI
pkg/cli/cobra-parser.go:247:	// If we want to remove some parameters from the CLI args (for example some output settings or so)
pkg/cli/cobra-parser.go:248:	err := c.Layers.ForEachE(func(_ string, layer schema.Section) error {
pkg/cli/cobra-parser.go:249:		// check that layer is a CobraSection
pkg/cli/cobra-parser.go:251:		cobraLayer, ok := layer.(schema.CobraSection)
pkg/cli/cobra-parser.go:253:			log.Error().Str("layer", layer.GetName()).Msg("Layer is not a CobraSection")
pkg/cli/cobra-parser.go:254:			return errors.Errorf("layer %s is not a CobraSection", layer.GetName())
pkg/cli/cobra-parser.go:257:		err := cobraLayer.AddLayerToCobraCommand(cmd)
pkg/cli/cobra-parser.go:259:			log.Error().Err(err).Str("layer", layer.GetName()).Msg("Could not add layer to cobra command")
pkg/cli/cobra-parser.go:269:	if len(c.shortHelpLayers) > 0 {
pkg/cli/cobra-parser.go:270:		shortHelperLayer := strings.Join(c.shortHelpLayers, ",")
pkg/cli/cobra-parser.go:271:		cmd.Annotations["shortHelpLayers"] = shortHelperLayer
pkg/cli/cobra-parser.go:283:	parsedCommandLayers, err := ParseCommandSettingsLayer(cmd)
pkg/cli/cobra-parser.go:290:	middlewares_, err := c.middlewaresFunc(parsedCommandLayers, cmd, args)
pkg/cli/cobra-parser.go:295:	parsedLayers := values.New()
pkg/cli/cobra-parser.go:296:	err = cmd_sources.Execute(c.Layers, parsedLayers, middlewares_...)
pkg/cli/cobra-parser.go:301:	return parsedLayers, nil
pkg/cli/cobra-parser.go:304:// ParseGlazedCommandLayer parses the global glazed settings from the given cobra.Command, if not nil,
pkg/cli/cobra-parser.go:306:func ParseCommandSettingsLayer(cmd *cobra.Command) (*values.Values, error) {
pkg/cli/cobra-parser.go:307:	parsedLayers := values.New()
pkg/cli/cobra-parser.go:308:	commandSettingsLayer, err := NewCommandSettingsLayer()
pkg/cli/cobra-parser.go:313:	profileSettingsLayer, err := NewProfileSettingsLayer()
pkg/cli/cobra-parser.go:318:	createCommandSettingsLayer, err := NewCreateCommandSettingsLayer()
pkg/cli/cobra-parser.go:323:	commandSettingsLayers := schema.NewSchema(schema.WithSections(
pkg/cli/cobra-parser.go:324:		commandSettingsLayer,
pkg/cli/cobra-parser.go:325:		profileSettingsLayer,
pkg/cli/cobra-parser.go:326:		createCommandSettingsLayer,
pkg/cli/cobra-parser.go:336:	err = cmd_sources.Execute(commandSettingsLayers, parsedLayers, middlewares_...)
pkg/cli/cobra-parser.go:341:	return parsedLayers, nil
AGENT.md:58:Don't add backwards compatibility layers unless explicitly asked.
prompto/glazed/command-description.md:8:- **Layers** (contains parameter definitions, i.e. your command’s flags/arguments)
prompto/glazed/command-description.md:48:Your command’s parameters (both flags and positional arguments) are grouped in a default “layer.” You typically add them via the convenience functions:
prompto/glazed/command-description.md:53:### 3.1 Defining Parameter Definitions
prompto/glazed/command-description.md:55:Parameters themselves are described by `fields.Definition` from the `glazed/pkg/cmds/parameters` package. For example:
prompto/glazed/command-description.md:67:**Common parameter definition functions**:
prompto/glazed/command-description.md:69:- `fields.New(name string, paramType ParameterType, opts ...ParameterDefinitionOption)`
prompto/glazed/command-description.md:77:Flags are typically optional or named parameters. You call `WithFlags(...)` with one or more `ParameterDefinition`s:
prompto/glazed/command-description.md:101:Positional arguments (like `my-command [ARGS ...]`) are also stored as parameters but with `IsArgument = true`. You can use `WithArguments(...)`:
prompto/glazed/command-description.md:134:4. **`WithFlags(flags ...*ParameterDefinition)`**  
prompto/glazed/command-description.md:135:   Adds parameter definitions as **flags** to the default layer.
prompto/glazed/command-description.md:137:5. **`WithArguments(arguments ...*ParameterDefinition)`**  
prompto/glazed/command-description.md:138:   Adds parameter definitions as **positional arguments** to the default layer.
prompto/glazed/command-description.md:140:6. **`WithLayers(ls *schema.Schema)`** or **`WithLayersList(ls ...ParameterLayer)`**  
prompto/glazed/command-description.md:141:   Used if you already have a custom `ParameterLayers` object or multiple parameter layers. Typically more advanced usage.
prompto/glazed/command-description.md:143:7. **`WithReplaceLayers(layers_ ...ParameterLayer)`**  
prompto/glazed/command-description.md:144:   Replaces any existing layers with the ones you provide.
prompto/glazed/command-description.md:164:## 5. Inspecting Parameters at Runtime
prompto/glazed/command-description.md:166:Once your `CommandDescription` is built, you can retrieve parameter definitions in code:
prompto/glazed/command-description.md:168:- **`GetDefaultFlags()`**: Returns a `ParameterDefinitions` object of all flags in the default layer.  
prompto/glazed/command-description.md:169:- **`GetDefaultArguments()`**: Returns all arguments (where `IsArgument = true`) from the default layer.  
prompto/glazed/command-description.md:170:- **`Layers`**: The entire `ParameterLayers` object if you need advanced usage.
prompto/glazed/command-description.md:183:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
prompto/glazed/command-description.md:239:5. **Optionally** set the source string or manipulate the advanced parameter layering.  
prompto/glazed/parameter-types:3:echo "// Here are the types that can be used to define parameters in glazed:"
prompto/glazed/parameter-types:5:echo "package github.com/go-go-golems/glazed/pkg/cmds/parameters"
prompto/glazed/parameter-types:7:oak go consts pkg/cmds/parameters/parameter-type.go
prompto/glazed/parameter-types:9:oak go definitions pkg/cmds/parameters/file.go --name "FileData" --definition-type struct,interface
prompto/glazed/parameters:3:prompto get glazed/parameter-types
prompto/glazed/parameters:6:echo "Here are all the types and method signatures for manipulating parameters and parsed parameters in glazed (github.com/go-go-golems/glazed is the base package):"
prompto/glazed/parameters:8:echo "package github.com/go-go-golems/glazed/pkg/cmds/parameters"
prompto/glazed/parameters:10:oak go definitions --only-public pkg/cmds/parameters/parameters.go
prompto/glazed/parameters:12:oak go definitions --only-public pkg/cmds/parameters/parsed-parameter.go
prompto/glazed/parameters:17:echo "Here are all the types and method signatures for manipulating layers in glazed:"
prompto/glazed/parameters:19:echo "package layers"
prompto/glazed/parameters:21:oak go definitions --only-public pkg/cmds/layers/layer.go
prompto/glazed/parameters:23:oak go definitions --only-public pkg/cmds/layers/parsed-layer.go
changelog.md:1:# Parameter Layer Serialization
changelog.md:3:Added ability to serialize parameter layers to YAML/JSON format for better interoperability and configuration management.
changelog.md:5:- Added SerializableParameterLayer struct for YAML/JSON serialization
changelog.md:6:- Added SerializableLayers struct for serializing collections of layers as a map keyed by slug
changelog.md:7:- Added conversion functions ToSerializable and LayersToSerializable
changelog.md:8:- Implemented YAML and JSON marshaling for ParameterLayers
changelog.md:9:- Updated serialization to maintain layer order while providing slug-based access
changelog.md:10:- Added custom YAML and JSON marshalers for SerializableLayers
changelog.md:12:# Parsed Parameters Serialization
changelog.md:14:Added ability to serialize parsed parameters to YAML/JSON format for better debugging and state persistence.
changelog.md:16:- Added SerializableParsedParameter struct for YAML/JSON serialization
changelog.md:17:- Added SerializableParsedParameters struct for serializing collections of parsed parameters
changelog.md:18:- Added conversion functions for ParsedParameter and ParsedParameters
changelog.md:19:- Implemented YAML and JSON marshaling for ParsedParameters
changelog.md:20:- Maintained parameter order while providing name-based access in serialized format
changelog.md:22:# Parsed Layer Serialization
changelog.md:24:Added ability to serialize parsed layers to YAML/JSON format, combining layer definitions and parsed parameters.
changelog.md:26:- Added SerializableParsedLayer struct for YAML/JSON serialization
changelog.md:27:- Added SerializableParsedLayers struct for serializing collections of parsed layers
changelog.md:28:- Added conversion functions for ParsedLayer and ParsedLayers
changelog.md:29:- Implemented YAML and JSON marshaling for ParsedLayer and ParsedLayers
changelog.md:30:- Included both layer definitions and parsed parameters in serialized output
changelog.md:39:# Optional GlazedCommandLayer in CobraParser
changelog.md:41:Added ability to skip adding the GlazedCommandLayer when creating a new CobraParser.
changelog.md:43:- Added skipGlazedCommandLayer flag to CobraParser struct
changelog.md:44:- Added WithSkipGlazedCommandLayer option function
changelog.md:45:- Modified NewCobraParserFromLayers to respect the skip flag
changelog.md:47:# Optional Profile and Create Command Settings Layers in CobraParser
changelog.md:49:Added ability to enable ProfileSettingsLayer and CreateCommandSettingsLayer when creating a new CobraParser. These layers are disabled by default and must be explicitly enabled.
changelog.md:51:- Added enableProfileSettingsLayer flag to CobraParser struct
changelog.md:52:- Added enableCreateCommandSettingsLayer flag to CobraParser struct
changelog.md:53:- Added WithProfileSettingsLayer option function to enable profile settings
changelog.md:54:- Added WithCreateCommandSettingsLayer option function to enable create command settings
changelog.md:55:- Modified NewCobraParserFromLayers to only add these layers when explicitly enabled 
pkg/config/editor.go:102:// GetDefaultConfigPath is updated to take an appName parameter
cmd/examples/appconfig-parser/main.go:13:	RedisSlug appconfig.LayerSlug = "redis"
cmd/examples/appconfig-parser/main.go:14:	DBSlug    appconfig.LayerSlug = "db"
cmd/examples/appconfig-parser/main.go:40:	redisLayer := mustSection(schema.NewSection(
cmd/examples/appconfig-parser/main.go:50:	dbLayer := mustSection(schema.NewSection(
cmd/examples/appconfig-parser/main.go:61:		appconfig.WithValuesForLayers(map[string]map[string]interface{}{
cmd/examples/appconfig-parser/main.go:71:	if err := parser.Register(RedisSlug, redisLayer, func(t *AppSettings) any { return &t.Redis }); err != nil {
cmd/examples/appconfig-parser/main.go:72:		fmt.Fprintf(os.Stderr, "failed to register redis layer: %v\n", err)
cmd/examples/appconfig-parser/main.go:75:	if err := parser.Register(DBSlug, dbLayer, func(t *AppSettings) any { return &t.DB }); err != nil {
cmd/examples/appconfig-parser/main.go:76:		fmt.Fprintf(os.Stderr, "failed to register db layer: %v\n", err)
cmd/examples/sources-example/main.go:117:	// cmd.Layers is *schema.Schema, but we convert to schema.Schema (type alias)
cmd/examples/sources-example/main.go:119:	cmdSchema := (*schema.Schema)(cmd.Layers)
pkg/doc/tutorials/migrating-to-facade-packages.md:4:Short: Step-by-step guide to migrate Glazed code from layers/parameters/middlewares vocabulary to the new facade packages (schema/fields/values/sources)
pkg/doc/tutorials/migrating-to-facade-packages.md:27:- `schema` — schema sections (previously “layers”)
pkg/doc/tutorials/migrating-to-facade-packages.md:28:- `fields` — field definitions and field types (previously “parameters”)
pkg/doc/tutorials/migrating-to-facade-packages.md:29:- `values` — resolved values + decoding helpers (previously “parsed layers”)
pkg/doc/tutorials/migrating-to-facade-packages.md:42:- `pkg/cmds/layers.ParameterLayer` → `pkg/cmds/schema.Section`
pkg/doc/tutorials/migrating-to-facade-packages.md:43:- `pkg/cmds/layers.ParameterLayers` → `pkg/cmds/schema.Schema`
pkg/doc/tutorials/migrating-to-facade-packages.md:44:- `pkg/cmds/parameters.ParameterDefinition` → `pkg/cmds/fields.Definition`
pkg/doc/tutorials/migrating-to-facade-packages.md:45:- `pkg/cmds/parameters.ParameterDefinitions` → `pkg/cmds/fields.Definitions`
pkg/doc/tutorials/migrating-to-facade-packages.md:46:- `pkg/cmds/parameters.ParameterType*` → `pkg/cmds/fields.Type*`
pkg/doc/tutorials/migrating-to-facade-packages.md:50:- `pkg/cmds/layers.ParsedLayers` → `pkg/cmds/values.Values`
pkg/doc/tutorials/migrating-to-facade-packages.md:51:- `pkg/cmds/layers.ParsedLayer` → `pkg/cmds/values.SectionValues`
pkg/doc/tutorials/migrating-to-facade-packages.md:52:- `layers.NewParsedLayers()` → `values.New()`
pkg/doc/tutorials/migrating-to-facade-packages.md:53:- `layers.NewParsedLayer(section, ...)` → `values.NewSectionValues(section, ...)`
pkg/doc/tutorials/migrating-to-facade-packages.md:54:- `layers.WithParsedParameters(...)` → `values.WithParameters(...)`
pkg/doc/tutorials/migrating-to-facade-packages.md:55:- `layers.WithParsedParameterValue(...)` → `values.WithParameterValue(...)`
pkg/doc/tutorials/migrating-to-facade-packages.md:56:- `parsedLayers.InitializeStruct(slug, &dst)` → `values.DecodeSectionInto(parsedLayers, slug, &dst)`
pkg/doc/tutorials/migrating-to-facade-packages.md:64:- `middlewares.LoadParametersFromFile(s)` → `sources.FromFile` / `sources.FromFiles`
pkg/doc/tutorials/migrating-to-facade-packages.md:67:- `parameters.WithParseStepSource(...)` → `sources.WithSource(...)`
pkg/doc/tutorials/migrating-to-facade-packages.md:79:…and it still satisfies interfaces that mention `*layers.ParsedLayers`, because `values.Values` is an alias for `layers.ParsedLayers`.
pkg/doc/tutorials/migrating-to-facade-packages.md:88:- `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`).
pkg/doc/tutorials/migrating-to-facade-packages.md:89:- `layers.ParameterLayer` interface methods now use `*fields.Definition` / `*fields.Definitions`:
pkg/doc/tutorials/migrating-to-facade-packages.md:91:  - `GetParameterDefinitions() *fields.Definitions`
pkg/doc/tutorials/migrating-to-facade-packages.md:94:  - `cli.CobraRunFunc`, `cli.CobraParser.Parse`, `cli.ParseCommandSettingsLayer`
pkg/doc/tutorials/migrating-to-facade-packages.md:99:- `values` additions: `NewSectionValues`, `SectionValuesOption`, `WithParameters`, `WithParameterValue`.
pkg/doc/tutorials/migrating-to-facade-packages.md:107:- `github.com/go-go-golems/glazed/pkg/cmds/layers`
pkg/doc/tutorials/migrating-to-facade-packages.md:108:- `github.com/go-go-golems/glazed/pkg/cmds/parameters`
pkg/doc/tutorials/migrating-to-facade-packages.md:118:You can keep old imports for advanced/legacy types (for example `parameters.FileData`) until you’re ready to refactor them.
pkg/doc/tutorials/migrating-to-facade-packages.md:120:### Step 2: Replace parameter definitions
pkg/doc/tutorials/migrating-to-facade-packages.md:125:parameters.NewParameterDefinition("limit", parameters.ParameterTypeInteger, parameters.WithDefault(10))
pkg/doc/tutorials/migrating-to-facade-packages.md:136:If you currently build explicit layers:
pkg/doc/tutorials/migrating-to-facade-packages.md:141:demoLayer, _ := layers.NewParameterLayer("demo", "Demo",
pkg/doc/tutorials/migrating-to-facade-packages.md:142:    layers.WithPrefix("demo-"),
pkg/doc/tutorials/migrating-to-facade-packages.md:143:    layers.WithParameterDefinitions(
pkg/doc/tutorials/migrating-to-facade-packages.md:144:        parameters.NewParameterDefinition("api-key", parameters.ParameterTypeString),
pkg/doc/tutorials/migrating-to-facade-packages.md:165:func (c *MyCmd) Run(ctx context.Context, parsedLayers *layers.ParsedLayers) error {
pkg/doc/tutorials/migrating-to-facade-packages.md:173:func (c *MyCmd) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/tutorials/migrating-to-facade-packages.md:184:_ = parsedLayers.InitializeStruct(layers.DefaultSlug, settings)
pkg/doc/tutorials/migrating-to-facade-packages.md:210:## Glazed “output flags” layer: what to do now
pkg/doc/tutorials/migrating-to-facade-packages.md:212:- If your command implements `cmds.GlazeCommand`, `cli.BuildCobraCommand(...)` will ensure the glazed output layer exists, so you usually don’t need to add it manually.
pkg/doc/tutorials/migrating-to-facade-packages.md:213:- If you do want to add it explicitly (e.g. when building a schema yourself), prefer `settings.NewGlazedSchema()` (wrapper around `settings.NewGlazedParameterLayers()`).
pkg/doc/tutorials/migrating-to-facade-packages.md:221:- Cobra-only plumbing: attaching layers to Cobra uses `layers.CobraParameterLayer`.
pkg/doc/tutorials/migrating-to-facade-packages.md:222:- Some helper types/functions still live in `parameters` (e.g. `parameters.FileData`, `parameters.RenderValue`).
pkg/doc/topics/15-profiles.md:5:  Use profiles.yaml to apply named configuration bundles across parameter layers, with predictable precedence and debugging.
pkg/doc/topics/15-profiles.md:21:Profiles are a **named bundle of parameter overrides** stored in a YAML file (typically `profiles.yaml`).
pkg/doc/topics/15-profiles.md:34:- **Second level**: layer slug
pkg/doc/topics/15-profiles.md:35:- **Third level**: parameter name/value pairs for that layer
pkg/doc/topics/15-profiles.md:65:In a Cobra CLI built with Glazed, profile selection typically comes from the **ProfileSettings layer**:
pkg/doc/topics/15-profiles.md:77:These flags only exist if you enable the ProfileSettings layer when building your Cobra command:
pkg/doc/topics/15-profiles.md:81:  cli.WithProfileSettingsLayer(),
pkg/doc/topics/15-profiles.md:85:Without that layer:
pkg/doc/topics/15-profiles.md:93:Glazed config files are parsed in **layer-slug form**:
pkg/doc/topics/15-profiles.md:96:<layer-slug>:
pkg/doc/topics/15-profiles.md:100:So profile selection in a config file must be expressed under the `profile-settings` layer:
pkg/doc/topics/15-profiles.md:147:3. Run the main middleware chain for all layers, with the profiles middleware inserted between defaults and higher-precedence sources.
pkg/doc/topics/15-profiles.md:153:Use `--print-parsed-parameters` to inspect parse provenance per parameter, including which values came from:
cmd/examples/config-custom-mapper/config.yaml:1:# Flat config structure - different from the default layer-based structure
pkg/doc/topics/19-writing-yaml-commands.md:39:## Parameter Types
pkg/doc/topics/19-writing-yaml-commands.md:41:Glazed supports these parameter types for both flags and arguments:
pkg/doc/topics/19-writing-yaml-commands.md:75:Flags are optional parameters that modify command behavior. Here's a comprehensive example:
pkg/doc/topics/19-writing-yaml-commands.md:102:- `type`: Parameter type (required)
pkg/doc/topics/19-writing-yaml-commands.md:110:Arguments are positional parameters. They're defined similarly to flags:
pkg/doc/topics/19-writing-yaml-commands.md:129:## Using Layers
pkg/doc/topics/19-writing-yaml-commands.md:131:Layers help organize related parameters. Define layers in your YAML:
pkg/doc/topics/19-writing-yaml-commands.md:134:layers:
pkg/doc/topics/19-writing-yaml-commands.md:164:   - Group related parameters using layers
pkg/doc/topics/19-writing-yaml-commands.md:165:   - Use consistent parameter ordering
pkg/doc/topics/19-writing-yaml-commands.md:171:   - Mark parameters as required when necessary
pkg/doc/topics/19-writing-yaml-commands.md:198:layers:
cmd/examples/config-custom-mapper/main.go:29:	demoLayer, err := schema.NewSection(
cmd/examples/config-custom-mapper/main.go:54:		cmds.WithLayersList(demoLayer),
cmd/examples/config-custom-mapper/main.go:80:// flatConfigMapper transforms a flat config structure to the layer map format.
cmd/examples/config-custom-mapper/main.go:96:	// Map flat keys to layer parameters
cmd/examples/config-custom-mapper/main.go:135:			SkipCommandSettingsLayer: true,
cmd/examples/config-custom-mapper/main.go:136:			MiddlewaresFunc: func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]sources.Middleware, error) {
cmd/examples/config-custom-mapper/main.go:157:	// validate command: validate config.yaml using the custom mapper and layer definitions
cmd/examples/config-custom-mapper/main.go:183:			// Validate mapped structure against known layers and params
cmd/examples/config-custom-mapper/main.go:184:			for layerSlug, kv := range mapped {
cmd/examples/config-custom-mapper/main.go:185:				layer, ok := demo.Description().Layers.Get(layerSlug)
cmd/examples/config-custom-mapper/main.go:187:					issues = append(issues, fmt.Sprintf("unknown layer: %s", layerSlug))
cmd/examples/config-custom-mapper/main.go:191:				pds := layer.GetDefinitions()
cmd/examples/config-custom-mapper/main.go:196:						issues = append(issues, fmt.Sprintf("unknown parameter in layer %s: %s", layerSlug, key))
cmd/examples/config-custom-mapper/main.go:201:						issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))
pkg/doc/topics/22-templating-helpers.md:156:	ps map[string]interface{}, // Parameters for the template
pkg/doc/examples/cliopatra/cliopatra.md:31:map it to the ParameterDefinition the Command uses, and create a YAML file with the default values.
pkg/doc/tutorials/config-files-quickstart.md:17:This tutorial shows how to load configuration from one or more files using Glazed middlewares. You’ll see a simple single-file setup and a multi-file overlay with deterministic precedence. We’ll also show how to inspect parse steps using `--print-parsed-parameters`.
pkg/doc/tutorials/config-files-quickstart.md:22:- Familiarity with Cobra commands and Glazed layers
pkg/doc/tutorials/config-files-quickstart.md:26:Create a minimal command with a single custom layer and an explicit config file path:
pkg/doc/tutorials/config-files-quickstart.md:29:demoLayer, _ := schema.NewSection(
pkg/doc/tutorials/config-files-quickstart.md:31:    layers.WithPrefix("demo-"),
pkg/doc/tutorials/config-files-quickstart.md:38:desc := cmds.NewCommandDescription("demo", cmds.WithLayersList(demoLayer))
pkg/doc/tutorials/config-files-quickstart.md:44:        SkipCommandSettingsLayer: true,
pkg/doc/tutorials/config-files-quickstart.md:81:        SkipCommandSettingsLayer: true,
pkg/doc/tutorials/config-files-quickstart.md:124:Add `--print-parsed-parameters` to see each config file applied in sequence:
pkg/doc/tutorials/config-files-quickstart.md:127:go run ./cmd/examples/config-overlay overlay --print-parsed-parameters
pkg/doc/tutorials/config-files-quickstart.md:162:To layer `<base>.override.yaml` automatically on top of `--config-file`:
pkg/doc/tutorials/config-files-quickstart.md:192:Map arbitrary config structures to parameters without custom Go by using the pattern-based config mapper. Works with YAML or JSON files.
pkg/doc/tutorials/config-files-quickstart.md:195:// Define a layer
pkg/doc/tutorials/config-files-quickstart.md:196:demoLayer, _ := schema.NewSection("demo", "Demo",
pkg/doc/tutorials/config-files-quickstart.md:203:paramLayers := schema.NewSchema(layers.WithLayers(demoLayer))
pkg/doc/tutorials/config-files-quickstart.md:206:mapper, _ := patternmapper.NewConfigMapper(paramLayers,
pkg/doc/tutorials/config-files-quickstart.md:209:        TargetLayer: "demo",
pkg/doc/tutorials/config-files-quickstart.md:211:            {Source: "api_key", TargetParameter: "{env}-api-key"},
pkg/doc/tutorials/config-files-quickstart.md:220:_ = sources.Execute(paramLayers, values.New(), mw)
pkg/doc/tutorials/config-files-quickstart.md:226:b := patternmapper.NewConfigMapperBuilder(paramLayers).
pkg/doc/tutorials/config-files-quickstart.md:238:err := sources.Execute(layers_, parsed,
pkg/doc/tutorials/config-files-quickstart.md:253:      TargetLayer:     "demo",
pkg/doc/tutorials/config-files-quickstart.md:254:      TargetParameter: "api-key",
pkg/doc/tutorials/config-files-quickstart.md:259:- Ambiguity: wildcard patterns that match multiple different values or rules that resolve to the same target parameter cause errors. Prefer named captures (e.g., `app.{env}.api_key`) when collecting multiple values.
pkg/doc/tutorials/config-files-quickstart.md:261:- Missing parameters: mapping to a non-existent parameter errors (prefix-aware), helping catch typos early.
pkg/doc/tutorials/config-files-quickstart.md:268:err := sources.Execute(layers_, parsed,
cmd/examples/parameter-types/sample-text.txt:4:Perfect for testing string-from-file parameters.
cmd/glaze/main.go:26:	err := logging.AddLoggingLayerToRootCommand(rootCmd, "glaze")
pkg/cmds/json-schema.go:29:// parameterTypeToJsonSchema converts a parameter definition to a JSON schema property
pkg/cmds/json-schema.go:30:func parameterTypeToJsonSchema(param *fields.Definition) (*JsonSchemaProperty, error) {
pkg/cmds/json-schema.go:110:	// File-based parameter types
pkg/cmds/json-schema.go:145:		return nil, fmt.Errorf("unsupported parameter type: %s", param.Type)
pkg/cmds/json-schema.go:162:		prop, err := parameterTypeToJsonSchema(flag)
pkg/cmds/json-schema.go:178:		prop, err := parameterTypeToJsonSchema(arg)
cmd/examples/parameter-types/README.md:1:# Parameter Types Example
cmd/examples/parameter-types/README.md:3:This example demonstrates all parameter types available in the glazed framework.
cmd/examples/parameter-types/README.md:9:go build -o parameter-types .
cmd/examples/parameter-types/README.md:11:# Show help to see all available parameters
cmd/examples/parameter-types/README.md:12:./parameter-types --help
cmd/examples/parameter-types/README.md:15:./parameter-types
cmd/examples/parameter-types/README.md:18:./parameter-types \
cmd/examples/parameter-types/README.md:28:./parameter-types \
cmd/examples/parameter-types/README.md:35:./parameter-types \
cmd/examples/parameter-types/README.md:44:./parameter-types \
cmd/examples/parameter-types/README.md:48:./parameter-types \
cmd/examples/parameter-types/README.md:52:## Parameter Types Demonstrated
cmd/examples/parameter-types/README.md:85:- `sample.json` - JSON object for testing object parameters
cmd/examples/parameter-types/README.md:87:- `sample-list.json` - JSON array for testing list parameters
cmd/examples/parameter-types/README.md:88:- `sample-text.txt` - Multi-line text for string parameters
cmd/examples/parameter-types/README.md:89:- `sample-lines.txt` - Line-by-line text for list parameters
cmd/examples/parameter-types/README.md:90:- `config.yaml` - Configuration file for key-value parameters
cmd/examples/parameter-types/README.md:94:The program displays all parsed parameter values in a structured format, demonstrating how each type is processed and what the final values look like.
cmd/examples/parameter-types/README.md:96:Note that secret parameters will show as `***` in the output to protect sensitive data.
cmd/examples/parameter-types/main.go:25:type ParameterTypesSettings struct {
cmd/examples/parameter-types/main.go:56:type ParameterTypesCommand struct {
cmd/examples/parameter-types/main.go:60:var _ cmds.GlazeCommand = (*ParameterTypesCommand)(nil)
cmd/examples/parameter-types/main.go:62:func NewParameterTypesCommand() (*ParameterTypesCommand, error) {
cmd/examples/parameter-types/main.go:65:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")
cmd/examples/parameter-types/main.go:68:	return &ParameterTypesCommand{
cmd/examples/parameter-types/main.go:70:			"parameter-types",
cmd/examples/parameter-types/main.go:71:			cmds.WithShort("Showcase all parameter types available in glazed"),
cmd/examples/parameter-types/main.go:72:			cmds.WithLong(`This command demonstrates all the different parameter types available in the glazed framework.
cmd/examples/parameter-types/main.go:75:Parameter types demonstrated:
cmd/examples/parameter-types/main.go:81:Use --help to see all available parameters and their descriptions.`),
cmd/examples/parameter-types/main.go:87:					fields.WithHelp("A simple string parameter"),
cmd/examples/parameter-types/main.go:93:					fields.WithHelp("A secret parameter (will be masked when displayed)"),
cmd/examples/parameter-types/main.go:99:					fields.WithHelp("An integer parameter"),
cmd/examples/parameter-types/main.go:105:					fields.WithHelp("A floating point parameter"),
cmd/examples/parameter-types/main.go:111:					fields.WithHelp("A boolean parameter"),
cmd/examples/parameter-types/main.go:117:					fields.WithHelp("A date parameter (RFC3339 format or natural language)"),
cmd/examples/parameter-types/main.go:123:					fields.WithHelp("A choice parameter with predefined options"),
cmd/examples/parameter-types/main.go:159:					fields.WithHelp("A file parameter that loads file metadata"),
cmd/examples/parameter-types/main.go:210:			cmds.WithLayersList(
cmd/examples/parameter-types/main.go:217:func (c *ParameterTypesCommand) RunIntoGlazeProcessor(
cmd/examples/parameter-types/main.go:222:	s := &ParameterTypesSettings{}
cmd/examples/parameter-types/main.go:225:		return errors.Wrap(err, "Failed to initialize settings from parameters")
cmd/examples/parameter-types/main.go:228:	// We'll use hardcoded metadata since layer access is complex
cmd/examples/parameter-types/main.go:230:	// Create a result row for each parameter
cmd/examples/parameter-types/main.go:231:	parameterData := []struct {
cmd/examples/parameter-types/main.go:240:		{"string-param", fields.TypeString, s.StringParam, "A simple string parameter", false, nil, "default-string"},
cmd/examples/parameter-types/main.go:241:		{"secret-param", fields.TypeSecret, s.SecretParam, "A secret parameter (will be masked when displayed)", false, nil, "secret-value"},
cmd/examples/parameter-types/main.go:242:		{"integer-param", fields.TypeInteger, s.IntegerParam, "An integer parameter", false, nil, 42},
cmd/examples/parameter-types/main.go:243:		{"float-param", fields.TypeFloat, s.FloatParam, "A floating point parameter", false, nil, 3.14},
cmd/examples/parameter-types/main.go:244:		{"bool-param", fields.TypeBool, s.BoolParam, "A boolean parameter", false, nil, true},
cmd/examples/parameter-types/main.go:245:		{"date-param", fields.TypeDate, s.DateParam, "A date parameter (RFC3339 format or natural language)", false, nil, "2024-01-01T00:00:00Z"},
cmd/examples/parameter-types/main.go:246:		{"choice-param", fields.TypeChoice, s.ChoiceParam, "A choice parameter with predefined options", false, []string{"option1", "option2", "option3"}, "option1"},
cmd/examples/parameter-types/main.go:251:		{"file-param", fields.TypeFile, s.FileParam, "A file parameter that loads file metadata", false, nil, nil},
cmd/examples/parameter-types/main.go:263:	for _, param := range parameterData {
cmd/examples/parameter-types/main.go:302:			types.MRP("parameter_name", param.name),
cmd/examples/parameter-types/main.go:303:			types.MRP("parameter_type", string(param.paramType)),
cmd/examples/parameter-types/main.go:324:	cmd, err := NewParameterTypesCommand()
cmd/examples/parameter-types/main.go:331:		Use:   "parameter-types",
cmd/examples/parameter-types/main.go:332:		Short: "Showcase all glazed parameter types",
pkg/doc/topics/07-load-parameters-from-json.md:2:Title: Loading Parameters from JSON
pkg/doc/topics/07-load-parameters-from-json.md:3:Slug: load-parameters-json
pkg/doc/topics/07-load-parameters-from-json.md:4:Short: Explains how to load parameters from a JSON file.
pkg/doc/topics/07-load-parameters-from-json.md:7:- Parameters
pkg/doc/topics/07-load-parameters-from-json.md:9:- load-parameters-from-json
pkg/doc/topics/07-load-parameters-from-json.md:16:In addition to specifying parameters via command line flags, you can also load parameters from a JSON file.
pkg/doc/topics/07-load-parameters-from-json.md:19:This allows you to store common parameter configurations and reuse them across commands.
pkg/doc/topics/07-load-parameters-from-json.md:21:To load parameters from JSON, use the `--load-parameters-from-json` flag followed by the path to your JSON file:
pkg/doc/topics/07-load-parameters-from-json.md:24:command --load-parameters-from-json parameters.json [other arguments]
pkg/doc/topics/07-load-parameters-from-json.md:27:The JSON file should contain a JSON object where the keys are parameter names and the values are the parameter values you want to set.
pkg/doc/topics/07-load-parameters-from-json.md:39:This will set the `fields` and `output` parameters as if they had been passed via the command line.
pkg/doc/topics/07-load-parameters-from-json.md:60:❯ glaze json --load-parameters-from-json /tmp/test-json.json misc/test-data/[123].json 
pkg/doc/topics/07-load-parameters-from-json.md:79:The `ParseCommandFromMap` function in `cmds/map.go` is used to parse command parameters from a map structure, such as when loading parameters from JSON.
pkg/doc/topics/07-load-parameters-from-json.md:81:It takes a `CommandDescription`, a `map[string]interface{}` of parameters, and returns:
pkg/doc/topics/07-load-parameters-from-json.md:83:- A map of `ParsedParameterLayer` structs for each layer
pkg/doc/topics/07-load-parameters-from-json.md:84:- A combined map of all parameter values
pkg/doc/topics/07-load-parameters-from-json.md:89:1. It iterates through each layer in the `CommandDescription`
pkg/doc/topics/07-load-parameters-from-json.md:90:2. For layers that implement the `JSONParameterLayer` interface, it calls `ParseFlagsFromJSON` to parse values from the map into a `ParsedParameterLayer`
pkg/doc/topics/07-load-parameters-from-json.md:91:3. It adds the parsed layer to the output map
pkg/doc/topics/07-load-parameters-from-json.md:92:4. It also copies layer parameters into the combined parameter map
pkg/doc/topics/07-load-parameters-from-json.md:93:5. After parsing layers, it parses any remaining flags and arguments using the `CommandDescription` directly
pkg/doc/topics/07-load-parameters-from-json.md:108:layers, allParams, err := cmds.ParseCommandFromMap(cmd, params)
pkg/doc/topics/07-load-parameters-from-json.md:111:The returned `layers` map contains the parsed layers, while `allParams` contains all parameters combined.
cmd/glaze/cmds/example.go:31:	glazedLayer, err := settings.NewGlazedSchema()
cmd/glaze/cmds/example.go:33:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")
cmd/glaze/cmds/example.go:56:			cmds.WithLayersList(
cmd/glaze/cmds/example.go:57:				glazedLayer,
cmd/glaze/cmds/example.go:65:// parsedLayers contains the result of parsing each layer that has been
cmd/glaze/cmds/example.go:66:// registered with the command description. These layers can be glazed structured data
cmd/glaze/cmds/example.go:67:// flags, database connection parameters, application specification fields.
cmd/glaze/cmds/example.go:76:		return errors.Wrap(err, "failed to initialize example settings from parameters")
pkg/doc/topics/23-pattern-based-config-mapping.md:4:Short: Declarative mapping of config files to parameter layers using pattern matching rules
pkg/doc/topics/23-pattern-based-config-mapping.md:18:The pattern-based config mapping system provides a declarative way to map arbitrary config file structures to Glazed's layer-based parameter system without writing custom Go functions. Instead of implementing `ConfigFileMapper` functions with manual config traversal, you define mapping rules that specify patterns to match in config files and how to map matched values to parameters. This keeps configuration logic concise, testable, and consistent across commands.
pkg/doc/topics/23-pattern-based-config-mapping.md:26:- Using the Mapper: Wire into `LoadParametersFromFile`
pkg/doc/topics/23-pattern-based-config-mapping.md:39:- Verify target layers exist and static target parameters are valid (prefix-aware)
pkg/doc/topics/23-pattern-based-config-mapping.md:40:- Check that any `{name}` referenced in `TargetParameter` is captured in `Source`
pkg/doc/topics/23-pattern-based-config-mapping.md:44:- For each pattern, collect matches; resolve `{captures}` into parameter names
pkg/doc/topics/23-pattern-based-config-mapping.md:45:- Write values to the target layer/parameter; error on ambiguity or collisions
pkg/doc/topics/23-pattern-based-config-mapping.md:56:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/23-pattern-based-config-mapping.md:62:mapper, err := pm.NewConfigMapper(layers_,
pkg/doc/topics/23-pattern-based-config-mapping.md:65:        TargetLayer:     "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:66:        TargetParameter: "api-key",
pkg/doc/topics/23-pattern-based-config-mapping.md:70:// Use with LoadParametersFromFile
pkg/doc/topics/23-pattern-based-config-mapping.md:85:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/23-pattern-based-config-mapping.md:90:b := pm.NewConfigMapperBuilder(layers_).
pkg/doc/topics/23-pattern-based-config-mapping.md:98:// Use with LoadParametersFromFile
pkg/doc/topics/23-pattern-based-config-mapping.md:116:    target_layer: "demo"
pkg/doc/topics/23-pattern-based-config-mapping.md:117:    target_parameter: "api-key"
pkg/doc/topics/23-pattern-based-config-mapping.md:119:    target_layer: "demo"
pkg/doc/topics/23-pattern-based-config-mapping.md:120:    target_parameter: "{env}-api-key"
pkg/doc/topics/23-pattern-based-config-mapping.md:127:  target_layer: "demo"
pkg/doc/topics/23-pattern-based-config-mapping.md:128:  target_parameter: "threshold"
pkg/doc/topics/23-pattern-based-config-mapping.md:137:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/23-pattern-based-config-mapping.md:146:mapper, err := pm.NewConfigMapper(layers_, rules...)
pkg/doc/topics/23-pattern-based-config-mapping.md:150:mapper2, err := pm.LoadMapperFromFile(layers_, "mappings.yaml")
pkg/doc/topics/23-pattern-based-config-mapping.md:165:Exact match patterns map specific config paths to parameters with no variation:
pkg/doc/topics/23-pattern-based-config-mapping.md:170:    TargetLayer:     "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:171:    TargetParameter: "api-key",
pkg/doc/topics/23-pattern-based-config-mapping.md:186:Named captures extract segments from config paths and use them in parameter names, enabling environment-specific or multi-tenant configurations:
pkg/doc/topics/23-pattern-based-config-mapping.md:191:    TargetLayer:     "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:192:    TargetParameter: "{env}-api-key",
pkg/doc/topics/23-pattern-based-config-mapping.md:209:The `{env}` capture extracts whatever value appears at that position in the config (here, "dev" or "prod") and makes it available for use in the target parameter name.
pkg/doc/topics/23-pattern-based-config-mapping.md:218:    TargetLayer:     "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:219:    TargetParameter: "api-key",
pkg/doc/topics/23-pattern-based-config-mapping.md:234:Important: When a wildcard pattern matches multiple keys with different values, the mapper treats this as an ambiguity and returns an error by default. Use named captures (e.g., `app.{env}.api_key`) if you need to collect multiple values, or ensure matched values are identical if a single target parameter is intended. This prevents accidental aggregation of unrelated values.
pkg/doc/topics/23-pattern-based-config-mapping.md:243:    TargetLayer: "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:245:        {Source: "api_key", TargetParameter: "api-key"},
pkg/doc/topics/23-pattern-based-config-mapping.md:246:        {Source: "threshold", TargetParameter: "threshold"},
pkg/doc/topics/23-pattern-based-config-mapping.md:247:        {Source: "timeout", TargetParameter: "timeout"},
pkg/doc/topics/23-pattern-based-config-mapping.md:255:b := patternmapper.NewConfigMapperBuilder(layers).
pkg/doc/topics/23-pattern-based-config-mapping.md:287:    TargetLayer: "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:289:        {Source: "api_key", TargetParameter: "{env}-api-key"},
pkg/doc/topics/23-pattern-based-config-mapping.md:290:        {Source: "threshold", TargetParameter: "threshold"},
pkg/doc/topics/23-pattern-based-config-mapping.md:314:The `{env}` capture from the parent pattern is available in all child rules, allowing them to construct environment-specific parameter names.
pkg/doc/topics/23-pattern-based-config-mapping.md:326:    // Target layer slug (required for leaf rules)
pkg/doc/topics/23-pattern-based-config-mapping.md:328:    TargetLayer string
pkg/doc/topics/23-pattern-based-config-mapping.md:330:    // Target parameter name (required for leaf rules)
pkg/doc/topics/23-pattern-based-config-mapping.md:332:    TargetParameter string
pkg/doc/topics/23-pattern-based-config-mapping.md:347:b := patternmapper.NewConfigMapperBuilder(layers).
pkg/doc/topics/23-pattern-based-config-mapping.md:359:- Prefix-aware parameter resolution and compile-time validation of static targets apply at Build().
pkg/doc/topics/23-pattern-based-config-mapping.md:370:3. **Target layer**: Must exist in parameter layers
pkg/doc/topics/23-pattern-based-config-mapping.md:371:4. **Target parameter**: Must exist in target layer *(validated at runtime per match)*
pkg/doc/topics/23-pattern-based-config-mapping.md:379:    TargetParameter: "{env}-api-key",  // {env} not captured in source
pkg/doc/topics/23-pattern-based-config-mapping.md:381:// Error: "capture reference {env} in target parameter not found in source pattern"
pkg/doc/topics/23-pattern-based-config-mapping.md:383:// Error: target layer doesn't exist
pkg/doc/topics/23-pattern-based-config-mapping.md:386:    TargetLayer: "nonexistent",
pkg/doc/topics/23-pattern-based-config-mapping.md:387:    TargetParameter: "api-key",
pkg/doc/topics/23-pattern-based-config-mapping.md:389:// Error: "target layer \"nonexistent\" does not exist"
pkg/doc/topics/23-pattern-based-config-mapping.md:399:    TargetLayer:     "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:400:    TargetParameter: "api-key",
pkg/doc/topics/23-pattern-based-config-mapping.md:411:- Multi-match: If a single pattern matches multiple paths that would resolve to the same target parameter with different values (e.g., `app.*.api_key` for `dev` and `prod`), an error is returned.
pkg/doc/topics/23-pattern-based-config-mapping.md:412:- Collisions: If different patterns resolve to the same target parameter (e.g., `app.settings.api_key` and `config.api_key` both mapping to `demo.api-key`), an error is returned.
pkg/doc/topics/23-pattern-based-config-mapping.md:416:Runtime errors occur when config files don't match expectations or reference nonexistent parameters. The system provides detailed error messages to aid debugging. Error messages include both the user-provided target name and the canonical (prefix-aware) parameter name where relevant.
pkg/doc/topics/23-pattern-based-config-mapping.md:420:- Target parameter doesn't exist in layer
pkg/doc/topics/23-pattern-based-config-mapping.md:429:**Example error for missing parameter**:
pkg/doc/topics/23-pattern-based-config-mapping.md:431:target parameter "api-key" does not exist in layer "demo" (pattern: "app.settings.api_key")
pkg/doc/topics/23-pattern-based-config-mapping.md:434:**Example error for missing parameter with prefix**:
pkg/doc/topics/23-pattern-based-config-mapping.md:436:target parameter "api-key" (checked as "demo-api-key") does not exist in layer "demo" (pattern: "app.settings.api_key")
pkg/doc/topics/23-pattern-based-config-mapping.md:439:When a layer has a prefix and the target parameter name doesn't include it, the error message shows both the provided name and the resolved canonical name (with prefix). This helps debug parameter name mismatches.
pkg/doc/topics/23-pattern-based-config-mapping.md:445:- Overwrites: Overwrites across different rules to the same parameter are considered collisions and will error.
pkg/doc/topics/23-pattern-based-config-mapping.md:455:- Grouped parameters (nested rules)
pkg/doc/topics/23-pattern-based-config-mapping.md:470:A real-world example showing pattern mapper integration. This example highlights capture inheritance, prefix-aware parameters, and minimal application wiring.
pkg/doc/topics/23-pattern-based-config-mapping.md:476:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/23-pattern-based-config-mapping.md:479:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/23-pattern-based-config-mapping.md:483:    // Define parameter layers
pkg/doc/topics/23-pattern-based-config-mapping.md:484:    layer, _ := schema.NewSection("demo", "Demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:491:    paramLayers := schema.NewSchema(layers.WithLayers(layer))
pkg/doc/topics/23-pattern-based-config-mapping.md:494:    mapper, err := patternmapper.NewConfigMapper(paramLayers,
pkg/doc/topics/23-pattern-based-config-mapping.md:497:            TargetLayer: "demo",
pkg/doc/topics/23-pattern-based-config-mapping.md:499:                {Source: "api_key", TargetParameter: "{env}-api-key"},
pkg/doc/topics/23-pattern-based-config-mapping.md:514:    parsedLayers := values.New()
pkg/doc/topics/23-pattern-based-config-mapping.md:515:    err = sources.Execute(paramLayers, parsedLayers, middleware)
pkg/doc/topics/23-pattern-based-config-mapping.md:536:patternMapper, _ := patternmapper.NewConfigMapper(layers, rules...)
pkg/doc/topics/23-pattern-based-config-mapping.md:561:glaze help parameter-layers-and-parsed-layers
cmd/glaze/cmds/yaml.go:30:	glazedLayer, err := settings.NewGlazedSchema()
cmd/glaze/cmds/yaml.go:32:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")
cmd/glaze/cmds/yaml.go:66:			cmds.WithLayersList(
cmd/glaze/cmds/yaml.go:67:				glazedLayer,
cmd/glaze/cmds/yaml.go:84:		return errors.Wrap(err, "Failed to initialize yaml settings from parameters")
pkg/doc/topics/18-lua.md:37:Executes a GlazeCommand with parameters from a Lua table.
pkg/doc/topics/18-lua.md:43:Executes a BareCommand with parameters from a Lua table.
pkg/doc/topics/18-lua.md:49:Executes a WriterCommand with parameters from a Lua table.
pkg/doc/topics/18-lua.md:65:Middleware to parse nested Lua tables into ParsedLayers.
pkg/doc/topics/18-lua.md:91:1. **ParseLuaTableToLayer**
pkg/doc/topics/18-lua.md:93:func ParseLuaTableToLayer(L *lua.LState, luaTable *lua.LTable, layer schema.Section) (*values.SectionValues, error)
pkg/doc/topics/18-lua.md:95:Parses a Lua table into a ParsedLayer.
pkg/doc/topics/18-lua.md:97:2. **ParseNestedLuaTableToParsedLayers**
pkg/doc/topics/18-lua.md:99:func ParseNestedLuaTableToParsedLayers(L *lua.LState, luaTable *lua.LTable, parameterLayers *schema.Schema) (*values.Values, error)
pkg/doc/topics/18-lua.md:101:Parses a nested Lua table into ParsedLayers.
pkg/doc/topics/18-lua.md:103:3. **ParseParameterFromLua**
pkg/doc/topics/18-lua.md:105:func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error)
pkg/doc/topics/18-lua.md:107:Parses a Lua value into a Go value based on the parameter definition.
pkg/doc/topics/18-lua.md:129:2. A global table containing parameter information (`command_name_params`)
pkg/doc/topics/18-lua.md:146:### Accessing Command Parameters
pkg/doc/topics/18-lua.md:148:The registration process creates a global Lua table with parameter information:
pkg/doc/topics/18-lua.md:150:for layer_name, layer_params in pairs(animal_list_params) do
pkg/doc/topics/18-lua.md:151:    print("Layer: " .. layer_name)
pkg/doc/topics/18-lua.md:152:    for param_name, param_info in pairs(layer_params) do
pkg/doc/topics/18-lua.md:162:The wrapper supports nested Lua tables for complex parameter structures:
pkg/doc/topics/18-lua.md:205:4. Structure your parameter tables to match the expected layer organization
pkg/doc/topics/18-lua.md:207:5. Leverage the parameter information tables for runtime validation and documentation
cmd/glaze/cmds/markdown.go:428:	glazedLayer, err := settings.NewGlazedSchema()
cmd/glaze/cmds/markdown.go:432:	cobraLayer, ok := glazedLayer.(schema.CobraSection)
cmd/glaze/cmds/markdown.go:434:		panic("glazed layer is not a CobraSection")
cmd/glaze/cmds/markdown.go:437:	err = cobraLayer.AddLayerToCobraCommand(parseCmd)
cmd/glaze/cmds/markdown.go:447:	err = cobraLayer.AddLayerToCobraCommand(splitByHeadingCmd)
pkg/doc/topics/08-file-parameter-type.md:3:Slug: file-parameters
pkg/doc/topics/08-file-parameter-type.md:4:Short: Describes how to work with file inputs in command parameters.
pkg/doc/topics/08-file-parameter-type.md:7:- Parameters
pkg/doc/topics/08-file-parameter-type.md:14:Glazed provides two new parameter types `file` and `fileList` that allow passing file paths which will be automatically loaded and parsed.
pkg/doc/topics/08-file-parameter-type.md:18:File parameters are parsed into a single or a list of `FileData` structures which can then be accessed from within a template.
pkg/doc/topics/08-file-parameter-type.md:21:package parameters
pkg/doc/topics/08-file-parameter-type.md:55:The `FileData` structure returned by the `file` and `fileList` parameters can be easily used inside templates.
pkg/doc/topics/08-file-parameter-type.md:86:## The `file` ParameterType
pkg/doc/topics/08-file-parameter-type.md:88:The `file` parameter type allows passing a single file path, which will be read and parsed into a `FileData` structure.
pkg/doc/topics/08-file-parameter-type.md:113:## The `fileList` Parameter
cmd/glaze/cmds/csv.go:25:	glazedLayer, err := settings.NewGlazedSchema()
cmd/glaze/cmds/csv.go:73:			cmds.WithLayersList(
cmd/glaze/cmds/csv.go:74:				glazedLayer,
cmd/glaze/cmds/csv.go:93:		return errors.Wrap(err, "failed to initialize csv settings from parameters")
pkg/doc/topics/16-adding-parameter-types.md:2:Title: Adding New Parameter Types to Glazed
pkg/doc/topics/16-adding-parameter-types.md:3:Slug: adding-parameter-types
pkg/doc/topics/16-adding-parameter-types.md:4:Short: Comprehensive guide on implementing new parameter types in the Glazed framework.
pkg/doc/topics/16-adding-parameter-types.md:6:- parameters
pkg/doc/topics/16-adding-parameter-types.md:18:# Adding New Parameter Types to Glazed
pkg/doc/topics/16-adding-parameter-types.md:22:Parameter types in glazed are defined in the [`glazed/pkg/cmds/parameters`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters) package. Each parameter type requires modifications to several files to handle:
pkg/doc/topics/16-adding-parameter-types.md:32:This guide explains how to add a new parameter type to the glazed command line framework. We'll use the example of adding a `credentials` parameter type to demonstrate the process.
pkg/doc/topics/16-adding-parameter-types.md:36:When adding a new parameter type, you need to modify these files:
pkg/doc/topics/16-adding-parameter-types.md:38:### Core Parameter Files
pkg/doc/topics/16-adding-parameter-types.md:39:1. [`parameter-type.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameter-type.go) - Define the type constant and metadata methods
pkg/doc/topics/16-adding-parameter-types.md:40:2. [`parse.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parse.go) - Add parsing logic
pkg/doc/topics/16-adding-parameter-types.md:41:3. [`parameters.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameters.go) - Add validation and value assignment
pkg/doc/topics/16-adding-parameter-types.md:42:4. [`cobra.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/cobra.go) - Add CLI flag support
pkg/doc/topics/16-adding-parameter-types.md:43:5. [`viper.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/viper.go) - Add configuration file support
pkg/doc/topics/16-adding-parameter-types.md:44:6. [`render.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/render.go) - Add display formatting
pkg/doc/topics/16-adding-parameter-types.md:53:## Step 1: Define the Parameter Type
pkg/doc/topics/16-adding-parameter-types.md:55:In [`parameter-type.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameter-type.go), add your new type constant:
pkg/doc/topics/16-adding-parameter-types.md:60:    ParameterTypeCredentials ParameterType = "credentials"
pkg/doc/topics/16-adding-parameter-types.md:67:func (p ParameterType) IsList() bool {
pkg/doc/topics/16-adding-parameter-types.md:69:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:85:In [`parse.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parse.go), add a case to the `ParseParameter` method:
pkg/doc/topics/16-adding-parameter-types.md:88:func (p *ParameterDefinition) ParseParameter(v []string, options ...ParseStepOption) (*ParsedParameter, error) {
pkg/doc/topics/16-adding-parameter-types.md:94:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:136:func (p *ParameterDefinition) ParseFromReader(f io.Reader, filename string, options ...ParseStepOption) (*ParsedParameter, error) {
pkg/doc/topics/16-adding-parameter-types.md:142:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:160:In [`parameters.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameters.go), add validation to `CheckValueValidity`:
pkg/doc/topics/16-adding-parameter-types.md:163:func (p *ParameterDefinition) CheckValueValidity(v interface{}) (interface{}, error) {
pkg/doc/topics/16-adding-parameter-types.md:169:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:175:                return nil, errors.Errorf("Value for parameter %s is not credentials (expected map[string]string): %v", p.Name, v)
pkg/doc/topics/16-adding-parameter-types.md:203:func (p *ParameterDefinition) InitializeValueToEmptyValue(value reflect.Value) error {
pkg/doc/topics/16-adding-parameter-types.md:207:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:216:func (p *ParameterDefinition) SetValueFromInterface(value reflect.Value, v interface{}) error {
pkg/doc/topics/16-adding-parameter-types.md:222:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:225:            return errors.Errorf("expected credentials for parameter %s, got %T", p.Name, v)
pkg/doc/topics/16-adding-parameter-types.md:234:In [`cobra.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/cobra.go), add flag creation logic:
pkg/doc/topics/16-adding-parameter-types.md:237:func (ps *ParameterDefinitions) AddToCobraCommand(cmd *cobra.Command) error {
pkg/doc/topics/16-adding-parameter-types.md:240:    switch parameter.Type {
pkg/doc/topics/16-adding-parameter-types.md:243:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:245:        if parameter.Default != nil {
pkg/doc/topics/16-adding-parameter-types.md:246:            if creds, ok := (*parameter.Default).(map[string]string); ok {
pkg/doc/topics/16-adding-parameter-types.md:252:        cmd.Flags().StringSliceVarP(&ps.cobraParameterValues[parameter.Name], 
pkg/doc/topics/16-adding-parameter-types.md:253:            parameter.Name, parameter.ShortFlag, defaultValue, parameter.Help)
pkg/doc/topics/16-adding-parameter-types.md:261:func (ps *ParameterDefinitions) SetupCobraCompletions(cmd *cobra.Command) error {
pkg/doc/topics/16-adding-parameter-types.md:264:    switch parameter.Type {
pkg/doc/topics/16-adding-parameter-types.md:265:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:266:        err = cmd.RegisterFlagCompletionFunc(parameter.Name, func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
pkg/doc/topics/16-adding-parameter-types.md:275:In [`render.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/render.go), add display formatting:
pkg/doc/topics/16-adding-parameter-types.md:278:func RenderValue(parameterType ParameterType, value interface{}) (string, error) {
pkg/doc/topics/16-adding-parameter-types.md:279:    switch parameterType {
pkg/doc/topics/16-adding-parameter-types.md:282:    case ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:304:After implementing the core parameter functionality, you may need to update additional files that have exhaustive switch statements on parameter types:
pkg/doc/topics/16-adding-parameter-types.md:321:func FlagTypeToGoType(s *jen.Statement, parameterType fields.Type) *jen.Statement {
pkg/doc/topics/16-adding-parameter-types.md:322:    switch parameterType {
pkg/doc/topics/16-adding-parameter-types.md:332:func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error) {
pkg/doc/topics/16-adding-parameter-types.md:347:        return nil, fmt.Errorf("invalid type for credentials parameter '%s': expected table, got %s", paramDef.Name, value.Type())
pkg/doc/topics/16-adding-parameter-types.md:352:**Pro Tip**: Run `make lint` or `golangci-lint run` after adding your parameter type to discover any additional files with exhaustive switches that need updating.
pkg/doc/topics/16-adding-parameter-types.md:354:## Step 8: Update Parameter Types Example
pkg/doc/topics/16-adding-parameter-types.md:356:Update the parameter types example command in [`cmd/examples/parameter-types/main.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/cmd/examples/parameter-types/main.go) to showcase your new parameter type.
pkg/doc/topics/16-adding-parameter-types.md:358:### Add to Parameter Definitions
pkg/doc/topics/16-adding-parameter-types.md:359:Add your parameter to the `cmds.WithFlags()` section:
pkg/doc/topics/16-adding-parameter-types.md:365:    fields.WithHelp("A credentials parameter for username/password pairs"),
pkg/doc/topics/16-adding-parameter-types.md:371:Add a field to the `ParameterTypesSettings` struct:
pkg/doc/topics/16-adding-parameter-types.md:374:type ParameterTypesSettings struct {
pkg/doc/topics/16-adding-parameter-types.md:380:### Add to Parameter Data Array
pkg/doc/topics/16-adding-parameter-types.md:381:Add an entry to the `parameterData` slice in `RunIntoGlazeProcessor`:
pkg/doc/topics/16-adding-parameter-types.md:384:{"credentials-param", fields.TypeCredentials, s.CredentialsParam, "A credentials parameter for username/password pairs", false, nil, map[string]string{"username": "admin", "password": "secret"}},
pkg/doc/topics/16-adding-parameter-types.md:387:This ensures that developers and users can easily test and understand how your new parameter type works in practice.
pkg/doc/topics/16-adding-parameter-types.md:391:After updating the example, test it to ensure your new parameter type works correctly:
pkg/doc/topics/16-adding-parameter-types.md:394:cd cmd/examples/parameter-types
pkg/doc/topics/16-adding-parameter-types.md:395:go build -o parameter-types .
pkg/doc/topics/16-adding-parameter-types.md:398:./parameter-types parameter-types
pkg/doc/topics/16-adding-parameter-types.md:401:./parameter-types parameter-types --credentials-param username:admin,password:secret
pkg/doc/topics/16-adding-parameter-types.md:403:# Test parameter parsing (useful for debugging)
pkg/doc/topics/16-adding-parameter-types.md:404:./parameter-types parameter-types --credentials-param username:test,password:demo --print-parsed-parameters
pkg/doc/topics/16-adding-parameter-types.md:408:- Your parameter appears in the help output (`--help`)
pkg/doc/topics/16-adding-parameter-types.md:416:Create comprehensive tests for your new parameter type:
pkg/doc/topics/16-adding-parameter-types.md:419:func TestCredentialsParameter(t *testing.T) {
pkg/doc/topics/16-adding-parameter-types.md:445:            pd := &ParameterDefinition{
pkg/doc/topics/16-adding-parameter-types.md:447:                Type: ParameterTypeCredentials,
pkg/doc/topics/16-adding-parameter-types.md:450:            result, err := pd.ParseParameter(tt.input)
pkg/doc/topics/16-adding-parameter-types.md:463:## Example: Complete Credentials Parameter Type
pkg/doc/topics/16-adding-parameter-types.md:465:Here's what the complete implementation would look like for a credentials parameter type:
pkg/doc/topics/16-adding-parameter-types.md:467:### In parameter-type.go
pkg/doc/topics/16-adding-parameter-types.md:471:    ParameterTypeCredentials ParameterType = "credentials"
pkg/doc/topics/16-adding-parameter-types.md:474:func (p ParameterType) IsKeyValue() bool {
pkg/doc/topics/16-adding-parameter-types.md:476:    case ParameterTypeKeyValue, ParameterTypeCredentials:
pkg/doc/topics/16-adding-parameter-types.md:493:When adding a new parameter type to glazed, you need to modify these core files and follow these steps:
pkg/doc/topics/16-adding-parameter-types.md:495:1. **Define the type constant** in `parameter-type.go`
pkg/doc/topics/16-adding-parameter-types.md:497:3. **Add validation and value assignment** in `parameters.go`
pkg/doc/topics/16-adding-parameter-types.md:502:8. **Update the parameter types example** in `cmd/examples/parameter-types/main.go`
pkg/doc/topics/16-adding-parameter-types.md:508:1. **Consistent naming**: Use the pattern `ParameterType<Name>` for constants
pkg/doc/topics/16-adding-parameter-types.md:514:7. **Documentation**: Update parameter type documentation and help text
pkg/doc/topics/16-adding-parameter-types.md:516:9. **Update examples**: Always update the parameter types example to showcase new types
pkg/doc/topics/16-adding-parameter-types.md:527:Follow these patterns when implementing your custom parameter type to ensure consistency with the rest of the glazed framework.
pkg/doc/topics/16-adding-parameter-types.md:529:**Important**: The parameter types example in `cmd/examples/parameter-types/` serves as both documentation and a testing tool. Always update it when adding new parameter types so users and developers can easily understand and test the new functionality.
pkg/doc/tutorials/custom-layer.md:2:Title: Creating Custom Parameter Layers
pkg/doc/tutorials/custom-layer.md:3:Slug: custom-layer-tutorial
pkg/doc/tutorials/custom-layer.md:4:Short: Step-by-step tutorial for creating reusable custom parameter layers in Glazed
pkg/doc/tutorials/custom-layer.md:7:- layers
pkg/doc/tutorials/custom-layer.md:8:- parameters
pkg/doc/tutorials/custom-layer.md:17:# Creating Custom Parameter Layers: Tutorial
pkg/doc/tutorials/custom-layer.md:21:Custom parameter layers address the common challenge of duplicating parameter definitions across multiple CLI commands. Instead of copying the same flags for logging, database connections, or API configurations across commands, parameter layers provide reusable components that encapsulate related parameters and their validation logic.
pkg/doc/tutorials/custom-layer.md:23:This tutorial demonstrates building a production-ready logging layer that can be reused across any Glazed command, providing consistent configuration interfaces and behavior throughout an application.
pkg/doc/tutorials/custom-layer.md:29:- **Reusable logging layer implementation** with comprehensive parameter definitions
pkg/doc/tutorials/custom-layer.md:30:- **Type-safe configuration structures** using struct tags for parameter binding
pkg/doc/tutorials/custom-layer.md:32:- **Command composition patterns** demonstrating layer reuse across multiple commands
pkg/doc/tutorials/custom-layer.md:43:Comprehensive logging configuration for production applications requires multiple parameter categories:
pkg/doc/tutorials/custom-layer.md:56:Parameter layers eliminate the need to duplicate these 7+ flags across every command by defining the configuration once and reusing it throughout the application.
pkg/doc/tutorials/custom-layer.md:58:## Step 1: Parameter Design
pkg/doc/tutorials/custom-layer.md:60:Production logging layers require parameters that address both developer and operational requirements:
pkg/doc/tutorials/custom-layer.md:62:**Core Parameters:**
pkg/doc/tutorials/custom-layer.md:69:**Production Parameters:**
pkg/doc/tutorials/custom-layer.md:73:- **Input validation**: Clear error messages for invalid parameter combinations
pkg/doc/tutorials/custom-layer.md:78:mkdir glazed-logging-layer
pkg/doc/tutorials/custom-layer.md:79:cd glazed-logging-layer
pkg/doc/tutorials/custom-layer.md:80:go mod init glazed-logging-layer
pkg/doc/tutorials/custom-layer.md:86:The project structure separates parameter definitions from business logic for maintainability:
pkg/doc/tutorials/custom-layer.md:89:glazed-logging-layer/
pkg/doc/tutorials/custom-layer.md:90:├── main.go           # Demo commands showing layer usage
pkg/doc/tutorials/custom-layer.md:92:│   ├── layer.go      # Parameter definitions and layer creation
pkg/doc/tutorials/custom-layer.md:98:This separation enables independent testing of parameter validation and provides clear initialization patterns for applications using the layer.
pkg/doc/tutorials/custom-layer.md:104:The settings struct defines the layer's configuration interface, using struct tags to map CLI parameters to Go fields. This struct serves as both the parameter binding target and the configuration container for logger initialization.
pkg/doc/tutorials/custom-layer.md:121:// This struct serves as both the parameter binding target and the
pkg/doc/tutorials/custom-layer.md:261:## Step 4: Define the Parameter Interface
pkg/doc/tutorials/custom-layer.md:263:Create `logging/layer.go`:
pkg/doc/tutorials/custom-layer.md:265:The layer definition specifies the CLI parameters and their configuration options. Each parameter includes type, default values, validation rules, and help text.
pkg/doc/tutorials/custom-layer.md:271:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/tutorials/custom-layer.md:272:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/tutorials/custom-layer.md:276:    // LoggingSlug is the unique identifier for this layer.
pkg/doc/tutorials/custom-layer.md:280:// NewLoggingLayer creates a new parameter layer for logging configuration.
pkg/doc/tutorials/custom-layer.md:281:func NewLoggingLayer() (schema.Section, error) {
pkg/doc/tutorials/custom-layer.md:286:            // Core logging parameters - the ones everyone needs
pkg/doc/tutorials/custom-layer.md:309:            // Developer convenience parameters
pkg/doc/tutorials/custom-layer.md:341:// NewLoggingLayerWithOptions creates a logging layer with customization options
pkg/doc/tutorials/custom-layer.md:342:func NewLoggingLayerWithOptions(opts ...LoggingLayerOption) (schema.Section, error) {
pkg/doc/tutorials/custom-layer.md:343:    config := &loggingLayerConfig{
pkg/doc/tutorials/custom-layer.md:354:    layer, err := NewLoggingLayer()
pkg/doc/tutorials/custom-layer.md:360:    params := layer.GetParameterDefinitions()
pkg/doc/tutorials/custom-layer.md:373:    // To implement conditional parameters, you would need to create separate layers
pkg/doc/tutorials/custom-layer.md:374:    // or build the layer conditionally rather than removing parameters after creation.
pkg/doc/tutorials/custom-layer.md:375:    // For production code, use the basic NewLoggingLayer() without RemoveFlag calls.
pkg/doc/tutorials/custom-layer.md:377:    return layer, nil
pkg/doc/tutorials/custom-layer.md:380:// Configuration options for the logging layer
pkg/doc/tutorials/custom-layer.md:381:type loggingLayerConfig struct {
pkg/doc/tutorials/custom-layer.md:387:type LoggingLayerOption func(*loggingLayerConfig)
pkg/doc/tutorials/custom-layer.md:389:// WithLogstash includes Logstash configuration parameters
pkg/doc/tutorials/custom-layer.md:390:func WithLogstash() LoggingLayerOption {
pkg/doc/tutorials/custom-layer.md:391:    return func(c *loggingLayerConfig) {
pkg/doc/tutorials/custom-layer.md:397:func WithDefaultLevel(level string) LoggingLayerOption {
pkg/doc/tutorials/custom-layer.md:398:    return func(c *loggingLayerConfig) {
pkg/doc/tutorials/custom-layer.md:404:func WithDefaultFormat(format string) LoggingLayerOption {
pkg/doc/tutorials/custom-layer.md:405:    return func(c *loggingLayerConfig) {
pkg/doc/tutorials/custom-layer.md:421:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/tutorials/custom-layer.md:425:// GetLoggingSettings extracts logging settings from parsed layers
pkg/doc/tutorials/custom-layer.md:426:func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {
pkg/doc/tutorials/custom-layer.md:428:    if err := parsedLayers.InitializeStruct(LoggingSlug, settings); err != nil {
pkg/doc/tutorials/custom-layer.md:434:// InitializeLogging sets up logging from parsed layers
pkg/doc/tutorials/custom-layer.md:435:func InitializeLogging(parsedLayers *values.Values) error {
pkg/doc/tutorials/custom-layer.md:436:    settings, err := GetLoggingSettings(parsedLayers)
pkg/doc/tutorials/custom-layer.md:457:func MustInitializeLogging(parsedLayers *values.Values) {
pkg/doc/tutorials/custom-layer.md:458:    if err := InitializeLogging(parsedLayers); err != nil {
pkg/doc/tutorials/custom-layer.md:476:## Step 6: Create a Command Using the Layer
pkg/doc/tutorials/custom-layer.md:489:    "glazed-logging-layer/logging"
pkg/doc/tutorials/custom-layer.md:493:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/tutorials/custom-layer.md:494:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/tutorials/custom-layer.md:502:// ProcessDataCommand demonstrates using the logging layer
pkg/doc/tutorials/custom-layer.md:516:    parsedLayers *values.Values,
pkg/doc/tutorials/custom-layer.md:520:    if err := logging.InitializeLogging(parsedLayers); err != nil {
pkg/doc/tutorials/custom-layer.md:528:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, settings); err != nil {
pkg/doc/tutorials/custom-layer.md:575:    // Create logging layer with custom options
pkg/doc/tutorials/custom-layer.md:576:    loggingLayer, err := logging.NewLoggingLayerWithOptions(
pkg/doc/tutorials/custom-layer.md:585:    // Create glazed layer for output formatting
pkg/doc/tutorials/custom-layer.md:586:    glazedLayer, err := settings.NewGlazedParameterLayers()
pkg/doc/tutorials/custom-layer.md:596:This command demonstrates how to use the custom logging layer.
pkg/doc/tutorials/custom-layer.md:635:        // Add both logging and glazed layers
pkg/doc/tutorials/custom-layer.md:636:        cmds.WithLayersList(loggingLayer, glazedLayer),
pkg/doc/tutorials/custom-layer.md:646:// Second command to demonstrate layer reuse
pkg/doc/tutorials/custom-layer.md:659:    parsedLayers *values.Values,
pkg/doc/tutorials/custom-layer.md:662:    // Initialize logging (same layer, reused!)
pkg/doc/tutorials/custom-layer.md:663:    if err := logging.InitializeLogging(parsedLayers); err != nil {
pkg/doc/tutorials/custom-layer.md:670:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, settings); err != nil {
pkg/doc/tutorials/custom-layer.md:704:    // Reuse the same logging layer - this is the power of layers!
pkg/doc/tutorials/custom-layer.md:705:    loggingLayer, err := logging.NewLoggingLayer()
pkg/doc/tutorials/custom-layer.md:710:    glazedLayer, err := settings.NewGlazedParameterLayers()
pkg/doc/tutorials/custom-layer.md:742:        cmds.WithLayersList(loggingLayer, glazedLayer),
pkg/doc/tutorials/custom-layer.md:755:        Short: "Data processing application with custom logging layer",
pkg/doc/tutorials/custom-layer.md:756:        Long:  "Demonstrates how to create and reuse custom parameter layers in Glazed",
pkg/doc/tutorials/custom-layer.md:793:## Step 7: Test Your Custom Layer
pkg/doc/tutorials/custom-layer.md:857:### Layer Composition
pkg/doc/tutorials/custom-layer.md:859:Create specialized layers by combining the logging layer with others:
pkg/doc/tutorials/custom-layer.md:862:func NewDatabaseLayerWithLogging() ([]schema.Section, error) {
pkg/doc/tutorials/custom-layer.md:863:    loggingLayer, err := logging.NewLoggingLayer()
pkg/doc/tutorials/custom-layer.md:868:    dbLayer, err := database.NewDatabaseLayer()
pkg/doc/tutorials/custom-layer.md:873:    return []schema.Section{loggingLayer, dbLayer}, nil
pkg/doc/tutorials/custom-layer.md:883:**Before layers**: Adding logging to commands required copying flag definitions, validation logic, and initialization code across multiple files, leading to inconsistent behavior and maintenance overhead.
pkg/doc/tutorials/custom-layer.md:885:**With layers**: Adding logging to any command requires a single line: `cmds.WithLayersList(loggingLayer)`. All commands share the same interface, validation, and behavior patterns.
pkg/doc/tutorials/custom-layer.md:889:**Separation of Concerns**: The logging layer handles configuration independently from business logic, enabling isolated testing and reuse across different commands.
pkg/doc/tutorials/custom-layer.md:893:**Sensible Defaults**: The layer provides working defaults for common use cases while supporting advanced configurations for enterprise requirements.
pkg/doc/tutorials/custom-layer.md:895:**Convention Over Configuration**: Consistent patterns for parameter naming, struct tags, and validation provide familiar interfaces for Go developers.
pkg/doc/tutorials/custom-layer.md:899:The implemented layer includes production-ready capabilities:
pkg/doc/tutorials/custom-layer.md:909:Layer composition enables modular architecture patterns for complex applications:
pkg/doc/tutorials/custom-layer.md:913:│   API Layer     │  │ Database Layer  │  │ Logging Layer   │
pkg/doc/tutorials/custom-layer.md:925:                    │   parameters      │
pkg/doc/tutorials/custom-layer.md:929:Each layer handles a specific concern. Commands compose required layers to build applications that scale from simple scripts to complex enterprise systems.
pkg/doc/tutorials/custom-layer.md:933:### Layer Library Development
pkg/doc/tutorials/custom-layer.md:935:Common layer implementations for production applications:
pkg/doc/tutorials/custom-layer.md:937:**Database Layer**: Connection pooling, transaction management, migration flags
pkg/doc/tutorials/custom-layer.md:938:**HTTP Client Layer**: Authentication, retries, circuit breakers, rate limiting  
pkg/doc/tutorials/custom-layer.md:939:**File Processing Layer**: Input/output directories, file patterns, validation
pkg/doc/tutorials/custom-layer.md:940:**Cache Layer**: Redis configuration, TTL settings, eviction policies
pkg/doc/tutorials/custom-layer.md:948:baseLayer := NewBaseLayer(
pkg/doc/tutorials/custom-layer.md:954:apiLayer := NewAPILayer(
pkg/doc/tutorials/custom-layer.md:962:Enterprise layer implementations must address:
pkg/doc/tutorials/custom-layer.md:966:- **Validation relationships**: Cross-parameter validation and dependency checking
pkg/doc/tutorials/custom-layer.md:967:- **Backward compatibility**: Evolution strategies for layer APIs
pkg/doc/tutorials/custom-layer.md:969:## Layer Patterns That Work in Production
pkg/doc/tutorials/custom-layer.md:971:### Database Layer
pkg/doc/tutorials/custom-layer.md:985:### HTTP Client Layer
pkg/doc/tutorials/custom-layer.md:998:### File Processing Layer
pkg/doc/tutorials/custom-layer.md:1014:This tutorial demonstrates implementing reusable parameter layers for CLI applications. The key principle is **configuration through composition**.
pkg/doc/tutorials/custom-layer.md:1016:Rather than defining flags individually per command, standardized layers encapsulate interface and behavior patterns. This approach creates application consistency, reduces maintenance overhead, and provides predictable user interfaces.
pkg/doc/tutorials/custom-layer.md:1018:The layer pattern enables scalable CLI architecture that grows from simple commands to comprehensive enterprise applications.
pkg/doc/topics/10-template-command.md:17:A TemplateCommand allows you to define commands that render Go template text using command-line parameters as template variables. This enables rapid prototyping of text generation tools without writing Go code—simply define parameters in YAML and write a template that uses those parameters.
pkg/doc/topics/10-template-command.md:21:Template commands are defined in YAML files with a `template` field containing Go template syntax. The template receives all parsed parameters as variables accessible through the standard `{{.variable}}` syntax.
pkg/doc/topics/10-template-command.md:97:		// Provide parameter values for the "default" layer
pkg/doc/topics/10-template-command.md:114:Template commands use Go's `text/template` package syntax. All parsed parameters are available as variables in the template context.
pkg/doc/topics/10-template-command.md:135:  # Using defaults for optional parameters
pkg/doc/topics/10-template-command.md:139:## Parameter Types
pkg/doc/topics/10-template-command.md:141:Template commands can leverage the full range of Glazed parameter types, allowing for rich and validated inputs. This means you can create templates that accept everything from simple strings and booleans to lists, choices, and even content from files.
pkg/doc/topics/10-template-command.md:143:Template commands support all standard Glazed parameter types:
pkg/doc/topics/10-template-command.md:151:For more details on parameter types, see:
pkg/doc/topics/10-template-command.md:153:glaze help parameter-types
cmd/glaze/cmds/docs.go:52:	// This is an example of selective use of glazed parameter schema.
cmd/glaze/cmds/docs.go:56:	glazedLayer, err := settings.NewGlazedSchema(
cmd/glaze/cmds/docs.go:57:		settings.WithFieldsFiltersParameterLayerOptions(
cmd/glaze/cmds/docs.go:79:	cobraLayer, ok := glazedLayer.(schema.CobraSection)
cmd/glaze/cmds/docs.go:81:		panic("glazed layer is not a CobraSection")
cmd/glaze/cmds/docs.go:84:	err = cobraLayer.AddLayerToCobraCommand(DocsCmd)
pkg/doc/topics/13-layers-and-parsed-layers.md:2:Title: Parameter Layers and Parsed Layers
pkg/doc/topics/13-layers-and-parsed-layers.md:3:Slug: parameter-layers-and-parsed-layers
pkg/doc/topics/13-layers-and-parsed-layers.md:5:    Learn how to use parameter layers and parsed layers in Glazed to organize and manage parameter definitions.
pkg/doc/topics/13-layers-and-parsed-layers.md:7:  - layers
pkg/doc/topics/13-layers-and-parsed-layers.md:17:## Parameter Layers
pkg/doc/topics/13-layers-and-parsed-layers.md:19:Layers in the glazed package provide a way to group and organize parameter definitions. They allow for better structure and modularity in command-line interfaces and other parameter-driven systems.
pkg/doc/topics/13-layers-and-parsed-layers.md:21:A layer is a logical grouping of related parameter definitions. It consists of several components:
pkg/doc/topics/13-layers-and-parsed-layers.md:22:1. **Name**: A human-readable name for the layer.
pkg/doc/topics/13-layers-and-parsed-layers.md:23:2. **Slug**: A unique identifier for the layer, used in code.
pkg/doc/topics/13-layers-and-parsed-layers.md:24:3. **Description**: A brief explanation of the layer's purpose.
pkg/doc/topics/13-layers-and-parsed-layers.md:25:4. **Prefix**: An optional prefix for parameter names within the layer.
pkg/doc/topics/13-layers-and-parsed-layers.md:26:5. **Parameter Definitions**: A collection of parameter definitions that belong to this layer.
pkg/doc/topics/13-layers-and-parsed-layers.md:28:### Parameter Definitions
pkg/doc/topics/13-layers-and-parsed-layers.md:30:A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.
pkg/doc/topics/13-layers-and-parsed-layers.md:32:1. **ParameterLayer**: An interface that groups parameter definitions and provides metadata.
pkg/doc/topics/13-layers-and-parsed-layers.md:33:2. **ParameterLayers**: A collection of ParameterLayer objects.
pkg/doc/topics/13-layers-and-parsed-layers.md:35:## Creating and Working with Parameter Layers
pkg/doc/topics/13-layers-and-parsed-layers.md:37:The `ParameterLayerImpl` struct provides a straightforward implementation of the
pkg/doc/topics/13-layers-and-parsed-layers.md:38:`ParameterLayer` interface.
pkg/doc/topics/13-layers-and-parsed-layers.md:40:### Creating a Parameter Layer
pkg/doc/topics/13-layers-and-parsed-layers.md:42:You can create a new parameter layer using the `NewParameterLayer` function:
pkg/doc/topics/13-layers-and-parsed-layers.md:45:layer, err := NewParameterLayer("config", "Configuration",
pkg/doc/topics/13-layers-and-parsed-layers.md:48:    WithParameterDefinitions(
pkg/doc/topics/13-layers-and-parsed-layers.md:58:### Adding Parameters to a Layer
pkg/doc/topics/13-layers-and-parsed-layers.md:60:You can add parameters to an existing layer using the `AddFlags` method:
pkg/doc/topics/13-layers-and-parsed-layers.md:63:layer.AddFlags(
pkg/doc/topics/13-layers-and-parsed-layers.md:69:### Initializing Parameter Defaults from a Struct
pkg/doc/topics/13-layers-and-parsed-layers.md:71:You can initialize the default values of parameters in a layer using a struct:
pkg/doc/topics/13-layers-and-parsed-layers.md:88:err := layer.InitializeParameterDefaultsFromStruct(&defaultConfig)
pkg/doc/topics/13-layers-and-parsed-layers.md:94:### Initializing Parameter Defaults from a Map
pkg/doc/topics/13-layers-and-parsed-layers.md:106:err := layer.InitializeParameterDefaultsFromParameters(defaultValues)
pkg/doc/topics/13-layers-and-parsed-layers.md:112:### Initializing a Struct from Parameter Defaults
pkg/doc/topics/13-layers-and-parsed-layers.md:114:You can also populate a struct with the default values from the parameter layer:
pkg/doc/topics/13-layers-and-parsed-layers.md:118:err := layer.InitializeStructFromParameterDefaults(&config)
pkg/doc/topics/13-layers-and-parsed-layers.md:124:### Loading a Parameter Layer from YAML
pkg/doc/topics/13-layers-and-parsed-layers.md:126:You can create a parameter layer from a YAML definition:
pkg/doc/topics/13-layers-and-parsed-layers.md:142:layer, err := NewParameterLayerFromYAML(yamlContent)
pkg/doc/topics/13-layers-and-parsed-layers.md:148:### Cloning a Parameter Layer
pkg/doc/topics/13-layers-and-parsed-layers.md:150:To create a deep copy of a parameter layer:
pkg/doc/topics/13-layers-and-parsed-layers.md:153:clonedLayer := layer.Clone()
pkg/doc/topics/13-layers-and-parsed-layers.md:156:### Creating ParameterLayers
pkg/doc/topics/13-layers-and-parsed-layers.md:159:layers := NewParameterLayers(
pkg/doc/topics/13-layers-and-parsed-layers.md:160:    WithLayers(configLayer, outputLayer),
pkg/doc/topics/13-layers-and-parsed-layers.md:164:### Registering Layers Under Explicit Slugs on Commands
pkg/doc/topics/13-layers-and-parsed-layers.md:166:When creating a `cmds.CommandDescription`, you can register layers under explicit slugs using `cmds.WithLayersMap`.
pkg/doc/topics/13-layers-and-parsed-layers.md:169:// Create layers with internal slugs
pkg/doc/topics/13-layers-and-parsed-layers.md:170:cfgLayer, _ := schema.NewSection("config", "Configuration")
pkg/doc/topics/13-layers-and-parsed-layers.md:171:outLayer, _ := schema.NewSection("output", "Output")
pkg/doc/topics/13-layers-and-parsed-layers.md:176:    cmds.WithLayersMap(map[string]schema.Section{
pkg/doc/topics/13-layers-and-parsed-layers.md:177:        "cfg": cfgLayer,   // registered as "cfg"
pkg/doc/topics/13-layers-and-parsed-layers.md:178:        "out": outLayer,   // registered as "out"
pkg/doc/topics/13-layers-and-parsed-layers.md:182:// Later, parsed layers will be accessed by these slugs
pkg/doc/topics/13-layers-and-parsed-layers.md:183:// parsedLayers.InitializeStruct("cfg", &myCfg)
pkg/doc/topics/13-layers-and-parsed-layers.md:186:Note: If the layer is a `*schema.SectionImpl` and the key differs from the layer's internal slug, the layer is cloned and aligned to the registration key to maintain consistency at runtime.
pkg/doc/topics/13-layers-and-parsed-layers.md:188:### Accessing Layer Information
pkg/doc/topics/13-layers-and-parsed-layers.md:191:name := layer.GetName()
pkg/doc/topics/13-layers-and-parsed-layers.md:192:slug := layer.GetSlug()
pkg/doc/topics/13-layers-and-parsed-layers.md:193:description := layer.GetDescription()
pkg/doc/topics/13-layers-and-parsed-layers.md:198:Iterate over all parameter layers:
pkg/doc/topics/13-layers-and-parsed-layers.md:201:parameterLayers.ForEach(func(key string, p ParameterLayer) {
pkg/doc/topics/13-layers-and-parsed-layers.md:202:    // Process each layer
pkg/doc/topics/13-layers-and-parsed-layers.md:205:err := parameterLayers.ForEachE(func(key string, p ParameterLayer) error {
pkg/doc/topics/13-layers-and-parsed-layers.md:206:    // Process each layer, return error to stop iteration
pkg/doc/topics/13-layers-and-parsed-layers.md:213:Create a new ParameterLayers containing only the specified layers:
pkg/doc/topics/13-layers-and-parsed-layers.md:216:subset := parameterLayers.Subset("config", "output")
pkg/doc/topics/13-layers-and-parsed-layers.md:219:### AppendLayers and PrependLayers
pkg/doc/topics/13-layers-and-parsed-layers.md:221:Add layers to the end or beginning of the collection:
pkg/doc/topics/13-layers-and-parsed-layers.md:224:parameterLayers.AppendLayers(newLayer1, newLayer2)
pkg/doc/topics/13-layers-and-parsed-layers.md:225:parameterLayers.PrependLayers(newLayer3, newLayer4)
pkg/doc/topics/13-layers-and-parsed-layers.md:230:Merge two ParameterLayers collections:
pkg/doc/topics/13-layers-and-parsed-layers.md:233:mergedLayers := parameterLayers.Merge(otherParameterLayers)
pkg/doc/topics/13-layers-and-parsed-layers.md:238:Create a deep copy of ParameterLayers:
pkg/doc/topics/13-layers-and-parsed-layers.md:241:clonedParameterLayers := parameterLayers.Clone()
pkg/doc/topics/13-layers-and-parsed-layers.md:244:### GetAllParameterDefinitions
pkg/doc/topics/13-layers-and-parsed-layers.md:246:Get all parameter definitions across all layers:
pkg/doc/topics/13-layers-and-parsed-layers.md:249:allDefinitions := parameterLayers.GetAllParameterDefinitions()
pkg/doc/topics/13-layers-and-parsed-layers.md:252:## Parsed Layers
pkg/doc/topics/13-layers-and-parsed-layers.md:254:A ParsedLayer is the result of parsing input data (such as command-line
pkg/doc/topics/13-layers-and-parsed-layers.md:255:arguments, configuration files, or environment variables) using a ParameterLayer
pkg/doc/topics/13-layers-and-parsed-layers.md:258:1. **Layer**: A reference to the original ParameterLayer used for parsing.
pkg/doc/topics/13-layers-and-parsed-layers.md:259:2. **Parameters**: A collection of ParsedParameter objects, each containing:
pkg/doc/topics/13-layers-and-parsed-layers.md:260:    - The original ParameterDefinition
pkg/doc/topics/13-layers-and-parsed-layers.md:264:ParsedLayers is a collection of ParsedLayer objects, typically representing all the layers used in a command or application.
pkg/doc/topics/13-layers-and-parsed-layers.md:266:### Usage of ParsedLayers
pkg/doc/topics/13-layers-and-parsed-layers.md:268:ParsedLayers are primarily used to:
pkg/doc/topics/13-layers-and-parsed-layers.md:270:1. Store and organize parsed parameter values
pkg/doc/topics/13-layers-and-parsed-layers.md:271:2. Access parsed values across different layers
pkg/doc/topics/13-layers-and-parsed-layers.md:274:5. Provide a unified interface for accessing all parsed parameters in an application
pkg/doc/topics/13-layers-and-parsed-layers.md:277:### Creating a ParsedLayer
pkg/doc/topics/13-layers-and-parsed-layers.md:280:parsedLayer, err := NewParsedLayer(layer,
pkg/doc/topics/13-layers-and-parsed-layers.md:281:    WithParsedParameterValue("verbose", true),
pkg/doc/topics/13-layers-and-parsed-layers.md:288:### Creating ParsedLayers
pkg/doc/topics/13-layers-and-parsed-layers.md:291:parsedLayers := NewParsedLayers(
pkg/doc/topics/13-layers-and-parsed-layers.md:292:    WithParsedLayer("config", parsedConfigLayer),
pkg/doc/topics/13-layers-and-parsed-layers.md:293:    WithParsedLayer("output", parsedOutputLayer),
pkg/doc/topics/13-layers-and-parsed-layers.md:300:value, ok := parsedLayer.GetParameter("verbose")
pkg/doc/topics/13-layers-and-parsed-layers.md:302:    // Parameter not found
pkg/doc/topics/13-layers-and-parsed-layers.md:306:### Initializing Structs from ParsedLayers
pkg/doc/topics/13-layers-and-parsed-layers.md:315:err := parsedLayers.InitializeStruct("config", &config)
pkg/doc/topics/13-layers-and-parsed-layers.md:321:### Merging ParsedLayers
pkg/doc/topics/13-layers-and-parsed-layers.md:324:parsedLayers.GetDefaultParameterLayer().MergeParameters(otherParsedLayer)
pkg/doc/topics/13-layers-and-parsed-layers.md:327:### Getting All Parsed Parameters
pkg/doc/topics/13-layers-and-parsed-layers.md:330:allParams := parsedLayers.GetAllParsedParameters()
pkg/doc/topics/13-layers-and-parsed-layers.md:336:Iterate over all parsed layers:
pkg/doc/topics/13-layers-and-parsed-layers.md:339:parsedLayers.ForEach(func(k string, v *ParsedLayer) {
pkg/doc/topics/13-layers-and-parsed-layers.md:340:    // Process each layer
pkg/doc/topics/13-layers-and-parsed-layers.md:343:err := parsedLayers.ForEachE(func(k string, v *ParsedLayer) error {
pkg/doc/topics/13-layers-and-parsed-layers.md:344:    // Process each layer, return error to stop iteration
pkg/doc/topics/13-layers-and-parsed-layers.md:351:Get a map of all parameter values across all layers:
pkg/doc/topics/13-layers-and-parsed-layers.md:354:dataMap := parsedLayers.GetDataMap()
pkg/doc/topics/13-layers-and-parsed-layers.md:359:Get an existing ParsedLayer or create a new one if it doesn't exist:
pkg/doc/topics/13-layers-and-parsed-layers.md:362:parsedLayer := parsedLayers.GetOrCreate(someParameterLayer)
pkg/doc/topics/13-layers-and-parsed-layers.md:367:Create a deep copy of ParsedLayers:
pkg/doc/topics/13-layers-and-parsed-layers.md:370:clonedParsedLayers := parsedLayers.Clone()
pkg/doc/topics/13-layers-and-parsed-layers.md:376:Middlewares in the Glazed framework provide a powerful mechanism to manage parameter values from various sources such as environment variables, configuration files, and command-line arguments. They allow for flexible and modular parameter handling in your applications.
pkg/doc/topics/13-layers-and-parsed-layers.md:380:- **Middleware Structure**: Each middleware processes parameters before and/or after calling the next handler in the chain. They work with `ParameterLayers` and `ParsedLayers` to manage parameter definitions and values.
pkg/doc/topics/13-layers-and-parsed-layers.md:386:1. **SetFromDefaults**: Populates parameters with their default values if no value exists.
pkg/doc/topics/13-layers-and-parsed-layers.md:400:3. **LoadParametersFromFile / LoadParametersFromFiles**: Load parameters from JSON or YAML files.
pkg/doc/topics/13-layers-and-parsed-layers.md:411:4. **ParseFromCobraCommand**: Parses parameter values from a Cobra command, typically used for CLI applications.
pkg/doc/topics/13-layers-and-parsed-layers.md:420:To use middlewares, chain them together and execute them with your parameter layers and parsed layers:
pkg/doc/topics/13-layers-and-parsed-layers.md:424:sources.Execute(layers, parsedLayers,
pkg/doc/topics/13-layers-and-parsed-layers.md:435:- **Layer Filtering**: Apply middlewares to specific layers using whitelisting or blacklisting.
pkg/doc/topics/13-layers-and-parsed-layers.md:436:- **Source Tracking**: Use `WithParseStepSource` to track where parameter values originate.
pkg/help/cmd/cobra.go:150:	// if we are showing the short help and shortHelpLayers annotation was set,
pkg/help/cmd/cobra.go:153:		shortHelpLayers_, ok := c.Annotations["shortHelpLayers"]
pkg/help/cmd/cobra.go:155:			shortHelpLayers := map[string]interface{}{}
pkg/help/cmd/cobra.go:156:			for _, v := range strings.Split(shortHelpLayers_, ",") {
pkg/help/cmd/cobra.go:157:				shortHelpLayers[v] = true
pkg/help/cmd/cobra.go:163:				if _, ok = shortHelpLayers[f.Slug]; ok {
pkg/help/cmd/cobra.go:168:				if _, ok = shortHelpLayers[f.Slug]; ok {
pkg/doc/tutorials/04-lua.md:70:2. Creates a global table containing parameter information (`animal_list_params`)
pkg/doc/tutorials/04-lua.md:75:- Set up parameters for the command
pkg/doc/tutorials/04-lua.md:78:- Display parameter information
pkg/doc/tutorials/04-lua.md:98:-- Print parameter information
pkg/doc/tutorials/04-lua.md:99:print("\nParameters for animal_list command:")
pkg/doc/tutorials/04-lua.md:100:for layer_name, layer_params in pairs(animal_list_params) do
pkg/doc/tutorials/04-lua.md:101:    print("Layer: " .. layer_name)
pkg/doc/tutorials/04-lua.md:102:    for param_name, param_info in pairs(layer_params) do
pkg/doc/tutorials/04-lua.md:127:For more complex commands, you might need to work with nested parameter structures. Here's how to use nested tables:
pkg/doc/tutorials/04-lua.md:154:err := sources.Execute(cmd.Description().Layers, 
pkg/doc/tutorials/04-lua.md:155:    parsedLayers, 
pkg/doc/tutorials/04-lua.md:166:- Work with parameters and nested tables
pkg/doc/topics/16-parsing-parameters.md:2:Title: Parsing Parameters
pkg/doc/topics/16-parsing-parameters.md:3:Slug: parsing-parameters
pkg/doc/topics/16-parsing-parameters.md:4:Short: Learn how to define and parse parameters in Go applications using the Parameter API.
pkg/doc/topics/16-parsing-parameters.md:6:  - Parameter API
pkg/doc/topics/16-parsing-parameters.md:17:The **Parameter API** facilitates parsing and managing parameters in Go applications. It's ideal for applications requiring flexible parameter handling.
pkg/doc/topics/16-parsing-parameters.md:21:### ParameterDefinition
pkg/doc/topics/16-parsing-parameters.md:23:A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.
pkg/doc/topics/16-parsing-parameters.md:26:type ParameterDefinition struct {
pkg/doc/topics/16-parsing-parameters.md:29:    Type       ParameterType `yaml:"type"`
pkg/doc/topics/16-parsing-parameters.md:38:### ParameterDefinitions
pkg/doc/topics/16-parsing-parameters.md:40:`ParameterDefinitions` is an ordered map of `ParameterDefinition` instances, indexed by name.
pkg/doc/topics/16-parsing-parameters.md:43:type ParameterDefinitions struct {
pkg/doc/topics/16-parsing-parameters.md:44:    *orderedmap.OrderedMap[string, *ParameterDefinition]
pkg/doc/topics/16-parsing-parameters.md:48:### ParsedParameter
pkg/doc/topics/16-parsing-parameters.md:50:A `ParsedParameter` contains the parsed value, its `ParameterDefinition`, and a log of parsing steps.
pkg/doc/topics/16-parsing-parameters.md:53:type ParsedParameter struct {
pkg/doc/topics/16-parsing-parameters.md:55:    ParameterDefinition *ParameterDefinition
pkg/doc/topics/16-parsing-parameters.md:60:### ParsedParameters
pkg/doc/topics/16-parsing-parameters.md:62:`ParsedParameters` is an ordered map of `ParsedParameter` instances, indexed by parameter names.
pkg/doc/topics/16-parsing-parameters.md:65:type ParsedParameters struct {
pkg/doc/topics/16-parsing-parameters.md:66:    *orderedmap.OrderedMap[string, *ParsedParameter]
pkg/doc/topics/16-parsing-parameters.md:84:Follow these steps to use the Parameter API: define parameters and parse them from user input or configuration files.
pkg/doc/topics/16-parsing-parameters.md:86:### Defining Parameters
pkg/doc/topics/16-parsing-parameters.md:88:Define parameters using `ParameterDefinition`, specifying name, type, and options like default values or choices.
pkg/doc/topics/16-parsing-parameters.md:91:import "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/16-parsing-parameters.md:93:// Define a string parameter with a default value
pkg/doc/topics/16-parsing-parameters.md:103:### Parsing Parameters
pkg/doc/topics/16-parsing-parameters.md:105:Parse input values (e.g., from command-line arguments) to obtain `ParsedParameter` instances.
pkg/doc/topics/16-parsing-parameters.md:111:parsedParam, err := paramName.ParseParameter(inputs)
pkg/doc/topics/16-parsing-parameters.md:121:Access parsed parameter values via `ParsedParameters`.
pkg/doc/topics/16-parsing-parameters.md:124:// Create a collection of parameter definitions
pkg/doc/topics/16-parsing-parameters.md:126:    parameters.WithParameterDefinitionList([]*fields.Definition{paramName}),
pkg/doc/topics/16-parsing-parameters.md:129:// Parse a parameter value
pkg/doc/topics/16-parsing-parameters.md:130:parsedParams, err := paramDefs.ParseParameters(userInputs)
pkg/doc/topics/16-parsing-parameters.md:140:## Managing Parsed Parameters
pkg/doc/topics/16-parsing-parameters.md:142:Manage parsed parameters using these methods: updating values, merging parameter sets, and cloning parsed data.
pkg/doc/topics/16-parsing-parameters.md:146:Update a parsed parameter's value, optionally appending a new parsing step.
pkg/doc/topics/16-parsing-parameters.md:152:### Merging Parameters
pkg/doc/topics/16-parsing-parameters.md:154:Merge another `ParsedParameters` instance, combining values and logs.
pkg/doc/topics/16-parsing-parameters.md:160:### Cloning Parameters
pkg/doc/topics/16-parsing-parameters.md:162:Create a deep copy of `ParsedParameters` to avoid unintended mutations.
pkg/doc/topics/16-parsing-parameters.md:168:## Handling Defaults and Required Parameters
pkg/doc/topics/16-parsing-parameters.md:170:Specify default values and enforce required parameters.
pkg/doc/topics/16-parsing-parameters.md:173:// Define a required integer parameter without a default
pkg/doc/topics/16-parsing-parameters.md:182:During parsing, an error is returned if a required parameter is missing. If an optional parameter is missing, its default value is used.
pkg/doc/topics/16-parsing-parameters.md:185:parsedParam, err := ageParam.ParseParameter([]string{})
pkg/doc/topics/16-parsing-parameters.md:197:Each `ParsedParameter` logs parsing steps, showing how the final value was derived.
pkg/doc/topics/16-parsing-parameters.md:207:Define parameters to accept values from files (e.g., JSON, YAML, CSV).
pkg/doc/topics/16-parsing-parameters.md:210:// Define a parameter that expects a JSON file
pkg/doc/topics/16-parsing-parameters.md:218:// Parse the parameter from file input
pkg/doc/topics/16-parsing-parameters.md:219:parsedFileParam, err := fileParam.ParseParameter([]string{"config.json"})
pkg/cmds/fields/parameters.go:16:// Definition is a declarative way of describing a command line parameter.
pkg/cmds/fields/parameters.go:71:	parameterType Type,
pkg/cmds/fields/parameters.go:76:		Type: parameterType,
pkg/cmds/fields/parameters.go:87:	return fmt.Sprintf("{Parameter: %s - %s}", p.Name, p.Type)
pkg/cmds/fields/parameters.go:124:		return errors.Errorf("invalid value for parameter %s: %v", p.Name, value.Interface())
pkg/cmds/fields/parameters.go:151:// InitializeValueToEmptyValue initializes the given value to the empty value of the type of the parameter.
pkg/cmds/fields/parameters.go:182:		return errors.Errorf("unknown parameter type %s", p.Type)
pkg/cmds/fields/parameters.go:189:// various supported parameter types.
pkg/cmds/fields/parameters.go:200:			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:207:			return errors.Errorf("expected bool value for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:220:			return errors.Errorf("expected string list for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:227:			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:231:			return errors.Wrapf(err, "error parsing value for parameter %s", p.Name)
pkg/cmds/fields/parameters.go:244:			return errors.Errorf("expected list of files for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:251:			return errors.Errorf("expected list of maps for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:258:			return errors.Errorf("expected map for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:265:			return errors.Errorf("expected map for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:269:			return errors.Errorf("expected map of strings for parameter %s, got %T", p.Name, v)
pkg/cmds/fields/parameters.go:274:		return errors.Errorf("unknown parameter type %s", p.Type)
pkg/cmds/fields/parameters.go:279:// ParsedParametersFromDefaults uses the parameter definitions default values to create a ParsedParameters
pkg/cmds/fields/parameters.go:281:func (pds *Definitions) ParsedParametersFromDefaults() (*ParsedParameters, error) {
pkg/cmds/fields/parameters.go:282:	ret := NewParsedParameters()
pkg/cmds/fields/parameters.go:302:// InitializeStructFromDefaults initializes a struct from a map of parameter definitions.
pkg/cmds/fields/parameters.go:308:	parsedParameters, err := pds.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters.go:312:	return parsedParameters.InitializeStruct(s)
pkg/cmds/fields/parameters.go:315:// InitializeDefaultsFromStruct initializes the parameters definitions from a struct.
pkg/cmds/fields/parameters.go:317:// the default value of the corresponding definition in `parameterDefinitions`.
pkg/cmds/fields/parameters.go:355:						return errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)
pkg/cmds/fields/parameters.go:358:						return errors.Errorf("wildcard parameters require a map of strings, field %s is not a map of strings", field.Name)
pkg/cmds/fields/parameters.go:378:		parameter, ok := pds.Get(tagOptions.Name)
pkg/cmds/fields/parameters.go:380:			return errors.Errorf("unknown parameter %s when initializing defaults from struct", tag)
pkg/cmds/fields/parameters.go:384:		err = parameter.SetDefaultFromValue(value)
pkg/cmds/fields/parameters.go:397:		parameter, ok := pds.Get(k)
pkg/cmds/fields/parameters.go:399:			return errors.Errorf("unknown parameter when initializing defaults from map: %s", k)
pkg/cmds/fields/parameters.go:401:		err := parameter.SetDefaultFromValue(reflect.ValueOf(v))
pkg/cmds/fields/parameters.go:410:// CheckParameterDefaultValueValidity checks if the Definition's Default is valid.
pkg/cmds/fields/parameters.go:412:func (p *Definition) CheckParameterDefaultValueValidity() (interface{}, error) {
pkg/cmds/fields/parameters.go:421:		return nil, errors.Wrapf(err, "invalid default value for parameter %s", p.Name)
pkg/cmds/fields/parameters.go:444:			return nil, errors.Errorf("Value for parameter %s is not a string: %v", p.Name, v)
pkg/cmds/fields/parameters.go:453:			return nil, errors.Errorf("Value for parameter %s (type %T) is not a list of objects: %v", p.Name, v, v)
pkg/cmds/fields/parameters.go:460:			return nil, errors.Errorf("Value for parameter %s is not an object: %v", p.Name, v)
pkg/cmds/fields/parameters.go:467:			return nil, errors.Errorf("Value for parameter %s is not an integer: %v", p.Name, v)
pkg/cmds/fields/parameters.go:474:			return nil, errors.Errorf("Value for parameter %s is not a float: %v", p.Name, v)
pkg/cmds/fields/parameters.go:481:			return nil, errors.Errorf("Value for parameter %s is not a bool: %v", p.Name, v)
pkg/cmds/fields/parameters.go:490:				return nil, errors.Wrapf(err, "Value for parameter %s is not a valid date: %v", p.Name, v)
pkg/cmds/fields/parameters.go:496:			return nil, errors.Errorf("Value for parameter %s is not a valid date: %v", p.Name, v)
pkg/cmds/fields/parameters.go:502:			return nil, errors.Errorf("Value for parameter %s is not a file (got type %T): %v", p.Name, v, v)
pkg/cmds/fields/parameters.go:509:			return nil, errors.Errorf("Value for parameter %s is not a file list: %v", p.Name, v)
pkg/cmds/fields/parameters.go:522:				return nil, errors.Errorf("Value for parameter %s is not a string list: %v", p.Name, v)
pkg/cmds/fields/parameters.go:528:				return nil, errors.Errorf("Value for parameter %s is not a string list: %v", p.Name, v)
pkg/cmds/fields/parameters.go:537:			return nil, errors.Errorf("Default value for parameter %s is not an integer list: %v", p.Name, v)
pkg/cmds/fields/parameters.go:544:			return nil, errors.Errorf("Value for parameter %s is not a float list: %v", p.Name, v)
pkg/cmds/fields/parameters.go:550:			return nil, errors.Errorf("Definition %s is a choice parameter but has no choices", p.Name)
pkg/cmds/fields/parameters.go:555:			return nil, errors.Errorf("Value for parameter %s is not a string: %v", p.Name, v)
pkg/cmds/fields/parameters.go:566:			return nil, errors.Errorf("Definition %s is a choice parameter but has no choices", p.Name)
pkg/cmds/fields/parameters.go:571:			return nil, errors.Errorf("Value for parameter %s is not a choice list: %v", p.Name, v)
pkg/cmds/fields/parameters.go:590:			return nil, errors.Errorf("Value for parameter %s is not a key value map: %v", p.Name, v)
pkg/cmds/fields/parameters.go:595:			return nil, errors.Errorf("Value for parameter %s is not a key value map: %v", p.Name, v)
pkg/cmds/fields/parameters.go:600:		return nil, errors.Errorf("unknown parameter type %s", p.Type)
pkg/cmds/fields/parameters.go:610:	return errors.Errorf("Value %s is not a valid choice for parameter %s. Valid choices are: %v", choice, p.Name, p.Choices)
pkg/cmds/fields/parameters.go:617:	parameters_ := NewDefinitions()
pkg/cmds/fields/parameters.go:620:	var parameters []*Definition
pkg/cmds/fields/parameters.go:622:	err = yaml.Unmarshal(yamlContent, &parameters)
pkg/cmds/fields/parameters.go:627:	for _, p := range parameters {
pkg/cmds/fields/parameters.go:628:		_, err := p.CheckParameterDefaultValueValidity()
pkg/cmds/fields/parameters.go:630:			panic(errors.Wrap(err, "Failed to check parameter default value validity"))
pkg/cmds/fields/parameters.go:632:		parameters_.Set(p.Name, p)
pkg/cmds/fields/parameters.go:635:	return parameters_
pkg/cmds/fields/parameters.go:645:func WithDefinitions(parameterDefinitions *Definitions) DefinitionsOption {
pkg/cmds/fields/parameters.go:647:		p.Merge(parameterDefinitions)
pkg/cmds/fields/parameters.go:651:func WithDefinitionList(parameterDefinitions []*Definition) DefinitionsOption {
pkg/cmds/fields/parameters.go:653:		for _, pd := range parameterDefinitions {
pkg/cmds/fields/parameters.go:672:// The parameter definitions are cloned as well.
pkg/cmds/fields/parameters.go:677:// Merge merges the parameter definitions from m into p.
pkg/cmds/fields/parameters.go:678:// It clones each parameter definition before adding it to p
pkg/cmds/fields/parameters.go:688:// fields. The parameter definitions are not cloned.
pkg/cmds/fields/parameters.go:718:// fields. The parameter definitions are not cloned.
pkg/cmds/fields/parameters.go:731:// ForEachE calls the given function f on each parameter definition in p.
pkg/cmds/fields/parameters.go:744:// ForEach calls the given function f on each parameter definition in p.
pkg/cmds/fields/parameters.go:760:	var parameterDefinitions []*Definition
pkg/cmds/fields/parameters.go:761:	err := value.Decode(&parameterDefinitions)
pkg/cmds/fields/parameters.go:766:	for _, pd_ := range parameterDefinitions {
pkg/cmds/fields/parameters.go:782:			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:789:			return errors.Errorf("expected bool value for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:802:			return errors.Errorf("expected string list for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:809:			return errors.Errorf("expected time.Time value for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:822:			return errors.Errorf("expected list of files for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:829:			return errors.Errorf("expected list of maps for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:836:			return errors.Errorf("expected map for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:843:			return errors.Errorf("expected map of strings for parameter %s, got %T", p.Name, value)
pkg/cmds/fields/parameters.go:848:		return errors.Errorf("unknown parameter type %s", p.Type)
pkg/doc/topics/commands-reference.md:10:- layers
pkg/doc/topics/commands-reference.md:22:The Glazed command system provides a structured approach to building CLI applications that handle multiple output formats, complex parameter validation, and reusable components. This reference covers the complete command system architecture, interfaces, and implementation patterns.
pkg/doc/topics/commands-reference.md:24:Building CLI tools typically involves handling parameter parsing, validation, output formatting, and configuration management. Glazed addresses these concerns through a layered architecture that separates command logic from presentation and parameter management.
pkg/doc/topics/commands-reference.md:26:The core principle is separation of concerns: commands focus on business logic while Glazed handles parameter parsing, validation, and output formatting. This approach enables automatic support for multiple output formats, consistent parameter handling across commands, and reusable parameter groups.
pkg/doc/topics/commands-reference.md:41:│  (name, flags, arguments, layers, etc.)     │
pkg/doc/topics/commands-reference.md:46:│               Parameter Layers               │
pkg/doc/topics/commands-reference.md:56:│  Parameters  │          │ ParsedLayers    │
pkg/doc/topics/commands-reference.md:84:2. **CommandDescription**: Contains metadata about a command (name, description, parameters, etc.)
pkg/doc/topics/commands-reference.md:85:3. **Parameter Layers**: Organize parameters into logical groups (database, logging, output, etc.)
pkg/doc/topics/commands-reference.md:86:4. **Parameters**: Define command inputs with type information, validation, and help text
pkg/doc/topics/commands-reference.md:87:5. **ParsedLayers**: Runtime values after collecting from CLI flags, environment, config files, and defaults
pkg/doc/topics/commands-reference.md:92:The Glazed framework is organized into distinct packages to separate concerns like command definition, parameter handling, and output processing. This modular design makes the system extensible and easier to maintain. Key packages handle command interfaces (`cmds`), parameter definitions (`parameters`), and integration with CLI libraries like Cobra (`cli`).
pkg/doc/topics/commands-reference.md:95:- `github.com/go-go-golems/glazed/pkg/cmds/parameters`: Parameter types and definitions
pkg/doc/topics/commands-reference.md:96:- `github.com/go-go-golems/glazed/pkg/cmds/layers`: Parameter layering system
pkg/doc/topics/commands-reference.md:101:- `github.com/go-go-golems/glazed/pkg/settings`: Standard Glazed parameter layers
pkg/doc/topics/commands-reference.md:123:    Run(ctx context.Context, parsedLayers *values.Values) error
pkg/doc/topics/commands-reference.md:139:func (c *CleanupCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/commands-reference.md:141:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:187:    RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error
pkg/doc/topics/commands-reference.md:205:func (c *HealthReportCommand) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {
pkg/doc/topics/commands-reference.md:207:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:248:    RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error
pkg/doc/topics/commands-reference.md:268:    parsedLayers *values.Values,
pkg/doc/topics/commands-reference.md:272:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:332:func (c *StatusCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/commands-reference.md:334:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:348:    parsedLayers *values.Values, 
pkg/doc/topics/commands-reference.md:352:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:372:A well-structured Glazed command separates its identity and logic. The recommended pattern involves a `Command` struct embedding a `CommandDescription` for metadata, a separate `Settings` struct for type-safe parameter access via `glazed` tags, and a `Run` method containing the business logic. This separation is bridged at runtime by `InitializeStruct`, which populates the `Settings` struct from parsed command-line values.
pkg/doc/topics/commands-reference.md:380:**Settings Struct**: Provides type safety by defining a struct that mirrors command inputs. Glazed automatically maps parameters to struct fields through `glazed` tags.
pkg/doc/topics/commands-reference.md:384:**Constructor Function**: Creates the command description with its parameters and layers.
pkg/doc/topics/commands-reference.md:388:Settings structs provide type-safe access to parsed command parameters. Each field uses a `glazed` tag that must match the parameter name defined in the command description:
pkg/doc/topics/commands-reference.md:393:    Count   int    `glazed:"count"`     // Maps to "count" parameter
pkg/doc/topics/commands-reference.md:394:    Format  string `glazed:"format"`   // Maps to "format" parameter  
pkg/doc/topics/commands-reference.md:395:    Verbose bool   `glazed:"verbose"`  // Maps to "verbose" parameter
pkg/doc/topics/commands-reference.md:396:    DryRun  bool   `glazed:"dry-run"`  // Maps to "dry-run" parameter
pkg/doc/topics/commands-reference.md:400:The `InitializeStruct` method populates the settings struct from parsed layers. Always specify the correct layer slug (use `schema.DefaultSlug` for command-specific parameters):
pkg/doc/topics/commands-reference.md:405:    parsedLayers *values.Values,
pkg/doc/topics/commands-reference.md:411:    // Extract values from the "default" layer into the struct
pkg/doc/topics/commands-reference.md:412:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:440:### Working with Multiple Layers
pkg/doc/topics/commands-reference.md:442:Commands often use multiple parameter layers. Extract settings from each layer separately:
pkg/doc/topics/commands-reference.md:458:    parsedLayers *values.Values,
pkg/doc/topics/commands-reference.md:463:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, cmdSettings); err != nil {
pkg/doc/topics/commands-reference.md:467:    // Extract database layer settings
pkg/doc/topics/commands-reference.md:469:    if err := parsedLayers.InitializeStruct("database", dbSettings); err != nil {
pkg/doc/topics/commands-reference.md:473:    // Extract logging layer settings
pkg/doc/topics/commands-reference.md:475:    if err := parsedLayers.InitializeStruct("logging", logSettings); err != nil {
pkg/doc/topics/commands-reference.md:492:func (c *ExampleCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/commands-reference.md:498:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, &s); err != nil {
pkg/doc/topics/commands-reference.md:514:func (c *ExampleCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/commands-reference.md:516:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:527:func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {
pkg/doc/topics/commands-reference.md:529:    err := parsedLayers.InitializeStruct("database", settings)
pkg/doc/topics/commands-reference.md:534:    dbSettings, err := GetDatabaseSettings(parsedLayers)
pkg/doc/topics/commands-reference.md:545:While Glazed excels at building standard CLI tools, its architecture also supports more advanced use cases. Commands can be executed programmatically for testing or integration into other Go applications, and the parameter system can load values from multiple sources like environment variables and config files, not just CLI flags. These patterns allow you to build commands that are not just standalone tools, but reusable components in a larger software ecosystem.
pkg/doc/topics/commands-reference.md:561:// Define parameter values
pkg/doc/topics/commands-reference.md:563:    runner.WithValuesForLayers(map[string]map[string]interface{}{
pkg/doc/topics/commands-reference.md:584:### Parameter Loading Sources
pkg/doc/topics/commands-reference.md:586:Parameters can be loaded from multiple sources (in priority order):
pkg/doc/topics/commands-reference.md:602:    runner.WithValuesForLayers(map[string]map[string]interface{}{
pkg/doc/topics/commands-reference.md:656:    parsedLayers *values.Values,
pkg/doc/topics/commands-reference.md:682:    parsedLayers *values.Values,
pkg/doc/topics/commands-reference.md:686:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {
pkg/doc/topics/commands-reference.md:727:func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/commands-reference.md:782:## Parameters
pkg/doc/topics/commands-reference.md:784:Glazed treats command-line parameters as more than just strings. They are typed objects with built-in validation, default values, and help text. This approach shifts the burden of parsing and validation from the command's business logic to the framework itself. By defining a parameter's type (e.g., `ParameterTypeInteger`, `ParameterTypeDate`, `ParameterTypeFile`), you get automatic error handling and a more robust and user-friendly CLI.
pkg/doc/topics/commands-reference.md:786:Glazed parameters are typed objects with validation rules and behavior, unlike traditional CLI libraries that treat parameters as simple strings requiring manual parsing and validation. This enables automatic validation, help generation, and multi-source value loading.
pkg/doc/topics/commands-reference.md:788:### Parameter Type System
pkg/doc/topics/commands-reference.md:790:Parameter types define data structure, parsing behavior, and validation rules. Each type handles string parsing, validation, and help text generation.
pkg/doc/topics/commands-reference.md:793:**`ParameterTypeString`**: The workhorse for text inputs - names, descriptions, URLs
pkg/doc/topics/commands-reference.md:794:**`ParameterTypeSecret`**: Like strings, but values are masked in help and logs (perfect for passwords, API keys)
pkg/doc/topics/commands-reference.md:795:**`ParameterTypeInteger`**: Whole numbers with automatic range validation
pkg/doc/topics/commands-reference.md:796:**`ParameterTypeFloat`**: Decimal numbers for measurements, percentages, ratios
pkg/doc/topics/commands-reference.md:797:**`ParameterTypeBool`**: True/false flags that work with `--flag` and `--no-flag` patterns
pkg/doc/topics/commands-reference.md:798:**`ParameterTypeDate`**: Intelligent date parsing that handles multiple formats
pkg/doc/topics/commands-reference.md:801:**`ParameterTypeStringList`**: Multiple values like `--tag web --tag api --tag production`
pkg/doc/topics/commands-reference.md:802:**`ParameterTypeIntegerList`**: Lists of numbers for ports, IDs, quantities
pkg/doc/topics/commands-reference.md:803:**`ParameterTypeFloatList`**: Multiple decimal values for coordinates, measurements
pkg/doc/topics/commands-reference.md:806:**`ParameterTypeChoice`**: Single selection from predefined options (with tab completion!)
pkg/doc/topics/commands-reference.md:807:**`ParameterTypeChoiceList`**: Multiple selections from predefined options
pkg/doc/topics/commands-reference.md:810:**`ParameterTypeFile`**: File paths with existence validation and tab completion
pkg/doc/topics/commands-reference.md:811:**`ParameterTypeFileList`**: Multiple file paths
pkg/doc/topics/commands-reference.md:812:**`ParameterTypeStringFromFile`**: Read text content from a file (useful for large inputs)
pkg/doc/topics/commands-reference.md:813:**`ParameterTypeStringListFromFile`**: Read line-separated lists from files
pkg/doc/topics/commands-reference.md:816:**`ParameterTypeKeyValue`**: Map-like inputs: `--env DATABASE_URL=postgres://... --env DEBUG=true`
pkg/doc/topics/commands-reference.md:818:### Parameter Definition Options
pkg/doc/topics/commands-reference.md:822:    "parameter-name",                    // Required: parameter name
pkg/doc/topics/commands-reference.md:823:    fields.TypeString,      // Required: parameter type
pkg/doc/topics/commands-reference.md:835:    parameters.WithFileExtensions(".txt", ".md"),
pkg/doc/topics/commands-reference.md:841:Arguments are positional parameters that don't use flags:
pkg/doc/topics/commands-reference.md:942:// Avoid: Manual parameter extraction
pkg/doc/topics/commands-reference.md:943:source, _ := parsedLayers.GetString("source")
pkg/doc/topics/commands-reference.md:944:maxAge, _ := parsedLayers.GetString("max-age") // Bug waiting to happen!
pkg/doc/topics/commands-reference.md:951:Write clear help text with examples for complex parameters:
pkg/doc/topics/commands-reference.md:977:Validate parameters before expensive operations. Always check context cancellation in loops and long operations.
pkg/doc/topics/commands-reference.md:1017:2. Study the layer guide to understand parameter organization:
pkg/doc/topics/commands-reference.md:1019:   glaze help layers-guide
cmd/glaze/cmds/html/cmds.go:55:	glazedLayer, err := settings.NewGlazedSchema()
cmd/glaze/cmds/html/cmds.go:59:	cobraLayer, ok := glazedLayer.(schema.CobraSection)
cmd/glaze/cmds/html/cmds.go:61:		return nil, fmt.Errorf("glazed layer is not a CobraSection")
cmd/glaze/cmds/html/cmds.go:64:	err = cobraLayer.AddLayerToCobraCommand(parseCmd)
cmd/glaze/cmds/html/cmds.go:119:	err = cobraLayer.AddLayerToCobraCommand(extractCmd)
pkg/doc/topics/03-templates.md:230:- `toUrlParameter(v interface{}) string` - Convert value to URL parameter format
pkg/cmds/fields/gather-parameters_test.go:14:	ParameterDefs []*Definition `yaml:"parameterDefs"`
pkg/cmds/fields/gather-parameters_test.go:15:	// The actual map fromwhich the parameters are gathered
pkg/cmds/fields/gather-parameters_test.go:17:	// Only gather parameters that are provided in the map
pkg/cmds/fields/gather-parameters_test.go:25:var gatherParametersYAML string
pkg/cmds/fields/gather-parameters_test.go:27:func TestGatherParametersFromMap(t *testing.T) {
pkg/cmds/fields/gather-parameters_test.go:28:	tests, err := yaml.LoadTestFromYAML[[]TestCase](gatherParametersYAML)
pkg/cmds/fields/gather-parameters_test.go:33:			pds := NewDefinitions(WithDefinitionList(tt.ParameterDefs))
pkg/cmds/fields/gather-parameters_test.go:35:			parsedParameters, err := pds.GatherParametersFromMap(tt.Data, tt.OnlyProvided)
pkg/cmds/fields/gather-parameters_test.go:41:				require.Equal(t, tt.ExpectedResult, parsedParameters.ToMap())
pkg/doc/topics/06-usage-string.md:19:In contrast to parameter flags, which are preceded by `--` for `-`, arguments are 
pkg/doc/topics/06-usage-string.md:32:- Parameters accepting list inputs should not directly follow each other.
pkg/doc/topics/06-usage-string.md:34:### Required Parameters
pkg/doc/topics/06-usage-string.md:45:### Optional Parameters
pkg/doc/topics/06-usage-string.md:57:### List Parameters
pkg/doc/topics/06-usage-string.md:69:Parameters may come with default values. These can be identified by text following the format `default: value`. This means that if you do not provide a value for this argument, the system will use the default value.
cmd/glaze/cmds/json.go:38:	glazedLayer, err := settings.NewGlazedSchema()
cmd/glaze/cmds/json.go:40:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")
cmd/glaze/cmds/json.go:79:			cmds.WithLayersList(
cmd/glaze/cmds/json.go:80:				glazedLayer,
cmd/glaze/cmds/json.go:90:		return errors.Wrap(err, "Failed to initialize json settings from parameters")
pkg/doc/topics/how-to-write-good-documentation-pages.md:335:- **Options/Config:** When documenting flags, parameters, or settings
pkg/doc/tutorials/01-a-simple-table-cli.md:20:- `ParameterDefinition`: This struct is used to define the parameters (flags or arguments) that the command takes. It
pkg/doc/tutorials/01-a-simple-table-cli.md:21:  includes the name of the parameter, the type, and any default value.
pkg/doc/tutorials/01-a-simple-table-cli.md:72:	parsedLayers map[string]*layers.ParsedParameterLayer,
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:21:The new system replaces Viper's automatic config discovery and merging with explicit file loading middlewares that record each parse step. This makes it clear where each parameter value originated and enables better debugging with `--print-parsed-parameters`.
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:27:1. **Config File Loading**: Replace `GatherFlagsFromViper()` and `GatherFlagsFromCustomViper()` with `LoadParametersFromFile()` or `LoadParametersFromFiles()`
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:28:2. **Logging Initialization**: Move from `InitLoggerFromViper()` to `InitLoggerFromCobra()` or `SetupLoggingFromParsedLayers()`
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:59:### 2. Config File Format Must Match Layer Structure
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:69:**After:** Config must match layer names and parameters:
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:71:# Layer names as top-level keys
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:82:- Group parameters under layer names
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:83:- Update parameter names to match definitions
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:87:mapper, _ := patternmapper.NewConfigMapper(layers,
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:90:        TargetLayer:     "demo",
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:91:        TargetParameter: "api-key",
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:101:    // Transform your config to layer format
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:121:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:141:### After: Using LoadParametersFromFile
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:146:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:171:For applications with a single config file, use `LoadParametersFromFile`:
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:181:The config file must match the default structure (layer names as top-level keys):
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:191:For applications that compose configuration from multiple files, use `LoadParametersFromFiles`:
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:243:### After: Using LoadParametersFromFiles
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:248:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:306:    // Add logging layer
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:307:    err := logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:340:    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:353:### Alternative: Initialize from Parsed Layers
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:355:If you're using Glazed's middleware system and want logging to respect config file values, initialize from parsed layers instead:
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:360:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:364:    // ... setup layers and parse ...
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:366:    err := sources.Execute(layers_, parsed,
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:375:    // Initialize logging from parsed layers (includes config file values)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:376:    err = logging.SetupLoggingFromParsedLayers(parsed)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:420:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:455:- `--config-file` flag is automatically available via `command-settings` layer
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:473:If your config files don't match the default layer structure, you have two options: pattern-based mapping (declarative) or custom mapper functions (programmatic).
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:485:mapper, err := pm.NewConfigMapper(layers_,
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:488:        TargetLayer:     "demo",
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:489:        TargetParameter: "api-key",
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:493:        TargetLayer:     "demo",
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:494:        TargetParameter: "{env}-api-key",
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:498:// Use with LoadParametersFromFile
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:521:    // Transform config structure to layer format
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:551:sources.Execute(layers_, parsed,
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:602:   logging.SetupLoggingFromParsedLayers(parsed)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:658:Environment variable names follow the pattern: `{PREFIX}_{LAYER}_{PARAMETER}` (e.g., `APP_DEMO_API_KEY` for `demo.api-key`).
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:693:Use `--print-parsed-parameters` to see exactly where each parameter value came from:
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:696:myapp command --print-parsed-parameters
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:699:This shows the full parse history for each parameter, including which config file set each value.
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:703:Before applying config files, validate them against your layer definitions:
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:711:func validateConfigFile(layers_ *schema.Schema, path string) error {
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:722:    // Check each layer and parameter
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:723:    for layerSlug, v := range raw {
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:724:        layer, ok := layers_.Get(layerSlug)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:726:            return fmt.Errorf("unknown layer: %s", layerSlug)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:731:            return fmt.Errorf("layer %s must be an object", layerSlug)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:734:        pds := layer.GetParameterDefinitions()
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:738:                return fmt.Errorf("unknown parameter %s.%s", layerSlug, key)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:742:                return fmt.Errorf("invalid value for %s.%s: %v", layerSlug, key, err)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:764:2. Variable names follow `{PREFIX}_{LAYER}_{PARAMETER}` format
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:771:2. Check config file order in `LoadParametersFromFiles` (low → high)
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:772:3. Use `--print-parsed-parameters` to see actual precedence
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:776:If you have legacy config files that don't match the layer structure:
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:807:    err := logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:853:    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")
pkg/doc/tutorials/migrating-from-viper-to-config-files.md:889:2. **Use `--print-parsed-parameters`**: Confirm precedence is as expected
pkg/cmds/fields/gather-arguments.go:13:// Only the last parameter definitions can be a list parameter type.
pkg/cmds/fields/gather-arguments.go:28:) (*ParsedParameters, error) {
pkg/cmds/fields/gather-arguments.go:30:	result := NewParsedParameters()
pkg/cmds/fields/gather-arguments.go:38:		p := &ParsedParameter{
pkg/cmds/fields/gather-arguments.go:70:		i2, err := argument.ParseParameter(v, parseOptions...)
pkg/doc/topics/24-config-files.md:19:- Traceability: Each config file write is logged with `source: config` and `{ config_file, index }` metadata and can be inspected with `--print-parsed-parameters`.
pkg/doc/topics/24-config-files.md:31:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:33:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/24-config-files.md:38:    // Define layers
pkg/doc/topics/24-config-files.md:46:    pls := schema.NewSchema(layers.WithLayers(demo))
pkg/doc/topics/24-config-files.md:63:If you’re building a CLI, the Cobra integration wires configuration, environment variables, positional arguments, and flags into a predictable pipeline with minimal boilerplate. `CobraParserConfig` lets you enable app-wide env prefixes, resolve config files, or inject your own resolver logic. This keeps your command code focused on business logic while Glazed handles the parsing pipeline and debug flags (like `--print-parsed-parameters`).
pkg/doc/topics/24-config-files.md:73:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:74:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/24-config-files.md:85:    desc := cmds.NewCommandDescription("demo", cmds.WithLayersList(demo))
pkg/doc/topics/24-config-files.md:104:Load a single YAML/JSON file when your application’s configuration is centralized. The file is parsed into your parameter layers, and each value update is recorded as a `config` parse step, making it clear where settings came from when debugging.
pkg/doc/topics/24-config-files.md:110:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:114:layers_ := schema.NewSchema(/* ... */)
pkg/doc/topics/24-config-files.md:116:_ = sources.Execute(layers_, parsed,
pkg/doc/topics/24-config-files.md:129:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:134:_ = sources.Execute(layers_, parsed,
pkg/doc/topics/24-config-files.md:141:Many CLIs have a conventional config location (XDG, home dotdir, or `/etc`). `ResolveAppConfigPath` encapsulates that search so your app can “just find” a config without hardcoding paths. Pair it with a `--config-file` flag (already provided by the `command-settings` layer) so power users can override discovery. For overlays, a resolver can add optional files like `<base>.override.yaml` if they exist, keeping configuration flexible without hidden magic.
pkg/doc/topics/24-config-files.md:171:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:191:Glazed supports both “default-shaped” configs (where the file mirrors your layers and parameters) and mappers (which translate arbitrary structures to parameter updates). Use the default structure for greenfield projects and simple cases—it’s the most transparent. Reach for mappers when you must consume legacy formats, have nested structures that don’t match your parameter layout, or need to derive multiple parameters from one subtree.
pkg/doc/topics/24-config-files.md:193:Glazed supports two ways to map config file data into parameter layers:
pkg/doc/topics/24-config-files.md:195:1) Default structure (no mapper): your config matches the layer/parameter shapes directly
pkg/doc/topics/24-config-files.md:204:2) Mappers: use a mapper to transform arbitrary config shapes to layer/parameter assignments.
pkg/doc/topics/24-config-files.md:208:Pattern mappers describe how to traverse a config tree and map matched values into parameters. Patterns support exact segments, wildcards, and named captures (for environment-like keys such as `{env}`). Validation happens both at construction time (syntax, capture references, static targets) and at runtime (required matches, ambiguity, collisions). Prefer named captures over wildcards when you expect multiple values to be collected.
pkg/doc/topics/24-config-files.md:210:Use `github.com/go-go-golems/glazed/pkg/cmds/middlewares/patternmapper` to declare mapping rules and pass the mapper to `LoadParametersFromFile`.
pkg/doc/topics/24-config-files.md:216:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:219:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/24-config-files.md:229:pls := schema.NewSchema(layers.WithLayers(demo))
pkg/doc/topics/24-config-files.md:234:        TargetLayer: "demo",
pkg/doc/topics/24-config-files.md:236:            {Source: "api_key", TargetParameter: "{env}-api-key"},
pkg/doc/topics/24-config-files.md:248:Use a custom function when you need full control: conditional logic, array handling, value transformations, or cross-field validation that’s not practical to express with patterns. The function receives the unmarshaled config as `interface{}` and returns a standard `map[layerSlug]map[paramName]any` for Glazed to apply.
pkg/doc/topics/24-config-files.md:250:Provide a `ConfigFileMapper` function to `WithConfigFileMapper` to transform raw config into a `map[layerSlug]map[paramName]any`:
pkg/doc/topics/24-config-files.md:260:    // inspect raw (unmarshaled YAML/JSON) and build the layer map
pkg/doc/topics/24-config-files.md:271:## Inspecting parse steps (`--print-parsed-parameters`)
pkg/doc/topics/24-config-files.md:273:Parsing is not a black box—every write records its source and any relevant metadata. Enable `--print-parsed-parameters` to see the exact sequence of updates for each parameter. This is invaluable when debugging precedence issues (for example, “why didn’t my local override win?”) or auditing where a value originated.
pkg/doc/topics/24-config-files.md:275:Add the `command-settings` layer (done automatically by the Cobra parser unless disabled) and run with `--print-parsed-parameters` to see where a value came from:
pkg/doc/topics/24-config-files.md:292:Validate configs early to catch mistakes before runtime. For default-shaped files, check for unknown layers/parameters and type errors. For pattern-based configs, instantiate a mapper and call `Map` in a validate-only pass; the mapper will fail fast on missing required matches, ambiguous patterns, or invalid targets. These validators are small enough to run in CI and provide crisp error messages for contributors.
pkg/doc/topics/24-config-files.md:298:Apply this validator to YAML/JSON files that mirror your layers. It’s conservative by design: any unexpected layer or parameter is flagged, and values are type-checked against your parameter definitions. This keeps configs tidy and prevents silent drift as parameters evolve.
pkg/doc/topics/24-config-files.md:308:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:309:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/24-config-files.md:313:func validateConfigFile(layers_ *schema.Schema, path string) error {
pkg/doc/topics/24-config-files.md:320:    for layerSlug, v := range raw {
pkg/doc/topics/24-config-files.md:321:        layer, ok := layers_.Get(layerSlug)
pkg/doc/topics/24-config-files.md:322:        if !ok { issues = append(issues, fmt.Sprintf("unknown layer %s", layerSlug)); continue }
pkg/doc/topics/24-config-files.md:324:        if !ok { issues = append(issues, fmt.Sprintf("layer %s must be an object", layerSlug)); continue }
pkg/doc/topics/24-config-files.md:325:        pds := layer.GetParameterDefinitions()
pkg/doc/topics/24-config-files.md:329:            if !known[key] { issues = append(issues, fmt.Sprintf("unknown parameter %s.%s", layerSlug, key)); continue }
pkg/doc/topics/24-config-files.md:332:                issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))
pkg/doc/topics/24-config-files.md:345:For declarative mappings, the mapper is your validator. Build it once per app (construction validates static aspects) and call `Map` on the raw config (runtime semantics validate dynamic aspects). Error messages include path hints and prefix-aware parameter names to accelerate debugging.
pkg/doc/topics/24-config-files.md:352:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/24-config-files.md:390:Legacy Viper-based middlewares like `GatherFlagsFromViper` and per-command `--load-parameters-from-file` are deprecated. Prefer config middlewares (`LoadParametersFromFiles`) with resolvers and `--config-file`.
pkg/cmds/fields/strings.go:8:// GatherFlagsFromStringList parses command line arguments into a ParsedParameters
pkg/cmds/fields/strings.go:12:// It returns the parsed parameters map, any non-flag arguments, and any error
pkg/cmds/fields/strings.go:32:) (*ParsedParameters, []string, error) {
pkg/cmds/fields/strings.go:37:	// build a map of flag names to parameter definitions, including through shortflags
pkg/cmds/fields/strings.go:119:	result := NewParsedParameters()
pkg/cmds/fields/strings.go:125:		parsedValue, err := param.ParseParameter(values, parseOptions...)
pkg/cmds/fields/strings.go:140:				p := &ParsedParameter{
pkg/doc/topics/21-cmds-middlewares.md:4:Short: Learn how to use Glazed's middleware system to load parameter values from various sources
pkg/doc/topics/21-cmds-middlewares.md:7:- parameters
pkg/doc/topics/21-cmds-middlewares.md:13:- LoadParametersFromFile
pkg/doc/topics/21-cmds-middlewares.md:23:# Glazed Middlewares Guide: Loading Parameter Values
pkg/doc/topics/21-cmds-middlewares.md:27:Glazed provides a flexible middleware system for loading parameter values from various sources. This guide explains how to use these middlewares effectively to populate your command parameters from different locations like environment variables, config files, and command line arguments.
pkg/doc/topics/21-cmds-middlewares.md:36:type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error
pkg/doc/topics/21-cmds-middlewares.md:40:### Relationship between ParameterLayers and ParsedLayers
pkg/doc/topics/21-cmds-middlewares.md:42:- **ParameterLayers**: These are collections of parameter definitions. They define the structure and metadata of parameters, such as their names, types, and default values.
pkg/doc/topics/21-cmds-middlewares.md:44:- **ParsedLayers**: These are collections of parsed parameter values. They store the actual values obtained from various sources like command-line arguments, environment variables, or configuration files.
pkg/doc/topics/21-cmds-middlewares.md:46:Middlewares operate on these two structures to manage and transform parameter values.
pkg/doc/topics/21-cmds-middlewares.md:52:1. **Modular Parameter Handling**: They allow for modular and reusable parameter processing logic. Each middleware can focus on a specific source or transformation of parameter values.
pkg/doc/topics/21-cmds-middlewares.md:54:2. **Logging and Tracking**: Each middleware can log its actions, providing a trace of how parameter values were derived.
pkg/doc/topics/21-cmds-middlewares.md:56:### Adding Information to Parsed Parameters
pkg/doc/topics/21-cmds-middlewares.md:58:Each middleware can add information to the parsed parameters by:
pkg/doc/topics/21-cmds-middlewares.md:62:- Logging the source and transformation steps for each parameter value.
pkg/doc/topics/21-cmds-middlewares.md:68:- It can process parameters before and/or after calling `next`
pkg/doc/topics/21-cmds-middlewares.md:70:    - `ParameterLayers`: Contains parameter definitions
pkg/doc/topics/21-cmds-middlewares.md:71:    - `ParsedLayers`: Stores the actual parameter values
pkg/doc/topics/21-cmds-middlewares.md:78:ExecuteMiddlewares(layers, parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:81:    LoadParametersFromFile("config.yaml"),
pkg/doc/topics/21-cmds-middlewares.md:86:1. LoadParametersFromFile
pkg/doc/topics/21-cmds-middlewares.md:94:Use `SetFromDefaults` to populate parameters with their default values:
pkg/doc/topics/21-cmds-middlewares.md:102:This middleware reads the default values specified in parameter definitions and sets them if no value exists.
pkg/doc/topics/21-cmds-middlewares.md:115:- Parameter `port` becomes `APP_PORT`
pkg/doc/topics/21-cmds-middlewares.md:116:- Parameter `db_host` becomes `APP_DB_HOST`
pkg/doc/topics/21-cmds-middlewares.md:120:Load parameters from JSON or YAML files using `LoadParametersFromFile`:
pkg/doc/topics/21-cmds-middlewares.md:130:By default, `LoadParametersFromFile` expects the config file to have this structure:
pkg/doc/topics/21-cmds-middlewares.md:132:layerName:
pkg/doc/topics/21-cmds-middlewares.md:133:  parameterName: value
pkg/doc/topics/21-cmds-middlewares.md:134:  anotherParameter: value
pkg/doc/topics/21-cmds-middlewares.md:149:    // Map flat keys to layer parameters
pkg/doc/topics/21-cmds-middlewares.md:191:The mapper handles both structures and maps them to the standard layer format. This allows you to:
pkg/doc/topics/21-cmds-middlewares.md:194:- Transform nested JSON/YAML hierarchies into layer parameters
pkg/doc/topics/21-cmds-middlewares.md:236:Load parameters from specific config files using built-in file middlewares:
pkg/doc/topics/21-cmds-middlewares.md:257:    // Transform your custom config structure to layer map format
pkg/doc/topics/21-cmds-middlewares.md:285:### 8. Layer Manipulation
pkg/doc/topics/21-cmds-middlewares.md:287:Glazed provides several middlewares for manipulating parsed layers directly:
pkg/doc/topics/21-cmds-middlewares.md:289:#### Replacing Layers
pkg/doc/topics/21-cmds-middlewares.md:291:Replace a single layer:
pkg/doc/topics/21-cmds-middlewares.md:293:// Replace the "config" layer with a new one
pkg/doc/topics/21-cmds-middlewares.md:294:middleware := middlewares.ReplaceParsedLayer("config", newLayer)
pkg/doc/topics/21-cmds-middlewares.md:297:Replace multiple layers at once:
pkg/doc/topics/21-cmds-middlewares.md:299:// Replace multiple layers with new ones
pkg/doc/topics/21-cmds-middlewares.md:300:middleware := middlewares.ReplaceParsedLayers(newLayers)
pkg/doc/topics/21-cmds-middlewares.md:303:#### Merging Layers
pkg/doc/topics/21-cmds-middlewares.md:305:Merge a single layer:
pkg/doc/topics/21-cmds-middlewares.md:307:// Merge a layer into the "config" layer
pkg/doc/topics/21-cmds-middlewares.md:308:middleware := middlewares.MergeParsedLayer("config", layerToMerge)
pkg/doc/topics/21-cmds-middlewares.md:311:Merge multiple layers:
pkg/doc/topics/21-cmds-middlewares.md:313:// Merge multiple layers into existing ones
pkg/doc/topics/21-cmds-middlewares.md:314:middleware := middlewares.MergeParsedLayers(layersToMerge)
pkg/doc/topics/21-cmds-middlewares.md:317:#### Selective Layer Operations
pkg/doc/topics/21-cmds-middlewares.md:319:For more fine-grained control, you can use selective middlewares that only operate on specific layers:
pkg/doc/topics/21-cmds-middlewares.md:322:// Replace only specific layers
pkg/doc/topics/21-cmds-middlewares.md:323:middleware := middlewares.ReplaceParsedLayersSelective(newLayers, []string{"config", "env"})
pkg/doc/topics/21-cmds-middlewares.md:325:// Merge only specific layers
pkg/doc/topics/21-cmds-middlewares.md:326:middleware := middlewares.MergeParsedLayersSelective(layersToMerge, []string{"user", "profile"})
pkg/doc/topics/21-cmds-middlewares.md:330:- Update only certain configuration layers while preserving others
pkg/doc/topics/21-cmds-middlewares.md:337:sources.Execute(layers, parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:338:    // Replace only the base configuration layers
pkg/doc/topics/21-cmds-middlewares.md:339:    middlewares.ReplaceParsedLayersSelective(baseConfig, []string{"system", "defaults"}),
pkg/doc/topics/21-cmds-middlewares.md:342:    middlewares.MergeParsedLayersSelective(userConfig, []string{"preferences", "history"}),
pkg/doc/topics/21-cmds-middlewares.md:345:    middlewares.ReplaceParsedLayers(envConfig),
pkg/doc/topics/21-cmds-middlewares.md:349:These layer manipulation middlewares are useful when you need to:
pkg/doc/topics/21-cmds-middlewares.md:352:- Apply temporary parameter changes
pkg/doc/topics/21-cmds-middlewares.md:357:sources.Execute(layers, parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:359:    middlewares.ReplaceParsedLayer("base", baseConfig),
pkg/doc/topics/21-cmds-middlewares.md:361:    middlewares.MergeParsedLayer("env", envSettings),
pkg/doc/topics/21-cmds-middlewares.md:363:    middlewares.MergeParsedLayer("user", userPrefs),
pkg/doc/topics/21-cmds-middlewares.md:402:### 2. Layer Filtering
pkg/doc/topics/21-cmds-middlewares.md:404:Restrict middleware operation to specific layers:
pkg/doc/topics/21-cmds-middlewares.md:407:// Only apply to specified layers
pkg/doc/topics/21-cmds-middlewares.md:408:middleware := middlewares.WrapWithWhitelistedLayers(
pkg/doc/topics/21-cmds-middlewares.md:413:// Exclude specific layers
pkg/doc/topics/21-cmds-middlewares.md:414:middleware := middlewares.WrapWithBlacklistedLayers(
pkg/doc/topics/21-cmds-middlewares.md:426:    "layer1": {
pkg/doc/topics/21-cmds-middlewares.md:443:   ExecuteMiddlewares(layers, parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:446:       LoadParametersFromFile(),    // More specific
pkg/doc/topics/21-cmds-middlewares.md:453:   err := sources.Execute(layers, parsedLayers, 
pkg/doc/topics/21-cmds-middlewares.md:461:4. **Layer Organization**: Group related parameters into logical layers for easier management and filtering.
pkg/doc/topics/21-cmds-middlewares.md:470:sources.Execute(layers, parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:492:sources.Execute(layers, parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:548:    layers := createTestLayers()
pkg/doc/topics/21-cmds-middlewares.md:549:    parsedLayers := values.New()
pkg/doc/topics/21-cmds-middlewares.md:553:    err := sources.Execute(layers, parsedLayers, middleware)
pkg/doc/topics/21-cmds-middlewares.md:557:    value, exists := parsedLayers.GetParameter("default", "param1")
pkg/doc/topics/21-cmds-middlewares.md:567:    layers := createTestLayers()
pkg/doc/topics/21-cmds-middlewares.md:568:    parsedLayers := values.New()
pkg/doc/topics/21-cmds-middlewares.md:579:    err := sources.Execute(layers, parsedLayers, mws...)
pkg/doc/topics/21-cmds-middlewares.md:583:    value, _ := parsedLayers.GetParameter("default", "param1")
pkg/doc/topics/21-cmds-middlewares.md:592:    layers := createTestLayers()
pkg/doc/topics/21-cmds-middlewares.md:593:    parsedLayers := values.New()
pkg/doc/topics/21-cmds-middlewares.md:596:    parsedLayers.SetParameter("default", "email", "invalid-email")
pkg/doc/topics/21-cmds-middlewares.md:600:    err := sources.Execute(layers, parsedLayers, middleware)
pkg/doc/topics/21-cmds-middlewares.md:608:1. Use logging middleware to track parameter changes:
pkg/doc/topics/21-cmds-middlewares.md:622:parsedLayers.ForEach(func(layer string, params *parameters.ParsedParameters) {
pkg/doc/topics/21-cmds-middlewares.md:624:        fmt.Printf("%s.%s = %v\n", layer, name, value)
pkg/doc/topics/21-cmds-middlewares.md:629:Remember that middlewares are a powerful tool for managing parameter values, but with that power comes the need for careful organization and consideration of precedence rules.
pkg/doc/topics/21-cmds-middlewares.md:670:            ShortHelpLayers: []string{"default", "helpers"},
pkg/doc/topics/21-cmds-middlewares.md:688:    if commandSettings.LoadParametersFromFile != "" {
pkg/doc/topics/21-cmds-middlewares.md:690:            sources.FromFile(commandSettings.LoadParametersFromFile))
pkg/doc/topics/21-cmds-middlewares.md:709:    // Env config for specific layers (if needed)
pkg/doc/topics/21-cmds-middlewares.md:710:    middlewares.WrapWithWhitelistedLayers(
pkg/doc/topics/21-cmds-middlewares.md:733:## Layer-Specific Configuration
pkg/doc/topics/21-cmds-middlewares.md:735:Restrict middleware to specific layers:
pkg/doc/topics/21-cmds-middlewares.md:738:middlewares.WrapWithWhitelistedLayers(
pkg/doc/topics/21-cmds-middlewares.md:750:The foundation of Glazed's parameter system is the `ParameterLayer`. Before we can use middlewares, we need to define our parameter structure. This example shows how to create a layer that matches the architectural concepts discussed earlier:
pkg/doc/topics/21-cmds-middlewares.md:756:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/21-cmds-middlewares.md:757:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/21-cmds-middlewares.md:762:    // Create a new parameter layer
pkg/doc/topics/21-cmds-middlewares.md:763:    layer, err := schema.NewSection(
pkg/doc/topics/21-cmds-middlewares.md:785:    // Create parameter layers container
pkg/doc/topics/21-cmds-middlewares.md:786:    parameterLayers := schema.NewSchema(
pkg/doc/topics/21-cmds-middlewares.md:787:        layers.WithLayers(layer),
pkg/doc/topics/21-cmds-middlewares.md:793:- Parameter definitions with types, defaults, and help text
pkg/doc/topics/21-cmds-middlewares.md:794:- Layer organization with meaningful names and descriptions
pkg/doc/topics/21-cmds-middlewares.md:795:- Error handling for layer creation
pkg/doc/topics/21-cmds-middlewares.md:796:- Container structure for managing multiple layers
pkg/doc/topics/21-cmds-middlewares.md:800:Now that we understand the middleware signature and execution order, let's see how to implement specific middlewares. These examples show how the middleware chain processes parameters in practice.
pkg/doc/topics/21-cmds-middlewares.md:804:The `SetFromDefaults` middleware demonstrates the basic middleware pattern of processing parameters after the next handler:
pkg/doc/topics/21-cmds-middlewares.md:808:    // Create empty parsed layers
pkg/doc/topics/21-cmds-middlewares.md:809:    parsedLayers := values.New()
pkg/doc/topics/21-cmds-middlewares.md:817:        parameterLayers,
pkg/doc/topics/21-cmds-middlewares.md:818:        parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:826:    configLayer, _ := parsedLayers.Get("config")
pkg/doc/topics/21-cmds-middlewares.md:827:    hostValue, _ := configLayer.GetParameter("host")
pkg/doc/topics/21-cmds-middlewares.md:833:- Creation of empty ParsedLayers to store results
pkg/doc/topics/21-cmds-middlewares.md:845:    parsedLayers := values.New()
pkg/doc/topics/21-cmds-middlewares.md:856:        parameterLayers,
pkg/doc/topics/21-cmds-middlewares.md:857:        parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:868:- Layer-specific updates
pkg/doc/topics/21-cmds-middlewares.md:874:After middlewares process the parameters, there are several ways to access the results. These patterns align with different use cases in the architecture:
pkg/doc/topics/21-cmds-middlewares.md:877:func accessParsedValues(parsedLayers *values.Values) {
pkg/doc/topics/21-cmds-middlewares.md:878:    // 1. Direct access through layer
pkg/doc/topics/21-cmds-middlewares.md:879:    configLayer, _ := parsedLayers.Get("config")
pkg/doc/topics/21-cmds-middlewares.md:880:    hostValue, _ := configLayer.GetParameter("host")
pkg/doc/topics/21-cmds-middlewares.md:882:    // 2. Get all parameters as a map
pkg/doc/topics/21-cmds-middlewares.md:883:    dataMap := parsedLayers.GetDataMap()
pkg/doc/topics/21-cmds-middlewares.md:893:    err := parsedLayers.InitializeStruct("config", &config)
pkg/doc/topics/21-cmds-middlewares.md:901:- Direct layer access for fine-grained control
pkg/doc/topics/21-cmds-middlewares.md:902:- Map-based access for dynamic parameter handling
pkg/doc/topics/21-cmds-middlewares.md:903:- Struct initialization for type-safe parameter usage
pkg/doc/topics/21-cmds-middlewares.md:906:### 4. Tracking Parameter History
pkg/doc/topics/21-cmds-middlewares.md:908:One of the key features of Glazed's middleware system is its ability to track parameter changes. This helps debug parameter processing and understand value origins:
pkg/doc/topics/21-cmds-middlewares.md:911:func checkParameterHistory(parsedLayers *values.Values) {
pkg/doc/topics/21-cmds-middlewares.md:912:    configLayer, _ := parsedLayers.Get("config")
pkg/doc/topics/21-cmds-middlewares.md:913:    hostParam, _ := configLayer.Parameters.Get("host")
pkg/doc/topics/21-cmds-middlewares.md:926:- Debugging support for parameter processing
pkg/doc/topics/21-cmds-middlewares.md:934:    parsedLayers := values.New()
pkg/doc/topics/21-cmds-middlewares.md:936:    // Define different parameter sources
pkg/doc/topics/21-cmds-middlewares.md:953:        parameterLayers,
pkg/doc/topics/21-cmds-middlewares.md:954:        parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:974:### 6. Working with Restricted Layers
pkg/doc/topics/21-cmds-middlewares.md:976:Layer restriction is a powerful feature that implements the modular parameter handling concept discussed in the architecture:
pkg/doc/topics/21-cmds-middlewares.md:979:func useRestrictedLayers() {
pkg/doc/topics/21-cmds-middlewares.md:980:    parsedLayers := values.New()
pkg/doc/topics/21-cmds-middlewares.md:988:    // Only apply to whitelisted layers
pkg/doc/topics/21-cmds-middlewares.md:989:    whitelistedMiddleware := middlewares.WrapWithWhitelistedLayers(
pkg/doc/topics/21-cmds-middlewares.md:994:    // Or blacklist specific layers
pkg/doc/topics/21-cmds-middlewares.md:995:    blacklistedMiddleware := middlewares.WrapWithBlacklistedLayers(
pkg/doc/topics/21-cmds-middlewares.md:996:        []string{"other-layer"},
pkg/doc/topics/21-cmds-middlewares.md:1001:        parameterLayers,
pkg/doc/topics/21-cmds-middlewares.md:1002:        parsedLayers,
pkg/doc/topics/21-cmds-middlewares.md:1014:- Layer isolation
pkg/doc/topics/21-cmds-middlewares.md:1015:- Parameter scope control
pkg/doc/topics/21-cmds-middlewares.md:1021:These examples can be combined to create sophisticated parameter handling systems. For instance, a typical application might:
pkg/doc/topics/21-cmds-middlewares.md:1023:1. Define multiple parameter layers for different concerns
pkg/doc/topics/21-cmds-middlewares.md:1025:3. Use layer restrictions to manage parameter scope
pkg/doc/topics/21-cmds-middlewares.md:1026:4. Track parameter history for debugging
pkg/cmds/fields/parameters_test.go:15://go:embed "test-data/parameters_test.yaml"
pkg/cmds/fields/parameters_test.go:18:var testParameterDefinitions *Definitions
pkg/cmds/fields/parameters_test.go:26:	parameterDefinition *Definition
pkg/cmds/fields/parameters_test.go:32://go:embed "test-data/parameters_validity_test.yaml"
pkg/cmds/fields/parameters_test.go:35:var testParameterValidList []*ValidityTest
pkg/cmds/fields/parameters_test.go:45:		test.parameterDefinition = &Definition{
pkg/cmds/fields/parameters_test.go:58:var testParametersTypesYaml []byte
pkg/cmds/fields/parameters_test.go:67:func loadParameterTypeTests(yamlData []byte) ([]TypeTest, error) {
pkg/cmds/fields/parameters_test.go:76:var testParameterTypeTests []TypeTest
pkg/cmds/fields/parameters_test.go:78:func initialParameterTests() {
pkg/cmds/fields/parameters_test.go:79:	testParameterDefinitions = LoadDefinitionsFromYAML(testFlagsYaml)
pkg/cmds/fields/parameters_test.go:81:	testParameterValidList, err = loadValidityTestDataFromYAML(validityTestYaml)
pkg/cmds/fields/parameters_test.go:86:	testParameterTypeTests, err = loadParameterTypeTests(testParametersTypesYaml)
pkg/cmds/fields/parameters_test.go:92:func TestParameterTypes(t *testing.T) {
pkg/cmds/fields/parameters_test.go:93:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:94:	for _, test := range testParameterTypeTests {
pkg/cmds/fields/parameters_test.go:103:func TestParameterValidity(t *testing.T) {
pkg/cmds/fields/parameters_test.go:104:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:105:	for _, validityTest := range testParameterValidList {
pkg/cmds/fields/parameters_test.go:107:			_, err := validityTest.parameterDefinition.CheckValueValidity(validityTest.Value)
pkg/cmds/fields/parameters_test.go:118:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:119:	intFlag, _ := testParameterDefinitions.Get("int-flag")
pkg/cmds/fields/parameters_test.go:130:	intFlag, _ = testParameterDefinitions.Get("int-flag-without-default")
pkg/cmds/fields/parameters_test.go:137:	intFlag, _ = testParameterDefinitions.Get("int-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:144:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:145:	intFlag, _ := testParameterDefinitions.Get("int-flag")
pkg/cmds/fields/parameters_test.go:156:	intFlag, _ = testParameterDefinitions.Get("int-flag-without-default")
pkg/cmds/fields/parameters_test.go:163:	intFlag, _ = testParameterDefinitions.Get("int-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:171:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:172:	floatFlag, _ := testParameterDefinitions.Get("float-flag")
pkg/cmds/fields/parameters_test.go:183:	floatFlag, _ = testParameterDefinitions.Get("float-flag-without-default")
pkg/cmds/fields/parameters_test.go:190:	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:195:	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-int-default")
pkg/cmds/fields/parameters_test.go:202:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:203:	floatFlag, _ := testParameterDefinitions.Get("float-flag")
pkg/cmds/fields/parameters_test.go:214:	floatFlag, _ = testParameterDefinitions.Get("float-flag-without-default")
pkg/cmds/fields/parameters_test.go:221:	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:228:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:229:	dateFlag, _ := testParameterDefinitions.Get("date-flag")
pkg/cmds/fields/parameters_test.go:244:	dateFlag, _ = testParameterDefinitions.Get("date-flag-without-default")
pkg/cmds/fields/parameters_test.go:251:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:252:	stringFlag, _ := testParameterDefinitions.Get("string-flag")
pkg/cmds/fields/parameters_test.go:263:	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")
pkg/cmds/fields/parameters_test.go:270:	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:277:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:278:	stringFlag, _ := testParameterDefinitions.Get("string-flag")
pkg/cmds/fields/parameters_test.go:289:	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")
pkg/cmds/fields/parameters_test.go:296:	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:303:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:304:	stringFlag, _ := testParameterDefinitions.Get("string-flag")
pkg/cmds/fields/parameters_test.go:315:	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")
pkg/cmds/fields/parameters_test.go:322:	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:328:	boolFlag, _ := testParameterDefinitions.Get("bool-flag")
pkg/cmds/fields/parameters_test.go:339:	boolFlag, _ = testParameterDefinitions.Get("bool-flag-without-default")
pkg/cmds/fields/parameters_test.go:346:	boolFlag, _ = testParameterDefinitions.Get("bool-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:353:	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")
pkg/cmds/fields/parameters_test.go:364:	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")
pkg/cmds/fields/parameters_test.go:380:	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")
pkg/cmds/fields/parameters_test.go:391:	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:407:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:408:	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")
pkg/cmds/fields/parameters_test.go:419:	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")
pkg/cmds/fields/parameters_test.go:435:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:436:	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")
pkg/cmds/fields/parameters_test.go:447:	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")
pkg/cmds/fields/parameters_test.go:463:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:464:	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")
pkg/cmds/fields/parameters_test.go:475:	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:491:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:492:	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")
pkg/cmds/fields/parameters_test.go:503:	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:519:	intListFlag, _ := testParameterDefinitions.Get("int-list-flag")
pkg/cmds/fields/parameters_test.go:530:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:537:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:544:	intListFlag, _ := testParameterDefinitions.Get("int-list-flag")
pkg/cmds/fields/parameters_test.go:556:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:564:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:572:	floatListFlag, _ := testParameterDefinitions.Get("float-list-flag")
pkg/cmds/fields/parameters_test.go:583:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:590:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:597:	floatListFlag, _ := testParameterDefinitions.Get("float-list-flag")
pkg/cmds/fields/parameters_test.go:609:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:617:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:625:	objectFromFileFlag, _ := testParameterDefinitions.Get("object-from-file-flag")
pkg/cmds/fields/parameters_test.go:634:	objectFromFileFlag, _ = testParameterDefinitions.Get("object-from-file-flag-without-default")
pkg/cmds/fields/parameters_test.go:641:	objectFromFileFlag, _ = testParameterDefinitions.Get("object-from-file-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:648:	objectListFromFileFlag, _ := testParameterDefinitions.Get("object-list-from-file-flag")
pkg/cmds/fields/parameters_test.go:660:	objectListFromFileFlag, _ = testParameterDefinitions.Get("object-list-from-file-flag-without-default")
pkg/cmds/fields/parameters_test.go:667:	objectListFromFileFlag, _ = testParameterDefinitions.Get("object-list-from-file-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:674:	stringFromFileFlag, _ := testParameterDefinitions.Get("string-from-file-flag")
pkg/cmds/fields/parameters_test.go:683:	stringFromFileFlag, _ = testParameterDefinitions.Get("string-from-file-flag-without-default")
pkg/cmds/fields/parameters_test.go:690:	stringFromFileFlag, _ = testParameterDefinitions.Get("string-from-file-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:697:	stringListFromFileFlag, _ := testParameterDefinitions.Get("string-list-from-file-flag")
pkg/cmds/fields/parameters_test.go:706:	stringListFromFileFlag, _ = testParameterDefinitions.Get("string-list-from-file-flag-without-default")
pkg/cmds/fields/parameters_test.go:713:	stringListFromFileFlag, _ = testParameterDefinitions.Get("string-list-from-file-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:720:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:721:	stringListFlag, _ := testParameterDefinitions.Get("string-list-flag")
pkg/cmds/fields/parameters_test.go:732:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:739:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:746:	initialParameterTests()
pkg/cmds/fields/parameters_test.go:747:	stringListFlag, _ := testParameterDefinitions.Get("string-list-flag")
pkg/cmds/fields/parameters_test.go:758:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-without-default")
pkg/cmds/fields/parameters_test.go:765:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-with-empty-default")
pkg/cmds/fields/parameters_test.go:772:	keyValueFlag, _ := testParameterDefinitions.Get("key-value-flag")
pkg/cmds/fields/parameters_test.go:781:	keyValueFlag, _ = testParameterDefinitions.Get("key-value-flag-without-default")
pkg/cmds/fields/parameters_test.go:788:	keyValueFlag, _ = testParameterDefinitions.Get("key-value-flag-with-empty-default")
pkg/doc/topics/01-help-system.md:349://   Parameters: [1 database]
pkg/cmds/fields/strings_test.go:10:// TestGatherFlagsFromStringList_ValidArgumentsAndParameters tests the function with valid arguments and fields.
pkg/cmds/fields/strings_test.go:11:func TestGatherFlagsFromStringList_ValidArgumentsAndParameters(t *testing.T) {
pkg/cmds/fields/strings_test.go:366:		// "--flag value" (empty parameters)
pkg/cmds/fields/strings_test.go:368:			name:    "EmptyParameters",
pkg/cmds/fields/strings_test.go:373:		// "--flag value" (parameters with empty ShortFlag)
pkg/cmds/fields/strings_test.go:375:			name: "ParametersWithEmptyShortFlag",
pkg/cmds/fields/strings_test.go:385:		// "--flag value -f value" (parameters with the same Name and ShortFlag)
pkg/cmds/fields/strings_test.go:386:		// "--flag1 value1 -f value2" (parameters with different Name but the same ShortFlag)
pkg/cmds/fields/strings_test.go:388:			name: "ParametersWithDifferentNameSameShortFlag",
pkg/cmds/fields/strings_test.go:396:		// "--flag1 value1 --flag2 value2" (mix of valid and invalid parameters)
pkg/cmds/fields/strings_test.go:398:			name: "MixOfValidAndInvalidParameters",
pkg/cmds/fields/strings_test.go:402:				// Assuming invalid parameter doesn't have a type
pkg/cmds/fields/strings_test.go:500:			got_.ForEach(func(key string, p *ParsedParameter) {
pkg/cmds/fields/viper.go:17:) (*ParsedParameters, error) {
pkg/cmds/fields/viper.go:19:		log.Warn().Msg("fields.GatherFlagsFromViper is deprecated; use LoadParametersFromFiles + UpdateFromEnv")
pkg/cmds/fields/viper.go:21:	ret := NewParsedParameters()
pkg/cmds/fields/viper.go:26:		parsed := &ParsedParameter{
pkg/cmds/fields/viper.go:118:			return nil, errors.Errorf("Unknown parameter type %s for flag %s", p.Type, p.Name)
pkg/cmds/fields/cobra.go:13:// GenerateUseString creates a string representation of the 'Use' field for a given cobra command and a list of parameter definitions. The first word of the existing 'Use' field is treated as the verb for the command.
pkg/cmds/fields/cobra.go:15://   - Required parameters are enclosed in '<>'.
pkg/cmds/fields/cobra.go:16://   - Optional parameters are enclosed in '[]'.
pkg/cmds/fields/cobra.go:17://   - Optional parameters that accept multiple input (TypeStringList or TypeIntegerList) are followed by '...'.
pkg/cmds/fields/cobra.go:18://   - If a parameter has a default value, it is specified after parameter name like 'parameter (default: value)'.
pkg/cmds/fields/cobra.go:21://   - If there is a required parameter 'name', and an optional parameter 'age' with a default value of '30', the resulting string will be: 'verb <name> [age (default: 30)]'.
pkg/cmds/fields/cobra.go:22://   - If there is a required parameter 'name', and an optional parameter 'colors' of type TypeStringList, the resulting Use string will be: 'verb <name> [colors...]'
pkg/cmds/fields/cobra.go:85:		_, err := argument.CheckParameterDefaultValueValidity()
pkg/cmds/fields/cobra.go:120:// AddParametersToCobraCommand takes the parameters from a CommandDescription and converts them
pkg/cmds/fields/cobra.go:121:// to cobra flags, before adding them to the Parameters() of a the passed cobra command.
pkg/cmds/fields/cobra.go:122:func (pds *Definitions) AddParametersToCobraCommand(
pkg/cmds/fields/cobra.go:133:	err = pds.GetFlags().ForEachE(func(parameter *Definition) error {
pkg/cmds/fields/cobra.go:134:		_, err := parameter.CheckParameterDefaultValueValidity()
pkg/cmds/fields/cobra.go:136:			return errors.Wrapf(err, "Invalid default value for argument %s", parameter.Name)
pkg/cmds/fields/cobra.go:139:		flagName := prefix + parameter.Name
pkg/cmds/fields/cobra.go:142:		shortFlag := parameter.ShortFlag
pkg/cmds/fields/cobra.go:154:		helpText := parameter.Help
pkg/cmds/fields/cobra.go:155:		helpText = fmt.Sprintf("%s - <%s>", helpText, parameter.Type)
pkg/cmds/fields/cobra.go:157:		switch parameter.Type {
pkg/cmds/fields/cobra.go:165:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:177:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:186:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:187:				defaultValue, err = cast.ToString(*parameter.Default)
pkg/cmds/fields/cobra.go:189:					return errors.Errorf("Default value for parameter %s is not a string: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:193:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:201:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:202:				defaultValue, ok = cast.CastNumberInterfaceToInt[int](*parameter.Default)
pkg/cmds/fields/cobra.go:204:					return errors.Errorf("Default value for parameter %s is not an integer: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:208:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:217:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:218:				defaultValue, ok = cast.CastFloatInterfaceToFloat[float64](*parameter.Default)
pkg/cmds/fields/cobra.go:220:					return errors.Errorf("Default value for parameter %s is not a float: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:224:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:233:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:234:				defaultValue, ok = (*parameter.Default).(bool)
pkg/cmds/fields/cobra.go:236:					return errors.Errorf("Default value for parameter %s is not a bool: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:240:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:249:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:250:				switch v_ := (*parameter.Default).(type) {
pkg/cmds/fields/cobra.go:261:					return errors.Errorf("Default value for parameter %s is not a valid date: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:265:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:274:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:275:				stringList, ok := (*parameter.Default).([]string)
pkg/cmds/fields/cobra.go:277:					defaultValue, ok := (*parameter.Default).([]interface{})
pkg/cmds/fields/cobra.go:279:						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:285:						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:292:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:301:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:302:				stringMap, ok := (*parameter.Default).(map[string]string)
pkg/cmds/fields/cobra.go:304:					defaultValue, ok := (*parameter.Default).(map[string]interface{})
pkg/cmds/fields/cobra.go:306:						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:325:				return errors.Wrapf(err, "Could not convert default value for parameter %s to string list: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:328:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:336:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:337:				defaultValue, ok = cast.CastInterfaceToIntList[int](*parameter.Default)
pkg/cmds/fields/cobra.go:339:					return errors.Errorf("Default value for parameter %s is not an integer list: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:343:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:351:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:352:				defaultValue, ok = cast.CastInterfaceToFloatList[float64](*parameter.Default)
pkg/cmds/fields/cobra.go:354:					return errors.Errorf("Default value for parameter %s is not a float list: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:357:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:366:			if parameter.Default != nil {
pkg/cmds/fields/cobra.go:367:				defaultValue, err = cast.ToString(*parameter.Default)
pkg/cmds/fields/cobra.go:369:					return errors.Errorf("Default value for parameter %s is not a string: %v", parameter.Name, *parameter.Default)
pkg/cmds/fields/cobra.go:373:			choiceString := strings.Join(parameter.Choices, ",")
pkg/cmds/fields/cobra.go:375:			if parameter.ShortFlag != "" {
pkg/cmds/fields/cobra.go:382:			return errors.Errorf("Unknown parameter type for parameter %s: %s", parameter.Name, parameter.Type)
pkg/cmds/fields/cobra.go:395:// to the parameter description passed in params. The result is a map of parameter
pkg/cmds/fields/cobra.go:398:// If onlyProvided is true, only parameters that are provided
pkg/cmds/fields/cobra.go:401:// If a parameter cannot be parsed correctly, or is missing even though it is not optional,
pkg/cmds/fields/cobra.go:404:// The required argument checks that all the required parameter definitions are present.
pkg/cmds/fields/cobra.go:413:) (*ParsedParameters, error) {
pkg/cmds/fields/cobra.go:414:	ps := NewParsedParameters()
pkg/cmds/fields/cobra.go:417:		p := &ParsedParameter{
pkg/cmds/fields/cobra.go:435:				return errors.Errorf("Parameter %s is required", pd.Name)
pkg/cmds/fields/cobra.go:468:			v2, err := pd.ParseParameter([]string{v}, options...)
pkg/cmds/fields/cobra.go:515:			v2, err := pd.ParseParameter(v, options...)
pkg/cmds/fields/cobra.go:552:				v2, err := pd.ParseParameter(v, options...)
pkg/cmds/test-data/cobra/02-key-value.yaml:13:    flagParameters:
pkg/cmds/test-data/cobra/01-test-simple.yaml:18:    argumentParameters:
pkg/cmds/test-data/cobra/01-test-simple.yaml:23:    flagParameters:
pkg/cmds/test-data/cobra/01-test-simple.yaml:28:    argumentParameters:
pkg/cmds/test-data/cobra/01-test-simple.yaml:32:    flagParameters:
pkg/cmds/fields/parse.go:29:// ParseParameter parses command line arguments according to the given Definition.
pkg/cmds/fields/parse.go:30:// It returns the parsed parameter value and a non-nil error if parsing failed.
pkg/cmds/fields/parse.go:36:// If the parameter is required and not provided, an error is returned.
pkg/cmds/fields/parse.go:37:// If the parameter is optional and not provided, the default value is returned.
pkg/cmds/fields/parse.go:81:func (p *Definition) ParseParameter(v []string, options ...ParseOption) (*ParsedParameter, error) {
pkg/cmds/fields/parse.go:82:	ret := &ParsedParameter{
pkg/cmds/fields/parse.go:316:				// TODO(2023-02-11): The separator could be stored in the parameter itself?
pkg/cmds/fields/parse.go:342:		return nil, errors.Errorf("Unknown parameter type %s", p.Type)
pkg/cmds/fields/parse.go:355:func parseFromFileName(fileName string, p *Definition, options ...ParseOption) (*ParsedParameter, error) {
pkg/cmds/fields/parse.go:356:	ret := &ParsedParameter{
pkg/cmds/fields/parse.go:440:// In the case of parameters taking multiple files, this needs to be called for each file
pkg/cmds/fields/parse.go:445:) (*ParsedParameter, error) {
pkg/cmds/fields/parse.go:446:	ret := &ParsedParameter{
pkg/cmds/fields/parse.go:607:		return nil, errors.New("Cannot parse from file for this parameter type")
pkg/cmds/fields/parse.go:615:) (*ParsedParameter, error) {
pkg/cmds/fields/parse.go:616:	ret := &ParsedParameter{
pkg/help/store/compat.go:11:// HelpSystem provides a compatibility layer with the existing help system interface
pkg/cmds/test-data/cobra/03-string-from-file.yaml:11:    flagParameters:
pkg/cmds/test-data/cobra/03-string-from-file.yaml:16:    flagParameters:
pkg/cmds/fields/initialize-struct_test.go:17:// TestInitializeStructWithValidStruct tests initializing a struct with valid parameters
pkg/cmds/fields/initialize-struct_test.go:19:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:20:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:26:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:44:	parsedParams := &fields.ParsedParameters{}
pkg/cmds/fields/initialize-struct_test.go:54:	parsedParams := &fields.ParsedParameters{}
pkg/cmds/fields/initialize-struct_test.go:65:	parsedParams := &fields.ParsedParameters{}
pkg/cmds/fields/initialize-struct_test.go:74:// TestInitializeStructWithMissingParameters tests initializing a struct with missing parameters
pkg/cmds/fields/initialize-struct_test.go:75:func TestInitializeStructWithMissingParameters(t *testing.T) {
pkg/cmds/fields/initialize-struct_test.go:76:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:77:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:100:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:101:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:123:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:124:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:146:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:147:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:169:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:170:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:199:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:200:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:222:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:223:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:244:// TestInitializeStructWithWildcardMultipleMatches tests wildcard pattern matching multiple parameters
pkg/cmds/fields/initialize-struct_test.go:246:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:247:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:253:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:271:// TestInitializeStructWithWildcardNoMatches tests wildcard pattern matching no parameters
pkg/cmds/fields/initialize-struct_test.go:273:	parsedParams := fields.NewParsedParameters()
pkg/cmds/fields/initialize-struct_test.go:288:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:289:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:301:	assert.Contains(t, err.Error(), "wildcard parameters require a map field")
pkg/cmds/fields/initialize-struct_test.go:310:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:311:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:317:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:334:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:335:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:358:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:359:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:365:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:371:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:395:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:396:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:451:	assert.Contains(t, err.Error(), "wildcard parameters require a map field")
pkg/cmds/fields/initialize-struct_test.go:528:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:529:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:563:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:564:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:591:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:592:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:617:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:618:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:643:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:644:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:679:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:680:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:706:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:707:		fields.WithParsedParameter(
pkg/cmds/fields/initialize-struct_test.go:746:	parsedParams := fields.NewParsedParameters(
pkg/cmds/fields/initialize-struct_test.go:747:		fields.WithParsedParameter(
pkg/help/store/README.md:23:- **Compat**: Compatibility layer for existing help system interface
pkg/help/store/README.md:197:## Compatibility Layer
pkg/help/store/README.md:241:The predicate system is more powerful than the existing `SectionQuery`, but the compatibility layer ensures existing code continues to work.
pkg/cmds/fields/initialize-struct.go:55:// InitializeStruct initializes a struct from a ParsedParameters map.
pkg/cmds/fields/initialize-struct.go:59:// parameter value in the ParsedParameters map and set the field's value.
pkg/cmds/fields/initialize-struct.go:61:// If the tag open `from_json` is appended to `glazed` and the parameter
pkg/cmds/fields/initialize-struct.go:64:// If the tag contains a wildcard, the function will match parameter names against the
pkg/cmds/fields/initialize-struct.go:76:// ps is the ParsedParameters map to lookup parameter values from.
pkg/cmds/fields/initialize-struct.go:130:// - A tagged field does not have a matching parameter value in ps
pkg/cmds/fields/initialize-struct.go:132:func (p *ParsedParameters) InitializeStruct(s interface{}) error {
pkg/cmds/fields/initialize-struct.go:160:				return errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)
pkg/cmds/fields/initialize-struct.go:166:			parameter, ok := p.Get(options.Name)
pkg/cmds/fields/initialize-struct.go:171:			if err := p.setTargetValue(dst, parameter.Value, options.FromJson); err != nil {
pkg/cmds/fields/initialize-struct.go:179:// setWildcardValues matches parameter names from ParsedParameters against a supplied pattern using the
pkg/cmds/fields/initialize-struct.go:187:// using the parameter name as the key and the parameter value as the map value.
pkg/cmds/fields/initialize-struct.go:191:// Parameters:
pkg/cmds/fields/initialize-struct.go:192://   - dst: A reflect.Value acting as the container for storing the matched keys and their parameter values.
pkg/cmds/fields/initialize-struct.go:193://   - pattern: String pattern used for matching parameter names. It can include literal characters,
pkg/cmds/fields/initialize-struct.go:195:func (p *ParsedParameters) setWildcardValues(dst reflect.Value, pattern string, fromJson bool) error {
pkg/cmds/fields/initialize-struct.go:208:	err := p.ForEachE(func(paramName string, parameter *ParsedParameter) error {
pkg/cmds/fields/initialize-struct.go:210:			// Check if the type of parameter.Value is compatible with the map's value type
pkg/cmds/fields/initialize-struct.go:211:			if reflect.TypeOf(parameter.Value) != elemType {
pkg/cmds/fields/initialize-struct.go:212:				return errors.Errorf("type mismatch: expected type %s, got %s", elemType, reflect.TypeOf(parameter.Value))
pkg/cmds/fields/initialize-struct.go:215:			paramValue := reflect.ValueOf(parameter.Value)
pkg/cmds/fields/initialize-struct.go:217:			// Check if the type of parameter.Value is directly assignable to the map's value type
pkg/cmds/fields/initialize-struct.go:219:				// Check if the type of parameter.Value can be converted to the map's value type
pkg/cmds/fields/initialize-struct.go:281:func (p *ParsedParameters) handleFromJSON(dst reflect.Value, value interface{}) error {
pkg/cmds/fields/initialize-struct.go:307:func (p *ParsedParameters) handleFileData(dst reflect.Value, value interface{}) (bool, error) {
pkg/cmds/fields/initialize-struct.go:389:func (p *ParsedParameters) setTargetValue(dst reflect.Value, value interface{}, fromJson bool) error {
pkg/cmds/fields/initialize-struct.go:482:				return nil, errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)
pkg/cmds/fields/parse_test.go:20:type ParameterTestCase struct {
pkg/cmds/fields/parse_test.go:66:type ParameterTest struct {
pkg/cmds/fields/parse_test.go:71:	Cases        []ParameterTestCase
pkg/cmds/fields/parse_test.go:74:func TestParameterDate(t *testing.T) {
pkg/cmds/fields/parse_test.go:75:	cases := []ParameterTestCase{
pkg/cmds/fields/parse_test.go:203:	parameter := New(
pkg/cmds/fields/parse_test.go:211:			got, err := parameter.ParseParameter(tc.Input)
pkg/cmds/fields/parse_test.go:225:func TestParseParameter(t *testing.T) {
pkg/cmds/fields/parse_test.go:226:	tests := []ParameterTest{
pkg/cmds/fields/parse_test.go:228:			Name:         "ParameterString",
pkg/cmds/fields/parse_test.go:231:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:238:			Name:         "ParameterStringList",
pkg/cmds/fields/parse_test.go:241:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:248:			Name:         "ParameterInt",
pkg/cmds/fields/parse_test.go:251:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:259:			Name:         "ParameterIntegerList",
pkg/cmds/fields/parse_test.go:262:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:271:			Name:         "ParameterBool",
pkg/cmds/fields/parse_test.go:274:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:283:			Name:         "ParameterFloat",
pkg/cmds/fields/parse_test.go:286:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:294:			Name:         "ParameterFloatList",
pkg/cmds/fields/parse_test.go:297:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:305:			Name:         "ParameterChoice",
pkg/cmds/fields/parse_test.go:309:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:317:			Name:         "ParameterChoiceList",
pkg/cmds/fields/parse_test.go:321:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:333:			Cases: []ParameterTestCase{
pkg/cmds/fields/parse_test.go:343:		parameter := New(
pkg/cmds/fields/parse_test.go:351:				got, err := parameter.ParseParameter(tc.Input)
pkg/cmds/fields/parse_test.go:364:	parameter := New("test", TypeStringListFromFile,
pkg/cmds/fields/parse_test.go:369:	i, err := parameter.ParseFromReader(reader, "test.txt")
pkg/cmds/fields/parse_test.go:374:	i, err = parameter.ParseFromReader(reader, "test.txt")
pkg/cmds/fields/parse_test.go:379:	i, err = parameter.ParseFromReader(reader, "test.txt")
pkg/cmds/fields/parse_test.go:385:	i, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:391:	i, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:397:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:402:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:407:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:412:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:417:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:422:	i, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:429:	i, err = parameter.ParseFromReader(reader, "test.yaml")
pkg/cmds/fields/parse_test.go:435:	i, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:442:	parameter := New("test", TypeObjectFromFile,
pkg/cmds/fields/parse_test.go:447:	i, err := parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:452:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:456:	i, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:461:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:466:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:471:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:476:	_, err = parameter.ParseFromReader(reader, "test.json")
pkg/cmds/fields/parse_test.go:481:	i, err = parameter.ParseFromReader(reader, "test.yaml")
pkg/cmds/fields/parse_test.go:486:	i, err = parameter.ParseFromReader(reader, "test.yml")
pkg/cmds/fields/parse_test.go:492:	i, err = parameter.ParseFromReader(reader, "test.yaml")
pkg/cmds/fields/parse_test.go:498:	_, err = parameter.ParseFromReader(reader, "test.yaml")
pkg/cmds/fields/parse_test.go:503:	_, err = parameter.ParseFromReader(reader, "test.yaml")
pkg/cmds/fields/parse_test.go:509:	i, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:517:	_, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:522:	_, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:527:	_, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:533:	i, err = parameter.ParseFromReader(reader, "test.tsv")
pkg/cmds/fields/parse_test.go:540:	i, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:547:	i, err = parameter.ParseFromReader(reader, "test.csv")
pkg/cmds/fields/parse_test.go:553:	parameter := New("test", TypeObjectListFromFile,
pkg/cmds/fields/parse_test.go:557:	v, err := parseObjectListFromString(parameter, `[{"test":"test"}]`, "test.json")
pkg/cmds/fields/parse_test.go:562:	v, err = parseObjectListFromString(parameter, `[{"test":"test"},{"test2":"test2"}]`, "test.json")
pkg/cmds/fields/parse_test.go:566:	_, err = parseObjectListFromString(parameter, `{"test":"test"`, "test.json")
pkg/cmds/fields/parse_test.go:569:	v, err = parseObjectListFromString(parameter, `[{"test":{"test":"test"}}]`, "test.json")
pkg/cmds/fields/parse_test.go:574:	v, err = parseObjectListFromString(parameter, `[]`, "test.json")
pkg/cmds/fields/parse_test.go:579:	_, err = parseObjectListFromString(parameter, ``, "test.json")
pkg/cmds/fields/parse_test.go:583:	_, err = parseObjectListFromString(parameter, `["test"]`, "test.json")
pkg/cmds/fields/parse_test.go:587:	v, err = parseObjectListFromString(parameter, `{"test":"test"}
pkg/cmds/fields/parse_test.go:593:	_, err = parseObjectListFromString(parameter, `{"test":"test"}{"test2":"test2"}`, "test.ndjson")
pkg/cmds/fields/parse_test.go:597:	v, err = parseObjectListFromString(parameter, `{"test":"test"}`, "test.ndjson")
pkg/cmds/fields/parse_test.go:602:	_, err = parseObjectListFromString(parameter, `{"test":"test"}
pkg/cmds/fields/parse_test.go:607:	v, err = parseObjectListFromString(parameter, `- test: test`, "test.yaml")
pkg/cmds/fields/parse_test.go:611:	v, err = parseObjectListFromString(parameter, `- test: test`, "test.yml")
pkg/cmds/fields/parse_test.go:616:	v, err = parseObjectListFromString(parameter, `- test: test
pkg/cmds/fields/parse_test.go:622:	v, err = parseObjectListFromString(parameter, `- test: {test: test}`, "test.yaml")
pkg/cmds/fields/parse_test.go:627:	_, err = parseObjectListFromString(parameter, `- test
pkg/cmds/fields/parse_test.go:632:	v, err = parseObjectListFromString(parameter, `test: test`, "test.yaml")
pkg/cmds/fields/parse_test.go:637:	v, err = parseObjectListFromString(parameter, `[]`, "test.yaml")
pkg/cmds/fields/parse_test.go:642:	_, err = parseObjectListFromString(parameter, ``, "test.yaml")
pkg/cmds/fields/parse_test.go:646:	v, err = parseObjectListFromString(parameter, `test,test2
pkg/cmds/fields/parse_test.go:652:	v, err = parseObjectListFromString(parameter, `test,test2
pkg/cmds/fields/parse_test.go:659:	_, err = parseObjectListFromString(parameter, `test,test2`, "test.csv")
pkg/cmds/fields/parse_test.go:663:	v, err = parseObjectListFromString(parameter, ``, "test.csv")
pkg/cmds/fields/parse_test.go:668:	v, err = parseObjectListFromString(parameter, `test,test2
pkg/cmds/fields/parse_test.go:675:func parseObjectListFromString(parameter *Definition, input string, fileName string) ([]map[string]interface{}, error) {
pkg/cmds/fields/parse_test.go:677:	i, err := parameter.ParseFromReader(reader, fileName)
pkg/cmds/fields/parse_test.go:689:	parameter := New("test", TypeStringFromFile,
pkg/cmds/fields/parse_test.go:694:	i, err := parameter.ParseFromReader(reader, "test.txt")
pkg/cmds/fields/parse_test.go:700:	i, err = parameter.ParseFromReader(reader, "test.txt")
pkg/cmds/fields/parse_test.go:705:	i, err = parameter.ParseFromReader(reader, "test.txt")
pkg/cmds/fields/parse_test.go:711:	parameter := New("test", TypeStringFromFile,
pkg/cmds/fields/parse_test.go:715:	v, err := parameter.ParseParameter([]string{"test-data/string.txt"})
pkg/cmds/fields/parse_test.go:719:	parameter = New("test", TypeStringFromFiles,
pkg/cmds/fields/parse_test.go:722:	v, err = parameter.ParseParameter([]string{"test-data/string.txt"})
pkg/cmds/fields/parse_test.go:726:	v, err = parameter.ParseParameter([]string{"test-data/string.txt", "test-data/string2.txt"})
pkg/cmds/fields/parse_test.go:732:	parameter := New("test", TypeStringListFromFile,
pkg/cmds/fields/parse_test.go:736:	v, err := parameter.ParseParameter([]string{"test-data/string.txt"})
pkg/cmds/fields/parse_test.go:740:	v, err = parameter.ParseParameter([]string{"test-data/stringList.csv"})
pkg/cmds/fields/parse_test.go:744:	v, err = parameter.ParseParameter([]string{"test-data/stringList.csv", "test-data/stringList2.csv"})
pkg/cmds/fields/parse_test.go:748:	parameter = New("test", TypeStringListFromFiles,
pkg/cmds/fields/parse_test.go:751:	v, err = parameter.ParseParameter([]string{"test-data/string.txt"})
pkg/cmds/fields/parse_test.go:755:	v, err = parameter.ParseParameter([]string{"test-data/string.txt", "test-data/string2.txt"})
pkg/cmds/fields/parse_test.go:761:	parameter := New("test", TypeObjectListFromFile,
pkg/cmds/fields/parse_test.go:765:	v, err := parameter.ParseParameter([]string{"test-data/object.json"})
pkg/cmds/fields/parse_test.go:769:	v, err = parameter.ParseParameter([]string{"test-data/objectList.json"})
pkg/cmds/fields/parse_test.go:783:	v, err = parameter.ParseParameter([]string{"test-data/objectList3.csv"})
pkg/cmds/fields/parse_test.go:797:	parameter = New("test", TypeObjectListFromFiles,
pkg/cmds/fields/parse_test.go:801:	v, err = parameter.ParseParameter([]string{"test-data/object.json"})
pkg/cmds/fields/parse_test.go:805:	v, err = parameter.ParseParameter([]string{"test-data/object.json", "test-data/object2.json"})
pkg/cmds/fields/parse_test.go:820:	v, err = parameter.ParseParameter([]string{
pkg/cmds/fields/parse_test.go:931:			_, err := param.CheckParameterDefaultValueValidity()
pkg/cmds/fields/parse_test.go:944:	_, err := param.CheckParameterDefaultValueValidity()
pkg/cmds/fields/parse_test.go:961:		_, err := param.CheckParameterDefaultValueValidity()
pkg/doc/tutorials/05-build-first-command.md:24:- Understand command configuration and parameter handling
pkg/doc/tutorials/05-build-first-command.md:79:Every Glazed command follows a consistent pattern: a command struct embeds `*cmds.CommandDescription` for metadata, and a settings struct maps command-line flags to Go fields using struct tags for type-safe parameter access.
pkg/doc/tutorials/05-build-first-command.md:87:// Step 2.2: Define settings for type-safe parameter access
pkg/doc/tutorials/05-build-first-command.md:97:1. **Command Struct**: `ListUsersCommand` embeds `*cmds.CommandDescription`, which contains command metadata (name, help text, parameters)
pkg/doc/tutorials/05-build-first-command.md:153:### Command Configuration and Parameters
pkg/doc/tutorials/05-build-first-command.md:155:Command configuration combines your custom fields with Glazed's built-in output formatting capabilities. The `settings.NewGlazedSchema()` helper (a wrapper around `settings.NewGlazedParameterLayers()`) adds standard flags like `--output`, `--fields`, and `--sort-columns`, while your custom field definitions specify the command's business logic inputs.
pkg/doc/tutorials/05-build-first-command.md:162:    glazedLayer, err := settings.NewGlazedSchema()
pkg/doc/tutorials/05-build-first-command.md:167:    // Create command settings layer for debugging features
pkg/doc/tutorials/05-build-first-command.md:168:    commandSettingsLayer, err := cli.NewCommandSettingsLayer()
pkg/doc/tutorials/05-build-first-command.md:173:    // Define command with parameters
pkg/doc/tutorials/05-build-first-command.md:215:        // Add glazed and command settings layers
pkg/doc/tutorials/05-build-first-command.md:216:        cmds.WithLayersList(glazedLayer, commandSettingsLayer),
pkg/doc/tutorials/05-build-first-command.md:227:1. **Glazed Schema Section**: `settings.NewGlazedSchema()` adds built-in parameters like `--output`, `--fields`, `--sort-columns` (and `cli.BuildCobraCommand` will auto-add it for `GlazeCommand` implementations if you don't)
pkg/doc/tutorials/05-build-first-command.md:228:2. **Command Settings Layer**: `cli.NewCommandSettingsLayer()` adds debugging and configuration parameters:
pkg/doc/tutorials/05-build-first-command.md:229:   - `--print-parsed-parameters`: Debug parameter parsing
pkg/doc/tutorials/05-build-first-command.md:231:   - `--load-parameters-from-file`: Load settings from JSON file
pkg/doc/tutorials/05-build-first-command.md:233:4. **Parameter Definitions**: Each flag specifies:
pkg/doc/tutorials/05-build-first-command.md:238:5. **Layer Composition**: Combines custom parameters with Glazed's built-in layers
pkg/doc/tutorials/05-build-first-command.md:328:3. **Filtering Logic**: Demonstrates how command parameters control data processing
pkg/doc/tutorials/05-build-first-command.md:332:Glazed commands integrate with standard Cobra applications through the `cli.BuildCobraCommand()` builder function. This function handles the conversion between Glazed's parameter layer system and Cobra's flag parsing, automatically configuring output processing and help text generation. You can pass parser and mode options via `CobraParserConfig` and `CobraOption` helpers.
pkg/doc/tutorials/05-build-first-command.md:354:            ShortHelpLayers: []string{schema.DefaultSlug},
pkg/doc/tutorials/05-build-first-command.md:379:Glazed provides a logging layer you can attach to your root command. This exposes logging-related flags and initializes logging based on configuration. Initialize the logger in `PersistentPreRunE` using Cobra-parsed flags so logging is active before your command logic runs.
pkg/doc/tutorials/05-build-first-command.md:399:    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "glazed-quickstart")
pkg/doc/tutorials/05-build-first-command.md:408:- Add logging flags with `logging.AddLoggingLayerToRootCommand(rootCmd, "<use-name>")`.
pkg/doc/tutorials/05-build-first-command.md:410:- Alternatively, you can call `logging.SetupLoggingFromParsedLayers(parsedLayers)` after parsing for per-command logging settings.
pkg/doc/tutorials/05-build-first-command.md:416:3. **Enhanced Cobra Bridge**: Use `cli.WithParserConfig` to pass a `CobraParserConfig` that customizes parser behavior (e.g., `ShortHelpLayers`, `MiddlewaresFunc`).
pkg/doc/tutorials/05-build-first-command.md:425:- `--print-parsed-parameters`: Shows how parameters were parsed from different sources
pkg/doc/tutorials/05-build-first-command.md:427:- `--print-schema`: Displays the command's parameter schema
pkg/doc/tutorials/05-build-first-command.md:434:- **Contextual Help**: Provides detailed help based on command context and available layers
pkg/doc/tutorials/05-build-first-command.md:435:- **Parameter Documentation**: Automatically generates help text from parameter definitions
pkg/doc/tutorials/05-build-first-command.md:436:- **Layer-Aware Help**: Shows relevant parameters based on active layers
pkg/doc/tutorials/05-build-first-command.md:441:Testing validates that your command properly parses parameters, processes data according to the business logic, and integrates correctly with Glazed's output system.
pkg/doc/tutorials/05-build-first-command.md:450:# Try different parameter combinations
pkg/doc/tutorials/05-build-first-command.md:457:./glazed-quickstart list-users --print-parsed-parameters
pkg/doc/tutorials/05-build-first-command.md:468:1. **Help Text**: `--help` displays auto-generated parameter descriptions and examples with enhanced formatting
pkg/doc/tutorials/05-build-first-command.md:469:2. **Parameter Validation**: Invalid values trigger automatic validation errors
pkg/doc/tutorials/05-build-first-command.md:472:5. **Help Command**: `help` command provides contextual documentation and parameter guidance
pkg/doc/tutorials/05-build-first-command.md:572:    // Add command settings layer for debugging features
pkg/doc/tutorials/05-build-first-command.md:573:    commandSettingsLayer, err := cli.NewCommandSettingsLayer()
pkg/doc/tutorials/05-build-first-command.md:591:        cmds.WithLayersList(commandSettingsLayer),
pkg/doc/tutorials/05-build-first-command.md:633:        ShortHelpLayers: []string{schema.DefaultSlug},
pkg/doc/tutorials/05-build-first-command.md:668:./glazed-quickstart status --print-parsed-parameters
pkg/doc/tutorials/05-build-first-command.md:700:**Type Safety**: Use settings structs with `glazed` tags for automatic parameter parsing and validation.
pkg/doc/tutorials/05-build-first-command.md:704:**Input Validation**: Validate business rules in your command implementation, not just parameter types:
pkg/doc/tutorials/05-build-first-command.md:707:// Validate business rules after parameter parsing
pkg/doc/tutorials/05-build-first-command.md:718:### Advanced Parameter Types
pkg/doc/tutorials/05-build-first-command.md:720:Glazed supports various parameter types beyond basic strings, integers, and booleans:
pkg/doc/tutorials/05-build-first-command.md:724:    // File parameter validates file exists
pkg/doc/tutorials/05-build-first-command.md:731:    // Choice parameter limits valid options
pkg/doc/tutorials/05-build-first-command.md:778:glaze help layers-guide
pkg/doc/tutorials/05-build-first-command.md:781:Learn about parameter layers for organizing reusable configuration sets across commands.
pkg/doc/tutorials/05-build-first-command.md:798:glaze help custom-layer
pkg/doc/tutorials/05-build-first-command.md:801:Create domain-specific parameter layers for your application's needs.
pkg/cmds/sources/update.go:12:// FromDefaults is a middleware that sets default values from parameter definitions.
pkg/cmds/sources/update.go:13:// It calls the next handler, and then iterates through each layer and parameter definition.
pkg/cmds/sources/update.go:14:// If a default is defined, it sets that as the parameter value in the parsed layer.
pkg/cmds/sources/update.go:17:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/update.go:18:			err := next(layers_, parsedLayers)
pkg/cmds/sources/update.go:22:			err = layers_.UpdateWithDefaults(parsedLayers, options...)
pkg/cmds/sources/update.go:31:// FromMap takes a map where the keys are layer slugs and the values are
pkg/cmds/sources/update.go:32:// maps of parameter name -> value. It calls next, and then merges the provided
pkg/cmds/sources/update.go:33:// values into the parsed layers, skipping any layers not present in layers_.
pkg/cmds/sources/update.go:36:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/update.go:37:			err := next(layers_, parsedLayers)
pkg/cmds/sources/update.go:42:			return updateFromMap(layers_, parsedLayers, m, options...)
pkg/cmds/sources/update.go:47:// FromMapFirst takes a map where the keys are layer slugs and the values are
pkg/cmds/sources/update.go:48:// maps of parameter name -> value. It calls next, and then merges the provided
pkg/cmds/sources/update.go:49:// values into the parsed layers, skipping any layers not present in layers_.
pkg/cmds/sources/update.go:52:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/update.go:53:			err := updateFromMap(layers_, parsedLayers, m, options...)
pkg/cmds/sources/update.go:58:			return next(layers_, parsedLayers)
pkg/cmds/sources/update.go:63:// FromMapAsDefault takes a map where the keys are layer slugs and the values are
pkg/cmds/sources/update.go:64:// maps of parameter name -> value. It calls next, and then merges the provided
pkg/cmds/sources/update.go:65:// values into the parsed layers if the parameter hasn't already been set, skipping any layers not present in layers_.
pkg/cmds/sources/update.go:68:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/update.go:69:			err := next(layers_, parsedLayers)
pkg/cmds/sources/update.go:74:			return updateFromMapAsDefault(layers_, parsedLayers, m, options...)
pkg/cmds/sources/update.go:79:// FromMapAsDefaultFirst takes a map where the keys are layer slugs and the values are
pkg/cmds/sources/update.go:80:// maps of parameter name -> value. It calls next, and then merges the provided
pkg/cmds/sources/update.go:81:// values into the parsed layers if the parameter hasn't already been set, skipping any layers not present in layers_.
pkg/cmds/sources/update.go:84:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/update.go:85:			err := updateFromMapAsDefault(layers_, parsedLayers, m, options...)
pkg/cmds/sources/update.go:90:			return next(layers_, parsedLayers)
pkg/cmds/sources/update.go:96:	layers_ *schema.Schema,
pkg/cmds/sources/update.go:97:	parsedLayers *values.Values,
pkg/cmds/sources/update.go:101:		layer, ok := layers_.Get(k)
pkg/cmds/sources/update.go:106:		parsedLayer := parsedLayers.GetOrCreate(layer)
pkg/cmds/sources/update.go:107:		ps, err := layer.GetDefinitions().GatherParametersFromMap(v, true, options...)
pkg/cmds/sources/update.go:111:		_, err = parsedLayer.Parameters.Merge(ps)
pkg/cmds/sources/update.go:120:	layers_ *schema.Schema,
pkg/cmds/sources/update.go:121:	parsedLayers *values.Values,
pkg/cmds/sources/update.go:125:		layer, ok := layers_.Get(k)
pkg/cmds/sources/update.go:130:		parsedLayer := parsedLayers.GetOrCreate(layer)
pkg/cmds/sources/update.go:131:		ps, err := layer.GetDefinitions().GatherParametersFromMap(v, true, options...)
pkg/cmds/sources/update.go:135:		_, err = parsedLayer.Parameters.MergeAsDefault(ps)
pkg/cmds/sources/update.go:144:	layers_ *schema.Schema,
pkg/cmds/sources/update.go:145:	parsedLayers *values.Values,
pkg/cmds/sources/update.go:149:	err := layers_.ForEachE(func(key string, l schema.Section) error {
pkg/cmds/sources/update.go:150:		parsedLayer := parsedLayers.GetOrCreate(l)
pkg/cmds/sources/update.go:152:		layerPrefix := l.GetPrefix()
pkg/cmds/sources/update.go:154:			// Compute env key based on layer prefix + param name, hyphen->underscore, uppercase,
pkg/cmds/sources/update.go:156:			base := layerPrefix + p.Name
pkg/cmds/sources/update.go:170:				// Parse env string into the appropriate typed value using the parameter's parser.
pkg/cmds/sources/update.go:193:				pp, err := p.ParseParameter(inputs, opts...)
pkg/cmds/sources/update.go:198:				if err := parsedLayer.Parameters.UpdateWithLog(p.Name, p, pp.Value, pp.Log...); err != nil {
pkg/cmds/sources/update.go:215:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/update.go:216:			err := next(layers_, parsedLayers)
pkg/cmds/sources/update.go:221:			return updateFromEnv(layers_, parsedLayers, prefix, options...)
pkg/cmds/sources/update.go:226:func updateFromStringList(layers_ *schema.Schema, parsedLayers *values.Values, prefix string, args []string, options ...fields.ParseOption) error {
pkg/cmds/sources/update.go:227:	err := layers_.ForEachE(func(key string, l schema.Section) error {
pkg/cmds/sources/update.go:228:		parsedLayer := parsedLayers.GetOrCreate(l)
pkg/cmds/sources/update.go:235:		_, err = parsedLayer.Parameters.Merge(ps)
pkg/cmds/sources/update.go:245:		_, err = parsedLayer.Parameters.Merge(ps)
pkg/cmds/sources/update.go:262:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/update.go:263:			err := next(layers_, parsedLayers)
pkg/cmds/sources/update.go:268:			return updateFromStringList(layers_, parsedLayers, prefix, args, options...)
pkg/cmds/fields/errors.go:12:	return fmt.Sprintf("invalid value %v for parameter %s of type %s", e.Value, e.Name, e.Type)
pkg/cmds/fields/serialize.go:9:// SerializableParsedParameter represents a parsed parameter in a format suitable for
pkg/cmds/fields/serialize.go:11:type SerializableParsedParameter struct {
pkg/cmds/fields/serialize.go:16:// ToSerializableParsedParameter converts a ParsedParameter to its serializable representation
pkg/cmds/fields/serialize.go:17:func ToSerializableParsedParameter(pp *ParsedParameter) *SerializableParsedParameter {
pkg/cmds/fields/serialize.go:18:	return &SerializableParsedParameter{
pkg/cmds/fields/serialize.go:24:// SerializableParsedParameters represents a collection of parsed parameters in a format suitable
pkg/cmds/fields/serialize.go:25:// for YAML/JSON serialization, maintaining the order of parameters
pkg/cmds/fields/serialize.go:26:type SerializableParsedParameters struct {
pkg/cmds/fields/serialize.go:27:	// Using orderedmap to maintain parameter order while having name-based access
pkg/cmds/fields/serialize.go:28:	Parameters *orderedmap.OrderedMap[string, *SerializableParsedParameter] `yaml:"parameters" json:"parameters"`
pkg/cmds/fields/serialize.go:31:// ToSerializableParsedParameters converts a ParsedParameters collection to its serializable representation
pkg/cmds/fields/serialize.go:32:func ToSerializableParsedParameters(pp *ParsedParameters) *SerializableParsedParameters {
pkg/cmds/fields/serialize.go:33:	ret := &SerializableParsedParameters{
pkg/cmds/fields/serialize.go:34:		Parameters: orderedmap.New[string, *SerializableParsedParameter](),
pkg/cmds/fields/serialize.go:37:	pp.ForEach(func(key string, value *ParsedParameter) {
pkg/cmds/fields/serialize.go:38:		serialized := ToSerializableParsedParameter(value)
pkg/cmds/fields/serialize.go:39:		ret.Parameters.Set(key, serialized)
pkg/cmds/fields/serialize.go:45:// MarshalYAML implements yaml.Marshaler for SerializableParsedParameters
pkg/cmds/fields/serialize.go:46:func (spp *SerializableParsedParameters) MarshalYAML() (interface{}, error) {
pkg/cmds/fields/serialize.go:48:	m := make(map[string]*SerializableParsedParameter)
pkg/cmds/fields/serialize.go:49:	for pair := spp.Parameters.Oldest(); pair != nil; pair = pair.Next() {
pkg/cmds/fields/serialize.go:55:// MarshalJSON implements json.Marshaler for SerializableParsedParameters
pkg/cmds/fields/serialize.go:56:func (spp *SerializableParsedParameters) MarshalJSON() ([]byte, error) {
pkg/cmds/fields/serialize.go:58:	m := make(map[string]*SerializableParsedParameter)
pkg/cmds/fields/serialize.go:59:	for pair := spp.Parameters.Oldest(); pair != nil; pair = pair.Next() {
pkg/cmds/fields/parameter-type.go:49:// NeedsFileContent returns true if the parameter type is one that loads one or more files, when provided with the given
pkg/cmds/fields/parameter-type.go:71:// NeedsMultipleFileContent returns true if the parameter type is one that loads multiple files.
pkg/cmds/fields/parameter-type.go:98:// IsList returns true if the parameter has to be parsed from a list of strings,
pkg/cmds/sources/middlewares_test.go:21:	ParameterLayers []helpers.TestParameterLayer `yaml:"parameterLayers"`
pkg/cmds/sources/middlewares_test.go:22:	Values          []helpers.TestSectionValues  `yaml:"parsedLayers"`
pkg/cmds/sources/middlewares_test.go:23:	ExpectedLayers  []helpers.TestExpectedLayer  `yaml:"expectedLayers"`
pkg/cmds/sources/middlewares_test.go:40:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)
pkg/cmds/sources/middlewares_test.go:41:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)
pkg/cmds/sources/middlewares_test.go:44:			err := middleware(func(layers *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/middlewares_test.go:46:			})(layers_, parsedLayers)
pkg/cmds/sources/middlewares_test.go:53:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)
pkg/cmds/sources/middlewares_test.go:73:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)
pkg/cmds/sources/middlewares_test.go:74:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)
pkg/cmds/sources/middlewares_test.go:77:				layers_, parsedLayers,
pkg/cmds/sources/middlewares_test.go:85:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)
pkg/cmds/sources/middlewares_test.go:100:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)
pkg/cmds/sources/middlewares_test.go:101:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)
pkg/cmds/sources/middlewares_test.go:104:				layers_, parsedLayers,
pkg/cmds/sources/middlewares_test.go:112:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)
pkg/cmds/sources/middlewares_test.go:132:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)
pkg/cmds/sources/middlewares_test.go:133:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)
pkg/cmds/sources/middlewares_test.go:142:				layers_, parsedLayers,
pkg/cmds/sources/middlewares_test.go:155:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)
pkg/cmds/sources/middlewares_test.go:161://go:embed tests/wrap-with-restricted-layers.yaml
pkg/cmds/sources/middlewares_test.go:162:var wrapWithRestrictedLayersTestsYAML string
pkg/cmds/sources/middlewares_test.go:164:type wrapWithRestrictedLayersTest struct {
pkg/cmds/sources/middlewares_test.go:174:func TestWrapWithRestrictedLayers(t *testing.T) {
pkg/cmds/sources/middlewares_test.go:175:	tests, err := yaml.LoadTestFromYAML[[]wrapWithRestrictedLayersTest](wrapWithRestrictedLayersTestsYAML)
pkg/cmds/sources/middlewares_test.go:180:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)
pkg/cmds/sources/middlewares_test.go:181:			parsedLayers := values.New()
pkg/cmds/sources/middlewares_test.go:189:				ms_ = append(ms_, sources.WrapWithBlacklistedLayers(tt.BlacklistedSlugs,
pkg/cmds/sources/middlewares_test.go:193:				ms_ = append(ms_, sources.WrapWithWhitelistedLayers(tt.WhitelistedSlugs,
pkg/cmds/sources/middlewares_test.go:201:				layers_, parsedLayers,
pkg/cmds/sources/middlewares_test.go:210:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)
pkg/cmds/sources/middlewares_test.go:230:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)
pkg/cmds/sources/middlewares_test.go:231:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)
pkg/cmds/sources/middlewares_test.go:236:			err = sources.Execute(layers_, parsedLayers, middlewares_...)
pkg/cmds/sources/middlewares_test.go:244:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)
pkg/help/help.go:474:		fmt.Printf("Parameters: %v\n", args)
pkg/cmds/fields/parsed-parameter.go:11:type ParsedParameter struct {
pkg/cmds/fields/parsed-parameter.go:54:// Update sets the value of the parsedParameter, and appends a new parseStep.
pkg/cmds/fields/parsed-parameter.go:55:func (p *ParsedParameter) Update(value interface{}, options ...ParseOption) error {
pkg/cmds/fields/parsed-parameter.go:73:func (p *ParsedParameter) RenderValue() (string, error) {
pkg/cmds/fields/parsed-parameter.go:77:// UpdateWithLog sets the value of the parsedParameter, and appends the given log.
pkg/cmds/fields/parsed-parameter.go:78:func (p *ParsedParameter) UpdateWithLog(value interface{}, log ...ParseStep) error {
pkg/cmds/fields/parsed-parameter.go:89:// Set sets the value of the parsedParameter, and manually updates the log
pkg/cmds/fields/parsed-parameter.go:90:func (p *ParsedParameter) Set(value interface{}, log ...ParseStep) {
pkg/cmds/fields/parsed-parameter.go:100:func (p *ParsedParameter) Merge(v *ParsedParameter, options ...ParseOption) {
pkg/cmds/fields/parsed-parameter.go:107:func (p *ParsedParameter) Clone() *ParsedParameter {
pkg/cmds/fields/parsed-parameter.go:108:	ret := &ParsedParameter{
pkg/cmds/fields/parsed-parameter.go:117:// GetInterfaceValue returns the value as an interface{}. If the type of the parameter is a list,
pkg/cmds/fields/parsed-parameter.go:120:func (p *ParsedParameter) GetInterfaceValue() (interface{}, error) {
pkg/cmds/fields/parsed-parameter.go:121:	parameterType := p.Definition.Type
pkg/cmds/fields/parsed-parameter.go:123:	case parameterType.IsList():
pkg/cmds/fields/parsed-parameter.go:130:	case parameterType.IsObject(),
pkg/cmds/fields/parsed-parameter.go:131:		parameterType.IsKeyValue():
pkg/cmds/fields/parsed-parameter.go:134:	case parameterType.IsObjectList():
pkg/cmds/fields/parsed-parameter.go:155:type ParsedParameters struct {
pkg/cmds/fields/parsed-parameter.go:156:	*orderedmap.OrderedMap[string, *ParsedParameter]
pkg/cmds/fields/parsed-parameter.go:159:type ParsedParametersOption func(*ParsedParameters)
pkg/cmds/fields/parsed-parameter.go:161:func WithParsedParameter(pd *Definition, key string, value interface{}) ParsedParametersOption {
pkg/cmds/fields/parsed-parameter.go:162:	return func(p *ParsedParameters) {
pkg/cmds/fields/parsed-parameter.go:163:		p.Set(key, &ParsedParameter{
pkg/cmds/fields/parsed-parameter.go:170:func NewParsedParameters(options ...ParsedParametersOption) *ParsedParameters {
pkg/cmds/fields/parsed-parameter.go:171:	ret := &ParsedParameters{
pkg/cmds/fields/parsed-parameter.go:172:		OrderedMap: orderedmap.New[string, *ParsedParameter](),
pkg/cmds/fields/parsed-parameter.go:180:func (p *ParsedParameters) GetValue(key string) interface{} {
pkg/cmds/fields/parsed-parameter.go:188:func (p *ParsedParameters) Clone() *ParsedParameters {
pkg/cmds/fields/parsed-parameter.go:189:	ret := NewParsedParameters()
pkg/cmds/fields/parsed-parameter.go:190:	p.ForEach(func(k string, v *ParsedParameter) {
pkg/cmds/fields/parsed-parameter.go:196:// UpdateExistingValue updates the value of an existing parameter, and returns true if the parameter existed.
pkg/cmds/fields/parsed-parameter.go:197:// If the parameter did not exist, it returns false.
pkg/cmds/fields/parsed-parameter.go:198:func (p *ParsedParameters) UpdateExistingValue(
pkg/cmds/fields/parsed-parameter.go:213:func (p *ParsedParameters) Update(
pkg/cmds/fields/parsed-parameter.go:214:	key string, pp *ParsedParameter,
pkg/cmds/fields/parsed-parameter.go:225:func (p *ParsedParameters) UpdateValue(
pkg/cmds/fields/parsed-parameter.go:233:		v_ = &ParsedParameter{
pkg/cmds/fields/parsed-parameter.go:245:func (p *ParsedParameters) MustUpdateValue(
pkg/cmds/fields/parsed-parameter.go:252:		return errors.Errorf("parameter %s not found", key)
pkg/cmds/fields/parsed-parameter.go:261:func (p *ParsedParameters) UpdateWithLog(
pkg/cmds/fields/parsed-parameter.go:268:		v_ = &ParsedParameter{
pkg/cmds/fields/parsed-parameter.go:280:// SetAsDefault sets the current value of the parameter if no value has yet been set.
pkg/cmds/fields/parsed-parameter.go:281:func (p *ParsedParameters) SetAsDefault(
pkg/cmds/fields/parsed-parameter.go:295:// in ParsedParameters.
pkg/cmds/fields/parsed-parameter.go:296:func (p *ParsedParameters) ForEach(f func(key string, value *ParsedParameter)) {
pkg/cmds/fields/parsed-parameter.go:303:// ParsedParameters. It stops at, and returns, the first error encountered.
pkg/cmds/fields/parsed-parameter.go:304:func (p *ParsedParameters) ForEachE(f func(key string, value *ParsedParameter) error) error {
pkg/cmds/fields/parsed-parameter.go:316:// we actually merge the ParsedParameter themselves, by appending the entire history of the other parameter to the
pkg/cmds/fields/parsed-parameter.go:318:func (p *ParsedParameters) Merge(other *ParsedParameters) (*ParsedParameters, error) {
pkg/cmds/fields/parsed-parameter.go:319:	err := other.ForEachE(func(k string, v *ParsedParameter) error {
pkg/cmds/fields/parsed-parameter.go:333:func (p *ParsedParameters) MergeAsDefault(other *ParsedParameters, options ...ParseOption) (*ParsedParameters, error) {
pkg/cmds/fields/parsed-parameter.go:334:	err := other.ForEachE(func(k string, v *ParsedParameter) error {
pkg/cmds/fields/parsed-parameter.go:347:// ToMap converts ParsedParameters to map[string]interface{} by assigning each ParsedParameter's value to its key.
pkg/cmds/fields/parsed-parameter.go:348:func (p *ParsedParameters) ToMap() map[string]interface{} {
pkg/cmds/fields/parsed-parameter.go:350:	p.ForEach(func(k string, v *ParsedParameter) {
pkg/cmds/fields/parsed-parameter.go:356:// ToInterfaceMap converts ParsedParameters to map[string]interface{} by converting each ParsedParameter's value to interface{}.
pkg/cmds/fields/parsed-parameter.go:357:// It returns an error if it fails to convert any ParsedParameter's value.
pkg/cmds/fields/parsed-parameter.go:358:func (p *ParsedParameters) ToInterfaceMap() (map[string]interface{}, error) {
pkg/cmds/fields/parsed-parameter.go:360:	err := p.ForEachE(func(k string, v *ParsedParameter) error {
pkg/cmds/fields/parsed-parameter.go:374:// MarshalYAML implements yaml.Marshaler for ParsedParameters
pkg/cmds/fields/parsed-parameter.go:375:func (p *ParsedParameters) MarshalYAML() (interface{}, error) {
pkg/cmds/fields/parsed-parameter.go:376:	return ToSerializableParsedParameters(p), nil
pkg/cmds/fields/parsed-parameter.go:379:// MarshalJSON implements json.Marshaler for ParsedParameters
pkg/cmds/fields/parsed-parameter.go:380:func (p *ParsedParameters) MarshalJSON() ([]byte, error) {
pkg/cmds/fields/parsed-parameter.go:381:	return json.Marshal(ToSerializableParsedParameters(p))
pkg/cmds/fields/gather-parameters.go:9:// GatherParametersFromMap gathers parameter values from a map.
pkg/cmds/fields/gather-parameters.go:13:// - If the parameter is missing and required, an error is returned.
pkg/cmds/fields/gather-parameters.go:14:// - If the parameter is missing and optional, the default value is used.
pkg/cmds/fields/gather-parameters.go:17:// Values are looked up by parameter name, as well as short flag if provided.
pkg/cmds/fields/gather-parameters.go:19:// The returned map contains the gathered parameter values, with defaults filled in
pkg/cmds/fields/gather-parameters.go:21:func (pds *Definitions) GatherParametersFromMap(
pkg/cmds/fields/gather-parameters.go:25:) (*ParsedParameters, error) {
pkg/cmds/fields/gather-parameters.go:26:	ret := NewParsedParameters()
pkg/cmds/fields/gather-parameters.go:29:		parsed := &ParsedParameter{
pkg/cmds/fields/gather-parameters.go:52:					return errors.Errorf("Missing required parameter %s", p.Name)
pkg/cmds/fields/gather-parameters.go:62:			v__, err := p.ParseParameter([]string{s})
pkg/cmds/fields/gather-parameters.go:64:				return errors.Wrapf(err, "Invalid value for parameter %s", p.Name)
pkg/cmds/fields/gather-parameters.go:72:			return errors.Wrapf(err, "Invalid value for parameter %s", p.Name)
pkg/cmds/helpers/test-helpers.go:17:// Package parameters provides structures and helper functions required for
pkg/cmds/helpers/test-helpers.go:32:// 3. Use the New* functions to convert the data loaded from YAML into appropriate form for the glazed library (typically, Values, ParsedDefinitions, ParameterLayers)
pkg/cmds/helpers/test-helpers.go:42:// - name: "Empty layers and parsedLayers"
pkg/cmds/helpers/test-helpers.go:43://  parameterLayers: []
pkg/cmds/helpers/test-helpers.go:44://  parsedLayers: []
pkg/cmds/helpers/test-helpers.go:45://  expectedLayers: []
pkg/cmds/helpers/test-helpers.go:48://- name: "Single layer with default"
pkg/cmds/helpers/test-helpers.go:49://  parameterLayers:
pkg/cmds/helpers/test-helpers.go:50://    - name: "layer1"
pkg/cmds/helpers/test-helpers.go:55://  parsedLayers:
pkg/cmds/helpers/test-helpers.go:56://    - name: "layer1"
pkg/cmds/helpers/test-helpers.go:57://  expectedLayers:
pkg/cmds/helpers/test-helpers.go:58://    - name: "layer1"
pkg/cmds/helpers/test-helpers.go:63://- name: "Multiple layers with defaults"
pkg/cmds/helpers/test-helpers.go:64://  parameterLayers:
pkg/cmds/helpers/test-helpers.go:65://    - name: "layer1"
pkg/cmds/helpers/test-helpers.go:73://    - name: "layer2"
pkg/cmds/helpers/test-helpers.go:78://  parsedLayers:
pkg/cmds/helpers/test-helpers.go:79://    - name: "layer1"
pkg/cmds/helpers/test-helpers.go:80://		parameters:
pkg/cmds/helpers/test-helpers.go:83://    - name: "layer2"
pkg/cmds/helpers/test-helpers.go:84://  expectedLayers:
pkg/cmds/helpers/test-helpers.go:85://    - name: "layer1"
pkg/cmds/helpers/test-helpers.go:89://    - name: "layer2"
pkg/cmds/helpers/test-helpers.go:99:// 	parameterLayers []fields.TestParameterLayer
pkg/cmds/helpers/test-helpers.go:100:// 	parsedLayers    []fields.TestSectionValues
pkg/cmds/helpers/test-helpers.go:101:// 	expectedLayers  []fields.TestExpectedLayer
pkg/cmds/helpers/test-helpers.go:110:// 			layers_ := fields.NewTestParameterLayers(tt.parameterLayers)
pkg/cmds/helpers/test-helpers.go:111:// 			parsedLayers := fields.NewTestValues(layers_, tt.parsedLayers)
pkg/cmds/helpers/test-helpers.go:120:// 			for _, l_ := range tt.expectedLayers {
pkg/cmds/helpers/test-helpers.go:121:// 				l, ok := parsedLayers.Get(l_.Name)
pkg/cmds/helpers/test-helpers.go:124:// 				actual := l.Parameters.ToMap()
pkg/cmds/helpers/test-helpers.go:131:type TestParameterLayer struct {
pkg/cmds/helpers/test-helpers.go:137:type TestParsedParameter struct {
pkg/cmds/helpers/test-helpers.go:144:	Parameters []TestParsedParameter `yaml:"parameters"`
pkg/cmds/helpers/test-helpers.go:147:type TestExpectedLayer struct {
pkg/cmds/helpers/test-helpers.go:159:const TestWhitelistLayers = "whitelistLayers"
pkg/cmds/helpers/test-helpers.go:160:const TestWhitelistLayersFirst = "whitelistLayersFirst"
pkg/cmds/helpers/test-helpers.go:161:const TestWhitelistLayerParameters = "whitelistLayerParameters"
pkg/cmds/helpers/test-helpers.go:162:const TestWhitelistLayerParametersFirst = "whitelistLayerParametersFirst"
pkg/cmds/helpers/test-helpers.go:163:const TestBlacklistLayers = "blacklistLayers"
pkg/cmds/helpers/test-helpers.go:164:const TestBlacklistLayersFirst = "blacklistLayersFirst"
pkg/cmds/helpers/test-helpers.go:165:const TestBlacklistLayerParameters = "blacklistLayerParameters"
pkg/cmds/helpers/test-helpers.go:166:const TestBlacklistLayerParametersFirst = "blacklistLayerParametersFirst"
pkg/cmds/helpers/test-helpers.go:184:	Layers     *[]string                          `yaml:"layers"`
pkg/cmds/helpers/test-helpers.go:185:	Parameters *map[string][]string               `yaml:"parameters"`
pkg/cmds/helpers/test-helpers.go:216:		case TestWhitelistLayers:
pkg/cmds/helpers/test-helpers.go:217:			ret = append(ret, sources.WhitelistLayers(*m.Layers))
pkg/cmds/helpers/test-helpers.go:218:		case TestWhitelistLayersFirst:
pkg/cmds/helpers/test-helpers.go:219:			ret = append(ret, sources.WhitelistLayersFirst(*m.Layers))
pkg/cmds/helpers/test-helpers.go:220:		case TestWhitelistLayerParameters:
pkg/cmds/helpers/test-helpers.go:221:			ret = append(ret, sources.WhitelistLayerParameters(*m.Parameters))
pkg/cmds/helpers/test-helpers.go:222:		case TestWhitelistLayerParametersFirst:
pkg/cmds/helpers/test-helpers.go:223:			ret = append(ret, sources.WhitelistLayerParametersFirst(*m.Parameters))
pkg/cmds/helpers/test-helpers.go:224:		case TestBlacklistLayers:
pkg/cmds/helpers/test-helpers.go:225:			ret = append(ret, sources.BlacklistLayers(*m.Layers))
pkg/cmds/helpers/test-helpers.go:226:		case TestBlacklistLayersFirst:
pkg/cmds/helpers/test-helpers.go:227:			ret = append(ret, sources.BlacklistLayersFirst(*m.Layers))
pkg/cmds/helpers/test-helpers.go:228:		case TestBlacklistLayerParameters:
pkg/cmds/helpers/test-helpers.go:229:			ret = append(ret, sources.BlacklistLayerParameters(*m.Parameters))
pkg/cmds/helpers/test-helpers.go:230:		case TestBlacklistLayerParametersFirst:
pkg/cmds/helpers/test-helpers.go:231:			ret = append(ret, sources.BlacklistLayerParametersFirst(*m.Parameters))
pkg/cmds/helpers/test-helpers.go:240:// NewTestParameterLayer is a helper function to create a ParameterLayer from parameterDefinition
pkg/cmds/helpers/test-helpers.go:241:func NewTestParameterLayer(l TestParameterLayer) schema.Section {
pkg/cmds/helpers/test-helpers.go:253:func NewTestParameterLayers(ls []TestParameterLayer) *schema.Schema {
pkg/cmds/helpers/test-helpers.go:256:		ret.Set(l.Name, NewTestParameterLayer(l))
pkg/cmds/helpers/test-helpers.go:261:// NewTestSectionValues helper function to create a Values from TestParsedParameter
pkg/cmds/helpers/test-helpers.go:263:	params_ := fields.NewParsedParameters()
pkg/cmds/helpers/test-helpers.go:265:	for _, p := range l.Parameters {
pkg/cmds/helpers/test-helpers.go:268:			panic("parameter definition not found")
pkg/cmds/helpers/test-helpers.go:276:	ret, err := values.NewSectionValues(pl, values.WithParameters(params_))
pkg/cmds/helpers/test-helpers.go:289:			panic("parameter layer not found")
pkg/cmds/helpers/test-helpers.go:307:func TestExpectedOutputs(t *testing.T, expectedLayers []TestExpectedLayer, parsedLayers *values.Values) {
pkg/cmds/helpers/test-helpers.go:308:	expectedLayers_ := map[string]TestExpectedLayer{}
pkg/cmds/helpers/test-helpers.go:309:	for _, l_ := range expectedLayers {
pkg/cmds/helpers/test-helpers.go:310:		expectedLayers_[l_.Name] = l_
pkg/cmds/helpers/test-helpers.go:311:		l, ok := parsedLayers.Get(l_.Name)
pkg/cmds/helpers/test-helpers.go:314:		actual, err := l.Parameters.ToInterfaceMap()
pkg/cmds/helpers/test-helpers.go:323:			actual, ok := l.Parameters.Get(k)
pkg/cmds/helpers/test-helpers.go:336:	parsedLayers.ForEach(func(key string, l *values.SectionValues) {
pkg/cmds/helpers/test-helpers.go:337:		if _, ok := expectedLayers_[key]; !ok {
pkg/cmds/helpers/test-helpers.go:338:			t.Errorf("did not expect layer %s to be present", key)
pkg/doc/topics/12-profiles-use-code.md:30:Profile middleware in Pinocchio is responsible for loading and applying configuration parameters from a specified
pkg/doc/topics/12-profiles-use-code.md:46:	parsedCommandLayers *values.Values,
pkg/doc/topics/12-profiles-use-code.md:71:For advanced use cases, combine profile middleware with additional config files using `LoadParametersFromFile` or `LoadParametersFromFiles`:
pkg/doc/topics/12-profiles-use-code.md:122:The middleware will then load the configuration parameters from the `development` profile and apply them to the command.
pkg/cmds/sources/load-parameters-from-json.go:15:// into the standard layer map format: map[layerSlug]map[parameterName]value.
pkg/cmds/sources/load-parameters-from-json.go:17:// The output should map layer slugs to parameter name/value pairs.
pkg/cmds/sources/load-parameters-from-json.go:23:// FromFile loads parameter definitions from a JSON or YAML file and applies them to the parameter layers.
pkg/cmds/sources/load-parameters-from-json.go:26://	layer-slug:
pkg/cmds/sources/load-parameters-from-json.go:27://	  parameter-name: value
pkg/cmds/sources/load-parameters-from-json.go:32:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/load-parameters-from-json.go:33:			err := next(layers_, parsedLayers)
pkg/cmds/sources/load-parameters-from-json.go:43:			m, err := readConfigFileToLayerMap(filename, opts.Mapper)
pkg/cmds/sources/load-parameters-from-json.go:47:			return updateFromMap(layers_, parsedLayers, m, opts.ParseOptions...)
pkg/cmds/sources/load-parameters-from-json.go:57:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/load-parameters-from-json.go:58:			if err := next(layers_, parsedLayers); err != nil {
pkg/cmds/sources/load-parameters-from-json.go:66:				m, err := readConfigFileToLayerMap(f, opts.Mapper)
pkg/cmds/sources/load-parameters-from-json.go:77:				if err := updateFromMap(layers_, parsedLayers, m, parseOpts...); err != nil {
pkg/cmds/sources/load-parameters-from-json.go:95:// into the standard layer map format. If not provided, the default behavior expects:
pkg/cmds/sources/load-parameters-from-json.go:97://	layer-slug:
pkg/cmds/sources/load-parameters-from-json.go:98://	  parameter-name: value
pkg/cmds/sources/load-parameters-from-json.go:108:// config file structures into the standard layer map format.
pkg/cmds/sources/load-parameters-from-json.go:116:// WithParseOptions adds parse step options that will be applied when loading parameters from the config file.
pkg/cmds/sources/load-parameters-from-json.go:123:func readConfigFileToLayerMap(filename string, mapper ConfigMapper) (map[string]map[string]interface{}, error) {
pkg/cmds/sources/load-parameters-from-json.go:151:	// Default behavior: expect the standard layer map structure
pkg/cmds/sources/load-parameters-from-json.go:154:		for layerSlug, layerData := range m {
pkg/cmds/sources/load-parameters-from-json.go:155:			if layerMap, ok := layerData.(map[string]interface{}); ok {
pkg/cmds/sources/load-parameters-from-json.go:156:				result[layerSlug] = layerMap
pkg/cmds/sources/load-parameters-from-json.go:158:				return nil, errors.Errorf("expected map[string]interface{} for layer %s, got %T", layerSlug, layerData)
pkg/doc/topics/09-gather-flags-from-string-list.md:25:	params []*ParameterDefinition,
pkg/doc/topics/09-gather-flags-from-string-list.md:32:## Parameters
pkg/doc/topics/09-gather-flags-from-string-list.md:35:- `params`: a slice of `*ParameterDefinition` representing the parameter definitions.
pkg/doc/topics/09-gather-flags-from-string-list.md:42:The function returns a map where the keys are the parameter names and the values are the parsed values. If a flag is not recognized or its value cannot be parsed, an error is returned.
pkg/doc/topics/09-gather-flags-from-string-list.md:49:params := []*ParameterDefinition{
pkg/doc/topics/09-gather-flags-from-string-list.md:50:   {Name: "verbose", ShortFlag: "v", Type: ParameterTypeBool},
pkg/doc/topics/09-gather-flags-from-string-list.md:51:   {Name: "output", ShortFlag: "o", Type: ParameterTypeString},
pkg/doc/topics/09-gather-flags-from-string-list.md:64:In this example, the function parses the `--verbose` and `-o` flags according to the provided parameter definitions. The `--verbose` flag is a boolean flag and is set to "true". The `-o` flag is a string flag and its value is "file.txt".
pkg/doc/topics/logging-layer.md:2:Title: Logging Layer API Reference
pkg/doc/topics/logging-layer.md:3:Slug: logging-layer-reference
pkg/doc/topics/logging-layer.md:16:# Logging Layer API Reference
pkg/doc/topics/logging-layer.md:20:The Glazed logging layer provides comprehensive logging configuration for CLI applications through command-line parameters, environment variables, and configuration files. The layer handles setup for console output, file logging, and centralized log aggregation while supporting multiple output formats and verbosity levels.
pkg/doc/topics/logging-layer.md:33:    A[CLI Parameters] --> B[Logging Layer]
pkg/doc/topics/logging-layer.md:43:The logging layer transforms command-line parameters into configured log outputs, supporting development, testing, and production deployment scenarios.
pkg/doc/topics/logging-layer.md:49:Add the logging layer to any Glazed command:
pkg/doc/topics/logging-layer.md:58:    loggingLayer, err := logging.NewLoggingLayer()
pkg/doc/topics/logging-layer.md:60:        return nil, fmt.Errorf("failed to create logging layer: %w", err)
pkg/doc/topics/logging-layer.md:66:        cmds.WithLayersList(loggingLayer),
pkg/doc/topics/logging-layer.md:74:    parsedLayers *values.Values,
pkg/doc/topics/logging-layer.md:77:    // Initialize logging settings from parsed layers
pkg/doc/topics/logging-layer.md:79:    if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {
pkg/doc/topics/logging-layer.md:149:## Configuration Parameters
pkg/doc/topics/logging-layer.md:153:| Parameter | Type | Default | Description |
pkg/doc/topics/logging-layer.md:262:To initialize logging from parsed layers, use the standard pattern:
pkg/doc/topics/logging-layer.md:265:// Extract logging settings from parsed layers
pkg/doc/topics/logging-layer.md:267:if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {
pkg/doc/topics/logging-layer.md:298:if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {
pkg/doc/topics/logging-layer.md:310:#### NewLoggingLayer
pkg/doc/topics/logging-layer.md:313:func NewLoggingLayer() (schema.Section, error)
pkg/doc/topics/logging-layer.md:316:Creates parameter layer for command definitions.
pkg/doc/topics/logging-layer.md:320:loggingLayer, err := logging.NewLoggingLayer()
pkg/doc/topics/logging-layer.md:327:    cmds.WithLayersList(loggingLayer),
pkg/doc/topics/logging-layer.md:389:   parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings)
pkg/doc/topics/logging-layer.md:416:- [Custom Layer Tutorial](../tutorials/custom-layer.md): Creating custom parameter layers
pkg/doc/topics/logging-layer.md:417:- [Layers Guide](../topics/layers-guide.md): Parameter layer system overview
pkg/doc/topics/22-command-loaders.md:146:	"github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/22-command-loaders.md:244:	// Add other options like WithLong, WithArguments, WithLayers etc. as needed
pkg/doc/topics/22-command-loaders.md:259:func (msc *MySpecificCommand) Run(ctx context.Context, parsedLayers *values.Values) error { /* ... */}
pkg/doc/topics/22-command-loaders.md:274:-   **`SqlCommandLoader` (`github.com/go-go-golems/sqleton/pkg/cmds`)**: Loads SQL execution commands for the `sqleton` tool from YAML files containing SQL queries and parameter definitions. Uses `loaders.CheckYamlFileType(f, fileName, "sqleton")` in `IsFileSupported`.
pkg/doc/topics/using-the-query-api.md:37:The query system consists of several layered components:
pkg/doc/topics/using-the-query-api.md:57:├── dsl_bridge.go          # Integration layer
pkg/doc/topics/using-the-query-api.md:206:fmt.Printf("Parameters: %v\n", debugInfo.Parameters)
pkg/doc/topics/using-the-query-api.md:569:            http.Error(w, "Missing query parameter", http.StatusBadRequest)
pkg/cmds/fields/parameters_from_defaults_test.go:12:func TestParsedParametersFromDefaults_BasicTypes(t *testing.T) {
pkg/cmds/fields/parameters_from_defaults_test.go:15:		parameterDefinitions *Definitions
pkg/cmds/fields/parameters_from_defaults_test.go:21:			parameterDefinitions: NewDefinitions(
pkg/cmds/fields/parameters_from_defaults_test.go:61:			parameterDefinitions: NewDefinitions(
pkg/cmds/fields/parameters_from_defaults_test.go:83:			result, err := tt.parameterDefinitions.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters_from_defaults_test.go:94:				assert.True(t, ok, "parameter %s should exist", paramName)
pkg/cmds/fields/parameters_from_defaults_test.go:95:				assert.Equal(t, expectedValue, param.Value, "parameter %s should have correct value", paramName)
pkg/cmds/fields/parameters_from_defaults_test.go:98:			// Special check for date parameter in the first test case
pkg/cmds/fields/parameters_from_defaults_test.go:101:				assert.True(t, ok, "date parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:103:				assert.True(t, ok, "date parameter should be time.Time")
pkg/cmds/fields/parameters_from_defaults_test.go:111:func TestParsedParametersFromDefaults_EdgeCases(t *testing.T) {
pkg/cmds/fields/parameters_from_defaults_test.go:114:		parameterDefinitions *Definitions
pkg/cmds/fields/parameters_from_defaults_test.go:119:			name:                 "empty parameter definitions",
pkg/cmds/fields/parameters_from_defaults_test.go:120:			parameterDefinitions: NewDefinitions(),
pkg/cmds/fields/parameters_from_defaults_test.go:125:			parameterDefinitions: NewDefinitions(
pkg/cmds/fields/parameters_from_defaults_test.go:143:			parameterDefinitions: NewDefinitions(
pkg/cmds/fields/parameters_from_defaults_test.go:172:			result, err := tt.parameterDefinitions.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters_from_defaults_test.go:180:			// Check that we have exactly the expected number of parameters
pkg/cmds/fields/parameters_from_defaults_test.go:182:				"number of parameters should match expected")
pkg/cmds/fields/parameters_from_defaults_test.go:187:				assert.True(t, ok, "parameter %s should exist", paramName)
pkg/cmds/fields/parameters_from_defaults_test.go:188:				assert.Equal(t, expectedValue, param.Value, "parameter %s should have correct value", paramName)
pkg/cmds/fields/parameters_from_defaults_test.go:194:func TestParsedParametersFromDefaults_ListTypes(t *testing.T) {
pkg/cmds/fields/parameters_from_defaults_test.go:221:	result, err := pd.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters_from_defaults_test.go:227:	assert.True(t, ok, "string-list parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:232:	assert.True(t, ok, "integer-list parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:237:	assert.True(t, ok, "choice-list parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:242:	assert.True(t, ok, "float-list parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:246:func TestParsedParametersFromDefaults_MapTypes(t *testing.T) {
pkg/cmds/fields/parameters_from_defaults_test.go:262:	result, err := pd.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters_from_defaults_test.go:268:	assert.True(t, ok, "key-value parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:273:	assert.True(t, ok, "object-from-file parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:277:func TestParsedParametersFromDefaults_FileLoadingTypes(t *testing.T) {
pkg/cmds/fields/parameters_from_defaults_test.go:296:	result, err := pd.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters_from_defaults_test.go:302:	assert.True(t, ok, "string-list-from-file parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:307:	assert.True(t, ok, "object-list-from-file parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:314:func TestParsedParametersFromDefaults_EmptyCollections(t *testing.T) {
pkg/cmds/fields/parameters_from_defaults_test.go:335:	result, err := pd.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters_from_defaults_test.go:341:	assert.True(t, ok, "empty-string-list parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:346:	assert.True(t, ok, "empty-key-value parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:351:	assert.True(t, ok, "empty-object parameter should exist")
pkg/cmds/fields/parameters_from_defaults_test.go:355:func TestParsedParametersFromDefaults_NilComplexTypes(t *testing.T) {
pkg/cmds/fields/parameters_from_defaults_test.go:417:	result, err := pd.ParsedParametersFromDefaults()
pkg/cmds/fields/parameters_from_defaults_test.go:421:	// All parameters should be excluded since they have nil defaults
pkg/cmds/fields/parameters_from_defaults_test.go:422:	assert.Equal(t, 0, result.Len(), "no parameters should be included")
pkg/cmds/fields/parameters_from_defaults_test.go:424:	// Verify each parameter is not present
pkg/cmds/fields/parameters_from_defaults_test.go:434:		assert.False(t, ok, "parameter %s should not exist", name)
pkg/cmds/cmds.go:26:	Layers         *schema.Schema         `yaml:"layers,omitempty"`
pkg/cmds/cmds.go:77:func WithLayersList(ls ...schema.Section) CommandDescriptionOption {
pkg/cmds/cmds.go:80:			c.Layers.Set(l.GetSlug(), l)
pkg/cmds/cmds.go:85:func WithLayers(ls *schema.Schema) CommandDescriptionOption {
pkg/cmds/cmds.go:87:		c.Layers.Merge(ls)
pkg/cmds/cmds.go:91:// WithSchema is an alias for WithLayers that accepts a schema.Schema.
pkg/cmds/cmds.go:94:	return WithLayers((*schema.Schema)(s))
pkg/cmds/cmds.go:97:// WithLayersMap registers layers using explicit slugs from the provided map.
pkg/cmds/cmds.go:98:// The map key is used as the registration slug. If a layer's internal slug
pkg/cmds/cmds.go:102://   - Prefer cloning the layer and overriding the slug on the clone when the
pkg/cmds/cmds.go:105://   - Otherwise, the layer is registered under the provided key as-is.
pkg/cmds/cmds.go:108:// from its internal slug, middlewares that derive parsed layer slugs from the
pkg/cmds/cmds.go:109:// layer's GetSlug() may use the internal slug instead of the registration key.
pkg/cmds/cmds.go:112:func WithLayersMap(m map[string]schema.Section) CommandDescriptionOption {
pkg/cmds/cmds.go:116:				// Try a generic clone: many wrapper types embed ParameterLayerImpl,
pkg/cmds/cmds.go:117:				// whose Clone returns *ParameterLayerImpl. If so, set the slug.
pkg/cmds/cmds.go:121:					c.Layers.Set(slug, impl)
pkg/cmds/cmds.go:122:					log.Debug().Str("slug", slug).Str("internalSlug", l.GetSlug()).Msg("WithLayersMap: cloned layer and set overridden slug")
pkg/cmds/cmds.go:125:				// Fallback: keep original layer but register under provided key.
pkg/cmds/cmds.go:126:				// Parsed layers may still use the internal slug when indexing.
pkg/cmds/cmds.go:127:				log.Warn().Str("slug", slug).Str("internalSlug", l.GetSlug()).Msg("WithLayersMap: registering layer with mismatched internal slug; parsed layers may use internal slug")
pkg/cmds/cmds.go:129:			c.Layers.Set(slug, l)
pkg/cmds/cmds.go:134:// WithFlags is a convenience function to add arguments to the default layer, useful
pkg/cmds/cmds.go:135:// to make the transition from explicit flags and arguments to a default layer a bit easier.
pkg/cmds/cmds.go:140:		layer, ok := c.GetDefaultLayer()
pkg/cmds/cmds.go:143:			layer, err = schema.NewSection(schema.DefaultSlug, "Flags")
pkg/cmds/cmds.go:147:			c.Layers.Set(layer.GetSlug(), layer)
pkg/cmds/cmds.go:148:			err = c.Layers.MoveToFront(layer.GetSlug())
pkg/cmds/cmds.go:153:		layer.AddFields(flags...)
pkg/cmds/cmds.go:157:// WithArguments is a convenience function to add arguments to the default layer, useful
pkg/cmds/cmds.go:158:// to make the transition from explicit flags and arguments to a default layer a bit easier.
pkg/cmds/cmds.go:163:		layer, ok := c.GetDefaultLayer()
pkg/cmds/cmds.go:166:			layer, err = schema.NewSection(schema.DefaultSlug, "Arguments")
pkg/cmds/cmds.go:170:			c.Layers.Set(layer.GetSlug(), layer)
pkg/cmds/cmds.go:171:			err = c.Layers.MoveToFront(layer.GetSlug())
pkg/cmds/cmds.go:180:		layer.AddFields(arguments...)
pkg/cmds/cmds.go:190:func WithReplaceLayers(layers_ ...schema.Section) CommandDescriptionOption {
pkg/cmds/cmds.go:192:		for _, l := range layers_ {
pkg/cmds/cmds.go:193:			c.Layers.Set(l.GetSlug(), l)
pkg/cmds/cmds.go:231:		Layers: schema.NewSchema(),
pkg/cmds/cmds.go:254:func (cd *CommandDescription) GetDefaultLayer() (schema.Section, bool) {
pkg/cmds/cmds.go:255:	return cd.GetLayer(schema.DefaultSlug)
pkg/cmds/cmds.go:259:	l, ok := cd.GetDefaultLayer()
pkg/cmds/cmds.go:267:	l, ok := cd.GetDefaultLayer()
pkg/cmds/cmds.go:275:// GetDefaultsMap returns a map of parameter names to their default values
pkg/cmds/cmds.go:281:	params, err := flags.ParsedParametersFromDefaults()
pkg/cmds/cmds.go:286:	argsParams, err := arguments.ParsedParametersFromDefaults()
pkg/cmds/cmds.go:299:func (cd *CommandDescription) GetLayer(name string) (schema.Section, bool) {
pkg/cmds/cmds.go:300:	return cd.Layers.Get(name)
pkg/cmds/cmds.go:303:func (cd *CommandDescription) Clone(cloneLayers bool, options ...CommandDescriptionOption) *CommandDescription {
pkg/cmds/cmds.go:305:	layers_ := schema.NewSchema()
pkg/cmds/cmds.go:306:	if cloneLayers {
pkg/cmds/cmds.go:307:		layers_ = cd.Layers.Clone()
pkg/cmds/cmds.go:318:		Layers:  layers_,
pkg/cmds/cmds.go:343:func (cd *CommandDescription) SetLayers(layers ...schema.Section) {
pkg/cmds/cmds.go:344:	for _, l := range layers {
pkg/cmds/cmds.go:345:		cd.Layers.Set(l.GetSlug(), l)
pkg/cmds/cmds.go:356:	Metadata(ctx context.Context, parsedLayers *values.Values) (map[string]interface{}, error)
pkg/cmds/cmds.go:368:	Run(ctx context.Context, parsedLayers *values.Values) error
pkg/cmds/cmds.go:373:	RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error
pkg/cmds/cmds.go:380:	// NOTE(manuel, 2023-02-27) We can probably simplify this to only take parsed layers
pkg/cmds/cmds.go:382:	// The ps and GlazeProcessor calls could be replaced by a GlazeCommand specific layer,
pkg/cmds/cmds.go:384:	// is just something created by the passed in GlazeLayer anyway.
pkg/cmds/cmds.go:392:	RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error
pkg/cmds/sources/layers.go:9:// ReplaceSectionValues is a middleware that replaces a parsed layer with a new one.
pkg/cmds/sources/layers.go:10:// It first calls next, then replaces the specified layer with a clone of the provided one.
pkg/cmds/sources/layers.go:11:// If the layer doesn't exist in the original parsedLayers, it will be added.
pkg/cmds/sources/layers.go:12:func ReplaceSectionValues(layerSlug string, newLayer *values.SectionValues) Middleware {
pkg/cmds/sources/layers.go:14:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/layers.go:15:			err := next(layers_, parsedLayers)
pkg/cmds/sources/layers.go:20:			if newLayer == nil {
pkg/cmds/sources/layers.go:21:				return errors.New("cannot replace with nil layer")
pkg/cmds/sources/layers.go:24:			parsedLayers.Set(layerSlug, newLayer.Clone())
pkg/cmds/sources/layers.go:30:// ReplaceValues is a middleware that replaces multiple parsed layers at once.
pkg/cmds/sources/layers.go:31:// It first calls next, then replaces all specified layers with clones of the provided ones.
pkg/cmds/sources/layers.go:32:// If a layer doesn't exist in the original parsedLayers, it will be added.
pkg/cmds/sources/layers.go:33:func ReplaceValues(newLayers *values.Values) Middleware {
pkg/cmds/sources/layers.go:35:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/layers.go:36:			err := next(layers_, parsedLayers)
pkg/cmds/sources/layers.go:41:			if newLayers == nil {
pkg/cmds/sources/layers.go:42:				return errors.New("cannot replace with nil layers")
pkg/cmds/sources/layers.go:45:			newLayers.ForEach(func(k string, v *values.SectionValues) {
pkg/cmds/sources/layers.go:46:				parsedLayers.Set(k, v.Clone())
pkg/cmds/sources/layers.go:53:// ReplaceValuesSelective is a middleware that replaces only the specified layers from the provided Values.
pkg/cmds/sources/layers.go:54:// It first calls next, then replaces only the layers specified in slugs with clones from newLayers.
pkg/cmds/sources/layers.go:55:// If a layer in slugs doesn't exist in newLayers, it is skipped.
pkg/cmds/sources/layers.go:56:func ReplaceValuesSelective(newLayers *values.Values, slugs []string) Middleware {
pkg/cmds/sources/layers.go:58:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/layers.go:59:			err := next(layers_, parsedLayers)
pkg/cmds/sources/layers.go:64:			if newLayers == nil {
pkg/cmds/sources/layers.go:65:				return errors.New("cannot replace with nil layers")
pkg/cmds/sources/layers.go:69:				if layer, ok := newLayers.Get(slug); ok {
pkg/cmds/sources/layers.go:70:					parsedLayers.Set(slug, layer.Clone())
pkg/cmds/sources/layers.go:78:// MergeSectionValues is a middleware that merges a parsed layer into an existing one.
pkg/cmds/sources/layers.go:79:// It first calls next, then merges the provided layer into the specified one.
pkg/cmds/sources/layers.go:80:// If the target layer doesn't exist, it will be created.
pkg/cmds/sources/layers.go:81:func MergeSectionValues(layerSlug string, layerToMerge *values.SectionValues) Middleware {
pkg/cmds/sources/layers.go:83:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/layers.go:84:			err := next(layers_, parsedLayers)
pkg/cmds/sources/layers.go:89:			if layerToMerge == nil {
pkg/cmds/sources/layers.go:90:				return errors.New("cannot merge nil layer")
pkg/cmds/sources/layers.go:93:			targetLayer, ok := parsedLayers.Get(layerSlug)
pkg/cmds/sources/layers.go:95:				parsedLayers.Set(layerSlug, layerToMerge.Clone())
pkg/cmds/sources/layers.go:99:			err = targetLayer.MergeParameters(layerToMerge)
pkg/cmds/sources/layers.go:108:// MergeValues is a middleware that merges multiple parsed layers at once.
pkg/cmds/sources/layers.go:109:// It first calls next, then merges all provided layers into the existing ones.
pkg/cmds/sources/layers.go:110:// If a target layer doesn't exist, it will be created.
pkg/cmds/sources/layers.go:111:func MergeValues(layersToMerge *values.Values) Middleware {
pkg/cmds/sources/layers.go:113:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/layers.go:114:			err := next(layers_, parsedLayers)
pkg/cmds/sources/layers.go:119:			if layersToMerge == nil {
pkg/cmds/sources/layers.go:120:				return errors.New("cannot merge nil layers")
pkg/cmds/sources/layers.go:123:			err = parsedLayers.Merge(layersToMerge)
pkg/cmds/sources/layers.go:132:// MergeValuesSelective is a middleware that merges only the specified layers from the provided Values.
pkg/cmds/sources/layers.go:133:// It first calls next, then merges only the layers specified in slugs from layersToMerge into the existing layers.
pkg/cmds/sources/layers.go:134:// If a layer in slugs doesn't exist in layersToMerge, it is skipped.
pkg/cmds/sources/layers.go:135:// If a target layer doesn't exist in parsedLayers, it will be created.
pkg/cmds/sources/layers.go:136:func MergeValuesSelective(layersToMerge *values.Values, slugs []string) Middleware {
pkg/cmds/sources/layers.go:138:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/layers.go:139:			err := next(layers_, parsedLayers)
pkg/cmds/sources/layers.go:144:			if layersToMerge == nil {
pkg/cmds/sources/layers.go:145:				return errors.New("cannot merge nil layers")
pkg/cmds/sources/layers.go:149:				if layer, ok := layersToMerge.Get(slug); ok {
pkg/cmds/sources/layers.go:150:					targetLayer, exists := parsedLayers.Get(slug)
pkg/cmds/sources/layers.go:152:						parsedLayers.Set(slug, layer.Clone())
pkg/cmds/sources/layers.go:154:						err = targetLayer.MergeParameters(layer)
pkg/doc/topics/layers-guide.md:2:Title: Glazed Command Layers Guide
pkg/doc/topics/layers-guide.md:3:Slug: layers-guide  
pkg/doc/topics/layers-guide.md:4:Short: Complete guide to understanding and working with command parameter layers in Glazed
pkg/doc/topics/layers-guide.md:6:- layers
pkg/doc/topics/layers-guide.md:7:- parameters
pkg/doc/topics/layers-guide.md:16:# Glazed Command Layers: Complete Guide
pkg/doc/topics/layers-guide.md:18:*Building maintainable CLI applications through modular parameter organization*
pkg/doc/topics/layers-guide.md:22:2. [Parameter Organization Challenges](#parameter-organization-challenges)
pkg/doc/topics/layers-guide.md:23:3. [Layer System Architecture](#layer-system-architecture)
pkg/doc/topics/layers-guide.md:24:4. [Core Layer Concepts](#core-layer-concepts)
pkg/doc/topics/layers-guide.md:25:5. [Layer Types & Components](#layer-types--components)
pkg/doc/topics/layers-guide.md:26:6. [Creating and Working with Layers](#creating-and-working-with-layers)
pkg/doc/topics/layers-guide.md:30:10. [Testing Layers](#testing-layers)
pkg/doc/topics/layers-guide.md:34:Parameter layers organize related command parameters into reusable groups. This modular approach addresses common CLI development challenges including parameter proliferation, code duplication, naming conflicts, and maintenance complexity in growing applications.
pkg/doc/topics/layers-guide.md:36:The layer system enables developers to:
pkg/doc/topics/layers-guide.md:38:- **Organize parameters** logically by functionality (database, logging, output)
pkg/doc/topics/layers-guide.md:39:- **Reuse parameter definitions** across multiple commands without duplication
pkg/doc/topics/layers-guide.md:41:- **Maintain consistency** through centralized parameter definitions
pkg/doc/topics/layers-guide.md:44:### Traditional Parameter Management Problems
pkg/doc/topics/layers-guide.md:56:- **Parameter pollution**: Commands inherit irrelevant flags, cluttering help screens
pkg/doc/topics/layers-guide.md:58:- **Code duplication**: Parameter definitions copy across commands, violating DRY principles
pkg/doc/topics/layers-guide.md:59:- **Poor organization**: Parameters scatter without logical grouping
pkg/doc/topics/layers-guide.md:90:### Glazed Layer Solution
pkg/doc/topics/layers-guide.md:92:The layer system eliminates these problems by treating parameters as modular components that can be shared, composed, reused, maintained centrally, and extended without breaking existing commands.
pkg/doc/topics/layers-guide.md:95:// Define reusable layers once
pkg/doc/topics/layers-guide.md:97:    DatabaseLayer = CreateDatabaseLayer()  // --db-host, --db-port, --db-name
pkg/doc/topics/layers-guide.md:98:    LoggingLayer  = CreateLoggingLayer()   // --log-level, --log-file, --verbose
pkg/doc/topics/layers-guide.md:99:    ServerLayer   = CreateServerLayer()    // --host, --port, --timeout
pkg/doc/topics/layers-guide.md:100:    GlazedLayer   = CreateGlazedLayer()    // --output, --fields, --format
pkg/doc/topics/layers-guide.md:103:// Compose commands by combining relevant layers
pkg/doc/topics/layers-guide.md:105:    cmds.WithLayers(ServerLayer, DatabaseLayer, LoggingLayer))
pkg/doc/topics/layers-guide.md:108:    cmds.WithLayers(ServerLayer, LoggingLayer))  // No database needed
pkg/doc/topics/layers-guide.md:111:    cmds.WithLayers(DatabaseLayer, LoggingLayer, GlazedLayer))  // No server needed
pkg/doc/topics/layers-guide.md:114:## Parameter Organization Challenges
pkg/doc/topics/layers-guide.md:116:Complex CLI applications face predictable parameter management challenges that layers directly address.
pkg/doc/topics/layers-guide.md:118:### Parameter Explosion
pkg/doc/topics/layers-guide.md:120:As applications add features, commands accumulate parameters that may not be relevant to their specific functionality. This creates cognitive overhead for users and increases implementation complexity.
pkg/doc/topics/layers-guide.md:124:Multiple subsystems often require similar parameters (host, port, timeout). Without organization, developers resort to verbose prefixes that reduce usability and create inconsistent interfaces.
pkg/doc/topics/layers-guide.md:128:Parameter definitions scattered across command implementations require manual synchronization. Adding SSL configuration to database connections means updating every command that uses databases.
pkg/doc/topics/layers-guide.md:132:Without centralized parameter definitions, similar functionality develops different flag names across commands, creating inconsistent user experiences and requiring additional documentation.
pkg/doc/topics/layers-guide.md:134:## Layer System Architecture
pkg/doc/topics/layers-guide.md:136:The layer system separates parameter definition from runtime value resolution, enabling flexible composition while maintaining type safety.
pkg/doc/topics/layers-guide.md:144:│  │            Command Description           │ ← Metadata + layer references
pkg/doc/topics/layers-guide.md:147:│  │  │          Parameter Layers           │ ← Layer definitions (design time)
pkg/doc/topics/layers-guide.md:150:│  │  │  │Default Layer│  Custom Layers  │   │ ← Different types of layers
pkg/doc/topics/layers-guide.md:160:│              Runtime Parsing                 │ ← Parameter resolution
pkg/doc/topics/layers-guide.md:162:│  Parameter Sources (in priority order):     │ ← Multi-source configuration
pkg/doc/topics/layers-guide.md:166:│  4. Default values from layer definitions   │
pkg/doc/topics/layers-guide.md:171:│               Parsed Layers                  │ ← Runtime values
pkg/doc/topics/layers-guide.md:172:│        (type-safe parameter values)         │
pkg/doc/topics/layers-guide.md:178:1. **Layer Definitions** (design time): Parameter specifications and constraints
pkg/doc/topics/layers-guide.md:180:3. **Parsed Layers** (application time): Type-safe access to resolved values
pkg/doc/topics/layers-guide.md:182:### Layer Lifecycle
pkg/doc/topics/layers-guide.md:184:Layers progress through distinct phases from definition to runtime use:
pkg/doc/topics/layers-guide.md:186:1. **Definition Phase**: Parameters defined with types, defaults, and validation rules
pkg/doc/topics/layers-guide.md:187:2. **Composition Phase**: Layers combined into command descriptions
pkg/doc/topics/layers-guide.md:189:4. **Execution Phase**: Commands access type-safe parameter values
pkg/doc/topics/layers-guide.md:191:## Core Layer Concepts
pkg/doc/topics/layers-guide.md:193:### Layer Identity and Organization
pkg/doc/topics/layers-guide.md:195:Every layer requires unique identification and logical organization within the application parameter namespace.
pkg/doc/topics/layers-guide.md:197:#### Layer Hierarchy
pkg/doc/topics/layers-guide.md:201:├── Default Layer (always present)
pkg/doc/topics/layers-guide.md:204:├── Standard Layers (optional, commonly used)
pkg/doc/topics/layers-guide.md:205:│   ├── Glazed Layer (for structured output)  ← Output formatting
pkg/doc/topics/layers-guide.md:206:│   ├── Logging Layer (for logging configuration)  ← Debug & monitoring
pkg/doc/topics/layers-guide.md:207:│   └── Database Layer (for database connections)  ← Data persistence
pkg/doc/topics/layers-guide.md:208:└── Custom Layers (application-specific)
pkg/doc/topics/layers-guide.md:209:    ├── Authentication Layer        ← Security & access control
pkg/doc/topics/layers-guide.md:210:    ├── API Configuration Layer     ← External service integration
pkg/doc/topics/layers-guide.md:211:    └── Feature Toggle Layer        ← Experimental or optional features
pkg/doc/topics/layers-guide.md:214:This hierarchy enables logical grouping, reusability across commands, extensibility without breaking changes, and automatic propagation of layer updates.
pkg/doc/topics/layers-guide.md:216:### Parameter Definitions vs. Parsed Values
pkg/doc/topics/layers-guide.md:218:The system distinguishes between parameter specifications (what's possible) and runtime values (what's actual).
pkg/doc/topics/layers-guide.md:220:**Parameter Definitions** (specifications stored in layers):
pkg/doc/topics/layers-guide.md:224:    "log-level",                    // Parameter name
pkg/doc/topics/layers-guide.md:238:loggingLayer, ok := parsedLayers.Get("logging")
pkg/doc/topics/layers-guide.md:240:    logLevel, ok := loggingLayer.GetParameter("log-level")
pkg/doc/topics/layers-guide.md:251:### Layer Composition Patterns
pkg/doc/topics/layers-guide.md:253:Layer composition determines command interfaces by selecting appropriate parameter groups.
pkg/doc/topics/layers-guide.md:260:// Combine only needed layers
pkg/doc/topics/layers-guide.md:262:    cmds.WithLayers(databaseLayer, loggingLayer))
pkg/doc/topics/layers-guide.md:267:Dynamic layer assembly based on runtime conditions:
pkg/doc/topics/layers-guide.md:270:// Build layer list based on features
pkg/doc/topics/layers-guide.md:271:layers := []schema.Section{baseLayer}
pkg/doc/topics/layers-guide.md:274:    layers = append(layers, databaseLayer)
pkg/doc/topics/layers-guide.md:278:    layers = append(layers, glazedLayer)
pkg/doc/topics/layers-guide.md:282:    cmds.WithLayersList(layers...))
pkg/doc/topics/layers-guide.md:285:#### Layer Extension
pkg/doc/topics/layers-guide.md:287:Building specialized variants from existing layers:
pkg/doc/topics/layers-guide.md:290:// Extend existing layer without modification
pkg/doc/topics/layers-guide.md:291:extendedDbLayer := databaseLayer.Clone()
pkg/doc/topics/layers-guide.md:292:extendedDbLayer.AddFlags(
pkg/doc/topics/layers-guide.md:298:## Layer Types & Components
pkg/doc/topics/layers-guide.md:300:### Built-in Layer Types
pkg/doc/topics/layers-guide.md:302:Glazed provides standard layer types for common CLI application requirements.
pkg/doc/topics/layers-guide.md:304:#### Default Layer
pkg/doc/topics/layers-guide.md:306:The Default Layer contains command-specific parameters unique to individual commands.
pkg/doc/topics/layers-guide.md:311:- **Use Case**: Parameters fundamental to command operation, unlikely to be shared
pkg/doc/topics/layers-guide.md:314:// Default layer created automatically
pkg/doc/topics/layers-guide.md:324:// Parameters live in default layer, unique to "serve" command
pkg/doc/topics/layers-guide.md:327:#### Glazed Layer
pkg/doc/topics/layers-guide.md:329:The Glazed Layer provides comprehensive output formatting capabilities for commands producing structured data.
pkg/doc/topics/layers-guide.md:333:- **Creation**: `settings.NewGlazedParameterLayers()`
pkg/doc/topics/layers-guide.md:337:glazedLayer, err := settings.NewGlazedParameterLayers()
pkg/doc/topics/layers-guide.md:339:    return nil, fmt.Errorf("failed to create glazed layer: %w", err)
pkg/doc/topics/layers-guide.md:345:### Custom Layer Components
pkg/doc/topics/layers-guide.md:347:Application-specific layers address domain requirements through custom parameter definitions.
pkg/doc/topics/layers-guide.md:349:#### Parameter Definitions
pkg/doc/topics/layers-guide.md:351:Individual parameter specifications define acceptable input and behavior:
pkg/doc/topics/layers-guide.md:355:    "connection-timeout",              // Parameter name
pkg/doc/topics/layers-guide.md:365:- **Name**: Parameter identifier for CLI flags
pkg/doc/topics/layers-guide.md:373:Parameter definitions include built-in validation for common patterns:
pkg/doc/topics/layers-guide.md:376:// Choice parameters with automatic validation
pkg/doc/topics/layers-guide.md:385:// Numeric parameters with defaults
pkg/doc/topics/layers-guide.md:395:## Creating and Working with Layers
pkg/doc/topics/layers-guide.md:397:### Method 1: Simple Layer Creation
pkg/doc/topics/layers-guide.md:399:Direct layer creation for straightforward parameter grouping:
pkg/doc/topics/layers-guide.md:402:func NewDatabaseLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:404:        "database",                    // Layer identifier
pkg/doc/topics/layers-guide.md:430:### Method 2: Type-Safe Layer with Settings Struct
pkg/doc/topics/layers-guide.md:432:For complex layers requiring type safety and structured access:
pkg/doc/topics/layers-guide.md:445:// 2. Create layer with parameter definitions
pkg/doc/topics/layers-guide.md:446:func NewDatabaseLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:491:func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {
pkg/doc/topics/layers-guide.md:493:    err := parsedLayers.InitializeStruct("database", settings)
pkg/doc/topics/layers-guide.md:500:    parsedLayers *values.Values,
pkg/doc/topics/layers-guide.md:503:    // Extract database settings from the "database" layer
pkg/doc/topics/layers-guide.md:504:    dbSettings, err := GetDatabaseSettings(parsedLayers)
pkg/doc/topics/layers-guide.md:523:### Method 3: Layer Builder Pattern
pkg/doc/topics/layers-guide.md:525:For complex scenarios requiring conditional parameters:
pkg/doc/topics/layers-guide.md:528:type DatabaseLayerBuilder struct {
pkg/doc/topics/layers-guide.md:529:    layer      schema.Section
pkg/doc/topics/layers-guide.md:534:func NewDatabaseLayerBuilder() *DatabaseLayerBuilder {
pkg/doc/topics/layers-guide.md:535:    layer, _ := schema.NewSection("database", "Database Configuration")
pkg/doc/topics/layers-guide.md:536:    return &DatabaseLayerBuilder{layer: layer}
pkg/doc/topics/layers-guide.md:539:func (b *DatabaseLayerBuilder) WithSSL() *DatabaseLayerBuilder {
pkg/doc/topics/layers-guide.md:544:func (b *DatabaseLayerBuilder) WithConnectionPool() *DatabaseLayerBuilder {
pkg/doc/topics/layers-guide.md:549:func (b *DatabaseLayerBuilder) Build() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:550:    // Add basic parameters
pkg/doc/topics/layers-guide.md:551:    b.layer.AddFlags(
pkg/doc/topics/layers-guide.md:558:    // Conditionally add SSL parameters
pkg/doc/topics/layers-guide.md:560:        b.layer.AddFlags(
pkg/doc/topics/layers-guide.md:567:    // Conditionally add connection pool parameters
pkg/doc/topics/layers-guide.md:569:        b.layer.AddFlags(
pkg/doc/topics/layers-guide.md:577:    return b.layer, nil
pkg/doc/topics/layers-guide.md:581:dbLayer, _ := NewDatabaseLayerBuilder().
pkg/doc/topics/layers-guide.md:587:### Method 4: Registering Layers with Explicit Slugs on Commands
pkg/doc/topics/layers-guide.md:589:In some cases you may want to register layers on a command under explicit slugs that differ from the layer's internal slug. Use `cmds.WithLayersMap` to provide a map of slug-to-layer entries when creating a command description.
pkg/doc/topics/layers-guide.md:592:dbLayer, _ := NewDatabaseLayer()        // internal slug: "database"
pkg/doc/topics/layers-guide.md:593:loggingLayer, _ := NewLoggingLayer()    // internal slug: "logging"
pkg/doc/topics/layers-guide.md:597:    cmds.WithLayersMap(map[string]schema.Section{
pkg/doc/topics/layers-guide.md:598:        "db":  dbLayer,    // registered under explicit slug "db"
pkg/doc/topics/layers-guide.md:599:        "log": loggingLayer,
pkg/doc/topics/layers-guide.md:607:- If a layer's internal slug differs from the map key and the layer is a `*schema.SectionImpl`, Glazed will clone the layer and align its slug to the provided key for consistent runtime behavior.
pkg/doc/topics/layers-guide.md:608:- For custom layer implementations, prefer using matching internal and registration slugs when possible.
pkg/doc/topics/layers-guide.md:614:Complete layer implementation for a web server with database, logging, and server configuration:
pkg/doc/topics/layers-guide.md:622:    "github.com/go-go-golems/glazed/pkg/cmds/layers"
pkg/doc/topics/layers-guide.md:623:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"
pkg/doc/topics/layers-guide.md:648:// Layer creation functions
pkg/doc/topics/layers-guide.md:649:func NewServerLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:684:func NewLoggingLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:712:func NewDatabaseLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:749:// Command creation with layer composition
pkg/doc/topics/layers-guide.md:751:    // Create layers
pkg/doc/topics/layers-guide.md:752:    serverLayer, err := NewServerLayer()
pkg/doc/topics/layers-guide.md:757:    loggingLayer, err := NewLoggingLayer()
pkg/doc/topics/layers-guide.md:762:    databaseLayer, err := NewDatabaseLayer()
pkg/doc/topics/layers-guide.md:767:    // Compose command with relevant layers
pkg/doc/topics/layers-guide.md:772:        cmds.WithLayersList(serverLayer, databaseLayer, loggingLayer),
pkg/doc/topics/layers-guide.md:778:    serverLayer, err := NewServerLayer()
pkg/doc/topics/layers-guide.md:783:    loggingLayer, err := NewLoggingLayer()
pkg/doc/topics/layers-guide.md:799:        cmds.WithLayersList(serverLayer, loggingLayer), // No database layer
pkg/doc/topics/layers-guide.md:803:// Settings extraction helpers demonstrate how to use InitializeStruct with layer-specific settings
pkg/doc/topics/layers-guide.md:804:func GetServerSettings(parsedLayers *values.Values) (*ServerSettings, error) {
pkg/doc/topics/layers-guide.md:806:    err := parsedLayers.InitializeStruct("server", settings)
pkg/doc/topics/layers-guide.md:810:func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {
pkg/doc/topics/layers-guide.md:812:    err := parsedLayers.InitializeStruct("logging", settings)
pkg/doc/topics/layers-guide.md:816:func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {
pkg/doc/topics/layers-guide.md:818:    err := parsedLayers.InitializeStruct("database", settings)
pkg/doc/topics/layers-guide.md:822:// Example command implementation using multiple layer settings
pkg/doc/topics/layers-guide.md:827:func (c *ServerCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/layers-guide.md:828:    // Extract settings from each layer
pkg/doc/topics/layers-guide.md:829:    serverSettings, err := GetServerSettings(parsedLayers)
pkg/doc/topics/layers-guide.md:834:    dbSettings, err := GetDatabaseSettings(parsedLayers)
pkg/doc/topics/layers-guide.md:839:    logSettings, err := GetLoggingSettings(parsedLayers)
pkg/doc/topics/layers-guide.md:844:    // Use settings from multiple layers
pkg/doc/topics/layers-guide.md:870:Layer composition for applications with conditional functionality. This example shows how to extract settings from optional layers and use them together:
pkg/doc/topics/layers-guide.md:873:// Feature layers for optional inclusion
pkg/doc/topics/layers-guide.md:874:func NewCacheLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:901:func NewMetricsLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:930:    baseLayers    []schema.Section
pkg/doc/topics/layers-guide.md:937:    loggingLayer, _ := NewLoggingLayer()
pkg/doc/topics/layers-guide.md:940:        baseLayers: []schema.Section{loggingLayer},
pkg/doc/topics/layers-guide.md:960:    commandLayers := append([]schema.Section{}, b.baseLayers...)
pkg/doc/topics/layers-guide.md:962:    // Add optional layers based on enabled features
pkg/doc/topics/layers-guide.md:964:        cacheLayer, err := NewCacheLayer()
pkg/doc/topics/layers-guide.md:968:        commandLayers = append(commandLayers, cacheLayer)
pkg/doc/topics/layers-guide.md:972:        metricsLayer, err := NewMetricsLayer()
pkg/doc/topics/layers-guide.md:976:        commandLayers = append(commandLayers, metricsLayer)
pkg/doc/topics/layers-guide.md:980:        authLayer, err := NewAuthLayer() // Assume this exists
pkg/doc/topics/layers-guide.md:984:        commandLayers = append(commandLayers, authLayer)
pkg/doc/topics/layers-guide.md:1003:        cmds.WithLayersList(commandLayers...),
pkg/doc/topics/layers-guide.md:1020:// Helper functions for optional layer settings
pkg/doc/topics/layers-guide.md:1021:func GetCacheSettings(parsedLayers *values.Values) (*CacheSettings, error) {
pkg/doc/topics/layers-guide.md:1023:    err := parsedLayers.InitializeStruct("cache", settings)
pkg/doc/topics/layers-guide.md:1027:func GetMetricsSettings(parsedLayers *values.Values) (*MetricsSettings, error) {
pkg/doc/topics/layers-guide.md:1029:    err := parsedLayers.InitializeStruct("metrics", settings)
pkg/doc/topics/layers-guide.md:1033:// Command implementation that handles optional layers
pkg/doc/topics/layers-guide.md:1038:func (c *ProcessCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/layers-guide.md:1040:    logSettings, err := GetLoggingSettings(parsedLayers)
pkg/doc/topics/layers-guide.md:1048:    if parsedLayers.Has("cache") {
pkg/doc/topics/layers-guide.md:1049:        cacheSettings, err := GetCacheSettings(parsedLayers)
pkg/doc/topics/layers-guide.md:1062:    if parsedLayers.Has("metrics") {
pkg/doc/topics/layers-guide.md:1063:        metricsSettings, err := GetMetricsSettings(parsedLayers)
pkg/doc/topics/layers-guide.md:1096:### 1. Layer Inheritance and Composition
pkg/doc/topics/layers-guide.md:1098:Extending existing layers without modification:
pkg/doc/topics/layers-guide.md:1101:// Base database layer
pkg/doc/topics/layers-guide.md:1102:func NewBaseDatabaseLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:1115:// Extended database layer with additional features
pkg/doc/topics/layers-guide.md:1116:func NewAdvancedDatabaseLayer() (schema.Section, error) {
pkg/doc/topics/layers-guide.md:1117:    // Start with base layer
pkg/doc/topics/layers-guide.md:1118:    baseLayer, err := NewBaseDatabaseLayer()
pkg/doc/topics/layers-guide.md:1124:    advancedLayer := baseLayer.Clone()
pkg/doc/topics/layers-guide.md:1126:    // Add additional parameters
pkg/doc/topics/layers-guide.md:1127:    advancedLayer.AddFlags(
pkg/doc/topics/layers-guide.md:1136:    return advancedLayer, nil
pkg/doc/topics/layers-guide.md:1140:### 2. Environment-Specific Layer Configuration
pkg/doc/topics/layers-guide.md:1142:Adapting layers for different deployment environments:
pkg/doc/topics/layers-guide.md:1150:func NewEnvironmentAwareDatabaseLayer(config EnvironmentConfig) (schema.Section, error) {
pkg/doc/topics/layers-guide.md:1151:    layer, err := NewBaseDatabaseLayer()
pkg/doc/topics/layers-guide.md:1156:    // Add environment-specific parameters
pkg/doc/topics/layers-guide.md:1159:        layer.AddFlags(
pkg/doc/topics/layers-guide.md:1166:        layer.AddFlags(
pkg/doc/topics/layers-guide.md:1175:    // Add feature-specific parameters
pkg/doc/topics/layers-guide.md:1179:            layer.AddFlags(
pkg/doc/topics/layers-guide.md:1185:            layer.AddFlags(
pkg/doc/topics/layers-guide.md:1192:    return layer, nil
pkg/doc/topics/layers-guide.md:1196:### 3. Dynamic Layer Registration
pkg/doc/topics/layers-guide.md:1198:Runtime layer registration for plugin systems:
pkg/doc/topics/layers-guide.md:1201:type LayerRegistry struct {
pkg/doc/topics/layers-guide.md:1202:    layers map[string]schema.Section
pkg/doc/topics/layers-guide.md:1206:func NewLayerRegistry() *LayerRegistry {
pkg/doc/topics/layers-guide.md:1207:    return &LayerRegistry{
pkg/doc/topics/layers-guide.md:1208:        layers: make(map[string]schema.Section),
pkg/doc/topics/layers-guide.md:1212:func (r *LayerRegistry) RegisterLayer(slug string, layer schema.Section) error {
pkg/doc/topics/layers-guide.md:1216:    if _, exists := r.layers[slug]; exists {
pkg/doc/topics/layers-guide.md:1217:        return fmt.Errorf("layer %s already registered", slug)
pkg/doc/topics/layers-guide.md:1220:    r.layers[slug] = layer
pkg/doc/topics/layers-guide.md:1224:func (r *LayerRegistry) GetLayer(slug string) (schema.Section, error) {
pkg/doc/topics/layers-guide.md:1228:    layer, exists := r.layers[slug]
pkg/doc/topics/layers-guide.md:1230:        return nil, fmt.Errorf("layer %s not found", slug)
pkg/doc/topics/layers-guide.md:1233:    return layer, nil
pkg/doc/topics/layers-guide.md:1236:func (r *LayerRegistry) BuildCommand(name string, layerSlugs []string) (*cmds.CommandDescription, error) {
pkg/doc/topics/layers-guide.md:1237:    var commandLayers []schema.Section
pkg/doc/topics/layers-guide.md:1239:    for _, slug := range layerSlugs {
pkg/doc/topics/layers-guide.md:1240:        layer, err := r.GetLayer(slug)
pkg/doc/topics/layers-guide.md:1244:        commandLayers = append(commandLayers, layer)
pkg/doc/topics/layers-guide.md:1248:        cmds.WithLayersList(commandLayers...)), nil
pkg/doc/topics/layers-guide.md:1252:func InitializePluginSystem() *LayerRegistry {
pkg/doc/topics/layers-guide.md:1253:    registry := NewLayerRegistry()
pkg/doc/topics/layers-guide.md:1255:    // Register core layers
pkg/doc/topics/layers-guide.md:1256:    databaseLayer, _ := NewDatabaseLayer()
pkg/doc/topics/layers-guide.md:1257:    registry.RegisterLayer("database", databaseLayer)
pkg/doc/topics/layers-guide.md:1259:    loggingLayer, _ := NewLoggingLayer()
pkg/doc/topics/layers-guide.md:1260:    registry.RegisterLayer("logging", loggingLayer)
pkg/doc/topics/layers-guide.md:1262:    // Plugins can register additional layers
pkg/doc/topics/layers-guide.md:1263:    // registry.RegisterLayer("custom-feature", customLayer)
pkg/doc/topics/layers-guide.md:1269:### 4. Layer Validation and Constraints
pkg/doc/topics/layers-guide.md:1271:Complex validation rules across layer parameters:
pkg/doc/topics/layers-guide.md:1274:type LayerValidator struct {
pkg/doc/topics/layers-guide.md:1280:func NewLayerValidator() *LayerValidator {
pkg/doc/topics/layers-guide.md:1281:    return &LayerValidator{}
pkg/doc/topics/layers-guide.md:1284:func (v *LayerValidator) AddRule(rule ValidationRule) {
pkg/doc/topics/layers-guide.md:1288:func (v *LayerValidator) Validate(parsedLayers *values.Values) error {
pkg/doc/topics/layers-guide.md:1290:        if err := rule(parsedLayers); err != nil {
pkg/doc/topics/layers-guide.md:1297:// Cross-layer validation rules
pkg/doc/topics/layers-guide.md:1298:func DatabaseConnectionRule(parsedLayers *values.Values) error {
pkg/doc/topics/layers-guide.md:1299:    dbLayer, ok := parsedLayers.Get("database")
pkg/doc/topics/layers-guide.md:1301:        return nil // Skip if database layer not present
pkg/doc/topics/layers-guide.md:1304:    host, ok := dbLayer.GetParameter("db-host")
pkg/doc/topics/layers-guide.md:1309:    port, ok := dbLayer.GetParameter("db-port")
pkg/doc/topics/layers-guide.md:1314:    // Validate connection parameters make sense together
pkg/doc/topics/layers-guide.md:1322:func SSLConfigurationRule(parsedLayers *values.Values) error {
pkg/doc/topics/layers-guide.md:1323:    dbLayer, ok := parsedLayers.Get("database")
pkg/doc/topics/layers-guide.md:1325:        return nil // Skip if database layer not present
pkg/doc/topics/layers-guide.md:1328:    sslMode, ok := dbLayer.GetParameter("db-ssl-mode")
pkg/doc/topics/layers-guide.md:1335:        cert, ok := dbLayer.GetParameter("db-ssl-cert")
pkg/doc/topics/layers-guide.md:1345:func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {
pkg/doc/topics/layers-guide.md:1346:    // Validate layer configuration
pkg/doc/topics/layers-guide.md:1347:    validator := NewLayerValidator()
pkg/doc/topics/layers-guide.md:1351:    if err := validator.Validate(parsedLayers); err != nil {
pkg/doc/topics/layers-guide.md:1362:### Layer Design Principles
pkg/doc/topics/layers-guide.md:1364:**Single Responsibility**: Each layer should handle one logical area of configuration. Database layers handle database parameters, logging layers handle logging configuration.
pkg/doc/topics/layers-guide.md:1366:**Clear Naming**: Use descriptive layer slugs and parameter names. Prefer `database-connection-timeout` over `timeout`.
pkg/doc/topics/layers-guide.md:1370:**Consistent Interfaces**: Use similar parameter names across layers. If one layer uses `host`, avoid `hostname` in another layer for the same concept.
pkg/doc/topics/layers-guide.md:1372:### Parameter Organization
pkg/doc/topics/layers-guide.md:1374:Group related parameters logically within layers. Database layers should include host, port, credentials, and connection options together.
pkg/doc/topics/layers-guide.md:1378:Consider parameter relationships when designing layers. Parameters that are frequently used together belong in the same layer.
pkg/doc/topics/layers-guide.md:1382:Only include layers that provide parameters relevant to the command's functionality. Avoid layer pollution by being selective.
pkg/doc/topics/layers-guide.md:1386:Consider creating specialized layer variants for different command types. A read-only database layer might exclude authentication parameters.
pkg/doc/topics/layers-guide.md:1390:Validate layer configuration early in command execution. Fail fast with clear error messages about parameter issues.
pkg/doc/topics/layers-guide.md:1394:Use type-safe parameter extraction where possible. Struct-based settings reduce runtime errors and improve code clarity.
pkg/doc/topics/layers-guide.md:1398:Write unit tests for layer definitions to ensure parameter validation works correctly. Test edge cases and error conditions.
pkg/doc/topics/layers-guide.md:1400:Test layer composition to verify that combined layers work correctly together. Check for parameter conflicts and validation interactions.
pkg/doc/topics/layers-guide.md:1402:Use integration tests to verify that commands work correctly with different layer combinations and parameter sources.
pkg/doc/topics/layers-guide.md:1404:Document layer dependencies and relationships. Explain when layers should be used together and any constraints.
pkg/doc/topics/layers-guide.md:1406:Keep layer definitions close to their usage when possible. This improves maintainability and reduces the chance of configuration drift.
pkg/doc/topics/layers-guide.md:1408:Version layer definitions carefully in evolving applications. Consider backward compatibility when modifying existing layers.
pkg/doc/topics/layers-guide.md:1410:## Testing Layers
pkg/doc/topics/layers-guide.md:1412:### Unit Testing Layer Definitions
pkg/doc/topics/layers-guide.md:1414:Test individual layer creation and parameter validation:
pkg/doc/topics/layers-guide.md:1417:func TestDatabaseLayer(t *testing.T) {
pkg/doc/topics/layers-guide.md:1418:    layer, err := NewDatabaseLayer()
pkg/doc/topics/layers-guide.md:1420:    assert.Equal(t, "database", layer.GetSlug())
pkg/doc/topics/layers-guide.md:1422:    // Test parameter definitions
pkg/doc/topics/layers-guide.md:1423:    params := layer.GetParameterDefinitions()
pkg/doc/topics/layers-guide.md:1436:func TestParameterValidation(t *testing.T) {
pkg/doc/topics/layers-guide.md:1437:    layer, _ := NewDatabaseLayer()
pkg/doc/topics/layers-guide.md:1440:    logLevelParam := layer.GetParameterDefinitions()["log-level"]
pkg/doc/topics/layers-guide.md:1444:    // Test required parameters
pkg/doc/topics/layers-guide.md:1445:    dbNameParam := layer.GetParameterDefinitions()["db-name"]
pkg/doc/topics/layers-guide.md:1450:### Integration Testing Layer Composition
pkg/doc/topics/layers-guide.md:1452:Test command creation with multiple layers:
pkg/doc/topics/layers-guide.md:1456:    serverLayer, _ := NewServerLayer()
pkg/doc/topics/layers-guide.md:1457:    databaseLayer, _ := NewDatabaseLayer()
pkg/doc/topics/layers-guide.md:1458:    loggingLayer, _ := NewLoggingLayer()
pkg/doc/topics/layers-guide.md:1461:        cmds.WithLayersList(serverLayer, databaseLayer, loggingLayer))
pkg/doc/topics/layers-guide.md:1466:    // Verify all layers are present
pkg/doc/topics/layers-guide.md:1467:    layers := command.GetLayers()
pkg/doc/topics/layers-guide.md:1468:    assert.Len(t, layers, 3)
pkg/doc/topics/layers-guide.md:1470:    // Verify no parameter conflicts
pkg/doc/topics/layers-guide.md:1472:    for _, layer := range layers {
pkg/doc/topics/layers-guide.md:1473:        for paramName := range layer.GetParameterDefinitions() {
pkg/doc/topics/layers-guide.md:1475:                "Parameter %s defined in multiple layers", paramName)
pkg/doc/topics/layers-guide.md:1482:### Testing Parameter Resolution
pkg/doc/topics/layers-guide.md:1484:Test parameter value resolution from different sources:
pkg/doc/topics/layers-guide.md:1487:func TestParameterResolution(t *testing.T) {
pkg/doc/topics/layers-guide.md:1488:    // Create test command with layers
pkg/doc/topics/layers-guide.md:1493:    parsedLayers, err := command.ParseLayers(args)
pkg/doc/topics/layers-guide.md:1497:    dbLayer, ok := parsedLayers.Get("database")
pkg/doc/topics/layers-guide.md:1500:    dbHost, ok := dbLayer.GetParameter("db-host")
pkg/doc/topics/layers-guide.md:1504:    dbPort, ok := dbLayer.GetParameter("db-port")
pkg/doc/topics/layers-guide.md:1510:    err = parsedLayers.InitializeStruct("database", dbSettings)
pkg/doc/topics/layers-guide.md:1520:    parsedLayers, err := command.ParseLayers([]string{})
pkg/doc/topics/layers-guide.md:1524:    dbLayer, _ := parsedLayers.Get("database")
pkg/doc/topics/layers-guide.md:1525:    dbHost, _ := dbLayer.GetParameter("db-host")
pkg/doc/topics/layers-guide.md:1528:    dbPort, _ := dbLayer.GetParameter("db-port")
pkg/doc/topics/layers-guide.md:1531:    loggingLayer, _ := parsedLayers.Get("logging")
pkg/doc/topics/layers-guide.md:1532:    logLevel, _ := loggingLayer.GetParameter("log-level")
pkg/doc/topics/layers-guide.md:1537:### Testing Layer Builders and Dynamic Composition
pkg/doc/topics/layers-guide.md:1539:Test builder patterns and conditional layer inclusion:
pkg/doc/topics/layers-guide.md:1542:func TestDatabaseLayerBuilder(t *testing.T) {
pkg/doc/topics/layers-guide.md:1543:    // Test basic layer
pkg/doc/topics/layers-guide.md:1544:    basicLayer, err := NewDatabaseLayerBuilder().Build()
pkg/doc/topics/layers-guide.md:1547:    basicParams := basicLayer.GetParameterDefinitions()
pkg/doc/topics/layers-guide.md:1552:    // Test layer with SSL
pkg/doc/topics/layers-guide.md:1553:    sslLayer, err := NewDatabaseLayerBuilder().WithSSL().Build()
pkg/doc/topics/layers-guide.md:1556:    sslParams := sslLayer.GetParameterDefinitions()
pkg/doc/topics/layers-guide.md:1561:    // Test layer with connection pool
pkg/doc/topics/layers-guide.md:1562:    poolLayer, err := NewDatabaseLayerBuilder().WithConnectionPool().Build()
pkg/doc/topics/layers-guide.md:1565:    poolParams := poolLayer.GetParameterDefinitions()
pkg/doc/topics/layers-guide.md:1570:func TestConditionalLayerComposition(t *testing.T) {
pkg/doc/topics/layers-guide.md:1576:    assert.Len(t, basicCmd.GetLayers(), 1) // Only logging layer
pkg/doc/topics/layers-guide.md:1581:    assert.Len(t, cacheCmd.GetLayers(), 2) // Logging + cache layers
pkg/doc/topics/layers-guide.md:1586:    assert.Len(t, fullCmd.GetLayers(), 4) // All layers
pkg/doc/topics/layers-guide.md:1590:This comprehensive testing approach ensures layers work correctly individually and in composition, parameter resolution functions properly across different sources, and dynamic layer construction produces expected results.
pkg/cmds/alias/alias.go:136:func (a *CommandAlias) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {
pkg/cmds/alias/alias.go:144:	return glazeCommand.RunIntoGlazeProcessor(ctx, parsedLayers, gp)
pkg/cmds/alias/alias.go:147:func (a *CommandAlias) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {
pkg/cmds/alias/alias.go:155:	return writerCommand.RunIntoWriter(ctx, parsedLayers, w)
pkg/cmds/alias/alias.go:177:	newLayers := s.Layers.Clone()
pkg/cmds/alias/alias.go:184:		Layers:         newLayers,
pkg/cmds/fields/test-data/parameters_test.yaml:1:#  ParameterTypeString         ParameterType = "string"
pkg/cmds/fields/test-data/parameters_test.yaml:2:#  ParameterTypeStringFromFile ParameterType = "stringFromFile"
pkg/cmds/fields/test-data/parameters_test.yaml:3:#  ParameterTypeObjectListFromFile ParameterType = "objectListFromFile"
pkg/cmds/fields/test-data/parameters_test.yaml:4:#  ParameterTypeObjectFromFile     ParameterType = "objectFromFile"
pkg/cmds/fields/test-data/parameters_test.yaml:5:#  // ParameterTypeKeyValue signals either a string with comma separate key-value options, or when beginning with @, a file with key-value options
pkg/cmds/fields/test-data/parameters_test.yaml:6:#  ParameterTypeKeyValue    ParameterType = "keyValue"
pkg/cmds/fields/test-data/parameters_test.yaml:7:#  ParameterTypeInteger     ParameterType = "int"
pkg/cmds/fields/test-data/parameters_test.yaml:8:#  ParameterTypeFloat       ParameterType = "float"
pkg/cmds/fields/test-data/parameters_test.yaml:9:#  ParameterTypeBool        ParameterType = "bool"
pkg/cmds/fields/test-data/parameters_test.yaml:10:#  ParameterTypeDate        ParameterType = "date"
pkg/cmds/fields/test-data/parameters_test.yaml:11:#  ParameterTypeStringList  ParameterType = "stringList"
pkg/cmds/fields/test-data/parameters_test.yaml:12:#  ParameterTypeIntegerList ParameterType = "intList"
pkg/cmds/fields/test-data/parameters_test.yaml:13:#  ParameterTypeFloatList   ParameterType = "floatList"
pkg/cmds/fields/test-data/parameters_test.yaml:14:#  ParameterTypeChoice      ParameterType = "choice"
pkg/cmds/fields/test-data/parameters_test.yaml:15:#  ParameterTypeChoiceList  ParameterType = "choiceList"
pkg/cmds/layout/layout.go:24:	// These can be specified to override the values read from the flag / layer parameter definition
pkg/cmds/sources/profiles.go:20:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/profiles.go:21:			err := next(layers_, parsedLayers)
pkg/cmds/sources/profiles.go:57:			//   layer1:
pkg/cmds/sources/profiles.go:58:			//     parameterName: parameterValue
pkg/cmds/sources/profiles.go:59:			//   layer2:
pkg/cmds/sources/profiles.go:60:			//     parameterName: parameterValue
pkg/cmds/sources/profiles.go:70:				return updateFromMap(layers_, parsedLayers, profileMap, options...)
pkg/cmds/sources/profiles.go:107:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/profiles.go:108:			err := next(layers_, parsedLayers)
pkg/cmds/sources/profiles.go:148:			return updateFromMap(layers_, parsedLayers, profileMap, config.ParseOptions...)
pkg/cmds/sources/profiles.go:223:	//   layer1:
pkg/cmds/sources/profiles.go:224:	//     parameterName: parameterValue
pkg/cmds/sources/profiles.go:225:	//   layer2:
pkg/cmds/sources/profiles.go:226:	//     parameterName: parameterValue
pkg/cmds/sources/update_test.go:15:	// Define a layer with a prefix so env keys are: PREFIX + "_" + UPPER(prefix+name)
pkg/cmds/sources/update_test.go:16:	cfgLayer, err := schema.NewSection("cfg", "Config",
pkg/cmds/sources/update_test.go:33:	pl := schema.NewSchema(schema.WithSections(cfgLayer))
pkg/cmds/sources/update_test.go:75:	layer, ok := parsed.Get("cfg")
pkg/cmds/sources/update_test.go:79:		v, ok := layer.Parameters.Get(name)
pkg/cmds/sources/update_test.go:80:		require.True(t, ok, "parameter %s should be set", name)
pkg/cmds/sources/update_test.go:101:	vp, ok := layer.Parameters.Get("verbose")
pkg/cmds/sources/update_test.go:117:	cfgLayer, err := schema.NewSection("cfg", "Config",
pkg/cmds/sources/update_test.go:125:	pl := schema.NewSchema(schema.WithSections(cfgLayer))
pkg/cmds/sources/whitelist.go:8:// WhitelistLayersHandler only leaves the specified layers from the given ParameterLayers.
pkg/cmds/sources/whitelist.go:9:// It takes a slice of layer slugs, and deletes any layers in the ParameterLayers
pkg/cmds/sources/whitelist.go:11:func WhitelistLayersHandler(slugs []string) HandlerFunc {
pkg/cmds/sources/whitelist.go:16:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:18:		layers_.ForEach(func(key string, l schema.Section) {
pkg/cmds/sources/whitelist.go:24:			layers_.Delete(key)
pkg/cmds/sources/whitelist.go:30:func WhitelistLayerParametersHandler(parameters_ map[string][]string) HandlerFunc {
pkg/cmds/sources/whitelist.go:31:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:32:		layersToDelete := []string{}
pkg/cmds/sources/whitelist.go:33:		layersToUpdate := map[string]schema.Section{}
pkg/cmds/sources/whitelist.go:34:		layers_.ForEach(func(key string, l schema.Section) {
pkg/cmds/sources/whitelist.go:35:			if _, ok := parameters_[key]; !ok {
pkg/cmds/sources/whitelist.go:36:				layersToDelete = append(layersToDelete, key)
pkg/cmds/sources/whitelist.go:40:			parametersToKeep := map[string]interface{}{}
pkg/cmds/sources/whitelist.go:41:			for _, p := range parameters_[key] {
pkg/cmds/sources/whitelist.go:42:				parametersToKeep[p] = nil
pkg/cmds/sources/whitelist.go:44:			layersToUpdate[key] = schema.NewWhitelistParameterLayer(l, parametersToKeep)
pkg/cmds/sources/whitelist.go:46:		for _, key := range layersToDelete {
pkg/cmds/sources/whitelist.go:47:			layers_.Delete(key)
pkg/cmds/sources/whitelist.go:49:		for key, l := range layersToUpdate {
pkg/cmds/sources/whitelist.go:50:			layers_.Set(key, l)
pkg/cmds/sources/whitelist.go:56:func WhitelistLayers(slugs []string) Middleware {
pkg/cmds/sources/whitelist.go:58:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:59:			err := next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:64:			return WhitelistLayersHandler(slugs)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:69:func WhitelistLayersFirst(slugs []string) Middleware {
pkg/cmds/sources/whitelist.go:71:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:72:			err := WhitelistLayersHandler(slugs)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:77:			return next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:82:func WhitelistLayerParameters(parameters_ map[string][]string) Middleware {
pkg/cmds/sources/whitelist.go:84:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:85:			err := next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:90:			return WhitelistLayerParametersHandler(parameters_)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:95:func WhitelistLayerParametersFirst(parameters_ map[string][]string) Middleware {
pkg/cmds/sources/whitelist.go:97:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:98:			err := WhitelistLayerParametersHandler(parameters_)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:103:			return next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:108:// BlacklistLayersHandler removes the specified layers from the given ParameterLayers.
pkg/cmds/sources/whitelist.go:109:// It takes a slice of layer slugs, and deletes any layers in the ParameterLayers
pkg/cmds/sources/whitelist.go:111:func BlacklistLayersHandler(slugs []string) HandlerFunc {
pkg/cmds/sources/whitelist.go:116:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:118:		layers_.ForEach(func(key string, l schema.Section) {
pkg/cmds/sources/whitelist.go:124:			layers_.Delete(key)
pkg/cmds/sources/whitelist.go:130:func BlacklistLayerParametersHandler(parameters_ map[string][]string) HandlerFunc {
pkg/cmds/sources/whitelist.go:131:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:132:		layersToDelete := []string{}
pkg/cmds/sources/whitelist.go:133:		layersToUpdate := map[string]schema.Section{}
pkg/cmds/sources/whitelist.go:134:		layers_.ForEach(func(key string, l schema.Section) {
pkg/cmds/sources/whitelist.go:135:			if _, ok := parameters_[key]; !ok {
pkg/cmds/sources/whitelist.go:139:			parametersToKeep := map[string]interface{}{}
pkg/cmds/sources/whitelist.go:140:			for _, p := range parameters_[key] {
pkg/cmds/sources/whitelist.go:141:				parametersToKeep[p] = nil
pkg/cmds/sources/whitelist.go:143:			layersToUpdate[key] = schema.NewBlacklistParameterLayer(l, parametersToKeep)
pkg/cmds/sources/whitelist.go:145:		for _, key := range layersToDelete {
pkg/cmds/sources/whitelist.go:146:			layers_.Delete(key)
pkg/cmds/sources/whitelist.go:148:		for key, l := range layersToUpdate {
pkg/cmds/sources/whitelist.go:149:			layers_.Set(key, l)
pkg/cmds/sources/whitelist.go:155:// BlacklistLayers is a middleware that removes the given layers from ParameterLayers after running `next`.
pkg/cmds/sources/whitelist.go:156:func BlacklistLayers(slugs []string) Middleware {
pkg/cmds/sources/whitelist.go:158:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:159:			err := next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:164:			return BlacklistLayersHandler(slugs)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:169:// BlacklistLayersFirst is a middleware that removes the given layers from ParameterLayers before running `next`.
pkg/cmds/sources/whitelist.go:170:func BlacklistLayersFirst(slugs []string) Middleware {
pkg/cmds/sources/whitelist.go:172:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:173:			err := next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:178:			return BlacklistLayersHandler(slugs)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:183:// BlacklistLayerParameters is a middleware that removes the given parameters from ParameterLayers after running `next`.
pkg/cmds/sources/whitelist.go:184:func BlacklistLayerParameters(parameters_ map[string][]string) Middleware {
pkg/cmds/sources/whitelist.go:186:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:187:			err := next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:192:			return BlacklistLayerParametersHandler(parameters_)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:197:// BlacklistLayerParametersFirst is a middleware that removes the given parameters from ParameterLayers before running `next`.
pkg/cmds/sources/whitelist.go:198:func BlacklistLayerParametersFirst(parameters_ map[string][]string) Middleware {
pkg/cmds/sources/whitelist.go:200:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:201:			err := BlacklistLayerParametersHandler(parameters_)(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:206:			return next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:211:// WrapWithLayerModifyingHandler wraps a middleware that modifies the layers
pkg/cmds/sources/whitelist.go:212:// with additional middlewares. It clones the original layers, calls the
pkg/cmds/sources/whitelist.go:213:// layer modifying middleware, chains any additional middlewares, calls
pkg/cmds/sources/whitelist.go:214:// next with the original layers, and returns any errors.
pkg/cmds/sources/whitelist.go:217:// restricted subset of layers. However, the normal set of middlewares is allowed
pkg/cmds/sources/whitelist.go:219:func WrapWithLayerModifyingHandler(m HandlerFunc, nextMiddlewares ...Middleware) Middleware {
pkg/cmds/sources/whitelist.go:221:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/whitelist.go:222:			err := next(layers_, parsedLayers)
pkg/cmds/sources/whitelist.go:229:			clonedLayers := layers_.Clone()
pkg/cmds/sources/whitelist.go:230:			err = m(clonedLayers, parsedLayers)
pkg/cmds/sources/whitelist.go:235:			err = chain(Identity)(clonedLayers, parsedLayers)
pkg/cmds/sources/whitelist.go:245:// WrapWithWhitelistedLayers wraps a middleware that restricts layers
pkg/cmds/sources/whitelist.go:248:// certain restricted layers.
pkg/cmds/sources/whitelist.go:249:func WrapWithWhitelistedLayers(slugs []string, nextMiddlewares ...Middleware) Middleware {
pkg/cmds/sources/whitelist.go:250:	return WrapWithLayerModifyingHandler(WhitelistLayersHandler(slugs), nextMiddlewares...)
pkg/cmds/sources/whitelist.go:253:func WrapWithWhitelistedParameterLayers(parameters_ map[string][]string, nextMiddlewares ...Middleware) Middleware {
pkg/cmds/sources/whitelist.go:254:	return WrapWithLayerModifyingHandler(WhitelistLayerParametersHandler(parameters_), nextMiddlewares...)
pkg/cmds/sources/whitelist.go:257:// WrapWithBlacklistedLayers wraps a middleware that restricts layers
pkg/cmds/sources/whitelist.go:260:// certain restricted layers.
pkg/cmds/sources/whitelist.go:261:func WrapWithBlacklistedLayers(slugs []string, nextMiddlewares ...Middleware) Middleware {
pkg/cmds/sources/whitelist.go:262:	return WrapWithLayerModifyingHandler(BlacklistLayersHandler(slugs), nextMiddlewares...)
pkg/cmds/sources/whitelist.go:265:func WrapWithBlacklistedParameterLayers(parameters_ map[string][]string, nextMiddlewares ...Middleware) Middleware {
pkg/cmds/sources/whitelist.go:266:	return WrapWithLayerModifyingHandler(BlacklistLayerParametersHandler(parameters_), nextMiddlewares...)
pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:17:	// Create a simple layer
pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:18:	layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:20:		"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:27:	pls := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:33:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:34:			TargetParameter: "api-key",
pkg/helpers/markdown/markdown.go:100:// them based on the `withQuotes` parameter to decide on the inclusion of the enclosing ``` marks.
pkg/cmds/sources/middlewares.go:8:type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error
pkg/cmds/sources/middlewares.go:12:// layer middlewares:
pkg/cmds/sources/middlewares.go:13:// - [x] whitelist (layers, parameters)
pkg/cmds/sources/middlewares.go:14:// - [x] blacklist (layers, parameters)
pkg/cmds/sources/middlewares.go:18:// - [x] from parameter definition defaults
pkg/cmds/sources/middlewares.go:22:func Identity(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/middlewares.go:39:// Finally, it calls the resulting handler with the provided layers and parsedLayers.
pkg/cmds/sources/middlewares.go:44:// [f1, f2, f3] will be executed as f1(f2(f3(handler)))(layers_, parsedLayers).
pkg/cmds/sources/middlewares.go:49://   - if all you do is modify the parsedLayers, call `next` first.
pkg/cmds/sources/middlewares.go:50://     This means that parsedLayers will be modified in the order of the middlewares.
pkg/cmds/sources/middlewares.go:53://   - if you want to modify the layers before parsing, use the
pkg/cmds/sources/middlewares.go:55://     get the newly updated ParameterLayers and thus potentially restrict which parameters they parse.
pkg/cmds/sources/middlewares.go:56:func Execute(layers_ *schema.Schema, parsedLayers *values.Values, middlewares ...Middleware) error {
pkg/cmds/sources/middlewares.go:66:	clonedLayers := layers_.Clone()
pkg/cmds/sources/middlewares.go:67:	return handler(clonedLayers, parsedLayers)
pkg/cmds/fields/test-data/gather-fields.yaml:3:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:23:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:40:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:60:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:79:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:99:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:117:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:135:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:151:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:168:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:184:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:198:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:217:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:225:  expectedError: "unknown parameter type foobar"
pkg/cmds/fields/test-data/gather-fields.yaml:229:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:241:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:253:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:263:- title: "Test with choice parameters"
pkg/cmds/fields/test-data/gather-fields.yaml:265:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:279:- title: "Test with valid choice parameter"
pkg/cmds/fields/test-data/gather-fields.yaml:281:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:296:- title: "Test with empty choice parameter"
pkg/cmds/fields/test-data/gather-fields.yaml:297:  description: "Ensure that providing an empty string for a choice parameter results in an error."
pkg/cmds/fields/test-data/gather-fields.yaml:298:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:313:# - title: "Test list-type parameter"
pkg/cmds/fields/test-data/gather-fields.yaml:314:#   description: "Ensure that the list-type parameter is correctly parsed"
pkg/cmds/fields/test-data/gather-fields.yaml:315:#   parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:330:# - title: "Test with empty list-type parameter"
pkg/cmds/fields/test-data/gather-fields.yaml:331:#   description: "Ensure that an empty list is handled correctly for list-type parameters."
pkg/cmds/fields/test-data/gather-fields.yaml:332:#   parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:342:- title: "Test with mixed types in list-type parameter"
pkg/cmds/fields/test-data/gather-fields.yaml:344:  parameterDefs:
pkg/cmds/fields/test-data/gather-fields.yaml:351:  expectedError: "List-type parameter 'scores' contains invalid types, expected float list."
pkg/cmds/fields/test-data/gather-fields.yaml:353:- title: "Test with single value for list-type parameter"
pkg/cmds/fields/test-data/gather-fields.yaml:354:  description: "Ensure that a single value is handled correctly for list-type parameters."
pkg/cmds/fields/test-data/gather-fields.yaml:355:  parameterDefs:
pkg/cmds/sources/custom-profiles_test.go:36:	// Create parameter definitions
pkg/cmds/sources/custom-profiles_test.go:50:	// Create layers
pkg/cmds/sources/custom-profiles_test.go:51:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(
pkg/cmds/sources/custom-profiles_test.go:56:	parameterLayers := schema.NewSchema()
pkg/cmds/sources/custom-profiles_test.go:57:	parameterLayers.Set("config", layer)
pkg/cmds/sources/custom-profiles_test.go:59:	parsedLayers := values.New()
pkg/cmds/sources/custom-profiles_test.go:69:	err = handler(parameterLayers, parsedLayers)
pkg/cmds/sources/custom-profiles_test.go:73:	parsedLayer, ok := parsedLayers.Get("config")
pkg/cmds/sources/custom-profiles_test.go:75:	require.NotNil(t, parsedLayer)
pkg/cmds/sources/custom-profiles_test.go:77:	hostParamParsed, ok := parsedLayer.Parameters.Get("host")
pkg/cmds/sources/custom-profiles_test.go:82:	portParamParsed, ok := parsedLayer.Parameters.Get("port")
pkg/cmds/sources/custom-profiles_test.go:87:	debugParamParsed, ok := parsedLayer.Parameters.Get("debug")
pkg/cmds/sources/custom-profiles_test.go:114:	// Create parameter definitions
pkg/cmds/sources/custom-profiles_test.go:128:	// Create layers
pkg/cmds/sources/custom-profiles_test.go:129:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(
pkg/cmds/sources/custom-profiles_test.go:134:	parameterLayers := schema.NewSchema()
pkg/cmds/sources/custom-profiles_test.go:135:	parameterLayers.Set("config", layer)
pkg/cmds/sources/custom-profiles_test.go:137:	parsedLayers := values.New()
pkg/cmds/sources/custom-profiles_test.go:147:	err = handler(parameterLayers, parsedLayers)
pkg/cmds/sources/custom-profiles_test.go:151:	parsedLayer, ok := parsedLayers.Get("config")
pkg/cmds/sources/custom-profiles_test.go:153:	require.NotNil(t, parsedLayer)
pkg/cmds/sources/custom-profiles_test.go:155:	hostParamParsed, ok := parsedLayer.Parameters.Get("host")
pkg/cmds/sources/custom-profiles_test.go:160:	portParamParsed, ok := parsedLayer.Parameters.Get("port")
pkg/cmds/sources/custom-profiles_test.go:165:	debugParamParsed, ok := parsedLayer.Parameters.Get("debug")
pkg/cmds/sources/custom-profiles_test.go:172:	// Create parameter definitions
pkg/cmds/sources/custom-profiles_test.go:178:	// Create layers
pkg/cmds/sources/custom-profiles_test.go:179:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(
pkg/cmds/sources/custom-profiles_test.go:184:	parameterLayers := schema.NewSchema()
pkg/cmds/sources/custom-profiles_test.go:185:	parameterLayers.Set("config", layer)
pkg/cmds/sources/custom-profiles_test.go:187:	parsedLayers := values.New()
pkg/cmds/sources/custom-profiles_test.go:197:	err = handler(parameterLayers, parsedLayers)
pkg/cmds/sources/custom-profiles_test.go:216:	// Create parameter definitions
pkg/cmds/sources/custom-profiles_test.go:222:	// Create layers
pkg/cmds/sources/custom-profiles_test.go:223:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(
pkg/cmds/sources/custom-profiles_test.go:228:	parameterLayers := schema.NewSchema()
pkg/cmds/sources/custom-profiles_test.go:229:	parameterLayers.Set("config", layer)
pkg/cmds/sources/custom-profiles_test.go:231:	parsedLayers := values.New()
pkg/cmds/sources/custom-profiles_test.go:242:	err = handler(parameterLayers, parsedLayers)
pkg/helpers/maps/maps.go:74:// GlazedStructToMap converts a struct pointer to a map of parameter names to values.
pkg/helpers/maps/maps.go:91:		parameterName, ok := field.Tag.Lookup("glazed")
pkg/helpers/maps/maps.go:97:		ret[parameterName] = value
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:16:	// Create test layers
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:17:	layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:19:		"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:25:	testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:41:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:42:			TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:47:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:71:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:85:	// Create test layers
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:86:	layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:88:		"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:94:	testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:110:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:111:			TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:115:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:116:			TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:121:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:134:	t.Run("no collision - different parameters", func(t *testing.T) {
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:135:		layerMulti, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:137:			"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:144:		testLayersMulti := schema.NewSchema(schema.WithSections(layerMulti))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:149:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:150:				TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:154:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:155:				TargetParameter: "threshold",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:170:		mapper, err := pm.NewConfigMapper(testLayersMulti, rulesMulti...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:175:		// Should not error because different parameters
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:186:		// Create a layer with a prefix
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:187:		layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:189:			"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:196:		testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:201:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:202:				TargetParameter: "api-key", // Without prefix
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:214:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:223:		// Create a layer with a prefix
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:224:		layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:226:			"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:234:		testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:239:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:240:				TargetParameter: "api-key", // This will resolve to demo-api-key which doesn't exist
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:246:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:255:	t.Run("error message for parameter with prefix already included (compile-time)", func(t *testing.T) {
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:256:		// Create a layer with a prefix
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:257:		layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:259:			"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:266:		testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:271:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:272:				TargetParameter: "demo-api-key", // With prefix already
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:276:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:289:		layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:291:			"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:297:		testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:303:				TargetLayer: "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:305:					{Source: "{env}.api_key", TargetParameter: "{env}-api-key"},
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:315:		_, _ = pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:326:		layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:328:			"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:334:		testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:353:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:354:				TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:358:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:359:				TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:363:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:374:		layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:376:			"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:383:		testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:399:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:400:				TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:404:				TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:405:				TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:409:		mapper, err := pm.NewConfigMapper(testLayers, rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:416:		// Error should mention the resolved parameter name (with prefix)
pkg/cmds/fields/test-data/parameters_validity_test.yaml:1:#  ParameterTypeString         ParameterType = "string"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:2:#  ParameterTypeStringFromFile ParameterType = "stringFromFile"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:3:#  ParameterTypeObjectListFromFile ParameterType = "objectListFromFile"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:4:#  ParameterTypeObjectFromFile     ParameterType = "objectFromFile"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:5:#  // ParameterTypeKeyValue signals either a string with comma separate key-value options, or when beginning with @, a file with key-value options
pkg/cmds/fields/test-data/parameters_validity_test.yaml:6:#  ParameterTypeKeyValue    ParameterType = "keyValue"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:7:#  ParameterTypeInteger     ParameterType = "int"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:8:#  ParameterTypeFloat       ParameterType = "float"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:9:#  ParameterTypeBool        ParameterType = "bool"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:10:#  ParameterTypeDate        ParameterType = "date"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:11:#  ParameterTypeStringList  ParameterType = "stringList"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:12:#  ParameterTypeIntegerList ParameterType = "intList"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:13:#  ParameterTypeFloatList   ParameterType = "floatList"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:14:#  ParameterTypeChoice      ParameterType = "choice"
pkg/cmds/fields/test-data/parameters_validity_test.yaml:15:#  ParameterTypeChoiceList  ParameterType = "choiceList"
pkg/cmds/sources/cobra.go:13:// FromCobra creates a middleware that parses parameter values from a Cobra command.
pkg/cmds/sources/cobra.go:16:// It iterates through each layer, and if the layer implements the CobraSection interface,
pkg/cmds/sources/cobra.go:17:// it parses the layer's parameters from the Cobra command.
pkg/cmds/sources/cobra.go:24:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/cobra.go:25:			err := next(layers_, parsedLayers)
pkg/cmds/sources/cobra.go:30:			err = layers_.ForEachE(func(key string, l schema.Section) error {
pkg/cmds/sources/cobra.go:33:						"layer":          l.GetName(),
pkg/cmds/sources/cobra.go:34:						"layer_slug":     l.GetSlug(),
pkg/cmds/sources/cobra.go:35:						"layer_prefix":   l.GetPrefix(),
pkg/cmds/sources/cobra.go:40:				parsedLayer := parsedLayers.GetOrCreate(l)
pkg/cmds/sources/cobra.go:42:				if cobraLayer, ok := l.(schema.CobraSection); ok {
pkg/cmds/sources/cobra.go:43:					cobraLayer, err := cobraLayer.ParseLayerFromCobraCommand(cmd, options_...)
pkg/cmds/sources/cobra.go:48:					_, err = parsedLayer.Parameters.Merge(cobraLayer.Parameters)
pkg/cmds/sources/cobra.go:65:// FromArgs creates a middleware that parses positional arguments for the default layer.
pkg/cmds/sources/cobra.go:74:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/cobra.go:75:			err := next(layers_, parsedLayers)
pkg/cmds/sources/cobra.go:80:			if defaultLayer, ok := layers_.Get(schema.DefaultSlug); ok {
pkg/cmds/sources/cobra.go:81:				pds := defaultLayer.GetDefinitions()
pkg/cmds/sources/cobra.go:87:				parsedLayer := parsedLayers.GetOrCreate(defaultLayer)
pkg/cmds/sources/cobra.go:88:				_, err = parsedLayer.Parameters.Merge(ps_)
pkg/cmds/sources/cobra.go:101:type ConfigFilesResolver func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]string, error)
pkg/cmds/sources/cobra.go:103:// LoadParametersFromResolvedFilesForCobra loads parameters from a resolver-provided list of files
pkg/cmds/sources/cobra.go:105:func LoadParametersFromResolvedFilesForCobra(
pkg/cmds/sources/cobra.go:112:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/cobra.go:113:			if err := next(layers_, parsedLayers); err != nil {
pkg/cmds/sources/cobra.go:116:			files, err := resolver(parsedLayers, cmd, args)
pkg/cmds/sources/cobra.go:126:			return FromFiles(files, configOpts...)(func(_ *schema.Schema, _ *values.Values) error { return nil })(layers_, parsedLayers)
pkg/cmds/sources/cobra.go:131:// GatherFlagsFromViper creates a middleware that loads parameter values from Viper configuration.
pkg/cmds/sources/cobra.go:134:// It iterates through each layer, gathering flags from Viper for all parameters in that layer.
pkg/cmds/sources/cobra.go:146:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/cobra.go:148:			err := next(layers_, parsedLayers)
pkg/cmds/sources/cobra.go:152:			err = layers_.ForEachE(func(key string, l schema.Section) error {
pkg/cmds/sources/cobra.go:156:						"layer":          l.GetName(),
pkg/cmds/sources/cobra.go:157:						"layer_slug":     l.GetSlug(),
pkg/cmds/sources/cobra.go:158:						"layer_prefix":   l.GetPrefix(),
pkg/cmds/sources/cobra.go:163:				parsedLayer := parsedLayers.GetOrCreate(l)
pkg/cmds/sources/cobra.go:164:				parameterDefinitions := l.GetDefinitions()
pkg/cmds/sources/cobra.go:167:				ps, err := parameterDefinitions.GatherFlagsFromViper(true, prefix, options_...)
pkg/cmds/sources/cobra.go:172:				_, err = parsedLayer.Parameters.Merge(ps)
pkg/cmds/sources/cobra.go:189:// GatherSpecificFlagsFromViper creates a middleware that loads specific parameter values from Viper configuration.
pkg/cmds/sources/cobra.go:192:// It's useful when you want to selectively load certain parameters from Viper while leaving others untouched.
pkg/cmds/sources/cobra.go:207:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {
pkg/cmds/sources/cobra.go:208:			err := next(layers_, parsedLayers)
pkg/cmds/sources/cobra.go:212:			err = layers_.ForEachE(func(key string, l schema.Section) error {
pkg/cmds/sources/cobra.go:216:						"layer": l.GetName(),
pkg/cmds/sources/cobra.go:220:				parsedLayer := parsedLayers.GetOrCreate(l)
pkg/cmds/sources/cobra.go:221:				parameterDefinitions := l.GetDefinitions()
pkg/cmds/sources/cobra.go:224:				// Filter the parameter definitions based on the specified flags
pkg/cmds/sources/cobra.go:227:					if pd, ok := parameterDefinitions.Get(flag); ok {
pkg/cmds/sources/cobra.go:237:				_, err = parsedLayer.Parameters.Merge(ps)
pkg/cmds/sources/config-mapper-interface.go:3:// ConfigMapper is an interface that can map raw config data to layer maps.
pkg/settings/settings_jq.go:21:type JqParameterLayer struct {
pkg/settings/settings_jq.go:25:func NewJqParameterLayer(options ...schema.SectionOption) (*JqParameterLayer, error) {
pkg/settings/settings_jq.go:26:	ret := &JqParameterLayer{}
pkg/settings/settings_jq.go:27:	layer, err := schema.NewSectionFromYAML(jqFlagsYaml, options...)
pkg/settings/settings_jq.go:29:		return nil, errors.Wrap(err, "Failed to create jq parameter layer")
pkg/settings/settings_jq.go:31:	ret.SectionImpl = layer
pkg/settings/settings_jq.go:35:func (f *JqParameterLayer) Clone() schema.Section {
pkg/settings/settings_jq.go:36:	return &JqParameterLayer{
pkg/settings/settings_jq.go:41:func NewJqSettingsFromParameters(glazedLayer *values.SectionValues) (*JqSettings, error) {
pkg/settings/settings_jq.go:43:	err := glazedLayer.Parameters.InitializeStruct(s)
pkg/settings/settings_jq.go:45:		return nil, errors.Wrap(err, "Failed to initialize jq settings from parameters")
pkg/cmds/schema/layer_test.go:12:// Helper function to create a parameter layer
pkg/cmds/schema/layer_test.go:13:func createParameterLayer(t *testing.T, slug, name string, paramDefs ...*fields.Definition) Section {
pkg/cmds/schema/layer_test.go:14:	layer, err := NewSection(slug, name, WithFields(paramDefs...))
pkg/cmds/schema/layer_test.go:16:	require.NotNil(t, layer)
pkg/cmds/schema/layer_test.go:17:	return layer
pkg/cmds/schema/layer_test.go:20:func TestNewParameterLayers(t *testing.T) {
pkg/cmds/schema/layer_test.go:21:	layers := NewSchema()
pkg/cmds/schema/layer_test.go:22:	assert.NotNil(t, layers)
pkg/cmds/schema/layer_test.go:23:	assert.Equal(t, 0, layers.Len())
pkg/cmds/schema/layer_test.go:26:func TestParameterLayersSubset(t *testing.T) {
pkg/cmds/schema/layer_test.go:27:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:28:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:29:	layer3 := createParameterLayer(t, "layer3", "Layer 3")
pkg/cmds/schema/layer_test.go:31:	layers := NewSchema(WithSections(layer1, layer2, layer3))
pkg/cmds/schema/layer_test.go:33:	subset := layers.Subset("layer1", "layer3")
pkg/cmds/schema/layer_test.go:36:	val, present := subset.Get("layer1")
pkg/cmds/schema/layer_test.go:39:	val, present = subset.Get("layer2")
pkg/cmds/schema/layer_test.go:42:	val, present = subset.Get("layer3")
pkg/cmds/schema/layer_test.go:47:func TestParameterLayersForEach(t *testing.T) {
pkg/cmds/schema/layer_test.go:48:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:49:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:51:	layers := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:54:	layers.ForEach(func(key string, p Section) {
pkg/cmds/schema/layer_test.go:56:		assert.Contains(t, []string{"layer1", "layer2"}, key)
pkg/cmds/schema/layer_test.go:62:func TestParameterLayersForEachE(t *testing.T) {
pkg/cmds/schema/layer_test.go:63:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:64:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:66:	layers := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:69:	err := layers.ForEachE(func(key string, p Section) error {
pkg/cmds/schema/layer_test.go:78:func TestParameterLayersAppendLayers(t *testing.T) {
pkg/cmds/schema/layer_test.go:79:	layers := NewSchema()
pkg/cmds/schema/layer_test.go:80:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:81:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:83:	layers.AppendLayers(layer1, layer2)
pkg/cmds/schema/layer_test.go:85:	assert.Equal(t, 2, layers.Len())
pkg/cmds/schema/layer_test.go:86:	val, present := layers.Get("layer1")
pkg/cmds/schema/layer_test.go:87:	assert.Equal(t, layer1, val)
pkg/cmds/schema/layer_test.go:89:	val, present = layers.Get("layer2")
pkg/cmds/schema/layer_test.go:90:	assert.Equal(t, layer2, val)
pkg/cmds/schema/layer_test.go:94:func TestParameterLayersPrependLayers(t *testing.T) {
pkg/cmds/schema/layer_test.go:95:	layer0 := createParameterLayer(t, "layer0", "Layer 0")
pkg/cmds/schema/layer_test.go:97:	layers := NewSchema(
pkg/cmds/schema/layer_test.go:98:		WithSections(layer0),
pkg/cmds/schema/layer_test.go:100:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:101:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:103:	layers.PrependLayers(layer1, layer2)
pkg/cmds/schema/layer_test.go:105:	assert.Equal(t, 3, layers.Len())
pkg/cmds/schema/layer_test.go:106:	first := layers.Oldest()
pkg/cmds/schema/layer_test.go:107:	assert.Equal(t, "layer1", first.Key)
pkg/cmds/schema/layer_test.go:108:	assert.Equal(t, layer1, first.Value)
pkg/cmds/schema/layer_test.go:110:	assert.Equal(t, "layer2", second.Key)
pkg/cmds/schema/layer_test.go:111:	assert.Equal(t, layer2, second.Value)
pkg/cmds/schema/layer_test.go:113:	assert.Equal(t, "layer0", third.Key)
pkg/cmds/schema/layer_test.go:114:	assert.Equal(t, "Layer 0", third.Value.GetName())
pkg/cmds/schema/layer_test.go:118:func TestParameterLayersMerge(t *testing.T) {
pkg/cmds/schema/layer_test.go:119:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:120:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:121:	layers1 := NewSchema(WithSections(layer1))
pkg/cmds/schema/layer_test.go:122:	layers2 := NewSchema(WithSections(layer2))
pkg/cmds/schema/layer_test.go:124:	merged := layers1.Merge(layers2)
pkg/cmds/schema/layer_test.go:127:	val, present := merged.Get("layer1")
pkg/cmds/schema/layer_test.go:130:	val, present = merged.Get("layer2")
pkg/cmds/schema/layer_test.go:135:func TestParameterLayersAsList(t *testing.T) {
pkg/cmds/schema/layer_test.go:136:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:137:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:138:	layers := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:140:	list := layers.AsList()
pkg/cmds/schema/layer_test.go:143:	assert.Contains(t, list, layer1)
pkg/cmds/schema/layer_test.go:144:	assert.Contains(t, list, layer2)
pkg/cmds/schema/layer_test.go:147:func TestParameterLayersClone(t *testing.T) {
pkg/cmds/schema/layer_test.go:148:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:149:	layers := NewSchema(WithSections(layer1))
pkg/cmds/schema/layer_test.go:151:	cloned := layers.Clone()
pkg/cmds/schema/layer_test.go:153:	assert.Equal(t, layers.Len(), cloned.Len())
pkg/cmds/schema/layer_test.go:154:	v1, p1 := layers.Get("layer1")
pkg/cmds/schema/layer_test.go:157:	v2, p2 := cloned.Get("layer1")
pkg/cmds/schema/layer_test.go:164:func TestParameterLayersGetAllDefinitions(t *testing.T) {
pkg/cmds/schema/layer_test.go:165:	layer1 := createParameterLayer(t, "layer1", "Layer 1",
pkg/cmds/schema/layer_test.go:168:	layer2 := createParameterLayer(t, "layer2", "Layer 2",
pkg/cmds/schema/layer_test.go:172:	layers := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:174:	allDefs := layers.GetAllDefinitions()
pkg/cmds/schema/layer_test.go:185:func TestParameterLayersWithLayers(t *testing.T) {
pkg/cmds/schema/layer_test.go:186:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:187:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:189:	layers := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:191:	assert.Equal(t, 2, layers.Len())
pkg/cmds/schema/layer_test.go:192:	val, present := layers.Get("layer1")
pkg/cmds/schema/layer_test.go:194:	assert.Equal(t, layer1, val)
pkg/cmds/schema/layer_test.go:195:	val, present = layers.Get("layer2")
pkg/cmds/schema/layer_test.go:197:	assert.Equal(t, layer2, val)
pkg/cmds/schema/layer_test.go:200:func TestParameterLayersWithDuplicateSlugs(t *testing.T) {
pkg/cmds/schema/layer_test.go:201:	layer1 := createParameterLayer(t, "duplicate", "Layer 1")
pkg/cmds/schema/layer_test.go:202:	layer2 := createParameterLayer(t, "duplicate", "Layer 2")
pkg/cmds/schema/layer_test.go:204:	layers := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:206:	assert.Equal(t, 1, layers.Len())
pkg/cmds/schema/layer_test.go:207:	val, present := layers.Get("duplicate")
pkg/cmds/schema/layer_test.go:209:	assert.Equal(t, "Layer 2", val.GetName())
pkg/cmds/schema/layer_test.go:212:func TestParameterLayersSubsetWithNonExistentLayers(t *testing.T) {
pkg/cmds/schema/layer_test.go:213:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/schema/layer_test.go:214:	layers := NewSchema(WithSections(layer1))
pkg/cmds/schema/layer_test.go:216:	subset := layers.Subset("layer1", "non_existent")
pkg/cmds/schema/layer_test.go:219:	_, present := subset.Get("layer1")
pkg/cmds/schema/layer_test.go:225:func TestParameterLayersMergeWithOverlappingLayers(t *testing.T) {
pkg/cmds/schema/layer_test.go:226:	layer1 := createParameterLayer(t, "layer1", "Layer 1 - Original")
pkg/cmds/schema/layer_test.go:227:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/schema/layer_test.go:228:	layers1 := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:230:	layer1Duplicate := createParameterLayer(t, "layer1", "Layer 1 - Duplicate")
pkg/cmds/schema/layer_test.go:231:	layer3 := createParameterLayer(t, "layer3", "Layer 3")
pkg/cmds/schema/layer_test.go:232:	layers2 := NewSchema(WithSections(layer1Duplicate, layer3))
pkg/cmds/schema/layer_test.go:234:	merged := layers1.Merge(layers2)
pkg/cmds/schema/layer_test.go:237:	val, present := merged.Get("layer1")
pkg/cmds/schema/layer_test.go:239:	assert.Equal(t, "Layer 1 - Duplicate", val.GetName())
pkg/cmds/schema/layer_test.go:240:	_, present = merged.Get("layer2")
pkg/cmds/schema/layer_test.go:242:	_, present = merged.Get("layer3")
pkg/cmds/schema/layer_test.go:246:func TestParameterLayersWithLargeNumberOfLayers(t *testing.T) {
pkg/cmds/schema/layer_test.go:247:	numLayers := 1000
pkg/cmds/schema/layer_test.go:248:	layers := NewSchema()
pkg/cmds/schema/layer_test.go:250:	for i := 0; i < numLayers; i++ {
pkg/cmds/schema/layer_test.go:251:		layer := createParameterLayer(t, fmt.Sprintf("layer%d", i), fmt.Sprintf("Layer %d", i))
pkg/cmds/schema/layer_test.go:252:		layers.AppendLayers(layer)
pkg/cmds/schema/layer_test.go:255:	assert.Equal(t, numLayers, layers.Len())
pkg/cmds/schema/layer_test.go:256:	_, present := layers.Get("layer0")
pkg/cmds/schema/layer_test.go:258:	_, present = layers.Get(fmt.Sprintf("layer%d", numLayers-1))
pkg/cmds/schema/layer_test.go:262:func TestParameterLayersWithUnicodeLayerNames(t *testing.T) {
pkg/cmds/schema/layer_test.go:263:	layer1 := createParameterLayer(t, "layer1", "Layer 1 - 你好")
pkg/cmds/schema/layer_test.go:264:	layer2 := createParameterLayer(t, "layer2", "Layer 2 - こんにちは")
pkg/cmds/schema/layer_test.go:266:	layers := NewSchema(WithSections(layer1, layer2))
pkg/cmds/schema/layer_test.go:268:	assert.Equal(t, 2, layers.Len())
pkg/cmds/schema/layer_test.go:269:	val, present := layers.Get("layer1")
pkg/cmds/schema/layer_test.go:271:	assert.Equal(t, "Layer 1 - 你好", val.GetName())
pkg/cmds/schema/layer_test.go:272:	val, present = layers.Get("layer2")
pkg/cmds/schema/layer_test.go:274:	assert.Equal(t, "Layer 2 - こんにちは", val.GetName())
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:17:		setupLayers func(t *testing.T) *schema.Schema
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:26:			setupLayers: createTestLayers,
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:30:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:31:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:40:			setupLayers: createTestLayers,
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:44:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:45:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:64:			setupLayers: createTestLayers,
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:68:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:69:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:96:			setupLayers: createTestLayers,
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:100:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:101:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:122:			setupLayers: createTestLayers,
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:126:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:127:					TargetParameter: "threshold",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:146:			setupLayers: func(t *testing.T) *schema.Schema {
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:147:				layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:149:					"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:155:				return schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:160:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:161:					TargetParameter: "enabled",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:180:			setupLayers: func(t *testing.T) *schema.Schema {
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:181:				layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:183:					"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:189:				return schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:194:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:195:					TargetParameter: "{env}-api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:214:			setupLayers: createTestLayers,
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:218:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:219:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:247:			testLayers := tt.setupLayers(t)
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:248:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:275:	testLayers := createTestLayers(t)
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:289:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:290:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:309:			name: "parameter does not exist - shows pattern and layer",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:313:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:314:					TargetParameter: "nonexistent-param",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:326:				"target parameter",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:337:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:360:// TestLayerPrefix tests handling of layer prefixes
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:361:func TestLayerPrefix(t *testing.T) {
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:362:	// Create a layer with a prefix
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:363:	layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:365:		"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:374:	testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:384:			name: "parameter name without prefix - should add prefix",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:388:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:389:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:407:			name: "parameter name with prefix - should not double prefix",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:411:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:412:					TargetParameter: "demo-api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:433:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:450:	// Create test layers with environment-region parameters
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:451:	layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:453:		"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:462:	testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:476:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:477:					TargetParameter: "{region}-{env}-api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:507:					TargetLayer: "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:509:						{Source: "api_key", TargetParameter: "{region}-{env}-api-key"},
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:537:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:554:	layer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:556:		"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:567:	testLayers := schema.NewSchema(schema.WithSections(layer))
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:569:	mapper, err := pm.NewConfigMapper(testLayers,
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:572:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:573:			TargetParameter: "string-param",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:577:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:578:			TargetParameter: "int-param",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:582:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:583:			TargetParameter: "float-param",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:587:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:588:			TargetParameter: "bool-param",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:592:			TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:593:			TargetParameter: "list-param",
pkg/settings/settings_fields-filters.go:27:type FieldsFiltersParameterLayer struct {
pkg/settings/settings_fields-filters.go:31:var _ schema.CobraSection = &FieldsFiltersParameterLayer{}
pkg/settings/settings_fields-filters.go:32:var _ schema.Section = &FieldsFiltersParameterLayer{}
pkg/settings/settings_fields-filters.go:34:func (f *FieldsFiltersParameterLayer) Clone() schema.Section {
pkg/settings/settings_fields-filters.go:35:	return &FieldsFiltersParameterLayer{
pkg/settings/settings_fields-filters.go:51:func NewFieldsFiltersParameterLayer(options ...schema.SectionOption) (*FieldsFiltersParameterLayer, error) {
pkg/settings/settings_fields-filters.go:52:	ret := &FieldsFiltersParameterLayer{}
pkg/settings/settings_fields-filters.go:53:	layer, err := schema.NewSectionFromYAML(fieldsFiltersFlagsYaml, options...)
pkg/settings/settings_fields-filters.go:55:		return nil, errors.Wrap(err, "Failed to create fields and filters parameter layer")
pkg/settings/settings_fields-filters.go:57:	ret.SectionImpl = layer
pkg/settings/settings_fields-filters.go:62:func (f *FieldsFiltersParameterLayer) AddLayerToCobraCommand(cmd *cobra.Command) error {
pkg/settings/settings_fields-filters.go:64:	err := f.InitializeStructFromParameterDefaults(defaults)
pkg/settings/settings_fields-filters.go:79:	return f.SectionImpl.AddLayerToCobraCommand(cmd)
pkg/settings/settings_fields-filters.go:82:func (f *FieldsFiltersParameterLayer) ParseLayerFromCobraCommand(
pkg/settings/settings_fields-filters.go:86:	l, err := f.SectionImpl.ParseLayerFromCobraCommand(cmd, options...)
pkg/settings/settings_fields-filters.go:93:	// This means we'd have to store if a flag was changed in the parsed layer
pkg/settings/settings_fields-filters.go:95:		parsedFilter, ok := l.Parameters.Get("filter")
pkg/settings/settings_fields-filters.go:100:				return nil, errors.New("Failed to find default filter parameter definition")
pkg/settings/settings_fields-filters.go:102:			p := &fields.ParsedParameter{
pkg/settings/settings_fields-filters.go:107:				return nil, errors.Wrap(err, "Failed to update filter parameter")
pkg/settings/settings_fields-filters.go:109:			l.Parameters.Set("filter", p)
pkg/settings/settings_fields-filters.go:113:				return nil, errors.Wrap(err, "Failed to update filter parameter")
pkg/settings/settings_fields-filters.go:121:func NewFieldsFilterSettings(glazedLayer *values.SectionValues) (*FieldsFilterSettings, error) {
pkg/settings/settings_fields-filters.go:123:	err := glazedLayer.Parameters.InitializeStruct(s)
pkg/cmds/sources/tests/multi-update-from-map.yaml:3:    description: "Applying an empty sequence of update maps should not change ParameterLayers or ParsedLayers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:4:    parameterLayers: []
pkg/cmds/sources/tests/multi-update-from-map.yaml:5:    parsedLayers: []
pkg/cmds/sources/tests/multi-update-from-map.yaml:6:    expectedLayers: []
pkg/cmds/sources/tests/multi-update-from-map.yaml:12:    description: "A single update map should correctly apply updates to the ParsedLayers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:13:    parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:14:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:19:    parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:20:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:21:        parameters:
pkg/cmds/sources/tests/multi-update-from-map.yaml:24:    expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:25:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:30:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:35:    description: "A single update map should correctly apply updates to the ParsedLayers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:36:    parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:37:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:42:    parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:43:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:44:        parameters:
pkg/cmds/sources/tests/multi-update-from-map.yaml:47:    expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:48:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:53:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:58:    description: "A single update map should correctly apply updates to the ParsedLayers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:59:    parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:60:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:67:    parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:68:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:69:        parameters:
pkg/cmds/sources/tests/multi-update-from-map.yaml:74:    expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:75:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:80:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:85:    description: "A single update map should correctly apply updates to the ParsedLayers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:86:    parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:87:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:96:    parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:97:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:98:        parameters:
pkg/cmds/sources/tests/multi-update-from-map.yaml:103:    expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:104:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:109:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:114:    description: "Multiple update maps should apply updates in sequence to the ParsedLayers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:115:    parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:116:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:124:    parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:125:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:126:        parameters:
pkg/cmds/sources/tests/multi-update-from-map.yaml:131:    expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:132:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:138:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:141:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:148:    parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:149:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:154:    parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:155:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:156:    expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:157:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:162:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:164:      - layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:167:  # Test 5: Non-Existent Layers
pkg/cmds/sources/tests/multi-update-from-map.yaml:168:  - name: "Non-Existent Layers"
pkg/cmds/sources/tests/multi-update-from-map.yaml:169:    description: "Updates that reference non-existent layers should be ignored."
pkg/cmds/sources/tests/multi-update-from-map.yaml:170:    parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:171:      - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:176:    expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:179:      - layer2: # This layer does not exist in parameterLayers
pkg/cmds/sources/tests/multi-update-from-map.yaml:182:# Test 6: New Layers
pkg/cmds/sources/tests/multi-update-from-map.yaml:183:- name: "New Layers"
pkg/cmds/sources/tests/multi-update-from-map.yaml:184:  description: "Update maps that reference new layers should create those layers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:185:  parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:186:    - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:191:    - name: "layer2"
pkg/cmds/sources/tests/multi-update-from-map.yaml:196:  parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:197:    - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:198:  expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:199:    - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:202:    - name: "layer2"
pkg/cmds/sources/tests/multi-update-from-map.yaml:204:        param1: "new-layer-value"
pkg/cmds/sources/tests/multi-update-from-map.yaml:207:    - layer2:
pkg/cmds/sources/tests/multi-update-from-map.yaml:208:        param1: "new-layer-value"
pkg/cmds/sources/tests/multi-update-from-map.yaml:210:# Test 7: New inexistent layers
pkg/cmds/sources/tests/multi-update-from-map.yaml:211:- name: "New inexistent layers"
pkg/cmds/sources/tests/multi-update-from-map.yaml:212:  description: "Update maps that reference new layers should create those layers."
pkg/cmds/sources/tests/multi-update-from-map.yaml:213:  parameterLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:214:    - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:219:    - name: "layer2"
pkg/cmds/sources/tests/multi-update-from-map.yaml:224:  parsedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:225:    - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:226:  expectedLayers:
pkg/cmds/sources/tests/multi-update-from-map.yaml:227:    - name: "layer1"
pkg/cmds/sources/tests/multi-update-from-map.yaml:229:        param1: "layer1-value"
pkg/cmds/sources/tests/multi-update-from-map.yaml:230:    - name: "layer2"
pkg/cmds/sources/tests/multi-update-from-map.yaml:232:        param1: "new-layer-value"
pkg/cmds/sources/tests/multi-update-from-map.yaml:235:    - layer2:
pkg/cmds/sources/tests/multi-update-from-map.yaml:236:        param1: "new-layer-value"
pkg/cmds/sources/tests/multi-update-from-map.yaml:238:        param1: "inexistent-layer-value"
pkg/cmds/sources/tests/multi-update-from-map.yaml:239:      layer1:
pkg/cmds/sources/tests/multi-update-from-map.yaml:240:        param1: "layer1-value"
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:11:	layers *schema.Schema
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:18:		layers: l,
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:25:func (b *ConfigMapperBuilder) Map(source string, targetLayer string, targetParameter string, required ...bool) *ConfigMapperBuilder {
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:28:		TargetLayer:     targetLayer,
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:29:		TargetParameter: targetParameter,
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:39:func (b *ConfigMapperBuilder) MapObject(parentSource string, targetLayer string, childRules []MappingRule) *ConfigMapperBuilder {
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:42:		TargetLayer: targetLayer,
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:51:	return NewConfigMapper(b.layers, b.rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:55:func Child(source string, targetParameter string) MappingRule {
pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:56:	return MappingRule{Source: source, TargetParameter: targetParameter}
pkg/settings/settings_template.go:48:type TemplateParameterLayer struct {
pkg/settings/settings_template.go:52:const GlazedTemplateLayerSlug = "glazed-template"
pkg/settings/settings_template.go:54:func NewTemplateParameterLayer(options ...schema.SectionOption) (*TemplateParameterLayer, error) {
pkg/settings/settings_template.go:55:	ret := &TemplateParameterLayer{}
pkg/settings/settings_template.go:56:	layer, err := schema.NewSectionFromYAML(templateFlagsYaml, options...)
pkg/settings/settings_template.go:58:		return nil, errors.Wrap(err, "Failed to create template parameter layer")
pkg/settings/settings_template.go:60:	ret.SectionImpl = layer
pkg/settings/settings_template.go:65:func (f *TemplateParameterLayer) Clone() schema.Section {
pkg/settings/settings_template.go:66:	return &TemplateParameterLayer{
pkg/settings/settings_template.go:71:func NewTemplateSettings(layer *values.SectionValues) (*TemplateSettings, error) {
pkg/settings/settings_template.go:77:	templateArgument, ok := layer.Parameters.GetValue("template").(string)
pkg/settings/settings_template.go:81:		v := layer.Parameters.GetValue("template-field")
pkg/settings/settings_template.go:95:	useRowTemplates, ok := layer.Parameters.GetValue("use-row-templates").(bool)
pkg/cmds/schema/layer-impl.go:18:	ChildLayers []Section           `yaml:"childLayers,omitempty"`
pkg/cmds/schema/layer-impl.go:103:			return p.InitializeDefaultsFromParameters(m)
pkg/cmds/schema/layer-impl.go:110:func WithFields(parameterDefinitions ...*fields.Definition) SectionOption {
pkg/cmds/schema/layer-impl.go:112:		for _, f := range parameterDefinitions {
pkg/cmds/schema/layer-impl.go:136:		_, err := f_.Value.CheckParameterDefaultValueValidity()
pkg/cmds/schema/layer-impl.go:168:// GetDefinitions returns a map that maps all parameters (flags and arguments) to their name.
pkg/cmds/schema/layer-impl.go:179:// InitializeDefaultsFromStruct initializes the `ParameterDefinition` of the layer,
pkg/cmds/schema/layer-impl.go:182:// This is in some ways the opposite of `InitializeStructFromParameterDefaults`.
pkg/cmds/schema/layer-impl.go:184:// to initialize the `ParameterDefinition` with a matching name. If no matching
pkg/cmds/schema/layer-impl.go:185:// `ParameterDefinition` is found, an error is returned.
pkg/cmds/schema/layer-impl.go:196:// InitializeDefaultsFromParameters initializes the parameter definitions
pkg/cmds/schema/layer-impl.go:197:// of the layer from the given map of parameter values. The parameter definitions
pkg/cmds/schema/layer-impl.go:199:func (p *SectionImpl) InitializeDefaultsFromParameters(
pkg/cmds/schema/layer-impl.go:207:func (p *SectionImpl) InitializeStructFromParameterDefaults(s interface{}) error {
pkg/cmds/schema/layer-impl.go:216:// AddLayerToCobraCommand adds all flags of the layer to the given Cobra command.
pkg/cmds/schema/layer-impl.go:217:// It also creates a flag group representing the layer and adds it to the command.
pkg/cmds/schema/layer-impl.go:218:// If the layer has a prefix, the flags are added with that prefix.
pkg/cmds/schema/layer-impl.go:219:func (p *SectionImpl) AddLayerToCobraCommand(cmd *cobra.Command) error {
pkg/cmds/schema/layer-impl.go:220:	err := p.Definitions.AddParametersToCobraCommand(cmd, p.Prefix)
pkg/cmds/schema/layer-impl.go:230:// ParseLayerFromCobraCommand parses the flags of the layer from the given Cobra command.
pkg/cmds/schema/layer-impl.go:231:// If the layer has a prefix, the flags are parsed with that prefix (meaning, the prefix
pkg/cmds/schema/layer-impl.go:235:// of the layer.
pkg/cmds/schema/layer-impl.go:236:func (p *SectionImpl) ParseLayerFromCobraCommand(
pkg/cmds/schema/layer-impl.go:256:		Layer:      p,
pkg/cmds/schema/layer-impl.go:257:		Parameters: ps,
pkg/cmds/schema/layer-impl.go:261:func (p *SectionImpl) GatherParametersFromMap(
pkg/cmds/schema/layer-impl.go:264:) (*fields.ParsedParameters, error) {
pkg/cmds/schema/layer-impl.go:265:	return p.Definitions.GatherParametersFromMap(m, onlyProvided, options...)
pkg/cmds/sources/patternmapper/exports.go:12:func ExtractCaptureReferences(targetParameter string) map[string]bool {
pkg/cmds/sources/patternmapper/exports.go:13:	return extractCaptureReferences(targetParameter)
pkg/cmds/sources/patternmapper/exports.go:16:// ResolveTargetParameter exposes internal resolveTargetParameter for testing and tooling.
pkg/cmds/sources/patternmapper/exports.go:17:func ResolveTargetParameter(targetParameter string, captures map[string]string) (string, error) {
pkg/cmds/sources/patternmapper/exports.go:18:	return resolveTargetParameter(targetParameter, captures)
pkg/cmds/fields/gather-arguments_test.go:31:// Test the parsing of every kind of parameter type for provided args
pkg/cmds/fields/gather-arguments_test.go:32:// This should be broken down into individual tests for each parameter types.
pkg/cmds/fields/gather-arguments_test.go:49:// Test parsing of list-type parameter with multiple arguments
pkg/cmds/fields/gather-arguments_test.go:50:func TestGatherArguments_ListParameterParsing(t *testing.T) {
pkg/cmds/fields/gather-arguments_test.go:261:func TestSingleParametersFollowedByListDefaults(t *testing.T) {
pkg/cmds/fields/gather-arguments_test.go:286:func TestThreeSingleParametersFollowedByListDefaults(t *testing.T) {
pkg/cmds/fields/gather-arguments_test.go:327:func TestThreeSingleParametersFollowedByListDefaultsOnlyTwoValues(t *testing.T) {
pkg/settings/settings_sort.go:20:func NewSortSettingsFromParameters(glazedLayer *values.SectionValues) (*SortFlagsSettings, error) {
pkg/settings/settings_sort.go:22:	err := glazedLayer.Parameters.InitializeStruct(s)
pkg/settings/settings_sort.go:24:		return nil, errors.Wrap(err, "Failed to initialize sort settings from parameters")
pkg/settings/settings_sort.go:30:type SortParameterLayer struct {
pkg/settings/settings_sort.go:34:func NewSortParameterLayer(options ...schema.SectionOption) (*SortParameterLayer, error) {
pkg/settings/settings_sort.go:35:	ret := &SortParameterLayer{}
pkg/settings/settings_sort.go:36:	layer, err := schema.NewSectionFromYAML(sortFlagsYaml, options...)
pkg/settings/settings_sort.go:38:		return nil, errors.Wrap(err, "Failed to create sort parameter layer")
pkg/settings/settings_sort.go:40:	ret.SectionImpl = layer
pkg/settings/settings_sort.go:45:func (f *SortParameterLayer) Clone() schema.Section {
pkg/settings/settings_sort.go:46:	return &SortParameterLayer{
pkg/cmds/schema/wrappers.go:5:type WhitelistParameterLayer struct {
pkg/cmds/schema/wrappers.go:7:	WhitelistedParameters map[string]interface{}
pkg/cmds/schema/wrappers.go:10:var _ Section = (*WhitelistParameterLayer)(nil)
pkg/cmds/schema/wrappers.go:12:func NewWhitelistParameterLayer(layer Section, whitelistedParameters map[string]interface{}) *WhitelistParameterLayer {
pkg/cmds/schema/wrappers.go:13:	return &WhitelistParameterLayer{
pkg/cmds/schema/wrappers.go:14:		Section:               layer,
pkg/cmds/schema/wrappers.go:15:		WhitelistedParameters: whitelistedParameters,
pkg/cmds/schema/wrappers.go:19:func (l *WhitelistParameterLayer) GetDefinitions() *fields.Definitions {
pkg/cmds/schema/wrappers.go:23:		if _, ok := l.WhitelistedParameters[pd.Name]; ok {
pkg/cmds/schema/wrappers.go:30:type BlacklistParameterLayer struct {
pkg/cmds/schema/wrappers.go:32:	BlacklistedParameters map[string]interface{}
pkg/cmds/schema/wrappers.go:35:var _ Section = (*BlacklistParameterLayer)(nil)
pkg/cmds/schema/wrappers.go:37:func NewBlacklistParameterLayer(layer Section, blacklistedParameters map[string]interface{}) *BlacklistParameterLayer {
pkg/cmds/schema/wrappers.go:38:	return &BlacklistParameterLayer{
pkg/cmds/schema/wrappers.go:39:		Section:               layer,
pkg/cmds/schema/wrappers.go:40:		BlacklistedParameters: blacklistedParameters,
pkg/cmds/schema/wrappers.go:44:func (l *BlacklistParameterLayer) GetDefinitions() *fields.Definitions {
pkg/cmds/schema/wrappers.go:48:		if _, ok := l.BlacklistedParameters[pd.Name]; !ok {
pkg/settings/settings_replace.go:42:type ReplaceParameterLayer struct {
pkg/settings/settings_replace.go:49:func NewReplaceParameterLayer(options ...schema.SectionOption) (*ReplaceParameterLayer, error) {
pkg/settings/settings_replace.go:50:	ret := &ReplaceParameterLayer{}
pkg/settings/settings_replace.go:51:	layer, err := schema.NewSectionFromYAML(replaceFlagsYaml, options...)
pkg/settings/settings_replace.go:55:	ret.SectionImpl = layer
pkg/settings/settings_replace.go:59:func (f *ReplaceParameterLayer) Clone() schema.Section {
pkg/settings/settings_replace.go:60:	return &ReplaceParameterLayer{
pkg/settings/settings_replace.go:65:func NewReplaceSettingsFromParameters(glazedLayer *values.SectionValues) (*ReplaceSettings, error) {
pkg/settings/settings_replace.go:67:	err := glazedLayer.Parameters.InitializeStruct(s)
pkg/settings/settings_replace.go:69:		return nil, errors.Wrap(err, "failed to initialize replace settings from parameters")
pkg/helpers/templating/templating.go:99:	"toUrlParameter": toUrlParameter,
pkg/helpers/templating/templating.go:127:// toUrlParameter encodes the value as a string that can be passed for url parameter decoding
pkg/helpers/templating/templating.go:128:func toUrlParameter(s interface{}) (string, error) {
pkg/helpers/templating/templating.go:647:// NOTE(manuel, 2023-04-18) Interestingly, we have a baseDir parameter here but only one pattern
pkg/settings/settings_select.go:21:func NewSelectSettingsFromParameters(glazedLayer *values.SectionValues) (*SelectSettings, error) {
pkg/settings/settings_select.go:23:	err := glazedLayer.Parameters.InitializeStruct(s)
pkg/settings/settings_select.go:25:		return nil, errors.Wrap(err, "Failed to initialize select settings from parameters")
pkg/settings/settings_select.go:39:type SelectParameterLayer struct {
pkg/settings/settings_select.go:43:func NewSelectParameterLayer(options ...schema.SectionOption) (*SelectParameterLayer, error) {
pkg/settings/settings_select.go:44:	ret := &SelectParameterLayer{}
pkg/settings/settings_select.go:45:	layer, err := schema.NewSectionFromYAML(selectFlagsYaml, options...)
pkg/settings/settings_select.go:47:		return nil, errors.Wrap(err, "Failed to create select parameter layer")
pkg/settings/settings_select.go:49:	ret.SectionImpl = layer
pkg/settings/settings_select.go:54:func (f *SelectParameterLayer) Clone() schema.Section {
pkg/settings/settings_select.go:55:	return &SelectParameterLayer{
pkg/cmds/schema/serialize.go:10:// SerializableParameterLayer represents a parameter layer in a format suitable for
pkg/cmds/schema/serialize.go:12:type SerializableParameterLayer struct {
pkg/cmds/schema/serialize.go:17:	Parameters  *fields.Definitions `yaml:"parameters" json:"parameters"`
pkg/cmds/schema/serialize.go:21:func ToSerializable(layer Section) *SerializableParameterLayer {
pkg/cmds/schema/serialize.go:22:	return &SerializableParameterLayer{
pkg/cmds/schema/serialize.go:23:		Name:        layer.GetName(),
pkg/cmds/schema/serialize.go:24:		Slug:        layer.GetSlug(),
pkg/cmds/schema/serialize.go:25:		Description: layer.GetDescription(),
pkg/cmds/schema/serialize.go:26:		Prefix:      layer.GetPrefix(),
pkg/cmds/schema/serialize.go:27:		Parameters:  layer.GetDefinitions(),
pkg/cmds/schema/serialize.go:31:// SerializableLayers represents a collection of parameter layers in a format suitable
pkg/cmds/schema/serialize.go:32:// for YAML/JSON serialization, maintaining the order of layers
pkg/cmds/schema/serialize.go:33:type SerializableLayers struct {
pkg/cmds/schema/serialize.go:34:	// Using orderedmap to maintain layer order while having slug-based access
pkg/cmds/schema/serialize.go:35:	Layers *orderedmap.OrderedMap[string, *SerializableParameterLayer] `yaml:"layers" json:"layers"`
pkg/cmds/schema/serialize.go:38:// LayersToSerializable converts a Schema collection to its serializable representation
pkg/cmds/schema/serialize.go:39:func LayersToSerializable(layers *Schema) *SerializableLayers {
pkg/cmds/schema/serialize.go:40:	ret := &SerializableLayers{
pkg/cmds/schema/serialize.go:41:		Layers: orderedmap.New[string, *SerializableParameterLayer](),
pkg/cmds/schema/serialize.go:44:	layers.ForEach(func(_ string, layer Section) {
pkg/cmds/schema/serialize.go:45:		serialized := ToSerializable(layer)
pkg/cmds/schema/serialize.go:46:		ret.Layers.Set(layer.GetSlug(), serialized)
pkg/cmds/schema/serialize.go:52:// MarshalYAML implements yaml.Marshaler for SerializableLayers
pkg/cmds/schema/serialize.go:53:func (sl *SerializableLayers) MarshalYAML() (interface{}, error) {
pkg/cmds/schema/serialize.go:55:	m := make(map[string]*SerializableParameterLayer)
pkg/cmds/schema/serialize.go:56:	for pair := sl.Layers.Oldest(); pair != nil; pair = pair.Next() {
pkg/cmds/schema/serialize.go:62:// MarshalJSON implements json.Marshaler for SerializableLayers
pkg/cmds/schema/serialize.go:63:func (sl *SerializableLayers) MarshalJSON() ([]byte, error) {
pkg/cmds/schema/serialize.go:65:	m := make(map[string]*SerializableParameterLayer)
pkg/cmds/schema/serialize.go:66:	for pair := sl.Layers.Oldest(); pair != nil; pair = pair.Next() {
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:1:- name: "Blacklist Single Layer"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:2:  description: "A single layer is blacklisted and should be removed from ParameterLayers."
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:3:  parameterLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:4:    - name: layer1
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:9:    - name: layer2
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:14:  parsedLayers: []
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:16:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:19:    - "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:22:- name: "Blacklist Multiple Layers"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:23:  description: "Multiple layers are blacklisted and should be removed from ParameterLayers."
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:24:  parameterLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:25:    - name: "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:30:    - name: "layer2"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:35:    - name: "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:40:  expectedLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:41:    - name: layer2
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:45:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:47:    layer2:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:49:    layer3:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:52:    - "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:53:    - "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:58:  parameterLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:59:    - name: "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:64:    - name: "layer2"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:69:    - name: "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:74:    - name: "layer4"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:79:  parsedLayers: []
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:81:    layer2:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:83:    layer4:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:86:    - "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:87:    - "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:89:  expectedLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:90:    - name: layer1
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:93:    - name: layer2
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:96:    - name: layer3
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:99:    - name: layer4
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:103:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:105:    layer2:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:107:    layer3:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:110:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:112:    layer3:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:114:    layer4:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:117:- name: "Whitelist single layer"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:118:  description: "A single layer is whitelisted and should be kept in ParameterLayers."
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:119:  parameterLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:120:    - name: layer1
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:125:    - name: layer2
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:130:  parsedLayers: []
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:131:  expectedLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:132:    - name: layer1
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:136:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:139:    - "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:142:- name: "Whitelist multiple layers"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:143:  description: "Multiple layers are whitelisted and should be kept in ParameterLayers."
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:144:  parameterLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:145:    - name: "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:150:    - name: "layer2"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:155:    - name: "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:160:  expectedLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:161:    - name: layer1
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:164:    - name: layer3
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:168:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:170:    layer3:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:173:    - "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:174:    - "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:179:  parameterLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:180:    - name: "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:185:    - name: "layer2"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:190:    - name: "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:195:    - name: "layer4"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:200:  parsedLayers: []
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:202:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:204:    layer3:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:207:    - "layer1"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:208:    - "layer3"
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:210:  expectedLayers:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:211:    - name: layer1
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:214:    - name: layer2
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:217:    - name: layer3
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:220:    - name: layer4
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:224:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:226:    layer2:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:228:    layer3:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:231:    layer1:
pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:233:    layer4:
pkg/settings/settings_rename.go:57:type RenameParameterLayer struct {
pkg/settings/settings_rename.go:61:func NewRenameParameterLayer(options ...schema.SectionOption) (*RenameParameterLayer, error) {
pkg/settings/settings_rename.go:62:	ret := &RenameParameterLayer{}
pkg/settings/settings_rename.go:63:	layer, err := schema.NewSectionFromYAML(renameFlagsYaml, options...)
pkg/settings/settings_rename.go:65:		return nil, errors.Wrap(err, "Failed to create rename parameter layer")
pkg/settings/settings_rename.go:67:	ret.SectionImpl = layer
pkg/settings/settings_rename.go:71:func (f *RenameParameterLayer) Clone() schema.Section {
pkg/settings/settings_rename.go:72:	return &RenameParameterLayer{
pkg/settings/settings_rename.go:77:func NewRenameSettingsFromParameters(glazedLayer *values.SectionValues) (*RenameSettings, error) {
pkg/settings/settings_rename.go:78:	ps := glazedLayer.Parameters
pkg/cmds/schema/layer-impl_test.go:11:func createSimpleParameterLayer(t *testing.T, options ...SectionOption) *SectionImpl {
pkg/cmds/schema/layer-impl_test.go:17:	layer, err := NewSection("simple", "Simple", options_...)
pkg/cmds/schema/layer-impl_test.go:20:	return layer
pkg/cmds/schema/layer-impl_test.go:24:	layer := createSimpleParameterLayer(t)
pkg/cmds/schema/layer-impl_test.go:30:	err := layer.AddLayerToCobraCommand(cmd)
pkg/cmds/schema/layer-impl_test.go:49:	layer := createSimpleParameterLayer(t, WithPrefix("test-"))
pkg/cmds/schema/layer-impl_test.go:55:	err := layer.AddLayerToCobraCommand(cmd)
pkg/settings/settings_template_test.go:15:	layer, err := NewTemplateParameterLayer()
pkg/settings/settings_template_test.go:17:	err = layer.InitializeDefaultsFromStruct(defaults)
pkg/settings/settings_template_test.go:20:	layers_ := schema.NewSchema(schema.WithSections(layer))
pkg/settings/settings_template_test.go:21:	parsedLayers := values.New()
pkg/settings/settings_template_test.go:22:	err = sources.Execute(layers_, parsedLayers,
pkg/settings/settings_template_test.go:28:	ps, ok := parsedLayers.Get(GlazedTemplateLayerSlug)
pkg/cmds/sources/patternmapper/pattern_mapper.go:15:// MappingRule defines a pattern-based mapping from config file structure to layer fields.
pkg/cmds/sources/patternmapper/pattern_mapper.go:18://   - TargetLayer: Which layer to place the value in
pkg/cmds/sources/patternmapper/pattern_mapper.go:19://   - TargetParameter: Which parameter name to use (supports capture references like "{env}-api-key")
pkg/cmds/sources/patternmapper/pattern_mapper.go:30:	// Target layer slug (e.g., "demo")
pkg/cmds/sources/patternmapper/pattern_mapper.go:32:	TargetLayer string
pkg/cmds/sources/patternmapper/pattern_mapper.go:34:	// Target parameter name (supports captures like "{env}-api-key")
pkg/cmds/sources/patternmapper/pattern_mapper.go:36:	TargetParameter string
pkg/cmds/sources/patternmapper/pattern_mapper.go:50:	layers           *schema.Schema
pkg/cmds/sources/patternmapper/pattern_mapper.go:66://   - All target parameters exist in their respective layers
pkg/cmds/sources/patternmapper/pattern_mapper.go:67://   - Capture references in target parameters match captures in source patterns
pkg/cmds/sources/patternmapper/pattern_mapper.go:68:func NewConfigMapper(layers *schema.Schema, rules ...MappingRule) (sources.ConfigMapper, error) {
pkg/cmds/sources/patternmapper/pattern_mapper.go:69:	if layers == nil {
pkg/cmds/sources/patternmapper/pattern_mapper.go:70:		return nil, errors.New("layers cannot be nil")
pkg/cmds/sources/patternmapper/pattern_mapper.go:75:		layers: layers,
pkg/cmds/sources/patternmapper/pattern_mapper.go:139:	// Validate target parameter if this is a leaf rule (no nested rules)
pkg/cmds/sources/patternmapper/pattern_mapper.go:141:		// Validate target layer exists
pkg/cmds/sources/patternmapper/pattern_mapper.go:142:		if rule.TargetLayer == "" {
pkg/cmds/sources/patternmapper/pattern_mapper.go:143:			return nil, errors.New("target layer is required for leaf rules")
pkg/cmds/sources/patternmapper/pattern_mapper.go:146:		_, ok := m.layers.Get(rule.TargetLayer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:148:			return nil, errors.Errorf("target layer %q does not exist", rule.TargetLayer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:151:		// Validate capture references in target parameter
pkg/cmds/sources/patternmapper/pattern_mapper.go:153:		if err := validateCaptureReferences(allCaptures, rule.TargetParameter); err != nil {
pkg/cmds/sources/patternmapper/pattern_mapper.go:154:			return nil, errors.Wrapf(err, "invalid capture reference in target parameter")
pkg/cmds/sources/patternmapper/pattern_mapper.go:157:		// Proposal 5: Early validation for static target parameters (no capture refs)
pkg/cmds/sources/patternmapper/pattern_mapper.go:158:		if len(extractCaptureReferences(rule.TargetParameter)) == 0 {
pkg/cmds/sources/patternmapper/pattern_mapper.go:159:			layer, _ := m.layers.Get(rule.TargetLayer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:160:			if layer != nil {
pkg/cmds/sources/patternmapper/pattern_mapper.go:161:				canonical := resolveCanonicalParameterName(layer, rule.TargetParameter)
pkg/cmds/sources/patternmapper/pattern_mapper.go:162:				if pd, ok := layer.GetDefinitions().Get(canonical); !ok || pd == nil {
pkg/cmds/sources/patternmapper/pattern_mapper.go:163:					if canonical != rule.TargetParameter {
pkg/cmds/sources/patternmapper/pattern_mapper.go:164:						return nil, errors.Errorf("target parameter %q (checked as %q) does not exist in layer %q", rule.TargetParameter, canonical, rule.TargetLayer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:166:					return nil, errors.Errorf("target parameter %q does not exist in layer %q", rule.TargetParameter, rule.TargetLayer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:189:			// Inherit target layer if not set
pkg/cmds/sources/patternmapper/pattern_mapper.go:190:			if childRule.TargetLayer == "" {
pkg/cmds/sources/patternmapper/pattern_mapper.go:191:				childRule.TargetLayer = rule.TargetLayer
pkg/cmds/sources/patternmapper/pattern_mapper.go:219:	// Key: layer+"."+paramName, Value: pattern source that last wrote to it
pkg/cmds/sources/patternmapper/pattern_mapper.go:230:		// Key: resolved target parameter name, Value: list of distinct values
pkg/cmds/sources/patternmapper/pattern_mapper.go:235:			// Resolve target parameter name (replace captures)
pkg/cmds/sources/patternmapper/pattern_mapper.go:236:			targetParam, err := resolveTargetParameter(compiled.rule.TargetParameter, match.captures)
pkg/cmds/sources/patternmapper/pattern_mapper.go:238:				return nil, errors.Wrapf(err, "failed to resolve target parameter")
pkg/cmds/sources/patternmapper/pattern_mapper.go:241:			// Validate parameter exists
pkg/cmds/sources/patternmapper/pattern_mapper.go:242:			layer, ok := m.layers.Get(match.layer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:244:				return nil, errors.Errorf("target layer %q does not exist", match.layer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:247:			// Resolve canonical parameter name (using helper from proposal 9)
pkg/cmds/sources/patternmapper/pattern_mapper.go:248:			paramName := resolveCanonicalParameterName(layer, targetParam)
pkg/cmds/sources/patternmapper/pattern_mapper.go:250:			paramDef, ok := layer.GetDefinitions().Get(paramName)
pkg/cmds/sources/patternmapper/pattern_mapper.go:254:				errorMsg := fmt.Sprintf("target parameter %q", targetParam)
pkg/cmds/sources/patternmapper/pattern_mapper.go:258:				errorMsg += fmt.Sprintf(" does not exist in layer %q (pattern: %q)", match.layer, compiled.rule.Source)
pkg/cmds/sources/patternmapper/pattern_mapper.go:278:						"pattern %q matched multiple distinct values for parameter %q: found %d distinct values",
pkg/cmds/sources/patternmapper/pattern_mapper.go:288:		// Track which parameters were written by this rule to avoid false collision detection
pkg/cmds/sources/patternmapper/pattern_mapper.go:291:			// Resolve target parameter name (replace captures)
pkg/cmds/sources/patternmapper/pattern_mapper.go:292:			targetParam, err := resolveTargetParameter(compiled.rule.TargetParameter, match.captures)
pkg/cmds/sources/patternmapper/pattern_mapper.go:294:				return nil, errors.Wrapf(err, "failed to resolve target parameter")
pkg/cmds/sources/patternmapper/pattern_mapper.go:297:			layer, _ := m.layers.Get(match.layer)
pkg/cmds/sources/patternmapper/pattern_mapper.go:298:			paramName := resolveCanonicalParameterName(layer, targetParam)
pkg/cmds/sources/patternmapper/pattern_mapper.go:301:			// Only check for collisions if this parameter wasn't already written by this rule
pkg/cmds/sources/patternmapper/pattern_mapper.go:302:			collisionKey := match.layer + "." + paramName
pkg/cmds/sources/patternmapper/pattern_mapper.go:305:					// Collision detected (different rule writing to same parameter): error
pkg/cmds/sources/patternmapper/pattern_mapper.go:307:						"collision: parameter %q in layer %q is written by multiple patterns: %q and %q",
pkg/cmds/sources/patternmapper/pattern_mapper.go:309:						match.layer,
pkg/cmds/sources/patternmapper/pattern_mapper.go:318:			// Initialize layer map if needed
pkg/cmds/sources/patternmapper/pattern_mapper.go:319:			if result[match.layer] == nil {
pkg/cmds/sources/patternmapper/pattern_mapper.go:320:				result[match.layer] = make(map[string]interface{})
pkg/cmds/sources/patternmapper/pattern_mapper.go:324:			result[match.layer][paramName] = match.value
pkg/cmds/sources/patternmapper/pattern_mapper.go:333:	layer    string
pkg/cmds/sources/patternmapper/pattern_mapper.go:479:			layer:    compiled.rule.TargetLayer,
pkg/cmds/sources/patternmapper/pattern_mapper.go:521:// validateCaptureReferences validates that all capture references in target parameter
pkg/cmds/sources/patternmapper/pattern_mapper.go:523:func validateCaptureReferences(availableCaptures []string, targetParameter string) error {
pkg/cmds/sources/patternmapper/pattern_mapper.go:524:	// Extract capture references from target parameter
pkg/cmds/sources/patternmapper/pattern_mapper.go:525:	targetRefs := extractCaptureReferences(targetParameter)
pkg/cmds/sources/patternmapper/pattern_mapper.go:537:			return errors.Errorf("capture reference {%s} in target parameter not found in source pattern", ref)
pkg/cmds/sources/patternmapper/pattern_mapper.go:557:// extractCaptureReferences extracts all capture references from a target parameter string
pkg/cmds/sources/patternmapper/pattern_mapper.go:558:func extractCaptureReferences(targetParameter string) map[string]bool {
pkg/cmds/sources/patternmapper/pattern_mapper.go:562:	matches := re.FindAllStringSubmatch(targetParameter, -1)
pkg/cmds/sources/patternmapper/pattern_mapper.go:603:// resolveCanonicalParameterName resolves the canonical parameter name including prefix
pkg/cmds/sources/patternmapper/pattern_mapper.go:604:// This is proposal 9: explicit helper for canonical parameter name resolution
pkg/cmds/sources/patternmapper/pattern_mapper.go:605:func resolveCanonicalParameterName(layer schema.Section, targetParam string) string {
pkg/cmds/sources/patternmapper/pattern_mapper.go:606:	if layer.GetPrefix() != "" {
pkg/cmds/sources/patternmapper/pattern_mapper.go:607:		// If layer has prefix, check if targetParam already includes it
pkg/cmds/sources/patternmapper/pattern_mapper.go:608:		if !strings.HasPrefix(targetParam, layer.GetPrefix()) {
pkg/cmds/sources/patternmapper/pattern_mapper.go:609:			return layer.GetPrefix() + targetParam
pkg/cmds/sources/patternmapper/pattern_mapper.go:615:// resolveTargetParameter resolves capture references in target parameter name
pkg/cmds/sources/patternmapper/pattern_mapper.go:616:func resolveTargetParameter(targetParameter string, captures map[string]string) (string, error) {
pkg/cmds/sources/patternmapper/pattern_mapper.go:617:	result := targetParameter
pkg/cmds/sources/patternmapper/pattern_mapper.go:619:	matches := re.FindAllStringSubmatch(targetParameter, -1)
pkg/settings/settings_skip_limit.go:19:func NewSkipLimitSettingsFromParameters(glazedLayer *values.SectionValues) (*SkipLimitSettings, error) {
pkg/settings/settings_skip_limit.go:21:	err := glazedLayer.Parameters.InitializeStruct(s)
pkg/settings/settings_skip_limit.go:23:		return nil, errors.Wrap(err, "Failed to initialize skipLimit settings from parameters")
pkg/settings/settings_skip_limit.go:29:type SkipLimitParameterLayer struct {
pkg/settings/settings_skip_limit.go:33:func NewSkipLimitParameterLayer(options ...schema.SectionOption) (*SkipLimitParameterLayer, error) {
pkg/settings/settings_skip_limit.go:34:	ret := &SkipLimitParameterLayer{}
pkg/settings/settings_skip_limit.go:35:	layer, err := schema.NewSectionFromYAML(skipLimitFlagsYaml, options...)
pkg/settings/settings_skip_limit.go:37:		return nil, errors.Wrap(err, "Failed to create skipLimit parameter layer")
pkg/settings/settings_skip_limit.go:39:	ret.SectionImpl = layer
pkg/settings/settings_skip_limit.go:43:func (f *SkipLimitParameterLayer) Clone() schema.Section {
pkg/settings/settings_skip_limit.go:44:	return &SkipLimitParameterLayer{
pkg/cmds/schema/cobra.go:11:	// AddLayerToCobraCommand adds all the flags and arguments defined in this layer to the given cobra command.
pkg/cmds/schema/cobra.go:12:	AddLayerToCobraCommand(cmd *cobra.Command) error
pkg/cmds/schema/cobra.go:13:	ParseLayerFromCobraCommand(cmd *cobra.Command, options ...fields.ParseOption) (*values.SectionValues, error)
pkg/settings/settings_output.go:55:type OutputParameterLayer struct {
pkg/settings/settings_output.go:59:func NewOutputParameterLayer(options ...schema.SectionOption) (*OutputParameterLayer, error) {
pkg/settings/settings_output.go:60:	ret := &OutputParameterLayer{}
pkg/settings/settings_output.go:61:	layer, err := schema.NewSectionFromYAML(outputFlagsYaml, options...)
pkg/settings/settings_output.go:65:	ret.SectionImpl = layer
pkg/settings/settings_output.go:70:func (f *OutputParameterLayer) Clone() schema.Section {
pkg/settings/settings_output.go:71:	return &OutputParameterLayer{
pkg/settings/settings_output.go:76:func NewOutputFormatterSettings(glazedLayer *values.SectionValues) (*OutputFormatterSettings, error) {
pkg/settings/settings_output.go:78:	err := glazedLayer.Parameters.InitializeStruct(s)
pkg/cmds/schema/errors.go:12:		return fmt.Sprintf("invalid parameter layer: %s", e.Name)
pkg/cmds/schema/errors.go:14:	return fmt.Sprintf("invalid parameter layer: %s (expected %s)", e.Name, e.Expected)
pkg/cmds/template.go:29:	Layers    schema.Schema        `yaml:"layers,omitempty"`
pkg/cmds/template.go:48:func (t *TemplateCommand) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {
pkg/cmds/template.go:55:	err = tmpl.Execute(w, parsedLayers.GetDataMap())
pkg/cmds/template.go:95:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/template.go:104:		WithLayersList(tcd.Layers.AsList()...),
pkg/cmds/template.go:105:		WithLayersList(defaultLayer),
pkg/cmds/schema/layer.go:13:// Section is a struct that is used by one specific functionality layer
pkg/cmds/schema/layer.go:14:// to group and describe all the parameter definitions that it uses.
pkg/cmds/schema/layer.go:41:func WithSections(layers ...Section) SchemaOption {
pkg/cmds/schema/layer.go:43:		for _, l := range layers {
pkg/cmds/schema/layer.go:92:func (pl *Schema) AppendLayers(layers ...Section) {
pkg/cmds/schema/layer.go:93:	for _, l := range layers {
pkg/cmds/schema/layer.go:98:func (pl *Schema) PrependLayers(layers ...Section) {
pkg/cmds/schema/layer.go:99:	list.Reverse[Section](layers)
pkg/cmds/schema/layer.go:101:	for _, l := range layers {
pkg/cmds/schema/layer.go:143:			err := v.(CobraSection).AddLayerToCobraCommand(cmd)
pkg/cmds/schema/layer.go:165:	parsedLayer *values.SectionValues,
pkg/cmds/schema/layer.go:171:		v, err := pd.CheckParameterDefaultValueValidity()
pkg/cmds/schema/layer.go:176:			err := parsedLayer.Parameters.SetAsDefault(pd.Name, pd, v, options...)
pkg/cmds/schema/layer.go:191:func (pl *Schema) UpdateWithDefaults(parsedLayers *values.Values, options ...fields.ParseOption) error {
pkg/cmds/schema/layer.go:193:		parsedLayer := parsedLayers.GetOrCreate(v)
pkg/cmds/schema/layer.go:194:		return InitializeSectionWithDefaults(v, parsedLayer, options...)
pkg/cmds/schema/layer.go:202:	return LayersToSerializable(pl), nil
pkg/cmds/schema/layer.go:207:	return json.Marshal(LayersToSerializable(pl))
pkg/cmds/sources/tests/set-from-defaults.yaml:1:- name: "Empty layers and parsedLayers"
pkg/cmds/sources/tests/set-from-defaults.yaml:2:  description: "Empty layers should result in empty parsed layers"
pkg/cmds/sources/tests/set-from-defaults.yaml:3:  parameterLayers: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:4:  parsedLayers: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:5:  expectedLayers: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:8:- name: "Single layer with default"
pkg/cmds/sources/tests/set-from-defaults.yaml:9:  description: "Single layer with default values should result in a single layer with these values"
pkg/cmds/sources/tests/set-from-defaults.yaml:10:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:11:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:16:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:17:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:18:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:19:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:27:- name: "Single layer with list type default"
pkg/cmds/sources/tests/set-from-defaults.yaml:28:  description: "Single layer with default values should result in a single layer with these values"
pkg/cmds/sources/tests/set-from-defaults.yaml:29:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:30:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:35:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:36:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:37:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:38:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:46:- name: "Single layer with objectFromFile type default"
pkg/cmds/sources/tests/set-from-defaults.yaml:47:  description: "Single layer with default values should result in a single layer with these values"
pkg/cmds/sources/tests/set-from-defaults.yaml:48:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:49:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:56:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:57:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:58:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:59:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:65:- name: "Single layer with objectListFromFile type default"
pkg/cmds/sources/tests/set-from-defaults.yaml:66:  description: "Single layer with default values should result in a single layer with these values"
pkg/cmds/sources/tests/set-from-defaults.yaml:67:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:68:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:77:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:78:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:79:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:80:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:96:- name: "Layer with existing values"
pkg/cmds/sources/tests/set-from-defaults.yaml:97:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:98:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:106:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:107:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:108:      parameters:
pkg/cmds/sources/tests/set-from-defaults.yaml:111:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:112:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:118:- name: "Multiple layers with defaults"
pkg/cmds/sources/tests/set-from-defaults.yaml:119:  description: "Multiple layers with defaults should result in multiple layers with these values"
pkg/cmds/sources/tests/set-from-defaults.yaml:120:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:121:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:129:    - name: "layer2"
pkg/cmds/sources/tests/set-from-defaults.yaml:134:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:135:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:136:      parameters: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:137:    - name: "layer2"
pkg/cmds/sources/tests/set-from-defaults.yaml:138:      parameters: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:139:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:140:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:144:    - name: "layer2"
pkg/cmds/sources/tests/set-from-defaults.yaml:149:- name: "Multiple layers with defaults (no defined target layers, should be created)"
pkg/cmds/sources/tests/set-from-defaults.yaml:150:  description: "Multiple layers with defaults should result in multiple layers with these values"
pkg/cmds/sources/tests/set-from-defaults.yaml:151:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:152:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:160:    - name: "layer2"
pkg/cmds/sources/tests/set-from-defaults.yaml:165:  parsedLayers: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:166:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:167:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:171:    - name: "layer2"
pkg/cmds/sources/tests/set-from-defaults.yaml:176:- name: "Layer with no default values"
pkg/cmds/sources/tests/set-from-defaults.yaml:177:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:178:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:184:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:185:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:186:      parameters: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:187:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:188:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:192:- name: "Layer with partially set values"
pkg/cmds/sources/tests/set-from-defaults.yaml:193:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:194:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:202:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:203:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:204:      parameters:
pkg/cmds/sources/tests/set-from-defaults.yaml:207:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:208:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:214:- name: "Layer with invalid default values"
pkg/cmds/sources/tests/set-from-defaults.yaml:215:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:216:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:221:  expectedLayers: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:224:- name: "Layer with invalid default values"
pkg/cmds/sources/tests/set-from-defaults.yaml:225:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:226:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:232:  expectedLayers: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:235:- name: "Layer with required parameters without defaults"
pkg/cmds/sources/tests/set-from-defaults.yaml:236:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:237:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:242:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:243:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:244:      parameters: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:245:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:246:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:250:- name: "Layer with optional parameters without defaults"
pkg/cmds/sources/tests/set-from-defaults.yaml:251:  parameterLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:252:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:256:  parsedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:257:    - name: "layer1"
pkg/cmds/sources/tests/set-from-defaults.yaml:258:      parameters: [ ]
pkg/cmds/sources/tests/set-from-defaults.yaml:259:  expectedLayers:
pkg/cmds/sources/tests/set-from-defaults.yaml:260:    - name: "layer1"
pkg/cmds/schema/cobra_flag_groups.go:18:// It limits us in the sense that we can't just get the full ParameterDefinition
pkg/cmds/schema/cobra_flag_groups.go:70:// template. Parameters that are not assigned to any group are passed as the "" group, with the
pkg/cmds/schema/cobra_flag_groups.go:89:// through layers usually.
pkg/cmds/schema/cobra_flag_groups.go:143:	// (usually through the ParameterDefinition), and add them to the correct
pkg/cmds/logging/README.md:1:# Clay Logging Layer
pkg/cmds/logging/README.md:3:This package provides a Glazed parameter layer for configuring logging in Clay applications.
pkg/cmds/logging/README.md:7:**📖 For API reference and detailed usage**, see: [Logging Layer API Reference](../../doc/reference/logging-layer.md)
pkg/cmds/logging/README.md:9:**🎓 To learn how to create custom layers**, see: [Custom Layer Tutorial](../../doc/tutorials/custom-layer.md)
pkg/cmds/logging/README.md:13:The logging layer provides:
pkg/cmds/logging/README.md:26:if err := logging.SetupLoggingFromParsedLayers(parsedLayers); err != nil {
pkg/cmds/logging/init.go:128:// Deprecated: Initialize logging from parsed layers using SetupLoggingFromValues instead.
pkg/cmds/logging/init.go:150:// Flags are added by AddLoggingLayerToRootCommand.
pkg/settings/glazed_layer.go:22:type GlazedParameterLayers struct {
pkg/settings/glazed_layer.go:23:	FieldsFiltersParameterLayer *FieldsFiltersParameterLayer `yaml:"fieldsFiltersParameterLayer"`
pkg/settings/glazed_layer.go:24:	OutputParameterLayer        *OutputParameterLayer        `yaml:"outputParameterLayer"`
pkg/settings/glazed_layer.go:25:	RenameParameterLayer        *RenameParameterLayer        `yaml:"renameParameterLayer"`
pkg/settings/glazed_layer.go:26:	ReplaceParameterLayer       *ReplaceParameterLayer       `yaml:"replaceParameterLayer"`
pkg/settings/glazed_layer.go:27:	SelectParameterLayer        *SelectParameterLayer        `yaml:"selectParameterLayer"`
pkg/settings/glazed_layer.go:28:	TemplateParameterLayer      *TemplateParameterLayer      `yaml:"templateParameterLayer"`
pkg/settings/glazed_layer.go:29:	JqParameterLayer            *JqParameterLayer            `yaml:"jqParameterLayer"`
pkg/settings/glazed_layer.go:30:	SortParameterLayer          *SortParameterLayer          `yaml:"sortParameterLayer"`
pkg/settings/glazed_layer.go:31:	SkipLimitParameterLayer     *SkipLimitParameterLayer     `yaml:"skipLimitParameterLayer"`
pkg/settings/glazed_layer.go:36:var _ schema.Section = (*GlazedParameterLayers)(nil)
pkg/settings/glazed_layer.go:37:var _ schema.CobraSection = (*GlazedParameterLayers)(nil)
pkg/settings/glazed_layer.go:40:// It wraps NewGlazedParameterLayers for the schema facade package.
pkg/settings/glazed_layer.go:41:func NewGlazedSchema(options ...GlazeParameterLayerOption) (schema.Section, error) {
pkg/settings/glazed_layer.go:42:	return NewGlazedParameterLayers(options...)
pkg/settings/glazed_layer.go:45:func (g *GlazedParameterLayers) Clone() schema.Section {
pkg/settings/glazed_layer.go:46:	return &GlazedParameterLayers{
pkg/settings/glazed_layer.go:47:		FieldsFiltersParameterLayer: g.FieldsFiltersParameterLayer.Clone().(*FieldsFiltersParameterLayer),
pkg/settings/glazed_layer.go:48:		OutputParameterLayer:        g.OutputParameterLayer.Clone().(*OutputParameterLayer),
pkg/settings/glazed_layer.go:49:		RenameParameterLayer:        g.RenameParameterLayer.Clone().(*RenameParameterLayer),
pkg/settings/glazed_layer.go:50:		ReplaceParameterLayer:       g.ReplaceParameterLayer.Clone().(*ReplaceParameterLayer),
pkg/settings/glazed_layer.go:51:		SelectParameterLayer:        g.SelectParameterLayer.Clone().(*SelectParameterLayer),
pkg/settings/glazed_layer.go:52:		TemplateParameterLayer:      g.TemplateParameterLayer.Clone().(*TemplateParameterLayer),
pkg/settings/glazed_layer.go:53:		JqParameterLayer:            g.JqParameterLayer.Clone().(*JqParameterLayer),
pkg/settings/glazed_layer.go:54:		SortParameterLayer:          g.SortParameterLayer.Clone().(*SortParameterLayer),
pkg/settings/glazed_layer.go:55:		SkipLimitParameterLayer:     g.SkipLimitParameterLayer.Clone().(*SkipLimitParameterLayer),
pkg/settings/glazed_layer.go:59:func (g *GlazedParameterLayers) MarshalYAML() (interface{}, error) {
pkg/settings/glazed_layer.go:65:		ChildLayers: []schema.Section{
pkg/settings/glazed_layer.go:66:			g.FieldsFiltersParameterLayer,
pkg/settings/glazed_layer.go:67:			g.OutputParameterLayer,
pkg/settings/glazed_layer.go:68:			g.RenameParameterLayer,
pkg/settings/glazed_layer.go:69:			g.ReplaceParameterLayer,
pkg/settings/glazed_layer.go:70:			g.SelectParameterLayer,
pkg/settings/glazed_layer.go:71:			g.TemplateParameterLayer,
pkg/settings/glazed_layer.go:72:			g.JqParameterLayer,
pkg/settings/glazed_layer.go:73:			g.SortParameterLayer,
pkg/settings/glazed_layer.go:78:func (g *GlazedParameterLayers) GetName() string {
pkg/settings/glazed_layer.go:82:func (g *GlazedParameterLayers) GetSlug() string {
pkg/settings/glazed_layer.go:86:func (g *GlazedParameterLayers) GetDescription() string {
pkg/settings/glazed_layer.go:90:func (g *GlazedParameterLayers) GetPrefix() string {
pkg/settings/glazed_layer.go:91:	return g.FieldsFiltersParameterLayer.GetPrefix()
pkg/settings/glazed_layer.go:94:func (g *GlazedParameterLayers) AddFields(...*fields.Definition) {
pkg/settings/glazed_layer.go:98:func (g *GlazedParameterLayers) GetDefinitions() *fields.Definitions {
pkg/settings/glazed_layer.go:100:	ret.Merge(g.OutputParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:101:		Merge(g.FieldsFiltersParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:102:		Merge(g.SelectParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:103:		Merge(g.TemplateParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:104:		Merge(g.RenameParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:105:		Merge(g.ReplaceParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:106:		Merge(g.JqParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:107:		Merge(g.SortParameterLayer.GetDefinitions()).
pkg/settings/glazed_layer.go:108:		Merge(g.SkipLimitParameterLayer.GetDefinitions())
pkg/settings/glazed_layer.go:113:func (g *GlazedParameterLayers) AddLayerToCobraCommand(cmd *cobra.Command) error {
pkg/settings/glazed_layer.go:114:	layers := []schema.CobraSection{
pkg/settings/glazed_layer.go:115:		g.OutputParameterLayer,
pkg/settings/glazed_layer.go:116:		g.FieldsFiltersParameterLayer,
pkg/settings/glazed_layer.go:117:		g.SelectParameterLayer,
pkg/settings/glazed_layer.go:118:		g.TemplateParameterLayer,
pkg/settings/glazed_layer.go:119:		g.RenameParameterLayer,
pkg/settings/glazed_layer.go:120:		g.ReplaceParameterLayer,
pkg/settings/glazed_layer.go:121:		g.JqParameterLayer,
pkg/settings/glazed_layer.go:122:		g.SortParameterLayer,
pkg/settings/glazed_layer.go:123:		g.SkipLimitParameterLayer,
pkg/settings/glazed_layer.go:126:	for _, layer := range layers {
pkg/settings/glazed_layer.go:127:		if err := layer.AddLayerToCobraCommand(cmd); err != nil {
pkg/settings/glazed_layer.go:134:func (g *GlazedParameterLayers) ParseLayerFromCobraCommand(
pkg/settings/glazed_layer.go:139:		Layer: g,
pkg/settings/glazed_layer.go:141:	ps := fields.NewParsedParameters()
pkg/settings/glazed_layer.go:143:	layers := []schema.CobraSection{
pkg/settings/glazed_layer.go:144:		g.OutputParameterLayer,
pkg/settings/glazed_layer.go:145:		g.SelectParameterLayer,
pkg/settings/glazed_layer.go:146:		g.RenameParameterLayer,
pkg/settings/glazed_layer.go:147:		g.TemplateParameterLayer,
pkg/settings/glazed_layer.go:148:		g.FieldsFiltersParameterLayer,
pkg/settings/glazed_layer.go:149:		g.ReplaceParameterLayer,
pkg/settings/glazed_layer.go:150:		g.JqParameterLayer,
pkg/settings/glazed_layer.go:151:		g.SortParameterLayer,
pkg/settings/glazed_layer.go:152:		g.SkipLimitParameterLayer,
pkg/settings/glazed_layer.go:155:	for _, layer := range layers {
pkg/settings/glazed_layer.go:156:		l, err := layer.ParseLayerFromCobraCommand(cmd, options...)
pkg/settings/glazed_layer.go:160:		if _, err = ps.Merge(l.Parameters); err != nil {
pkg/settings/glazed_layer.go:165:	res.Parameters = ps
pkg/settings/glazed_layer.go:169:func (g *GlazedParameterLayers) GatherParametersFromMap(
pkg/settings/glazed_layer.go:172:) (*fields.ParsedParameters, error) {
pkg/settings/glazed_layer.go:173:	ps := fields.NewParsedParameters()
pkg/settings/glazed_layer.go:175:	layers := []schema.Section{
pkg/settings/glazed_layer.go:176:		g.OutputParameterLayer,
pkg/settings/glazed_layer.go:177:		g.SelectParameterLayer,
pkg/settings/glazed_layer.go:178:		g.RenameParameterLayer,
pkg/settings/glazed_layer.go:179:		g.TemplateParameterLayer,
pkg/settings/glazed_layer.go:180:		g.FieldsFiltersParameterLayer,
pkg/settings/glazed_layer.go:181:		g.ReplaceParameterLayer,
pkg/settings/glazed_layer.go:182:		g.JqParameterLayer,
pkg/settings/glazed_layer.go:183:		g.SortParameterLayer,
pkg/settings/glazed_layer.go:184:		g.SkipLimitParameterLayer,
pkg/settings/glazed_layer.go:187:	for _, layer := range layers {
pkg/settings/glazed_layer.go:188:		ps_, err := layer.GetDefinitions().GatherParametersFromMap(m, onlyProvided, options...)
pkg/settings/glazed_layer.go:200:func (g *GlazedParameterLayers) InitializeDefaultsFromStruct(s interface{}) error {
pkg/settings/glazed_layer.go:201:	layers := []schema.Section{
pkg/settings/glazed_layer.go:202:		g.OutputParameterLayer,
pkg/settings/glazed_layer.go:203:		g.FieldsFiltersParameterLayer,
pkg/settings/glazed_layer.go:204:		g.SelectParameterLayer,
pkg/settings/glazed_layer.go:205:		g.TemplateParameterLayer,
pkg/settings/glazed_layer.go:206:		g.RenameParameterLayer,
pkg/settings/glazed_layer.go:207:		g.ReplaceParameterLayer,
pkg/settings/glazed_layer.go:208:		g.JqParameterLayer,
pkg/settings/glazed_layer.go:209:		g.SortParameterLayer,
pkg/settings/glazed_layer.go:210:		g.SkipLimitParameterLayer,
pkg/settings/glazed_layer.go:213:	for _, layer := range layers {
pkg/settings/glazed_layer.go:214:		if err := layer.InitializeDefaultsFromStruct(s); err != nil {
pkg/settings/glazed_layer.go:221:type GlazeParameterLayerOption func(*GlazedParameterLayers) error
pkg/settings/glazed_layer.go:223:func WithOutputParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:224:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:226:			err := option(g.OutputParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:235:func WithSelectParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:236:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:238:			err := option(g.SelectParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:247:func WithTemplateParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:248:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:250:			err := option(g.TemplateParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:259:func WithRenameParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:260:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:262:			err := option(g.RenameParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:271:func WithReplaceParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:272:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:274:			err := option(g.ReplaceParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:283:func WithFieldsFiltersParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:284:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:286:			err := option(g.FieldsFiltersParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:295:func WithJqParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:296:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:298:			err := option(g.JqParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:307:func WithSortParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:308:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:310:			err := option(g.SortParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:319:func WithSkipLimitParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {
pkg/settings/glazed_layer.go:320:	return func(g *GlazedParameterLayers) error {
pkg/settings/glazed_layer.go:322:			err := option(g.SkipLimitParameterLayer.SectionImpl)
pkg/settings/glazed_layer.go:331:func NewGlazedParameterLayers(options ...GlazeParameterLayerOption) (*GlazedParameterLayers, error) {
pkg/settings/glazed_layer.go:332:	fieldsFiltersParameterLayer, err := NewFieldsFiltersParameterLayer()
pkg/settings/glazed_layer.go:336:	outputParameterLayer, err := NewOutputParameterLayer()
pkg/settings/glazed_layer.go:340:	renameParameterLayer, err := NewRenameParameterLayer()
pkg/settings/glazed_layer.go:344:	replaceParameterLayer, err := NewReplaceParameterLayer()
pkg/settings/glazed_layer.go:348:	selectParameterLayer, err := NewSelectParameterLayer()
pkg/settings/glazed_layer.go:352:	templateParameterLayer, err := NewTemplateParameterLayer()
pkg/settings/glazed_layer.go:356:	jqParameterLayer, err := NewJqParameterLayer()
pkg/settings/glazed_layer.go:360:	sortParameterLayer, err := NewSortParameterLayer()
pkg/settings/glazed_layer.go:364:	skipLimitParameterLayer, err := NewSkipLimitParameterLayer()
pkg/settings/glazed_layer.go:368:	ret := &GlazedParameterLayers{
pkg/settings/glazed_layer.go:369:		FieldsFiltersParameterLayer: fieldsFiltersParameterLayer,
pkg/settings/glazed_layer.go:370:		OutputParameterLayer:        outputParameterLayer,
pkg/settings/glazed_layer.go:371:		RenameParameterLayer:        renameParameterLayer,
pkg/settings/glazed_layer.go:372:		ReplaceParameterLayer:       replaceParameterLayer,
pkg/settings/glazed_layer.go:373:		SelectParameterLayer:        selectParameterLayer,
pkg/settings/glazed_layer.go:374:		TemplateParameterLayer:      templateParameterLayer,
pkg/settings/glazed_layer.go:375:		JqParameterLayer:            jqParameterLayer,
pkg/settings/glazed_layer.go:376:		SortParameterLayer:          sortParameterLayer,
pkg/settings/glazed_layer.go:377:		SkipLimitParameterLayer:     skipLimitParameterLayer,
pkg/settings/glazed_layer.go:390:func SetupRowOutputFormatter(glazedLayer *values.SectionValues) (formatters.RowOutputFormatter, error) {
pkg/settings/glazed_layer.go:391:	outputSettings, err := NewOutputFormatterSettings(glazedLayer)
pkg/settings/glazed_layer.go:404:func SetupTableOutputFormatter(glazedLayer *values.SectionValues) (formatters.TableOutputFormatter, error) {
pkg/settings/glazed_layer.go:405:	selectSettings, err := NewSelectSettingsFromParameters(glazedLayer)
pkg/settings/glazed_layer.go:410:	outputSettings, err := NewOutputFormatterSettings(glazedLayer)
pkg/settings/glazed_layer.go:447:// DO(manuel, 2023-06-30) It would be good to used a parsedLayer here, if we ever refactor that part
pkg/settings/glazed_layer.go:449:	glazedLayer *values.SectionValues,
pkg/settings/glazed_layer.go:455:	templateSettings, err := NewTemplateSettings(glazedLayer)
pkg/settings/glazed_layer.go:459:	selectSettings, err := NewSelectSettingsFromParameters(glazedLayer)
pkg/settings/glazed_layer.go:463:	renameSettings, err := NewRenameSettingsFromParameters(glazedLayer)
pkg/settings/glazed_layer.go:467:	fieldsFilterSettings, err := NewFieldsFilterSettings(glazedLayer)
pkg/settings/glazed_layer.go:471:	replaceSettings, err := NewReplaceSettingsFromParameters(glazedLayer)
pkg/settings/glazed_layer.go:475:	jqSettings, err := NewJqSettingsFromParameters(glazedLayer)
pkg/settings/glazed_layer.go:479:	sortSettings, err := NewSortSettingsFromParameters(glazedLayer)
pkg/settings/glazed_layer.go:483:	outputSettings, err := NewOutputFormatterSettings(glazedLayer)
pkg/settings/glazed_layer.go:487:	skipLimitSettings, err := NewSkipLimitSettingsFromParameters(glazedLayer)
pkg/settings/glazed_layer.go:545:	// to the API that we currently use (which is a unordered hashmap, and parsed layers that lose the positioning)
pkg/settings/glazed_layer.go:569:	glazedLayer *values.SectionValues,
pkg/settings/glazed_layer.go:573:	rowOf, err := SetupRowOutputFormatter(glazedLayer)
pkg/settings/glazed_layer.go:587:		of, err := SetupTableOutputFormatter(glazedLayer)
pkg/cmds/logging/init-logging.go:30:// Deprecated: Use Glazed config middlewares (LoadParametersFromFiles + UpdateFromEnv) and InitGlazed/InitLoggerFromCobra.
pkg/cmds/logging/init-early.go:77:// Defaults match AddLoggingLayerToRootCommand in layer.go.
pkg/cmds/logging/init-early.go:92:	// Defaults must match glazed/pkg/cmds/logging/layer.go:AddLoggingLayerToRootCommand
pkg/cmds/logging/layer.go:13:// LoggingSettings holds the logging configuration parameters
pkg/cmds/logging/layer.go:28:const LoggingLayerSlug = "logging"
pkg/cmds/logging/layer.go:30:// NewLoggingLayer creates a new parameter layer for logging configuration
pkg/cmds/logging/layer.go:31:func NewLoggingLayer() (schema.Section, error) {
pkg/cmds/logging/layer.go:33:		LoggingLayerSlug,
pkg/cmds/logging/layer.go:110:// AddLoggingLayerToCommand adds the logging layer to a Glazed command
pkg/cmds/logging/layer.go:111:func AddLoggingLayerToCommand(cmd cmds.Command) (cmds.Command, error) {
pkg/cmds/logging/layer.go:112:	loggingLayer, err := NewLoggingLayer()
pkg/cmds/logging/layer.go:117:	cmd.Description().Layers.Set(LoggingLayerSlug, loggingLayer)
pkg/cmds/logging/layer.go:122:func AddLoggingLayerToRootCommand(rootCmd *cobra.Command, appName string) error {
pkg/cmds/logging/layer.go:123:	loggingLayer, err := NewLoggingLayer()
pkg/cmds/logging/layer.go:127:	_ = loggingLayer
pkg/cmds/logging/layer.go:129:	// XXX this would be the proper way to do it if we could easily add parameter definitions as persistent flags. For now, do it manually.
pkg/cmds/logging/layer.go:132:	// loggingLayer.GetDefinitions().ForEachE(func(definition *fields.Definition) error {
pkg/cmds/logging/layer.go:154:// SetupLoggingFromValues configures global logger from command-line parameters
pkg/cmds/logging/layer.go:155:func SetupLoggingFromValues(parsedLayers *values.Values) error {
pkg/cmds/logging/layer.go:156:	settings, err := GetLoggingSettings(parsedLayers)
pkg/cmds/logging/layer.go:164:func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {
pkg/cmds/logging/layer.go:166:	err := parsedLayers.InitializeStruct(LoggingLayerSlug, &settings)
pkg/cmds/runner/run.go:39:// RunCommand executes a Glazed command with the given parsed parameters and options
pkg/cmds/runner/run.go:43:	parsedLayers *values.Values,
pkg/cmds/runner/run.go:59:		return c.Run(ctx, parsedLayers)
pkg/cmds/runner/run.go:62:		return c.RunIntoWriter(ctx, parsedLayers, opts.Writer)
pkg/cmds/runner/run.go:67:			glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)
pkg/cmds/runner/run.go:69:				return fmt.Errorf("glazed layer not found")
pkg/cmds/runner/run.go:71:			gp, err := settings.SetupTableProcessor(glazedLayer)
pkg/cmds/runner/run.go:75:			_, err = settings.SetupProcessorOutput(gp, glazedLayer, opts.Writer)
pkg/cmds/runner/run.go:82:		err := c.RunIntoGlazeProcessor(ctx, parsedLayers, opts.GlazeProcessor)
pkg/cmds/runner/run.go:94:// ParseOptions contains configuration for parameter parsing
pkg/cmds/runner/run.go:96:	ValuesForLayers       map[string]map[string]interface{}
pkg/cmds/runner/run.go:106:// WithValuesForLayers sets values for parameters in specified layers
pkg/cmds/runner/run.go:107:func WithValuesForLayers(values map[string]map[string]interface{}) ParseOption {
pkg/cmds/runner/run.go:109:		o.ValuesForLayers = values
pkg/cmds/runner/run.go:127:// WithViper enables loading parameters from Viper configuration
pkg/cmds/runner/run.go:149:// ParseCommandParameters parses parameters for a command using a configurable middleware chain
pkg/cmds/runner/run.go:150:func ParseCommandParameters(
pkg/cmds/runner/run.go:187:	// Add values for layers middleware if provided
pkg/cmds/runner/run.go:188:	if opts.ValuesForLayers != nil {
pkg/cmds/runner/run.go:190:			cmd_sources.FromMap(opts.ValuesForLayers,
pkg/cmds/runner/run.go:203:	// Create parsed layers and execute middleware chain
pkg/cmds/runner/run.go:204:	parsedLayers := values.New()
pkg/cmds/runner/run.go:206:		cmd.Description().Layers,
pkg/cmds/runner/run.go:207:		parsedLayers,
pkg/cmds/runner/run.go:211:		return nil, fmt.Errorf("failed to parse parameters: %w", err)
pkg/cmds/runner/run.go:214:	return parsedLayers, nil
pkg/cmds/runner/run.go:217:// ParseAndRun combines parameter parsing and command execution into a single function
pkg/cmds/runner/run.go:224:	parsedLayers, err := ParseCommandParameters(cmd, parseOptions...)
pkg/cmds/runner/run.go:229:	return RunCommand(ctx, cmd, parsedLayers, runOptions...)
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:14:func buildTestLayers(t *testing.T, defs ...*fields.Definition) *schema.Schema {
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:20:		t.Fatalf("failed to create layer: %v", err)
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:29:    target_layer: "demo"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:32:        target_parameter: "api-key"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:34:        target_parameter: "threshold"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:44:	if rules[0].Source != "app.settings" || rules[0].TargetLayer != "demo" {
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:55:  target_layer: "demo"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:56:  target_parameter: "api-key"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:58:  target_layer: "demo"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:59:  target_parameter: "threshold"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:76:    target_layer: "demo"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:79:        target_parameter: "{env}-api-key"
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:87:	// Layers with expected params
pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:92:	pls := buildTestLayers(t, defs...)
pkg/cmds/values/serialize_parsed.go:24:	Parameters *fields.SerializableParsedParameters `yaml:"parameters" json:"parameters"`
pkg/cmds/values/serialize_parsed.go:30:	if pl.Layer != nil {
pkg/cmds/values/serialize_parsed.go:32:			Name:        pl.Layer.GetName(),
pkg/cmds/values/serialize_parsed.go:33:			Slug:        pl.Layer.GetSlug(),
pkg/cmds/values/serialize_parsed.go:34:			Description: pl.Layer.GetDescription(),
pkg/cmds/values/serialize_parsed.go:35:			Prefix:      pl.Layer.GetPrefix(),
pkg/cmds/values/serialize_parsed.go:36:			Fields:      pl.Layer.GetDefinitions(),
pkg/cmds/values/serialize_parsed.go:41:		Parameters: fields.ToSerializableParsedParameters(pl.Parameters),
pkg/cmds/values/serialize_parsed.go:49:	Layers *orderedmap.OrderedMap[string, *SerializableSectionValues] `yaml:"layers" json:"layers"`
pkg/cmds/values/serialize_parsed.go:55:		Layers: orderedmap.New[string, *SerializableSectionValues](),
pkg/cmds/values/serialize_parsed.go:60:		ret.Layers.Set(key, serialized)
pkg/cmds/values/serialize_parsed.go:70:	for pair := spl.Layers.Oldest(); pair != nil; pair = pair.Next() {
pkg/cmds/values/serialize_parsed.go:80:	for pair := spl.Layers.Oldest(); pair != nil; pair = pair.Next() {
pkg/cmds/values/test_helpers_test.go:38:func createParameterLayer(t *testing.T, slug, name string, paramDefs ...*fields.Definition) Section {
pkg/cmds/values/test_helpers_test.go:52:func createSectionValues(t *testing.T, layer Section, parsedValues map[string]interface{}) *SectionValues {
pkg/cmds/values/test_helpers_test.go:53:	sectionValues, err := NewSectionValues(layer)
pkg/cmds/values/test_helpers_test.go:60:		definition, ok := layer.GetDefinitions().Get(key)
pkg/cmds/values/test_helpers_test.go:62:		parsed := &fields.ParsedParameter{Definition: definition}
pkg/cmds/values/test_helpers_test.go:65:		sectionValues.Parameters.Set(key, parsed)
pkg/cmds/cobra_test.go:22:	err := definitions.AddParametersToCobraCommand(cmd, "")
pkg/cmds/cobra_test.go:30:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:40:		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),
pkg/cmds/cobra_test.go:42:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:66:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:81:	desc := NewCommandDescription("test", WithLayersList(defaultLayer))
pkg/cmds/cobra_test.go:82:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:113:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:129:		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),
pkg/cmds/cobra_test.go:131:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:168:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:178:	desc := NewCommandDescription("test", WithLayersList(defaultLayer))
pkg/cmds/cobra_test.go:179:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:204:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:215:		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),
pkg/cmds/cobra_test.go:217:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:262:		defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:272:		err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:282:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:293:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:304:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:316:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:322:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:332:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:343:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:353:	desc := NewCommandDescription("test", WithLayersList(defaultLayer))
pkg/cmds/cobra_test.go:354:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:383:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:395:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:401:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:411:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:422:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:436:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:447:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:461:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:471:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:486:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:497:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:510:	err = defaultLayer.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:515:// which is a list of parsed flag parameters, a list of parsed arguments parameters,
pkg/cmds/cobra_test.go:521:	ExpectedArgumentParameters map[string]interface{} `yaml:"argumentParameters"`
pkg/cmds/cobra_test.go:522:	ExpectedFlagParameters     map[string]interface{} `yaml:"flagParameters"`
pkg/cmds/cobra_test.go:556:		layer, err := schema.NewSection(schema.DefaultSlug, "Default",
pkg/cmds/cobra_test.go:561:		testSuite.Description.Layers = schema.NewSchema(schema.WithSections(layer))
pkg/cmds/cobra_test.go:570:			if test2.ExpectedArgumentParameters == nil {
pkg/cmds/cobra_test.go:571:				test2.ExpectedArgumentParameters = map[string]interface{}{}
pkg/cmds/cobra_test.go:573:			if test2.ExpectedFlagParameters == nil {
pkg/cmds/cobra_test.go:574:				test2.ExpectedFlagParameters = map[string]interface{}{}
pkg/cmds/cobra_test.go:593:	var flagParameters *fields.ParsedParameters
pkg/cmds/cobra_test.go:594:	var argumentParameters *fields.ParsedParameters
pkg/cmds/cobra_test.go:598:			flagParameters, flagsError = desc.GetDefaultFlags().GatherFlagsFromCobraCommand(cmd, false, false, "")
pkg/cmds/cobra_test.go:602:			argumentParameters, argsError = desc.GetDefaultArguments().GatherArguments(args, false, false)
pkg/cmds/cobra_test.go:609:	defaultLayer, ok := desc.GetDefaultLayer()
pkg/cmds/cobra_test.go:611:	defaultLayer_, ok := defaultLayer.(schema.CobraSection)
pkg/cmds/cobra_test.go:614:	err := defaultLayer_.AddLayerToCobraCommand(cmd)
pkg/cmds/cobra_test.go:646:	assertJsonEquivalent(t, expected.ExpectedArgumentParameters, argumentParameters)
pkg/cmds/cobra_test.go:647:	assertJsonEquivalent(t, expected.ExpectedFlagParameters, flagParameters)
pkg/cmds/sources/tests/update-from-map-as-default.yaml:2:  description: "Verify that calling UpdateFromMapAsDefault with an empty map does not alter parsedParameters."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:3:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:4:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:15:  parsedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:16:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:17:      parameters:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:25:  expectedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:26:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:33:- name: "Test with non-empty input maps but empty parsedParameters"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:34:  description: "Ensure that all default values from the input map are set in parsedParameters."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:35:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:36:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:44:  parsedLayers: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:46:    layer1:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:49:  expectedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:50:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:56:- name: "Test with existing values in parsedParameters"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:57:  description: "Confirm that existing values in parsedParameters are not overwritten by the defaults in the input map."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:58:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:59:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:67:  parsedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:68:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:69:      parameters:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:73:    layer1:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:76:  expectedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:77:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:84:  description: "Check that only the non-existing keys in parsedParameters are updated with the default values from the input map."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:85:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:86:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:94:  parsedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:95:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:96:      parameters:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:100:    layer1:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:102:  expectedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:103:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:110:  description: "Ensure that none of the values in parsedParameters are changed when the input map contains all the same keys but with different values."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:111:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:112:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:120:  parsedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:121:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:122:      parameters:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:128:    layer1:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:131:  expectedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:132:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:139:  description: "Attempt to update parsedParameters with defaults of incorrect types and verify that it results in an error."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:140:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:141:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:149:  parsedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:150:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:151:      parameters: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:153:    layer1:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:156:  expectedLayers: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:159:- name: "Test with ParameterLayer not present in layers_"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:160:  description: "Confirm that the middleware skips any layers not present in layers_ and does not throw an error."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:161:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:162:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:167:  parsedLayers: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:169:    layer2:  # This layer is not defined in parameterLayers
pkg/cmds/sources/tests/update-from-map-as-default.yaml:171:  expectedLayers: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:174:- name: "Test with ParameterDefinition choices"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:175:  description: "When a parameter has specific choices, verify that defaults not in the choices do not get set and result in an error."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:176:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:177:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:183:  parsedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:184:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:185:      parameters: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:187:    layer1:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:189:  expectedLayers: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:192:- name: "Test with multiple layers"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:193:  description: "Verify that the middleware correctly updates defaults across multiple layers without affecting already set parameters in any layer."
pkg/cmds/sources/tests/update-from-map-as-default.yaml:194:  parameterLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:195:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:200:    - name: "layer2"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:205:  parsedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:206:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:207:      parameters:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:210:    - name: "layer2"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:211:      parameters: []
pkg/cmds/sources/tests/update-from-map-as-default.yaml:213:    layer1:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:215:    layer2:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:217:  expectedLayers:
pkg/cmds/sources/tests/update-from-map-as-default.yaml:218:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map-as-default.yaml:221:    - name: "layer2"
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:13:// createTestLayers creates a test parameter layer structure
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:14:func createTestLayers(t *testing.T) *schema.Schema {
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:15:	demoLayer, err := schema.NewSection(
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:17:		"Demo Layer",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:32:		schema.WithSections(demoLayer),
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:48:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:49:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:59:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:60:					TargetParameter: "{env}-api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:70:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:71:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:81:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:82:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:93:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:94:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:105:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:106:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:117:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:118:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:129:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:130:					TargetParameter: "{env}-api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:134:			errorMsg:    "capture reference {env} in target parameter not found in source pattern",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:137:			name: "invalid target layer - does not exist",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:141:					TargetLayer:     "nonexistent",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:142:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:146:			errorMsg:    "target layer \"nonexistent\" does not exist",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:153:					TargetLayer: "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:155:						{Source: "api_key", TargetParameter: "api-key"},
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:156:						{Source: "threshold", TargetParameter: "threshold"},
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:167:					TargetLayer: "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:169:						{Source: "api_key", TargetParameter: "{env}-api-key"},
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:176:			name: "invalid static target parameter at compile time",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:180:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:181:					TargetParameter: "nonexistent", // Should fail at compile time
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:185:			errorMsg:    "target parameter \"nonexistent\" does not exist in layer \"demo\"",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:191:			layers_ := createTestLayers(t)
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:192:			_, err := pm.NewConfigMapper(layers_, tt.rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:219:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:220:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:242:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:243:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:247:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:248:					TargetParameter: "threshold",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:272:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:273:					TargetParameter: "{env}-api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:299:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:300:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:325:					TargetLayer: "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:327:						{Source: "api_key", TargetParameter: "api-key"},
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:328:						{Source: "threshold", TargetParameter: "threshold"},
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:353:					TargetLayer: "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:355:						{Source: "api_key", TargetParameter: "{env}-api-key"},
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:356:						{Source: "threshold", TargetParameter: "{env}-threshold"},
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:391:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:392:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:411:					TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:412:					TargetParameter: "api-key",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:430:			testLayers := createTestLayers(t)
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:431:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:609:func TestResolveTargetParameter(t *testing.T) {
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:660:			result, err := pm.ResolveTargetParameter(tt.target, tt.captures)
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:672:func TestIntegrationWithLoadParametersFromFile(t *testing.T) {
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:674:	testLayers := createTestLayers(t)
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:677:	mapper, err := pm.NewConfigMapper(testLayers, pm.MappingRule{
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:679:		TargetLayer:     "demo",
pkg/cmds/sources/patternmapper/pattern_mapper_test.go:680:		TargetParameter: "api-key",
pkg/cmds/sources/tests/middlewares.yaml:1:- name: "Empty middlewares and parsedLayers"
pkg/cmds/sources/tests/middlewares.yaml:2:  description: "Empty middlewares should result in empty parsed layers"
pkg/cmds/sources/tests/middlewares.yaml:3:  parameterLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:4:  parsedLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:5:  expectedLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:9:- name: "Empty parsedLayers, set from defaults"
pkg/cmds/sources/tests/middlewares.yaml:10:  description: "Only set from defaults middlewares, with empty parsed layers"
pkg/cmds/sources/tests/middlewares.yaml:11:  parameterLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:12:  parsedLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:13:  expectedLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:21:- name: "Single parameter, set from defaults"
pkg/cmds/sources/tests/middlewares.yaml:22:  description: "Only set from defaults middlewares, with single parameter"
pkg/cmds/sources/tests/middlewares.yaml:23:  parameterLayers:
pkg/cmds/sources/tests/middlewares.yaml:24:    - name: "layer1"
pkg/cmds/sources/tests/middlewares.yaml:29:  parsedLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:30:  expectedLayers:
pkg/cmds/sources/tests/middlewares.yaml:31:    - name: "layer1"
pkg/cmds/sources/tests/middlewares.yaml:45:- name: "Single parameter, set from defaults and then update from map"
pkg/cmds/sources/tests/middlewares.yaml:46:  description: "Set from defaults then map middlewares, with single parameter"
pkg/cmds/sources/tests/middlewares.yaml:47:  parameterLayers:
pkg/cmds/sources/tests/middlewares.yaml:48:    - name: "layer1"
pkg/cmds/sources/tests/middlewares.yaml:53:  parsedLayers: [ ]
pkg/cmds/sources/tests/middlewares.yaml:54:  expectedLayers:
pkg/cmds/sources/tests/middlewares.yaml:55:    - name: "layer1"
pkg/cmds/sources/tests/middlewares.yaml:73:        layer1:
pkg/cmds/values/parsed-layer.go:66:	Layer      Section
pkg/cmds/values/parsed-layer.go:67:	Parameters *fields.ParsedParameters
pkg/cmds/values/parsed-layer.go:72:func WithParameterValue(
pkg/cmds/values/parsed-layer.go:77:		pd, ok := pl.Layer.GetDefinitions().Get(key)
pkg/cmds/values/parsed-layer.go:79:			return errors.Errorf("parameter definition %s not found in layer %s", key, pl.Layer.GetName())
pkg/cmds/values/parsed-layer.go:81:		p := &fields.ParsedParameter{
pkg/cmds/values/parsed-layer.go:88:		pl.Parameters.Set(key, p)
pkg/cmds/values/parsed-layer.go:94:func WithParameters(pds *fields.ParsedParameters) SectionValuesOption {
pkg/cmds/values/parsed-layer.go:96:		pds.ForEach(func(k string, v *fields.ParsedParameter) {
pkg/cmds/values/parsed-layer.go:97:			pl.Parameters.Set(k, v)
pkg/cmds/values/parsed-layer.go:103:func NewSectionValues(layer Section, options ...SectionValuesOption) (*SectionValues, error) {
pkg/cmds/values/parsed-layer.go:105:		Layer:      layer,
pkg/cmds/values/parsed-layer.go:106:		Parameters: fields.NewParsedParameters(),
pkg/cmds/values/parsed-layer.go:119:// Clone returns a copy of the parsedParameterLayer with a fresh Parameters map.
pkg/cmds/values/parsed-layer.go:120:// However, neither the Layer nor the Parameters are deep copied.
pkg/cmds/values/parsed-layer.go:122:	parameters_, err := fields.NewParsedParameters().Merge(ppl.Parameters)
pkg/cmds/values/parsed-layer.go:127:		Layer:      ppl.Layer,
pkg/cmds/values/parsed-layer.go:128:		Parameters: parameters_,
pkg/cmds/values/parsed-layer.go:130:	ppl.Parameters.ForEach(func(k string, v *fields.ParsedParameter) {
pkg/cmds/values/parsed-layer.go:131:		ret.Parameters.Set(k, v)
pkg/cmds/values/parsed-layer.go:136:// MergeParameters merges the other SectionValues into this one, overwriting any
pkg/cmds/values/parsed-layer.go:137:// existing values. This doesn't replace the actual Layer pointer.
pkg/cmds/values/parsed-layer.go:138:func (ppl *SectionValues) MergeParameters(other *SectionValues) error {
pkg/cmds/values/parsed-layer.go:139:	_, err := ppl.Parameters.Merge(other.Parameters)
pkg/cmds/values/parsed-layer.go:143:func (ppl *SectionValues) GetParameter(k string) (interface{}, bool) {
pkg/cmds/values/parsed-layer.go:144:	v, ok := ppl.Parameters.Get(k)
pkg/cmds/values/parsed-layer.go:152:	return ppl.Parameters.InitializeStruct(s)
pkg/cmds/values/parsed-layer.go:191:			err := v.MergeParameters(o)
pkg/cmds/values/parsed-layer.go:206:			err := o_.MergeParameters(v)
pkg/cmds/values/parsed-layer.go:219:func (p *Values) GetOrCreate(layer Section) *SectionValues {
pkg/cmds/values/parsed-layer.go:220:	if layer == nil {
pkg/cmds/values/parsed-layer.go:221:		panic("layer must not be nil")
pkg/cmds/values/parsed-layer.go:223:	slug := layer.GetSlug()
pkg/cmds/values/parsed-layer.go:227:			Layer:      layer,
pkg/cmds/values/parsed-layer.go:228:			Parameters: fields.NewParsedParameters(),
pkg/cmds/values/parsed-layer.go:235:// GetDataMap is useful when rendering out templates using all passed in layers.
pkg/cmds/values/parsed-layer.go:239:		v.Parameters.ForEach(func(k string, v *fields.ParsedParameter) {
pkg/cmds/values/parsed-layer.go:247:// If the key is "default", it creates a fresh empty default layer for defaults and initializes the struct with it.
pkg/cmds/values/parsed-layer.go:248:// If the layer specified by the key is not found, it returns an error.
pkg/cmds/values/parsed-layer.go:249:// The struct must be passed by reference as the s parameter.
pkg/cmds/values/parsed-layer.go:250:func (p *Values) InitializeStruct(layerKey string, dst interface{}) error {
pkg/cmds/values/parsed-layer.go:251:	// We special case Default because we will create a fresh empty default layer for defaults.
pkg/cmds/values/parsed-layer.go:253:	if layerKey == DefaultSlug {
pkg/cmds/values/parsed-layer.go:254:		return p.GetDefaultParameterLayer().InitializeStruct(dst)
pkg/cmds/values/parsed-layer.go:256:	v, ok := p.Get(layerKey)
pkg/cmds/values/parsed-layer.go:258:		return errors.Errorf("layer %s not found", layerKey)
pkg/cmds/values/parsed-layer.go:263:// GetAllParsedParameters returns a new instance of fields.ParsedParameters
pkg/cmds/values/parsed-layer.go:264:// that merges the parameters from all Values.
pkg/cmds/values/parsed-layer.go:265:// The returned parameters are a deep clone of the fields.
pkg/cmds/values/parsed-layer.go:266:func (p *Values) GetAllParsedParameters() *fields.ParsedParameters {
pkg/cmds/values/parsed-layer.go:267:	ret := fields.NewParsedParameters()
pkg/cmds/values/parsed-layer.go:270:			_, err := ret.Merge(v.Parameters.Clone())
pkg/cmds/values/parsed-layer.go:280:func (p *Values) GetParameter(slug string, key string) (*fields.ParsedParameter, bool) {
pkg/cmds/values/parsed-layer.go:281:	layer, ok := p.Get(slug)
pkg/cmds/values/parsed-layer.go:285:	return layer.Parameters.Get(key)
pkg/cmds/values/parsed-layer.go:288:func (p *Values) GetDefaultParameterLayer() *SectionValues {
pkg/cmds/values/parsed-layer.go:293:	defaultParameterLayer := newDefaultSection(DefaultSlug, "Default")
pkg/cmds/values/parsed-layer.go:294:	defaultLayer := &SectionValues{
pkg/cmds/values/parsed-layer.go:295:		Layer:      defaultParameterLayer,
pkg/cmds/values/parsed-layer.go:296:		Parameters: fields.NewParsedParameters(),
pkg/cmds/values/parsed-layer.go:298:	p.Set(DefaultSlug, defaultLayer)
pkg/cmds/values/parsed-layer.go:300:	return defaultLayer
pkg/cmds/sources/tests/update-from-map.yaml:1:- name: "Update single layer with valid map"
pkg/cmds/sources/tests/update-from-map.yaml:2:  description: "Updating a single layer with valid values should correctly merge these values"
pkg/cmds/sources/tests/update-from-map.yaml:3:  parameterLayers:
pkg/cmds/sources/tests/update-from-map.yaml:4:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:10:  parsedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:11:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:12:      parameters:
pkg/cmds/sources/tests/update-from-map.yaml:16:    layer1:
pkg/cmds/sources/tests/update-from-map.yaml:19:  expectedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:20:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:26:- name: "Update non-existent layer"
pkg/cmds/sources/tests/update-from-map.yaml:27:  description: "Updating a non-existent layer should be ignored and no error should be thrown"
pkg/cmds/sources/tests/update-from-map.yaml:28:  parameterLayers:
pkg/cmds/sources/tests/update-from-map.yaml:29:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:33:  parsedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:34:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:36:    layer2:
pkg/cmds/sources/tests/update-from-map.yaml:38:  expectedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:39:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:43:- name: "Invalid parameter type in update map"
pkg/cmds/sources/tests/update-from-map.yaml:44:  description: "An invalid parameter type in the update map should result in an error"
pkg/cmds/sources/tests/update-from-map.yaml:45:  parameterLayers:
pkg/cmds/sources/tests/update-from-map.yaml:46:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:50:  parsedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:51:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:53:    layer1:
pkg/cmds/sources/tests/update-from-map.yaml:55:  expectedLayers: null
pkg/cmds/sources/tests/update-from-map.yaml:59:  description: "Updating with an empty map should leave the layers unchanged"
pkg/cmds/sources/tests/update-from-map.yaml:60:  parameterLayers:
pkg/cmds/sources/tests/update-from-map.yaml:61:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:65:  parsedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:66:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:67:      parameters:
pkg/cmds/sources/tests/update-from-map.yaml:71:    layer1: {}
pkg/cmds/sources/tests/update-from-map.yaml:72:  expectedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:73:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:79:  description: "Extra keys in the map that are not defined in the ParameterLayer are ignored"
pkg/cmds/sources/tests/update-from-map.yaml:80:  parameterLayers:
pkg/cmds/sources/tests/update-from-map.yaml:81:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:85:  parsedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:86:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:88:    layer1:
pkg/cmds/sources/tests/update-from-map.yaml:91:  expectedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:92:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:99:  parameterLayers:
pkg/cmds/sources/tests/update-from-map.yaml:100:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:107:  parsedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:108:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:110:    layer1:
pkg/cmds/sources/tests/update-from-map.yaml:112:  expectedLayers: null
pkg/cmds/sources/tests/update-from-map.yaml:115:- name: "TestUpdateFromMapWithMultipleLayers"
pkg/cmds/sources/tests/update-from-map.yaml:116:  description: "Correctly updates parsedLayers for multiple layers"
pkg/cmds/sources/tests/update-from-map.yaml:117:  parameterLayers:
pkg/cmds/sources/tests/update-from-map.yaml:118:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:122:    - name: "layer2"
pkg/cmds/sources/tests/update-from-map.yaml:126:  parsedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:127:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:128:    - name: "layer2"
pkg/cmds/sources/tests/update-from-map.yaml:130:    layer1:
pkg/cmds/sources/tests/update-from-map.yaml:132:    layer2:
pkg/cmds/sources/tests/update-from-map.yaml:134:  expectedLayers:
pkg/cmds/sources/tests/update-from-map.yaml:135:    - name: "layer1"
pkg/cmds/sources/tests/update-from-map.yaml:138:    - name: "layer2"
pkg/cmds/sources/patternmapper/loader.go:22:	TargetLayer     string        `yaml:"target_layer" json:"target_layer"`
pkg/cmds/sources/patternmapper/loader.go:23:	TargetParameter string        `yaml:"target_parameter" json:"target_parameter"`
pkg/cmds/sources/patternmapper/loader.go:31:		TargetLayer:     mr.TargetLayer,
pkg/cmds/sources/patternmapper/loader.go:32:		TargetParameter: mr.TargetParameter,
pkg/cmds/sources/patternmapper/loader.go:96:// LoadMapperFromFile loads a ConfigMapper from a YAML/JSON mapping file using the provided layers.
pkg/cmds/sources/patternmapper/loader.go:97:func LoadMapperFromFile(layers_ *schema.Schema, filename string) (sources.ConfigMapper, error) {
pkg/cmds/sources/patternmapper/loader.go:102:	return NewConfigMapper(layers_, rules...)
pkg/cmds/values/parsed-layer_test.go:12:	parsedLayers := New()
pkg/cmds/values/parsed-layer_test.go:13:	assert.NotNil(t, parsedLayers)
pkg/cmds/values/parsed-layer_test.go:14:	assert.Equal(t, 0, parsedLayers.Len())
pkg/cmds/values/parsed-layer_test.go:18:	layer := createParameterLayer(t, "test", "Test Layer")
pkg/cmds/values/parsed-layer_test.go:19:	parsedLayer := createSectionValues(t, layer, nil)
pkg/cmds/values/parsed-layer_test.go:21:	parsedLayers := New(WithSectionValues("test", parsedLayer))
pkg/cmds/values/parsed-layer_test.go:23:	assert.Equal(t, 1, parsedLayers.Len())
pkg/cmds/values/parsed-layer_test.go:24:	val, present := parsedLayers.Get("test")
pkg/cmds/values/parsed-layer_test.go:26:	assert.Equal(t, parsedLayer, val)
pkg/cmds/values/parsed-layer_test.go:30:	layer := createParameterLayer(t, "test", "Test Layer")
pkg/cmds/values/parsed-layer_test.go:31:	parsedLayer := createSectionValues(t, layer, nil)
pkg/cmds/values/parsed-layer_test.go:32:	parsedLayers := New(WithSectionValues("test", parsedLayer))
pkg/cmds/values/parsed-layer_test.go:34:	cloned := parsedLayers.Clone()
pkg/cmds/values/parsed-layer_test.go:36:	assert.Equal(t, parsedLayers.Len(), cloned.Len())
pkg/cmds/values/parsed-layer_test.go:37:	originalVal, _ := parsedLayers.Get("test")
pkg/cmds/values/parsed-layer_test.go:41:	assert.Equal(t, originalVal.Layer, clonedVal.Layer)
pkg/cmds/values/parsed-layer_test.go:45:	parsedLayers := New()
pkg/cmds/values/parsed-layer_test.go:46:	layer := createParameterLayer(t, "test", "Test Layer")
pkg/cmds/values/parsed-layer_test.go:48:	// Get non-existent layer (should create)
pkg/cmds/values/parsed-layer_test.go:49:	parsedLayer := parsedLayers.GetOrCreate(layer)
pkg/cmds/values/parsed-layer_test.go:50:	assert.NotNil(t, parsedLayer)
pkg/cmds/values/parsed-layer_test.go:51:	assert.Equal(t, layer, parsedLayer.Layer)
pkg/cmds/values/parsed-layer_test.go:53:	// Get existing layer
pkg/cmds/values/parsed-layer_test.go:54:	sameLayer := parsedLayers.GetOrCreate(layer)
pkg/cmds/values/parsed-layer_test.go:55:	assert.Equal(t, parsedLayer, sameLayer)
pkg/cmds/values/parsed-layer_test.go:59:	layer1 := createParameterLayer(t, "layer1", "Layer 1",
pkg/cmds/values/parsed-layer_test.go:62:	parsedLayer1 := createSectionValues(t, layer1, map[string]interface{}{"param1": "value1"})
pkg/cmds/values/parsed-layer_test.go:64:	layer2 := createParameterLayer(t, "layer2", "Layer 2",
pkg/cmds/values/parsed-layer_test.go:67:	parsedLayer2 := createSectionValues(t, layer2, map[string]interface{}{"param2": 42})
pkg/cmds/values/parsed-layer_test.go:69:	parsedLayers := New(
pkg/cmds/values/parsed-layer_test.go:70:		WithSectionValues("layer1", parsedLayer1),
pkg/cmds/values/parsed-layer_test.go:71:		WithSectionValues("layer2", parsedLayer2),
pkg/cmds/values/parsed-layer_test.go:74:	dataMap := parsedLayers.GetDataMap()
pkg/cmds/values/parsed-layer_test.go:86:	layer := createParameterLayer(t, "test", "Test Layer",
pkg/cmds/values/parsed-layer_test.go:90:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{
pkg/cmds/values/parsed-layer_test.go:94:	parsedLayers := New(WithSectionValues("test", parsedLayer))
pkg/cmds/values/parsed-layer_test.go:97:	err := parsedLayers.InitializeStruct("test", &result)
pkg/cmds/values/parsed-layer_test.go:103:func TestValuesGetAllParsedParameters(t *testing.T) {
pkg/cmds/values/parsed-layer_test.go:104:	layer1 := createParameterLayer(t, "layer1", "Layer 1",
pkg/cmds/values/parsed-layer_test.go:107:	parsedLayer1 := createSectionValues(t, layer1, map[string]interface{}{"param1": "value1"})
pkg/cmds/values/parsed-layer_test.go:109:	layer2 := createParameterLayer(t, "layer2", "Layer 2",
pkg/cmds/values/parsed-layer_test.go:112:	parsedLayer2 := createSectionValues(t, layer2, map[string]interface{}{"param2": 42})
pkg/cmds/values/parsed-layer_test.go:114:	parsedLayers := New(
pkg/cmds/values/parsed-layer_test.go:115:		WithSectionValues("layer1", parsedLayer1),
pkg/cmds/values/parsed-layer_test.go:116:		WithSectionValues("layer2", parsedLayer2),
pkg/cmds/values/parsed-layer_test.go:119:	allParams := parsedLayers.GetAllParsedParameters()
pkg/cmds/values/parsed-layer_test.go:129:func TestValuesGetParameter(t *testing.T) {
pkg/cmds/values/parsed-layer_test.go:130:	layer := createParameterLayer(t, "test", "Test Layer",
pkg/cmds/values/parsed-layer_test.go:133:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"param": "value"})
pkg/cmds/values/parsed-layer_test.go:134:	parsedLayers := New(WithSectionValues("test", parsedLayer))
pkg/cmds/values/parsed-layer_test.go:136:	param, present := parsedLayers.GetParameter("test", "param")
pkg/cmds/values/parsed-layer_test.go:140:	_, present = parsedLayers.GetParameter("non_existent", "param")
pkg/cmds/values/parsed-layer_test.go:143:	_, present = parsedLayers.GetParameter("test", "non_existent")
pkg/cmds/values/parsed-layer_test.go:147:func TestValuesGetDefaultParameterLayer(t *testing.T) {
pkg/cmds/values/parsed-layer_test.go:148:	parsedLayers := New()
pkg/cmds/values/parsed-layer_test.go:150:	defaultLayer := parsedLayers.GetDefaultParameterLayer()
pkg/cmds/values/parsed-layer_test.go:151:	assert.NotNil(t, defaultLayer)
pkg/cmds/values/parsed-layer_test.go:152:	assert.Equal(t, DefaultSlug, defaultLayer.Layer.GetSlug())
pkg/cmds/values/parsed-layer_test.go:154:	// Calling it again should return the same layer
pkg/cmds/values/parsed-layer_test.go:155:	sameDefaultLayer := parsedLayers.GetDefaultParameterLayer()
pkg/cmds/values/parsed-layer_test.go:156:	assert.Equal(t, defaultLayer, sameDefaultLayer)
pkg/cmds/values/parsed-layer_test.go:160:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/values/parsed-layer_test.go:161:	parsedLayer1 := createSectionValues(t, layer1, nil)
pkg/cmds/values/parsed-layer_test.go:163:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/values/parsed-layer_test.go:164:	parsedLayer2 := createSectionValues(t, layer2, nil)
pkg/cmds/values/parsed-layer_test.go:166:	parsedLayers := New(
pkg/cmds/values/parsed-layer_test.go:167:		WithSectionValues("layer1", parsedLayer1),
pkg/cmds/values/parsed-layer_test.go:168:		WithSectionValues("layer2", parsedLayer2),
pkg/cmds/values/parsed-layer_test.go:172:	parsedLayers.ForEach(func(k string, v *SectionValues) {
pkg/cmds/values/parsed-layer_test.go:174:		assert.Contains(t, []string{"layer1", "layer2"}, k)
pkg/cmds/values/parsed-layer_test.go:180:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/values/parsed-layer_test.go:181:	parsedLayer1 := createSectionValues(t, layer1, nil)
pkg/cmds/values/parsed-layer_test.go:183:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/values/parsed-layer_test.go:184:	parsedLayer2 := createSectionValues(t, layer2, nil)
pkg/cmds/values/parsed-layer_test.go:186:	parsedLayers := New(
pkg/cmds/values/parsed-layer_test.go:187:		WithSectionValues("layer1", parsedLayer1),
pkg/cmds/values/parsed-layer_test.go:188:		WithSectionValues("layer2", parsedLayer2),
pkg/cmds/values/parsed-layer_test.go:192:	err := parsedLayers.ForEachE(func(k string, v *SectionValues) error {
pkg/cmds/values/parsed-layer_test.go:200:	errorOnSecond := parsedLayers.ForEachE(func(k string, v *SectionValues) error {
pkg/cmds/values/parsed-layer_test.go:201:		if k == "layer2" {
pkg/cmds/values/parsed-layer_test.go:210:	layer := createParameterLayer(t, "test", "Test Layer",
pkg/cmds/values/parsed-layer_test.go:213:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"exported": "value"})
pkg/cmds/values/parsed-layer_test.go:223:	err := parsedLayer.InitializeStruct(&result)
pkg/cmds/values/parsed-layer_test.go:231:	parsedLayers := New()
pkg/cmds/values/parsed-layer_test.go:232:	layer := createParameterLayer(t, "test", "Test Layer",
pkg/cmds/values/parsed-layer_test.go:235:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"param": "value"})
pkg/cmds/values/parsed-layer_test.go:236:	parsedLayers.Set("test", parsedLayer)
pkg/cmds/values/parsed-layer_test.go:243:	err := parsedLayers.InitializeStruct("test", result) // Note: passing result, not &result
pkg/cmds/values/parsed-layer_test.go:248:func TestValuesGetParameterNonExistentLayer(t *testing.T) {
pkg/cmds/values/parsed-layer_test.go:249:	parsedLayers := New()
pkg/cmds/values/parsed-layer_test.go:251:	_, present := parsedLayers.GetParameter("non_existent", "param")
pkg/cmds/values/parsed-layer_test.go:255:func TestValuesGetOrCreateNilLayer(t *testing.T) {
pkg/cmds/values/parsed-layer_test.go:256:	parsedLayers := New()
pkg/cmds/values/parsed-layer_test.go:258:	// Depending on how you want to handle this case, you might expect an error or a new empty layer
pkg/cmds/values/parsed-layer_test.go:260:	assert.Panics(t, func() { parsedLayers.GetOrCreate(nil) })
pkg/cmds/values/parsed-layer_test.go:264:	layer := createParameterLayer(t, "test", "Test Layer",
pkg/cmds/values/parsed-layer_test.go:274:		options = append(options, WithParameterValue(key, value))
pkg/cmds/values/parsed-layer_test.go:276:	_, err := NewSectionValues(layer, options...)
pkg/cmds/values/parsed-layer_test.go:281:	layer1 := createParameterLayer(t, "layer1", "Layer 1")
pkg/cmds/values/parsed-layer_test.go:282:	parsedLayer1 := createSectionValues(t, layer1, nil)
pkg/cmds/values/parsed-layer_test.go:283:	layer2 := createParameterLayer(t, "layer2", "Layer 2")
pkg/cmds/values/parsed-layer_test.go:284:	parsedLayer2 := createSectionValues(t, layer2, nil)
pkg/cmds/values/parsed-layer_test.go:286:	parsedLayers := New(
pkg/cmds/values/parsed-layer_test.go:287:		WithSectionValues("layer1", parsedLayer1),
pkg/cmds/values/parsed-layer_test.go:288:		WithSectionValues("layer2", parsedLayer2),
pkg/cmds/values/parsed-layer_test.go:292:	err := parsedLayers.ForEachE(func(k string, v *SectionValues) error {
pkg/cmds/values/parsed-layer_test.go:294:		if k == "layer2" {
pkg/cmds/values/parsed-layer_test.go:302:	assert.Equal(t, 2, count) // The loop should have proceeded to the second layer before stopping
pkg/cmds/values/parsed-layer_test.go:320:	// Create a parameter layer with all the necessary definitions
pkg/cmds/values/parsed-layer_test.go:321:	layer := createParameterLayer(t, "test", "Test Layer",
pkg/cmds/values/parsed-layer_test.go:330:	// Create a parsed layer with test values
pkg/cmds/values/parsed-layer_test.go:331:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{
pkg/cmds/values/parsed-layer_test.go:340:	// Create Values and add the parsed layer
pkg/cmds/values/parsed-layer_test.go:341:	parsedLayers := New(WithSectionValues("test", parsedLayer))
pkg/cmds/values/parsed-layer_test.go:345:	err := parsedLayers.InitializeStruct("test", &result)
pkg/cmds/values/parsed-layer_test.go:379:	// Create a parameter layer with all the necessary definitions
pkg/cmds/values/parsed-layer_test.go:380:	layer := createParameterLayer(t, "test", "Test Layer",
pkg/cmds/values/parsed-layer_test.go:386:	// Create a parsed layer with test values
pkg/cmds/values/parsed-layer_test.go:387:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{
pkg/cmds/values/parsed-layer_test.go:393:	// Create Values and add the parsed layer
pkg/cmds/values/parsed-layer_test.go:394:	parsedLayers := New(WithSectionValues("test", parsedLayer))
pkg/cmds/values/parsed-layer_test.go:398:	err := parsedLayers.InitializeStruct("test", &result)
