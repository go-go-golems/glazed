---
Title: Exhaustive parameter/layer audit
Ticket: GL-002-FURTHER-CLEANUP
Status: active
Topics:
    - glazed
    - api-design
    - renaming
    - cleanup
DocType: analysis
Intent: long-term
Owners:
    - manuel
RelatedFiles: []
ExternalSources: []
Summary: ""
LastUpdated: 2026-02-02T19:55:00
WhatFor: ""
WhenToUse: ""
---

# Exhaustive Parameter/Layer Audit

Generated: `2026-02-02T19:55:00`

## Scope
This audit scanned **every file** under the `glazed/` repository root (excluding `.git`). Both filenames and file contents were inspected for case-insensitive mentions of `parameter` and `layer`, plus the legacy `glazed.parameter` struct tag. Binary files were detected by NUL bytes and recorded as binary without line-level inspection.

## Compile status
- `go test ./...` succeeded (see diary for full command output).

## Summary Counts
- Total files scanned: **644**
- Text files scanned: **638**
- Binary files scanned: **6**
- Files with `parameter` in contents: **246**
- Files with `layer` in contents: **221**
- Files with `glazed.parameter` in contents: **2**

## High-level answers
- **Does the repo still compile?** Yes (latest `go test ./...` succeeded).
- **Are there any remaining `layer`/`parameter` mentions?** Yes. See the per-file listings below; they remain in docs, example comments, and a handful of code paths that still describe domain concepts as layers/parameters.
- **Any remaining `glazed.parameter` tags?** Only if listed below; all runtime tag parsing now expects `glazed:`.

## Filenames containing "parameter"
- `cmd/examples/parameter-types/README.md`
- `cmd/examples/parameter-types/config.yaml`
- `cmd/examples/parameter-types/main.go`
- `cmd/examples/parameter-types/sample-lines.txt`
- `cmd/examples/parameter-types/sample-list.json`
- `cmd/examples/parameter-types/sample-text.txt`
- `cmd/examples/parameter-types/sample.json`
- `cmd/examples/parameter-types/sample.yaml`
- `cmd/examples/parameter-types/simple-config.yaml`
- `misc/json-parameters-from-json.json`
- `pkg/cmds/fields/gather-parameters.go`
- `pkg/cmds/fields/gather-parameters_test.go`
- `pkg/cmds/fields/parameter-type.go`
- `pkg/cmds/fields/parameters.go`
- `pkg/cmds/fields/parameters_from_defaults_test.go`
- `pkg/cmds/fields/parameters_test.go`
- `pkg/cmds/fields/parsed-parameter.go`
- `pkg/cmds/fields/test-data/parameters_test.yaml`
- `pkg/cmds/fields/test-data/parameters_validity_test.yaml`
- `pkg/cmds/sources/load-parameters-from-json.go`
- `pkg/doc/topics/07-load-parameters-from-json.md`
- `pkg/doc/topics/08-file-parameter-type.md`
- `pkg/doc/topics/16-adding-parameter-types.md`
- `pkg/doc/topics/16-parsing-parameters.md`
- `prompto/glazed/parameter-types`
- `prompto/glazed/parameters`
- `prompto/glazed/parameters-verbose`
- `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/analysis/01-glazed-parameter-parsing-architecture-analysis.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/README.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/changelog.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/01-debate-round-1-option-a-naming-api-design-schema-fields-values-sources.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-composer-metadata.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-independent-composer-analysis.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/diary/01-diary-layer-parameter-renaming-work.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/index.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/tasks.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/README.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/analysis/01-analysis-parameterlayer-to-pflag-flagset-conversion-for-early-logging.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/changelog.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/index.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/tasks.md`
- `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/01-documentation-deprecation-audit-layers-parameters-schema-fields-values-sources.md`
- `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/analysis/01-exhaustive-parameter-layer-audit.md`
- `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`

## Filenames containing "layer"
- `pkg/cmds/logging/layer.go`
- `pkg/cmds/schema/layer-impl.go`
- `pkg/cmds/schema/layer-impl_test.go`
- `pkg/cmds/schema/layer.go`
- `pkg/cmds/schema/layer_test.go`
- `pkg/cmds/sources/layers.go`
- `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml`
- `pkg/cmds/values/parsed-layer.go`
- `pkg/cmds/values/parsed-layer_test.go`
- `pkg/doc/topics/13-layers-and-parsed-layers.md`
- `pkg/doc/topics/layers-guide.md`
- `pkg/doc/topics/logging-layer.md`
- `pkg/doc/tutorials/custom-layer.md`
- `pkg/settings/glazed_layer.go`
- `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/design-doc/02-design-appconfig-module-register-layers-and-parse.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/README.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/changelog.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/01-debate-round-1-option-a-naming-api-design-schema-fields-values-sources.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-composer-metadata.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-independent-composer-analysis.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/diary/01-diary-layer-parameter-renaming-work.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/index.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md`
- `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/tasks.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/README.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/analysis/01-analysis-parameterlayer-to-pflag-flagset-conversion-for-early-logging.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/changelog.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/index.md`
- `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/tasks.md`
- `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/01-documentation-deprecation-audit-layers-parameters-schema-fields-values-sources.md`
- `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/analysis/01-exhaustive-parameter-layer-audit.md`
- `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`

## Files with content matches (documentation)
### `AGENT.md`
- L58: `Don't add backwards compatibility layers unless explicitly asked.`

### `README.md`
- L8: `Glazed is a comprehensive Go framework for building command-line applications that handle structured data elegantly. It provides a rich command system, flexible parameter management, multiple output formats, and an integrated help system.`
- L76: `### Parameter Layer System`
- L77: `Organize command parameters into reusable, composable layers:`
- L81: `- Type-safe parameter extraction`
- L103: `func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L114: `    parsedLayers *values.Values,`
- L135: `## Parameter Layers`
- L137: `Organize command parameters into logical, reusable groups:`
- L140: `// Define layers for different concerns`
- L141: `func NewDatabaseLayer() *schema.Section {`
- L150: `// Use layers in command definitions`
- L152: `    cmds.WithLayersList(`
- L153: `        databaseLayer,`
- L154: `        loggingLayer, `
- L155: `        glazedLayer,`
- L161: `- Reuse common parameter sets across commands`
- L162: `- Avoid parameter naming conflicts with prefixes`
- L163: `- Type-safe parameter extraction with structs`
- L265: `- [Parameter Layers Guide](pkg/doc/topics/layers-guide.md) - Layer system with examples`
- L273: `- Parameter layer usage`

### `changelog.md`
- L1: `# Parameter Layer Serialization`
- L3: `Added ability to serialize parameter layers to YAML/JSON format for better interoperability and configuration management.`
- L5: `- Added SerializableParameterLayer struct for YAML/JSON serialization`
- L6: `- Added SerializableLayers struct for serializing collections of layers as a map keyed by slug`
- L7: `- Added conversion functions ToSerializable and LayersToSerializable`
- L8: `- Implemented YAML and JSON marshaling for ParameterLayers`
- L9: `- Updated serialization to maintain layer order while providing slug-based access`
- L10: `- Added custom YAML and JSON marshalers for SerializableLayers`
- L12: `# Parsed Parameters Serialization`
- L14: `Added ability to serialize parsed parameters to YAML/JSON format for better debugging and state persistence.`
- L16: `- Added SerializableParsedParameter struct for YAML/JSON serialization`
- L17: `- Added SerializableParsedParameters struct for serializing collections of parsed parameters`
- L18: `- Added conversion functions for ParsedParameter and ParsedParameters`
- L19: `- Implemented YAML and JSON marshaling for ParsedParameters`
- L20: `- Maintained parameter order while providing name-based access in serialized format`
- L22: `# Parsed Layer Serialization`
- L24: `Added ability to serialize parsed layers to YAML/JSON format, combining layer definitions and parsed parameters.`
- L26: `- Added SerializableParsedLayer struct for YAML/JSON serialization`
- L27: `- Added SerializableParsedLayers struct for serializing collections of parsed layers`
- L28: `- Added conversion functions for ParsedLayer and ParsedLayers`
- L29: `- Implemented YAML and JSON marshaling for ParsedLayer and ParsedLayers`
- L30: `- Included both layer definitions and parsed parameters in serialized output`
- L39: `# Optional GlazedCommandLayer in CobraParser`
- L41: `Added ability to skip adding the GlazedCommandLayer when creating a new CobraParser.`
- L43: `- Added skipGlazedCommandLayer flag to CobraParser struct`
- L44: `- Added WithSkipGlazedCommandLayer option function`
- L45: `- Modified NewCobraParserFromLayers to respect the skip flag`
- L47: `# Optional Profile and Create Command Settings Layers in CobraParser`
- L49: `Added ability to enable ProfileSettingsLayer and CreateCommandSettingsLayer when creating a new CobraParser. These layers are disabled by default and must be explicitly enabled.`
- L51: `- Added enableProfileSettingsLayer flag to CobraParser struct`
- L52: `- Added enableCreateCommandSettingsLayer flag to CobraParser struct`
- L53: `- Added WithProfileSettingsLayer option function to enable profile settings`
- L54: `- Added WithCreateCommandSettingsLayer option function to enable create command settings`
- L55: `- Modified NewCobraParserFromLayers to only add these layers when explicitly enabled `

### `cmd/examples/config-pattern-mapper/README.md`
- L7: `The pattern mapper allows you to declaratively map config file structures to layer parameters using pattern matching rules, without writing custom Go functions.`
- L12: `2. **Named Captures**: Extract values from config paths and use them in parameter names`
- L31: `    TargetLayer: "demo",`
- L32: `    TargetParameter: "api-key",`
- L40: `    TargetLayer: "demo",`
- L41: `    TargetParameter: "{env}-api-key",  // Uses captured value`
- L49: `    TargetLayer: "demo",`
- L50: `    TargetParameter: "api-key",`
- L58: `    TargetLayer: "demo",`
- L60: `        {Source: "api_key", TargetParameter: "api-key"},`
- L61: `        {Source: "threshold", TargetParameter: "threshold"},`
- L91: `mapper, err := patternmapper.NewConfigMapper(layers,`
- L94: `        TargetLayer:     "demo",`
- L95: `        TargetParameter: "api-key",`
- L102: `b := patternmapper.NewConfigMapperBuilder(layers).`
- L116: `    target_layer: "demo"`
- L119: `        target_parameter: "{env}-api-key"`
- L122: `mapper, err := patternmapper.LoadMapperFromFile(layers, "mappings.yaml")`

### `cmd/examples/parameter-types/README.md`
- L1: `# Parameter Types Example`
- L3: `This example demonstrates all parameter types available in the glazed framework.`
- L9: `go build -o parameter-types .`
- L11: `# Show help to see all available parameters`
- L12: `./parameter-types --help`
- L15: `./parameter-types`
- L18: `./parameter-types \`
- L28: `./parameter-types \`
- L35: `./parameter-types \`
- L44: `./parameter-types \`
- L48: `./parameter-types \`
- L52: `## Parameter Types Demonstrated`
- L85: `- `sample.json` - JSON object for testing object parameters`
- L87: `- `sample-list.json` - JSON array for testing list parameters`
- L88: `- `sample-text.txt` - Multi-line text for string parameters`
- L89: `- `sample-lines.txt` - Line-by-line text for list parameters`
- L90: `- `config.yaml` - Configuration file for key-value parameters`
- L94: `The program displays all parsed parameter values in a structured format, demonstrating how each type is processed and what the final values look like.`
- L96: `Note that secret parameters will show as `***` in the output to protect sensitive data.`

### `cmd/examples/parameter-types/sample-text.txt`
- L4: `Perfect for testing string-from-file parameters.`

### `pkg/cmds/logging/README.md`
- L1: `# Clay Logging Layer`
- L3: `This package provides a Glazed parameter layer for configuring logging in Clay applications.`
- L7: `**üìñ For API reference and detailed usage**, see: [Logging Layer API Reference](../../doc/reference/logging-layer.md)`
- L9: `**üéì To learn how to create custom layers**, see: [Custom Layer Tutorial](../../doc/tutorials/custom-layer.md)`
- L13: `The logging layer provides:`
- L26: `if err := logging.SetupLoggingFromParsedLayers(parsedLayers); err != nil {`

### `pkg/doc/applications/03-user-store-command.md`
- L27: `- **Configuration via YAML**: Define commands and their parameters using YAML files for easy customization.`
- L134: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L135: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L169: `func (c *GenerateCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L176: `    if err := parsedLayers.InitializeStruct("default", settings); err != nil {`
- L213: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L214: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L236: `func (c *ListCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L265: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L266: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L295: `func (c *DeleteCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L301: `    if err := parsedLayers.InitializeStruct("default", settings); err != nil {`

### `pkg/doc/examples/cliopatra/cliopatra.md`
- L31: `map it to the ParameterDefinition the Command uses, and create a YAML file with the default values.`

### `pkg/doc/topics/01-help-system.md`
- L349: `//   Parameters: [1 database]`

### `pkg/doc/topics/03-templates.md`
- L230: `- `toUrlParameter(v interface{}) string` - Convert value to URL parameter format`

### `pkg/doc/topics/06-usage-string.md`
- L19: `In contrast to parameter flags, which are preceded by `--` for `-`, arguments are `
- L32: `- Parameters accepting list inputs should not directly follow each other.`
- L34: `### Required Parameters`
- L45: `### Optional Parameters`
- L57: `### List Parameters`
- L69: `Parameters may come with default values. These can be identified by text following the format `default: value`. This means that if you do not provide a value for this argument, the system will use the default value.`

### `pkg/doc/topics/07-load-parameters-from-json.md`
- L2: `Title: Loading Parameters from JSON`
- L3: `Slug: load-parameters-json`
- L4: `Short: Explains how to load parameters from a JSON file.`
- L7: `- Parameters`
- L9: `- load-parameters-from-json`
- L16: `In addition to specifying parameters via command line flags, you can also load parameters from a JSON file.`
- L19: `This allows you to store common parameter configurations and reuse them across commands.`
- L21: `To load parameters from JSON, use the `--load-parameters-from-json` flag followed by the path to your JSON file:`
- L24: `command --load-parameters-from-json parameters.json [other arguments]`
- L27: `The JSON file should contain a JSON object where the keys are parameter names and the values are the parameter values you want to set.`
- L39: `This will set the `fields` and `output` parameters as if they had been passed via the command line.`
- L60: `‚ùØ glaze json --load-parameters-from-json /tmp/test-json.json misc/test-data/[123].json `
- L79: `The `ParseCommandFromMap` function in `cmds/map.go` is used to parse command parameters from a map structure, such as when loading parameters from JSON.`
- L81: `It takes a `CommandDescription`, a `map[string]interface{}` of parameters, and returns:`
- L83: `- A map of `ParsedParameterLayer` structs for each layer`
- L84: `- A combined map of all parameter values`
- L89: `1. It iterates through each layer in the `CommandDescription``
- L90: `2. For layers that implement the `JSONParameterLayer` interface, it calls `ParseFlagsFromJSON` to parse values from the map into a `ParsedParameterLayer``
- L91: `3. It adds the parsed layer to the output map`
- L92: `4. It also copies layer parameters into the combined parameter map`
- L93: `5. After parsing layers, it parses any remaining flags and arguments using the `CommandDescription` directly`
- L108: `layers, allParams, err := cmds.ParseCommandFromMap(cmd, params)`
- L111: `The returned `layers` map contains the parsed layers, while `allParams` contains all parameters combined.`

### `pkg/doc/topics/08-file-parameter-type.md`
- L3: `Slug: file-parameters`
- L4: `Short: Describes how to work with file inputs in command parameters.`
- L7: `- Parameters`
- L14: `Glazed provides two new parameter types `file` and `fileList` that allow passing file paths which will be automatically loaded and parsed.`
- L18: `File parameters are parsed into a single or a list of `FileData` structures which can then be accessed from within a template.`
- L21: `package parameters`
- L55: `The `FileData` structure returned by the `file` and `fileList` parameters can be easily used inside templates.`
- L86: `## The `file` ParameterType`
- L88: `The `file` parameter type allows passing a single file path, which will be read and parsed into a `FileData` structure.`
- L113: `## The `fileList` Parameter`

### `pkg/doc/topics/09-gather-flags-from-string-list.md`
- L25: `	params []*ParameterDefinition,`
- L32: `## Parameters`
- L35: `- `params`: a slice of `*ParameterDefinition` representing the parameter definitions.`
- L42: `The function returns a map where the keys are the parameter names and the values are the parsed values. If a flag is not recognized or its value cannot be parsed, an error is returned.`
- L49: `params := []*ParameterDefinition{`
- L50: `   {Name: "verbose", ShortFlag: "v", Type: ParameterTypeBool},`
- L51: `   {Name: "output", ShortFlag: "o", Type: ParameterTypeString},`
- L64: `In this example, the function parses the `--verbose` and `-o` flags according to the provided parameter definitions. The `--verbose` flag is a boolean flag and is set to "true". The `-o` flag is a string flag and its value is "file.txt".`

### `pkg/doc/topics/10-template-command.md`
- L17: `A TemplateCommand allows you to define commands that render Go template text using command-line parameters as template variables. This enables rapid prototyping of text generation tools without writing Go code‚Äîsimply define parameters in YAML and write a template that uses those parameters.`
- L21: `Template commands are defined in YAML files with a `template` field containing Go template syntax. The template receives all parsed parameters as variables accessible through the standard `{{.variable}}` syntax.`
- L97: `		// Provide parameter values for the "default" layer`
- L114: `Template commands use Go's `text/template` package syntax. All parsed parameters are available as variables in the template context.`
- L135: `  # Using defaults for optional parameters`
- L139: `## Parameter Types`
- L141: `Template commands can leverage the full range of Glazed parameter types, allowing for rich and validated inputs. This means you can create templates that accept everything from simple strings and booleans to lists, choices, and even content from files.`
- L143: `Template commands support all standard Glazed parameter types:`
- L151: `For more details on parameter types, see:`
- L153: `glaze help parameter-types`

### `pkg/doc/topics/12-profiles-use-code.md`
- L30: `Profile middleware in Pinocchio is responsible for loading and applying configuration parameters from a specified`
- L46: `	parsedCommandLayers *values.Values,`
- L71: `For advanced use cases, combine profile middleware with additional config files using `LoadParametersFromFile` or `LoadParametersFromFiles`:`
- L122: `The middleware will then load the configuration parameters from the `development` profile and apply them to the command.`

### `pkg/doc/topics/13-layers-and-parsed-layers.md`
- L2: `Title: Parameter Layers and Parsed Layers`
- L3: `Slug: parameter-layers-and-parsed-layers`
- L5: `    Learn how to use parameter layers and parsed layers in Glazed to organize and manage parameter definitions.`
- L7: `  - layers`
- L17: `## Parameter Layers`
- L19: `Layers in the glazed package provide a way to group and organize parameter definitions. They allow for better structure and modularity in command-line interfaces and other parameter-driven systems.`
- L21: `A layer is a logical grouping of related parameter definitions. It consists of several components:`
- L22: `1. **Name**: A human-readable name for the layer.`
- L23: `2. **Slug**: A unique identifier for the layer, used in code.`
- L24: `3. **Description**: A brief explanation of the layer's purpose.`
- L25: `4. **Prefix**: An optional prefix for parameter names within the layer.`
- L26: `5. **Parameter Definitions**: A collection of parameter definitions that belong to this layer.`
- L28: `### Parameter Definitions`
- L30: `A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.`
- L32: `1. **ParameterLayer**: An interface that groups parameter definitions and provides metadata.`
- L33: `2. **ParameterLayers**: A collection of ParameterLayer objects.`
- L35: `## Creating and Working with Parameter Layers`
- L37: `The `ParameterLayerImpl` struct provides a straightforward implementation of the`
- L38: ``ParameterLayer` interface.`
- L40: `### Creating a Parameter Layer`
- L42: `You can create a new parameter layer using the `NewParameterLayer` function:`
- L45: `layer, err := NewParameterLayer("config", "Configuration",`
- L48: `    WithParameterDefinitions(`
- L58: `### Adding Parameters to a Layer`
- L60: `You can add parameters to an existing layer using the `AddFlags` method:`
- L63: `layer.AddFlags(`
- L69: `### Initializing Parameter Defaults from a Struct`
- L71: `You can initialize the default values of parameters in a layer using a struct:`
- L88: `err := layer.InitializeParameterDefaultsFromStruct(&defaultConfig)`
- L94: `### Initializing Parameter Defaults from a Map`
- L106: `err := layer.InitializeParameterDefaultsFromParameters(defaultValues)`
- L112: `### Initializing a Struct from Parameter Defaults`
- L114: `You can also populate a struct with the default values from the parameter layer:`
- L118: `err := layer.InitializeStructFromParameterDefaults(&config)`
- L124: `### Loading a Parameter Layer from YAML`
- L126: `You can create a parameter layer from a YAML definition:`
- L142: `layer, err := NewParameterLayerFromYAML(yamlContent)`
- L148: `### Cloning a Parameter Layer`
- L150: `To create a deep copy of a parameter layer:`
- L153: `clonedLayer := layer.Clone()`
- L156: `### Creating ParameterLayers`
- L159: `layers := NewParameterLayers(`
- L160: `    WithLayers(configLayer, outputLayer),`
- L164: `### Registering Layers Under Explicit Slugs on Commands`
- L166: `When creating a `cmds.CommandDescription`, you can register layers under explicit slugs using `cmds.WithLayersMap`.`
- L169: `// Create layers with internal slugs`
- L170: `cfgLayer, _ := schema.NewSection("config", "Configuration")`
- L171: `outLayer, _ := schema.NewSection("output", "Output")`
- L176: `    cmds.WithLayersMap(map[string]schema.Section{`
- L177: `        "cfg": cfgLayer,   // registered as "cfg"`
- L178: `        "out": outLayer,   // registered as "out"`
- L182: `// Later, parsed layers will be accessed by these slugs`
- L183: `// parsedLayers.InitializeStruct("cfg", &myCfg)`
- L186: `Note: If the layer is a `*schema.SectionImpl` and the key differs from the layer's internal slug, the layer is cloned and aligned to the registration key to maintain consistency at runtime.`
- L188: `### Accessing Layer Information`
- L191: `name := layer.GetName()`
- L192: `slug := layer.GetSlug()`
- L193: `description := layer.GetDescription()`
- L198: `Iterate over all parameter layers:`
- L201: `parameterLayers.ForEach(func(key string, p ParameterLayer) {`
- L202: `    // Process each layer`
- L205: `err := parameterLayers.ForEachE(func(key string, p ParameterLayer) error {`
- L206: `    // Process each layer, return error to stop iteration`
- L213: `Create a new ParameterLayers containing only the specified layers:`
- L216: `subset := parameterLayers.Subset("config", "output")`
- L219: `### AppendLayers and PrependLayers`
- L221: `Add layers to the end or beginning of the collection:`
- L224: `parameterLayers.AppendLayers(newLayer1, newLayer2)`
- L225: `parameterLayers.PrependLayers(newLayer3, newLayer4)`
- L230: `Merge two ParameterLayers collections:`
- L233: `mergedLayers := parameterLayers.Merge(otherParameterLayers)`
- L238: `Create a deep copy of ParameterLayers:`
- L241: `clonedParameterLayers := parameterLayers.Clone()`
- L244: `### GetAllParameterDefinitions`
- L246: `Get all parameter definitions across all layers:`
- L249: `allDefinitions := parameterLayers.GetAllParameterDefinitions()`
- L252: `## Parsed Layers`
- L254: `A ParsedLayer is the result of parsing input data (such as command-line`
- L255: `arguments, configuration files, or environment variables) using a ParameterLayer`
- L258: `1. **Layer**: A reference to the original ParameterLayer used for parsing.`
- L259: `2. **Parameters**: A collection of ParsedParameter objects, each containing:`
- L260: `    - The original ParameterDefinition`
- L264: `ParsedLayers is a collection of ParsedLayer objects, typically representing all the layers used in a command or application.`
- L266: `### Usage of ParsedLayers`
- L268: `ParsedLayers are primarily used to:`
- L270: `1. Store and organize parsed parameter values`
- L271: `2. Access parsed values across different layers`
- L274: `5. Provide a unified interface for accessing all parsed parameters in an application`
- L277: `### Creating a ParsedLayer`
- L280: `parsedLayer, err := NewParsedLayer(layer,`
- L281: `    WithParsedParameterValue("verbose", true),`
- L288: `### Creating ParsedLayers`
- L291: `parsedLayers := NewParsedLayers(`
- L292: `    WithParsedLayer("config", parsedConfigLayer),`
- L293: `    WithParsedLayer("output", parsedOutputLayer),`
- L300: `value, ok := parsedLayer.GetParameter("verbose")`
- L302: `    // Parameter not found`
- L306: `### Initializing Structs from ParsedLayers`
- L315: `err := parsedLayers.InitializeStruct("config", &config)`
- L321: `### Merging ParsedLayers`
- L324: `parsedLayers.GetDefaultParameterLayer().MergeParameters(otherParsedLayer)`
- L327: `### Getting All Parsed Parameters`
- L330: `allParams := parsedLayers.GetAllParsedParameters()`
- L336: `Iterate over all parsed layers:`
- L339: `parsedLayers.ForEach(func(k string, v *ParsedLayer) {`
- L340: `    // Process each layer`
- L343: `err := parsedLayers.ForEachE(func(k string, v *ParsedLayer) error {`
- L344: `    // Process each layer, return error to stop iteration`
- L351: `Get a map of all parameter values across all layers:`
- L354: `dataMap := parsedLayers.GetDataMap()`
- L359: `Get an existing ParsedLayer or create a new one if it doesn't exist:`
- L362: `parsedLayer := parsedLayers.GetOrCreate(someParameterLayer)`
- L367: `Create a deep copy of ParsedLayers:`
- L370: `clonedParsedLayers := parsedLayers.Clone()`
- L376: `Middlewares in the Glazed framework provide a powerful mechanism to manage parameter values from various sources such as environment variables, configuration files, and command-line arguments. They allow for flexible and modular parameter handling in your applications.`
- L380: `- **Middleware Structure**: Each middleware processes parameters before and/or after calling the next handler in the chain. They work with `ParameterLayers` and `ParsedLayers` to manage parameter definitions and values.`
- L386: `1. **SetFromDefaults**: Populates parameters with their default values if no value exists.`
- L400: `3. **LoadParametersFromFile / LoadParametersFromFiles**: Load parameters from JSON or YAML files.`
- L411: `4. **ParseFromCobraCommand**: Parses parameter values from a Cobra command, typically used for CLI applications.`
- L420: `To use middlewares, chain them together and execute them with your parameter layers and parsed layers:`
- L424: `sources.Execute(layers, parsedLayers,`
- L435: `- **Layer Filtering**: Apply middlewares to specific layers using whitelisting or blacklisting.`
- L436: `- **Source Tracking**: Use `WithParseStepSource` to track where parameter values originate.`

### `pkg/doc/topics/15-profiles.md`
- L5: `  Use profiles.yaml to apply named configuration bundles across parameter layers, with predictable precedence and debugging.`
- L21: `Profiles are a **named bundle of parameter overrides** stored in a YAML file (typically `profiles.yaml`).`
- L34: `- **Second level**: layer slug`
- L35: `- **Third level**: parameter name/value pairs for that layer`
- L65: `In a Cobra CLI built with Glazed, profile selection typically comes from the **ProfileSettings layer**:`
- L77: `These flags only exist if you enable the ProfileSettings layer when building your Cobra command:`
- L81: `  cli.WithProfileSettingsLayer(),`
- L85: `Without that layer:`
- L93: `Glazed config files are parsed in **layer-slug form**:`
- L96: `<layer-slug>:`
- L100: `So profile selection in a config file must be expressed under the `profile-settings` layer:`
- L147: `3. Run the main middleware chain for all layers, with the profiles middleware inserted between defaults and higher-precedence sources.`
- L153: `Use `--print-parsed-parameters` to inspect parse provenance per parameter, including which values came from:`

### `pkg/doc/topics/16-adding-parameter-types.md`
- L2: `Title: Adding New Parameter Types to Glazed`
- L3: `Slug: adding-parameter-types`
- L4: `Short: Comprehensive guide on implementing new parameter types in the Glazed framework.`
- L6: `- parameters`
- L18: `# Adding New Parameter Types to Glazed`
- L22: `Parameter types in glazed are defined in the [`glazed/pkg/cmds/parameters`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters) package. Each parameter type requires modifications to several files to handle:`
- L32: `This guide explains how to add a new parameter type to the glazed command line framework. We'll use the example of adding a `credentials` parameter type to demonstrate the process.`
- L36: `When adding a new parameter type, you need to modify these files:`
- L38: `### Core Parameter Files`
- L39: `1. [`parameter-type.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameter-type.go) - Define the type constant and metadata methods`
- L40: `2. [`parse.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parse.go) - Add parsing logic`
- L41: `3. [`parameters.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameters.go) - Add validation and value assignment`
- L42: `4. [`cobra.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/cobra.go) - Add CLI flag support`
- L43: `5. [`viper.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/viper.go) - Add configuration file support`
- L44: `6. [`render.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/render.go) - Add display formatting`
- L53: `## Step 1: Define the Parameter Type`
- L55: `In [`parameter-type.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameter-type.go), add your new type constant:`
- L60: `    ParameterTypeCredentials ParameterType = "credentials"`
- L67: `func (p ParameterType) IsList() bool {`
- L69: `    case ParameterTypeCredentials:`
- L85: `In [`parse.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parse.go), add a case to the `ParseParameter` method:`
- L88: `func (p *ParameterDefinition) ParseParameter(v []string, options ...ParseStepOption) (*ParsedParameter, error) {`
- L94: `    case ParameterTypeCredentials:`
- L136: `func (p *ParameterDefinition) ParseFromReader(f io.Reader, filename string, options ...ParseStepOption) (*ParsedParameter, error) {`
- L142: `    case ParameterTypeCredentials:`
- L160: `In [`parameters.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameters.go), add validation to `CheckValueValidity`:`
- L163: `func (p *ParameterDefinition) CheckValueValidity(v interface{}) (interface{}, error) {`
- L169: `    case ParameterTypeCredentials:`
- L175: `                return nil, errors.Errorf("Value for parameter %s is not credentials (expected map[string]string): %v", p.Name, v)`
- L203: `func (p *ParameterDefinition) InitializeValueToEmptyValue(value reflect.Value) error {`
- L207: `    case ParameterTypeCredentials:`
- L216: `func (p *ParameterDefinition) SetValueFromInterface(value reflect.Value, v interface{}) error {`
- L222: `    case ParameterTypeCredentials:`
- L225: `            return errors.Errorf("expected credentials for parameter %s, got %T", p.Name, v)`
- L234: `In [`cobra.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/cobra.go), add flag creation logic:`
- L237: `func (ps *ParameterDefinitions) AddToCobraCommand(cmd *cobra.Command) error {`
- L240: `    switch parameter.Type {`
- L243: `    case ParameterTypeCredentials:`
- L245: `        if parameter.Default != nil {`
- L246: `            if creds, ok := (*parameter.Default).(map[string]string); ok {`
- L252: `        cmd.Flags().StringSliceVarP(&ps.cobraParameterValues[parameter.Name], `
- L253: `            parameter.Name, parameter.ShortFlag, defaultValue, parameter.Help)`
- L261: `func (ps *ParameterDefinitions) SetupCobraCompletions(cmd *cobra.Command) error {`
- L264: `    switch parameter.Type {`
- L265: `    case ParameterTypeCredentials:`
- L266: `        err = cmd.RegisterFlagCompletionFunc(parameter.Name, func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {`
- L275: `In [`render.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/render.go), add display formatting:`
- L278: `func RenderValue(parameterType ParameterType, value interface{}) (string, error) {`
- L279: `    switch parameterType {`
- L282: `    case ParameterTypeCredentials:`
- L304: `After implementing the core parameter functionality, you may need to update additional files that have exhaustive switch statements on parameter types:`
- L321: `func FlagTypeToGoType(s *jen.Statement, parameterType fields.Type) *jen.Statement {`
- L322: `    switch parameterType {`
- L332: `func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error) {`
- L347: `        return nil, fmt.Errorf("invalid type for credentials parameter '%s': expected table, got %s", paramDef.Name, value.Type())`
- L352: `**Pro Tip**: Run `make lint` or `golangci-lint run` after adding your parameter type to discover any additional files with exhaustive switches that need updating.`
- L354: `## Step 8: Update Parameter Types Example`
- L356: `Update the parameter types example command in [`cmd/examples/parameter-types/main.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/cmd/examples/parameter-types/main.go) to showcase your new parameter type.`
- L358: `### Add to Parameter Definitions`
- L359: `Add your parameter to the `cmds.WithFlags()` section:`
- L365: `    fields.WithHelp("A credentials parameter for username/password pairs"),`
- L371: `Add a field to the `ParameterTypesSettings` struct:`
- L374: `type ParameterTypesSettings struct {`
- L380: `### Add to Parameter Data Array`
- L381: `Add an entry to the `parameterData` slice in `RunIntoGlazeProcessor`:`
- L384: `{"credentials-param", fields.TypeCredentials, s.CredentialsParam, "A credentials parameter for username/password pairs", false, nil, map[string]string{"username": "admin", "password": "secret"}},`
- L387: `This ensures that developers and users can easily test and understand how your new parameter type works in practice.`
- L391: `After updating the example, test it to ensure your new parameter type works correctly:`
- L394: `cd cmd/examples/parameter-types`
- L395: `go build -o parameter-types .`
- L398: `./parameter-types parameter-types`
- L401: `./parameter-types parameter-types --credentials-param username:admin,password:secret`
- L403: `# Test parameter parsing (useful for debugging)`
- L404: `./parameter-types parameter-types --credentials-param username:test,password:demo --print-parsed-parameters`
- L408: `- Your parameter appears in the help output (`--help`)`
- L416: `Create comprehensive tests for your new parameter type:`
- L419: `func TestCredentialsParameter(t *testing.T) {`
- L445: `            pd := &ParameterDefinition{`
- L447: `                Type: ParameterTypeCredentials,`
- L450: `            result, err := pd.ParseParameter(tt.input)`
- L463: `## Example: Complete Credentials Parameter Type`
- L465: `Here's what the complete implementation would look like for a credentials parameter type:`
- L467: `### In parameter-type.go`
- L471: `    ParameterTypeCredentials ParameterType = "credentials"`
- L474: `func (p ParameterType) IsKeyValue() bool {`
- L476: `    case ParameterTypeKeyValue, ParameterTypeCredentials:`
- L493: `When adding a new parameter type to glazed, you need to modify these core files and follow these steps:`
- L495: `1. **Define the type constant** in `parameter-type.go``
- L497: `3. **Add validation and value assignment** in `parameters.go``
- L502: `8. **Update the parameter types example** in `cmd/examples/parameter-types/main.go``
- L508: `1. **Consistent naming**: Use the pattern `ParameterType<Name>` for constants`
- L514: `7. **Documentation**: Update parameter type documentation and help text`
- L516: `9. **Update examples**: Always update the parameter types example to showcase new types`
- L527: `Follow these patterns when implementing your custom parameter type to ensure consistency with the rest of the glazed framework.`
- L529: `**Important**: The parameter types example in `cmd/examples/parameter-types/` serves as both documentation and a testing tool. Always update it when adding new parameter types so users and developers can easily understand and test the new functionality.`

### `pkg/doc/topics/16-parsing-parameters.md`
- L2: `Title: Parsing Parameters`
- L3: `Slug: parsing-parameters`
- L4: `Short: Learn how to define and parse parameters in Go applications using the Parameter API.`
- L6: `  - Parameter API`
- L17: `The **Parameter API** facilitates parsing and managing parameters in Go applications. It's ideal for applications requiring flexible parameter handling.`
- L21: `### ParameterDefinition`
- L23: `A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.`
- L26: `type ParameterDefinition struct {`
- L29: `    Type       ParameterType `yaml:"type"``
- L38: `### ParameterDefinitions`
- L40: ``ParameterDefinitions` is an ordered map of `ParameterDefinition` instances, indexed by name.`
- L43: `type ParameterDefinitions struct {`
- L44: `    *orderedmap.OrderedMap[string, *ParameterDefinition]`
- L48: `### ParsedParameter`
- L50: `A `ParsedParameter` contains the parsed value, its `ParameterDefinition`, and a log of parsing steps.`
- L53: `type ParsedParameter struct {`
- L55: `    ParameterDefinition *ParameterDefinition`
- L60: `### ParsedParameters`
- L62: ``ParsedParameters` is an ordered map of `ParsedParameter` instances, indexed by parameter names.`
- L65: `type ParsedParameters struct {`
- L66: `    *orderedmap.OrderedMap[string, *ParsedParameter]`
- L84: `Follow these steps to use the Parameter API: define parameters and parse them from user input or configuration files.`
- L86: `### Defining Parameters`
- L88: `Define parameters using `ParameterDefinition`, specifying name, type, and options like default values or choices.`
- L91: `import "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L93: `// Define a string parameter with a default value`
- L103: `### Parsing Parameters`
- L105: `Parse input values (e.g., from command-line arguments) to obtain `ParsedParameter` instances.`
- L111: `parsedParam, err := paramName.ParseParameter(inputs)`
- L121: `Access parsed parameter values via `ParsedParameters`.`
- L124: `// Create a collection of parameter definitions`
- L126: `    parameters.WithParameterDefinitionList([]*fields.Definition{paramName}),`
- L129: `// Parse a parameter value`
- L130: `parsedParams, err := paramDefs.ParseParameters(userInputs)`
- L140: `## Managing Parsed Parameters`
- L142: `Manage parsed parameters using these methods: updating values, merging parameter sets, and cloning parsed data.`
- L146: `Update a parsed parameter's value, optionally appending a new parsing step.`
- L152: `### Merging Parameters`
- L154: `Merge another `ParsedParameters` instance, combining values and logs.`
- L160: `### Cloning Parameters`
- L162: `Create a deep copy of `ParsedParameters` to avoid unintended mutations.`
- L168: `## Handling Defaults and Required Parameters`
- L170: `Specify default values and enforce required parameters.`
- L173: `// Define a required integer parameter without a default`
- L182: `During parsing, an error is returned if a required parameter is missing. If an optional parameter is missing, its default value is used.`
- L185: `parsedParam, err := ageParam.ParseParameter([]string{})`
- L197: `Each `ParsedParameter` logs parsing steps, showing how the final value was derived.`
- L207: `Define parameters to accept values from files (e.g., JSON, YAML, CSV).`
- L210: `// Define a parameter that expects a JSON file`
- L218: `// Parse the parameter from file input`
- L219: `parsedFileParam, err := fileParam.ParseParameter([]string{"config.json"})`

### `pkg/doc/topics/18-lua.md`
- L37: `Executes a GlazeCommand with parameters from a Lua table.`
- L43: `Executes a BareCommand with parameters from a Lua table.`
- L49: `Executes a WriterCommand with parameters from a Lua table.`
- L65: `Middleware to parse nested Lua tables into ParsedLayers.`
- L91: `1. **ParseLuaTableToLayer**`
- L93: `func ParseLuaTableToLayer(L *lua.LState, luaTable *lua.LTable, layer schema.Section) (*values.SectionValues, error)`
- L95: `Parses a Lua table into a ParsedLayer.`
- L97: `2. **ParseNestedLuaTableToParsedLayers**`
- L99: `func ParseNestedLuaTableToParsedLayers(L *lua.LState, luaTable *lua.LTable, parameterLayers *schema.Schema) (*values.Values, error)`
- L101: `Parses a nested Lua table into ParsedLayers.`
- L103: `3. **ParseParameterFromLua**`
- L105: `func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error)`
- L107: `Parses a Lua value into a Go value based on the parameter definition.`
- L129: `2. A global table containing parameter information (`command_name_params`)`
- L146: `### Accessing Command Parameters`
- L148: `The registration process creates a global Lua table with parameter information:`
- L150: `for layer_name, layer_params in pairs(animal_list_params) do`
- L151: `    print("Layer: " .. layer_name)`
- L152: `    for param_name, param_info in pairs(layer_params) do`
- L162: `The wrapper supports nested Lua tables for complex parameter structures:`
- L205: `4. Structure your parameter tables to match the expected layer organization`
- L207: `5. Leverage the parameter information tables for runtime validation and documentation`

### `pkg/doc/topics/19-writing-yaml-commands.md`
- L39: `## Parameter Types`
- L41: `Glazed supports these parameter types for both flags and arguments:`
- L75: `Flags are optional parameters that modify command behavior. Here's a comprehensive example:`
- L102: `- `type`: Parameter type (required)`
- L110: `Arguments are positional parameters. They're defined similarly to flags:`
- L129: `## Using Layers`
- L131: `Layers help organize related parameters. Define layers in your YAML:`
- L134: `layers:`
- L164: `   - Group related parameters using layers`
- L165: `   - Use consistent parameter ordering`
- L171: `   - Mark parameters as required when necessary`
- L198: `layers:`

### `pkg/doc/topics/21-cmds-middlewares.md`
- L4: `Short: Learn how to use Glazed's middleware system to load parameter values from various sources`
- L7: `- parameters`
- L13: `- LoadParametersFromFile`
- L23: `# Glazed Middlewares Guide: Loading Parameter Values`
- L27: `Glazed provides a flexible middleware system for loading parameter values from various sources. This guide explains how to use these middlewares effectively to populate your command parameters from different locations like environment variables, config files, and command line arguments.`
- L36: `type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error`
- L40: `### Relationship between ParameterLayers and ParsedLayers`
- L42: `- **ParameterLayers**: These are collections of parameter definitions. They define the structure and metadata of parameters, such as their names, types, and default values.`
- L44: `- **ParsedLayers**: These are collections of parsed parameter values. They store the actual values obtained from various sources like command-line arguments, environment variables, or configuration files.`
- L46: `Middlewares operate on these two structures to manage and transform parameter values.`
- L52: `1. **Modular Parameter Handling**: They allow for modular and reusable parameter processing logic. Each middleware can focus on a specific source or transformation of parameter values.`
- L54: `2. **Logging and Tracking**: Each middleware can log its actions, providing a trace of how parameter values were derived.`
- L56: `### Adding Information to Parsed Parameters`
- L58: `Each middleware can add information to the parsed parameters by:`
- L62: `- Logging the source and transformation steps for each parameter value.`
- L68: `- It can process parameters before and/or after calling `next``
- L70: `    - `ParameterLayers`: Contains parameter definitions`
- L71: `    - `ParsedLayers`: Stores the actual parameter values`
- L78: `ExecuteMiddlewares(layers, parsedLayers,`
- L81: `    LoadParametersFromFile("config.yaml"),`
- L86: `1. LoadParametersFromFile`
- L94: `Use `SetFromDefaults` to populate parameters with their default values:`
- L102: `This middleware reads the default values specified in parameter definitions and sets them if no value exists.`
- L115: `- Parameter `port` becomes `APP_PORT``
- L116: `- Parameter `db_host` becomes `APP_DB_HOST``
- L120: `Load parameters from JSON or YAML files using `LoadParametersFromFile`:`
- L130: `By default, `LoadParametersFromFile` expects the config file to have this structure:`
- L132: `layerName:`
- L133: `  parameterName: value`
- L134: `  anotherParameter: value`
- L149: `    // Map flat keys to layer parameters`
- L191: `The mapper handles both structures and maps them to the standard layer format. This allows you to:`
- L194: `- Transform nested JSON/YAML hierarchies into layer parameters`
- L236: `Load parameters from specific config files using built-in file middlewares:`
- L257: `    // Transform your custom config structure to layer map format`
- L285: `### 8. Layer Manipulation`
- L287: `Glazed provides several middlewares for manipulating parsed layers directly:`
- L289: `#### Replacing Layers`
- L291: `Replace a single layer:`
- L293: `// Replace the "config" layer with a new one`
- L294: `middleware := middlewares.ReplaceParsedLayer("config", newLayer)`
- L297: `Replace multiple layers at once:`
- L299: `// Replace multiple layers with new ones`
- L300: `middleware := middlewares.ReplaceParsedLayers(newLayers)`
- L303: `#### Merging Layers`
- L305: `Merge a single layer:`
- L307: `// Merge a layer into the "config" layer`
- L308: `middleware := middlewares.MergeParsedLayer("config", layerToMerge)`
- L311: `Merge multiple layers:`
- L313: `// Merge multiple layers into existing ones`
- L314: `middleware := middlewares.MergeParsedLayers(layersToMerge)`
- L317: `#### Selective Layer Operations`
- L319: `For more fine-grained control, you can use selective middlewares that only operate on specific layers:`
- L322: `// Replace only specific layers`
- L323: `middleware := middlewares.ReplaceParsedLayersSelective(newLayers, []string{"config", "env"})`
- L325: `// Merge only specific layers`
- L326: `middleware := middlewares.MergeParsedLayersSelective(layersToMerge, []string{"user", "profile"})`
- L330: `- Update only certain configuration layers while preserving others`
- L337: `sources.Execute(layers, parsedLayers,`
- L338: `    // Replace only the base configuration layers`
- L339: `    middlewares.ReplaceParsedLayersSelective(baseConfig, []string{"system", "defaults"}),`
- L342: `    middlewares.MergeParsedLayersSelective(userConfig, []string{"preferences", "history"}),`
- L345: `    middlewares.ReplaceParsedLayers(envConfig),`
- L349: `These layer manipulation middlewares are useful when you need to:`
- L352: `- Apply temporary parameter changes`
- L357: `sources.Execute(layers, parsedLayers,`
- L359: `    middlewares.ReplaceParsedLayer("base", baseConfig),`
- L361: `    middlewares.MergeParsedLayer("env", envSettings),`
- L363: `    middlewares.MergeParsedLayer("user", userPrefs),`
- L402: `### 2. Layer Filtering`
- L404: `Restrict middleware operation to specific layers:`
- L407: `// Only apply to specified layers`
- L408: `middleware := middlewares.WrapWithWhitelistedLayers(`
- L413: `// Exclude specific layers`
- L414: `middleware := middlewares.WrapWithBlacklistedLayers(`
- L426: `    "layer1": {`
- L443: `   ExecuteMiddlewares(layers, parsedLayers,`
- L446: `       LoadParametersFromFile(),    // More specific`
- L453: `   err := sources.Execute(layers, parsedLayers, `
- L461: `4. **Layer Organization**: Group related parameters into logical layers for easier management and filtering.`
- L470: `sources.Execute(layers, parsedLayers,`
- L492: `sources.Execute(layers, parsedLayers,`
- L548: `    layers := createTestLayers()`
- L549: `    parsedLayers := values.New()`
- L553: `    err := sources.Execute(layers, parsedLayers, middleware)`
- L557: `    value, exists := parsedLayers.GetParameter("default", "param1")`
- L567: `    layers := createTestLayers()`
- L568: `    parsedLayers := values.New()`
- L579: `    err := sources.Execute(layers, parsedLayers, mws...)`
- L583: `    value, _ := parsedLayers.GetParameter("default", "param1")`
- L592: `    layers := createTestLayers()`
- L593: `    parsedLayers := values.New()`
- L596: `    parsedLayers.SetParameter("default", "email", "invalid-email")`
- L600: `    err := sources.Execute(layers, parsedLayers, middleware)`
- L608: `1. Use logging middleware to track parameter changes:`
- L622: `parsedLayers.ForEach(func(layer string, params *parameters.ParsedParameters) {`
- L624: `        fmt.Printf("%s.%s = %v\n", layer, name, value)`
- L629: `Remember that middlewares are a powerful tool for managing parameter values, but with that power comes the need for careful organization and consideration of precedence rules.`
- L670: `            ShortHelpLayers: []string{"default", "helpers"},`
- L688: `    if commandSettings.LoadParametersFromFile != "" {`
- L690: `            sources.FromFile(commandSettings.LoadParametersFromFile))`
- L709: `    // Env config for specific layers (if needed)`
- L710: `    middlewares.WrapWithWhitelistedLayers(`
- L733: `## Layer-Specific Configuration`
- L735: `Restrict middleware to specific layers:`
- L738: `middlewares.WrapWithWhitelistedLayers(`
- L750: `The foundation of Glazed's parameter system is the `ParameterLayer`. Before we can use middlewares, we need to define our parameter structure. This example shows how to create a layer that matches the architectural concepts discussed earlier:`
- L756: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L757: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L762: `    // Create a new parameter layer`
- L763: `    layer, err := schema.NewSection(`
- L785: `    // Create parameter layers container`
- L786: `    parameterLayers := schema.NewSchema(`
- L787: `        layers.WithLayers(layer),`
- L793: `- Parameter definitions with types, defaults, and help text`
- L794: `- Layer organization with meaningful names and descriptions`
- L795: `- Error handling for layer creation`
- L796: `- Container structure for managing multiple layers`
- L800: `Now that we understand the middleware signature and execution order, let's see how to implement specific middlewares. These examples show how the middleware chain processes parameters in practice.`
- L804: `The `SetFromDefaults` middleware demonstrates the basic middleware pattern of processing parameters after the next handler:`
- L808: `    // Create empty parsed layers`
- L809: `    parsedLayers := values.New()`
- L817: `        parameterLayers,`
- L818: `        parsedLayers,`
- L826: `    configLayer, _ := parsedLayers.Get("config")`
- L827: `    hostValue, _ := configLayer.GetParameter("host")`
- L833: `- Creation of empty ParsedLayers to store results`
- L845: `    parsedLayers := values.New()`
- L856: `        parameterLayers,`
- L857: `        parsedLayers,`
- L868: `- Layer-specific updates`
- L874: `After middlewares process the parameters, there are several ways to access the results. These patterns align with different use cases in the architecture:`
- L877: `func accessParsedValues(parsedLayers *values.Values) {`
- L878: `    // 1. Direct access through layer`
- L879: `    configLayer, _ := parsedLayers.Get("config")`
- L880: `    hostValue, _ := configLayer.GetParameter("host")`
- L882: `    // 2. Get all parameters as a map`
- L883: `    dataMap := parsedLayers.GetDataMap()`
- L893: `    err := parsedLayers.InitializeStruct("config", &config)`
- L901: `- Direct layer access for fine-grained control`
- L902: `- Map-based access for dynamic parameter handling`
- L903: `- Struct initialization for type-safe parameter usage`
- L906: `### 4. Tracking Parameter History`
- L908: `One of the key features of Glazed's middleware system is its ability to track parameter changes. This helps debug parameter processing and understand value origins:`
- L911: `func checkParameterHistory(parsedLayers *values.Values) {`
- L912: `    configLayer, _ := parsedLayers.Get("config")`
- L913: `    hostParam, _ := configLayer.Parameters.Get("host")`
- L926: `- Debugging support for parameter processing`
- L934: `    parsedLayers := values.New()`
- L936: `    // Define different parameter sources`
- L953: `        parameterLayers,`
- L954: `        parsedLayers,`
- L974: `### 6. Working with Restricted Layers`
- L976: `Layer restriction is a powerful feature that implements the modular parameter handling concept discussed in the architecture:`
- L979: `func useRestrictedLayers() {`
- L980: `    parsedLayers := values.New()`
- L988: `    // Only apply to whitelisted layers`
- L989: `    whitelistedMiddleware := middlewares.WrapWithWhitelistedLayers(`
- L994: `    // Or blacklist specific layers`
- L995: `    blacklistedMiddleware := middlewares.WrapWithBlacklistedLayers(`
- L996: `        []string{"other-layer"},`
- L1001: `        parameterLayers,`
- L1002: `        parsedLayers,`
- L1014: `- Layer isolation`
- L1015: `- Parameter scope control`
- L1021: `These examples can be combined to create sophisticated parameter handling systems. For instance, a typical application might:`
- L1023: `1. Define multiple parameter layers for different concerns`
- L1025: `3. Use layer restrictions to manage parameter scope`
- L1026: `4. Track parameter history for debugging`

### `pkg/doc/topics/22-command-loaders.md`
- L146: `	"github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L244: `	// Add other options like WithLong, WithArguments, WithLayers etc. as needed`
- L259: `func (msc *MySpecificCommand) Run(ctx context.Context, parsedLayers *values.Values) error { /* ... */}`
- L274: `-   **`SqlCommandLoader` (`github.com/go-go-golems/sqleton/pkg/cmds`)**: Loads SQL execution commands for the `sqleton` tool from YAML files containing SQL queries and parameter definitions. Uses `loaders.CheckYamlFileType(f, fileName, "sqleton")` in `IsFileSupported`.`

### `pkg/doc/topics/22-templating-helpers.md`
- L156: `	ps map[string]interface{}, // Parameters for the template`

### `pkg/doc/topics/23-pattern-based-config-mapping.md`
- L4: `Short: Declarative mapping of config files to parameter layers using pattern matching rules`
- L18: `The pattern-based config mapping system provides a declarative way to map arbitrary config file structures to Glazed's layer-based parameter system without writing custom Go functions. Instead of implementing `ConfigFileMapper` functions with manual config traversal, you define mapping rules that specify patterns to match in config files and how to map matched values to parameters. This keeps configuration logic concise, testable, and consistent across commands.`
- L26: `- Using the Mapper: Wire into `LoadParametersFromFile``
- L39: `- Verify target layers exist and static target parameters are valid (prefix-aware)`
- L40: `- Check that any `{name}` referenced in `TargetParameter` is captured in `Source``
- L44: `- For each pattern, collect matches; resolve `{captures}` into parameter names`
- L45: `- Write values to the target layer/parameter; error on ambiguity or collisions`
- L56: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L62: `mapper, err := pm.NewConfigMapper(layers_,`
- L65: `        TargetLayer:     "demo",`
- L66: `        TargetParameter: "api-key",`
- L70: `// Use with LoadParametersFromFile`
- L85: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L90: `b := pm.NewConfigMapperBuilder(layers_).`
- L98: `// Use with LoadParametersFromFile`
- L116: `    target_layer: "demo"`
- L117: `    target_parameter: "api-key"`
- L119: `    target_layer: "demo"`
- L120: `    target_parameter: "{env}-api-key"`
- L127: `  target_layer: "demo"`
- L128: `  target_parameter: "threshold"`
- L137: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L146: `mapper, err := pm.NewConfigMapper(layers_, rules...)`
- L150: `mapper2, err := pm.LoadMapperFromFile(layers_, "mappings.yaml")`
- L165: `Exact match patterns map specific config paths to parameters with no variation:`
- L170: `    TargetLayer:     "demo",`
- L171: `    TargetParameter: "api-key",`
- L186: `Named captures extract segments from config paths and use them in parameter names, enabling environment-specific or multi-tenant configurations:`
- L191: `    TargetLayer:     "demo",`
- L192: `    TargetParameter: "{env}-api-key",`
- L209: `The `{env}` capture extracts whatever value appears at that position in the config (here, "dev" or "prod") and makes it available for use in the target parameter name.`
- L218: `    TargetLayer:     "demo",`
- L219: `    TargetParameter: "api-key",`
- L234: `Important: When a wildcard pattern matches multiple keys with different values, the mapper treats this as an ambiguity and returns an error by default. Use named captures (e.g., `app.{env}.api_key`) if you need to collect multiple values, or ensure matched values are identical if a single target parameter is intended. This prevents accidental aggregation of unrelated values.`
- L243: `    TargetLayer: "demo",`
- L245: `        {Source: "api_key", TargetParameter: "api-key"},`
- L246: `        {Source: "threshold", TargetParameter: "threshold"},`
- L247: `        {Source: "timeout", TargetParameter: "timeout"},`
- L255: `b := patternmapper.NewConfigMapperBuilder(layers).`
- L287: `    TargetLayer: "demo",`
- L289: `        {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L290: `        {Source: "threshold", TargetParameter: "threshold"},`
- L314: `The `{env}` capture from the parent pattern is available in all child rules, allowing them to construct environment-specific parameter names.`
- L326: `    // Target layer slug (required for leaf rules)`
- L328: `    TargetLayer string`
- L330: `    // Target parameter name (required for leaf rules)`
- L332: `    TargetParameter string`
- L347: `b := patternmapper.NewConfigMapperBuilder(layers).`
- L359: `- Prefix-aware parameter resolution and compile-time validation of static targets apply at Build().`
- L370: `3. **Target layer**: Must exist in parameter layers`
- L371: `4. **Target parameter**: Must exist in target layer *(validated at runtime per match)*`
- L379: `    TargetParameter: "{env}-api-key",  // {env} not captured in source`
- L381: `// Error: "capture reference {env} in target parameter not found in source pattern"`
- L383: `// Error: target layer doesn't exist`
- L386: `    TargetLayer: "nonexistent",`
- L387: `    TargetParameter: "api-key",`
- L389: `// Error: "target layer \"nonexistent\" does not exist"`
- L399: `    TargetLayer:     "demo",`
- L400: `    TargetParameter: "api-key",`
- L411: `- Multi-match: If a single pattern matches multiple paths that would resolve to the same target parameter with different values (e.g., `app.*.api_key` for `dev` and `prod`), an error is returned.`
- L412: `- Collisions: If different patterns resolve to the same target parameter (e.g., `app.settings.api_key` and `config.api_key` both mapping to `demo.api-key`), an error is returned.`
- L416: `Runtime errors occur when config files don't match expectations or reference nonexistent parameters. The system provides detailed error messages to aid debugging. Error messages include both the user-provided target name and the canonical (prefix-aware) parameter name where relevant.`
- L420: `- Target parameter doesn't exist in layer`
- L429: `**Example error for missing parameter**:`
- L431: `target parameter "api-key" does not exist in layer "demo" (pattern: "app.settings.api_key")`
- L434: `**Example error for missing parameter with prefix**:`
- L436: `target parameter "api-key" (checked as "demo-api-key") does not exist in layer "demo" (pattern: "app.settings.api_key")`
- L439: `When a layer has a prefix and the target parameter name doesn't include it, the error message shows both the provided name and the resolved canonical name (with prefix). This helps debug parameter name mismatches.`
- L445: `- Overwrites: Overwrites across different rules to the same parameter are considered collisions and will error.`
- L455: `- Grouped parameters (nested rules)`
- L470: `A real-world example showing pattern mapper integration. This example highlights capture inheritance, prefix-aware parameters, and minimal application wiring.`
- L476: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L479: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L483: `    // Define parameter layers`
- L484: `    layer, _ := schema.NewSection("demo", "Demo",`
- L491: `    paramLayers := schema.NewSchema(layers.WithLayers(layer))`
- L494: `    mapper, err := patternmapper.NewConfigMapper(paramLayers,`
- L497: `            TargetLayer: "demo",`
- L499: `                {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L514: `    parsedLayers := values.New()`
- L515: `    err = sources.Execute(paramLayers, parsedLayers, middleware)`
- L536: `patternMapper, _ := patternmapper.NewConfigMapper(layers, rules...)`
- L561: `glaze help parameter-layers-and-parsed-layers`

### `pkg/doc/topics/24-config-files.md`
- L19: `- Traceability: Each config file write is logged with `source: config` and `{ config_file, index }` metadata and can be inspected with `--print-parsed-parameters`.`
- L31: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L33: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L38: `    // Define layers`
- L46: `    pls := schema.NewSchema(layers.WithLayers(demo))`
- L63: `If you‚Äôre building a CLI, the Cobra integration wires configuration, environment variables, positional arguments, and flags into a predictable pipeline with minimal boilerplate. `CobraParserConfig` lets you enable app-wide env prefixes, resolve config files, or inject your own resolver logic. This keeps your command code focused on business logic while Glazed handles the parsing pipeline and debug flags (like `--print-parsed-parameters`).`
- L73: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L74: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L85: `    desc := cmds.NewCommandDescription("demo", cmds.WithLayersList(demo))`
- L104: `Load a single YAML/JSON file when your application‚Äôs configuration is centralized. The file is parsed into your parameter layers, and each value update is recorded as a `config` parse step, making it clear where settings came from when debugging.`
- L110: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L114: `layers_ := schema.NewSchema(/* ... */)`
- L116: `_ = sources.Execute(layers_, parsed,`
- L129: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L134: `_ = sources.Execute(layers_, parsed,`
- L141: `Many CLIs have a conventional config location (XDG, home dotdir, or `/etc`). `ResolveAppConfigPath` encapsulates that search so your app can ‚Äújust find‚Äù a config without hardcoding paths. Pair it with a `--config-file` flag (already provided by the `command-settings` layer) so power users can override discovery. For overlays, a resolver can add optional files like `<base>.override.yaml` if they exist, keeping configuration flexible without hidden magic.`
- L171: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L191: `Glazed supports both ‚Äúdefault-shaped‚Äù configs (where the file mirrors your layers and parameters) and mappers (which translate arbitrary structures to parameter updates). Use the default structure for greenfield projects and simple cases‚Äîit‚Äôs the most transparent. Reach for mappers when you must consume legacy formats, have nested structures that don‚Äôt match your parameter layout, or need to derive multiple parameters from one subtree.`
- L193: `Glazed supports two ways to map config file data into parameter layers:`
- L195: `1) Default structure (no mapper): your config matches the layer/parameter shapes directly`
- L204: `2) Mappers: use a mapper to transform arbitrary config shapes to layer/parameter assignments.`
- L208: `Pattern mappers describe how to traverse a config tree and map matched values into parameters. Patterns support exact segments, wildcards, and named captures (for environment-like keys such as `{env}`). Validation happens both at construction time (syntax, capture references, static targets) and at runtime (required matches, ambiguity, collisions). Prefer named captures over wildcards when you expect multiple values to be collected.`
- L210: `Use `github.com/go-go-golems/glazed/pkg/cmds/middlewares/patternmapper` to declare mapping rules and pass the mapper to `LoadParametersFromFile`.`
- L216: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L219: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L229: `pls := schema.NewSchema(layers.WithLayers(demo))`
- L234: `        TargetLayer: "demo",`
- L236: `            {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L248: `Use a custom function when you need full control: conditional logic, array handling, value transformations, or cross-field validation that‚Äôs not practical to express with patterns. The function receives the unmarshaled config as `interface{}` and returns a standard `map[layerSlug]map[paramName]any` for Glazed to apply.`
- L250: `Provide a `ConfigFileMapper` function to `WithConfigFileMapper` to transform raw config into a `map[layerSlug]map[paramName]any`:`
- L260: `    // inspect raw (unmarshaled YAML/JSON) and build the layer map`
- L271: `## Inspecting parse steps (`--print-parsed-parameters`)`
- L273: `Parsing is not a black box‚Äîevery write records its source and any relevant metadata. Enable `--print-parsed-parameters` to see the exact sequence of updates for each parameter. This is invaluable when debugging precedence issues (for example, ‚Äúwhy didn‚Äôt my local override win?‚Äù) or auditing where a value originated.`
- L275: `Add the `command-settings` layer (done automatically by the Cobra parser unless disabled) and run with `--print-parsed-parameters` to see where a value came from:`
- L292: `Validate configs early to catch mistakes before runtime. For default-shaped files, check for unknown layers/parameters and type errors. For pattern-based configs, instantiate a mapper and call `Map` in a validate-only pass; the mapper will fail fast on missing required matches, ambiguous patterns, or invalid targets. These validators are small enough to run in CI and provide crisp error messages for contributors.`
- L298: `Apply this validator to YAML/JSON files that mirror your layers. It‚Äôs conservative by design: any unexpected layer or parameter is flagged, and values are type-checked against your parameter definitions. This keeps configs tidy and prevents silent drift as parameters evolve.`
- L308: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L309: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L313: `func validateConfigFile(layers_ *schema.Schema, path string) error {`
- L320: `    for layerSlug, v := range raw {`
- L321: `        layer, ok := layers_.Get(layerSlug)`
- L322: `        if !ok { issues = append(issues, fmt.Sprintf("unknown layer %s", layerSlug)); continue }`
- L324: `        if !ok { issues = append(issues, fmt.Sprintf("layer %s must be an object", layerSlug)); continue }`
- L325: `        pds := layer.GetParameterDefinitions()`
- L329: `            if !known[key] { issues = append(issues, fmt.Sprintf("unknown parameter %s.%s", layerSlug, key)); continue }`
- L332: `                issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))`
- L345: `For declarative mappings, the mapper is your validator. Build it once per app (construction validates static aspects) and call `Map` on the raw config (runtime semantics validate dynamic aspects). Error messages include path hints and prefix-aware parameter names to accelerate debugging.`
- L352: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L390: `Legacy Viper-based middlewares like `GatherFlagsFromViper` and per-command `--load-parameters-from-file` are deprecated. Prefer config middlewares (`LoadParametersFromFiles`) with resolvers and `--config-file`.`

### `pkg/doc/topics/commands-reference.md`
- L10: `- layers`
- L22: `The Glazed command system provides a structured approach to building CLI applications that handle multiple output formats, complex parameter validation, and reusable components. This reference covers the complete command system architecture, interfaces, and implementation patterns.`
- L24: `Building CLI tools typically involves handling parameter parsing, validation, output formatting, and configuration management. Glazed addresses these concerns through a layered architecture that separates command logic from presentation and parameter management.`
- L26: `The core principle is separation of concerns: commands focus on business logic while Glazed handles parameter parsing, validation, and output formatting. This approach enables automatic support for multiple output formats, consistent parameter handling across commands, and reusable parameter groups.`
- L41: `‚îÇ  (name, flags, arguments, layers, etc.)     ‚îÇ`
- L46: `‚îÇ               Parameter Layers               ‚îÇ`
- L56: `‚îÇ  Parameters  ‚îÇ          ‚îÇ ParsedLayers    ‚îÇ`
- L84: `2. **CommandDescription**: Contains metadata about a command (name, description, parameters, etc.)`
- L85: `3. **Parameter Layers**: Organize parameters into logical groups (database, logging, output, etc.)`
- L86: `4. **Parameters**: Define command inputs with type information, validation, and help text`
- L87: `5. **ParsedLayers**: Runtime values after collecting from CLI flags, environment, config files, and defaults`
- L92: `The Glazed framework is organized into distinct packages to separate concerns like command definition, parameter handling, and output processing. This modular design makes the system extensible and easier to maintain. Key packages handle command interfaces (`cmds`), parameter definitions (`parameters`), and integration with CLI libraries like Cobra (`cli`).`
- L95: `- `github.com/go-go-golems/glazed/pkg/cmds/parameters`: Parameter types and definitions`
- L96: `- `github.com/go-go-golems/glazed/pkg/cmds/layers`: Parameter layering system`
- L101: `- `github.com/go-go-golems/glazed/pkg/settings`: Standard Glazed parameter layers`
- L123: `    Run(ctx context.Context, parsedLayers *values.Values) error`
- L139: `func (c *CleanupCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L141: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L187: `    RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error`
- L205: `func (c *HealthReportCommand) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {`
- L207: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L248: `    RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error`
- L268: `    parsedLayers *values.Values,`
- L272: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L332: `func (c *StatusCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L334: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L348: `    parsedLayers *values.Values, `
- L352: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L372: `A well-structured Glazed command separates its identity and logic. The recommended pattern involves a `Command` struct embedding a `CommandDescription` for metadata, a separate `Settings` struct for type-safe parameter access via `glazed` tags, and a `Run` method containing the business logic. This separation is bridged at runtime by `InitializeStruct`, which populates the `Settings` struct from parsed command-line values.`
- L380: `**Settings Struct**: Provides type safety by defining a struct that mirrors command inputs. Glazed automatically maps parameters to struct fields through `glazed` tags.`
- L384: `**Constructor Function**: Creates the command description with its parameters and layers.`
- L388: `Settings structs provide type-safe access to parsed command parameters. Each field uses a `glazed` tag that must match the parameter name defined in the command description:`
- L393: `    Count   int    `glazed:"count"`     // Maps to "count" parameter`
- L394: `    Format  string `glazed:"format"`   // Maps to "format" parameter  `
- L395: `    Verbose bool   `glazed:"verbose"`  // Maps to "verbose" parameter`
- L396: `    DryRun  bool   `glazed:"dry-run"`  // Maps to "dry-run" parameter`
- L400: `The `InitializeStruct` method populates the settings struct from parsed layers. Always specify the correct layer slug (use `schema.DefaultSlug` for command-specific parameters):`
- L405: `    parsedLayers *values.Values,`
- L411: `    // Extract values from the "default" layer into the struct`
- L412: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L440: `### Working with Multiple Layers`
- L442: `Commands often use multiple parameter layers. Extract settings from each layer separately:`
- L458: `    parsedLayers *values.Values,`
- L463: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, cmdSettings); err != nil {`
- L467: `    // Extract database layer settings`
- L469: `    if err := parsedLayers.InitializeStruct("database", dbSettings); err != nil {`
- L473: `    // Extract logging layer settings`
- L475: `    if err := parsedLayers.InitializeStruct("logging", logSettings); err != nil {`
- L492: `func (c *ExampleCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L498: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, &s); err != nil {`
- L514: `func (c *ExampleCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L516: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L527: `func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {`
- L529: `    err := parsedLayers.InitializeStruct("database", settings)`
- L534: `    dbSettings, err := GetDatabaseSettings(parsedLayers)`
- L545: `While Glazed excels at building standard CLI tools, its architecture also supports more advanced use cases. Commands can be executed programmatically for testing or integration into other Go applications, and the parameter system can load values from multiple sources like environment variables and config files, not just CLI flags. These patterns allow you to build commands that are not just standalone tools, but reusable components in a larger software ecosystem.`
- L561: `// Define parameter values`
- L563: `    runner.WithValuesForLayers(map[string]map[string]interface{}{`
- L584: `### Parameter Loading Sources`
- L586: `Parameters can be loaded from multiple sources (in priority order):`
- L602: `    runner.WithValuesForLayers(map[string]map[string]interface{}{`
- L656: `    parsedLayers *values.Values,`
- L682: `    parsedLayers *values.Values,`
- L686: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L727: `func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L782: `## Parameters`
- L784: `Glazed treats command-line parameters as more than just strings. They are typed objects with built-in validation, default values, and help text. This approach shifts the burden of parsing and validation from the command's business logic to the framework itself. By defining a parameter's type (e.g., `ParameterTypeInteger`, `ParameterTypeDate`, `ParameterTypeFile`), you get automatic error handling and a more robust and user-friendly CLI.`
- L786: `Glazed parameters are typed objects with validation rules and behavior, unlike traditional CLI libraries that treat parameters as simple strings requiring manual parsing and validation. This enables automatic validation, help generation, and multi-source value loading.`
- L788: `### Parameter Type System`
- L790: `Parameter types define data structure, parsing behavior, and validation rules. Each type handles string parsing, validation, and help text generation.`
- L793: `**`ParameterTypeString`**: The workhorse for text inputs - names, descriptions, URLs`
- L794: `**`ParameterTypeSecret`**: Like strings, but values are masked in help and logs (perfect for passwords, API keys)`
- L795: `**`ParameterTypeInteger`**: Whole numbers with automatic range validation`
- L796: `**`ParameterTypeFloat`**: Decimal numbers for measurements, percentages, ratios`
- L797: `**`ParameterTypeBool`**: True/false flags that work with `--flag` and `--no-flag` patterns`
- L798: `**`ParameterTypeDate`**: Intelligent date parsing that handles multiple formats`
- L801: `**`ParameterTypeStringList`**: Multiple values like `--tag web --tag api --tag production``
- L802: `**`ParameterTypeIntegerList`**: Lists of numbers for ports, IDs, quantities`
- L803: `**`ParameterTypeFloatList`**: Multiple decimal values for coordinates, measurements`
- L806: `**`ParameterTypeChoice`**: Single selection from predefined options (with tab completion!)`
- L807: `**`ParameterTypeChoiceList`**: Multiple selections from predefined options`
- L810: `**`ParameterTypeFile`**: File paths with existence validation and tab completion`
- L811: `**`ParameterTypeFileList`**: Multiple file paths`
- L812: `**`ParameterTypeStringFromFile`**: Read text content from a file (useful for large inputs)`
- L813: `**`ParameterTypeStringListFromFile`**: Read line-separated lists from files`
- L816: `**`ParameterTypeKeyValue`**: Map-like inputs: `--env DATABASE_URL=postgres://... --env DEBUG=true``
- L818: `### Parameter Definition Options`
- L822: `    "parameter-name",                    // Required: parameter name`
- L823: `    fields.TypeString,      // Required: parameter type`
- L835: `    parameters.WithFileExtensions(".txt", ".md"),`
- L841: `Arguments are positional parameters that don't use flags:`
- L942: `// Avoid: Manual parameter extraction`
- L943: `source, _ := parsedLayers.GetString("source")`
- L944: `maxAge, _ := parsedLayers.GetString("max-age") // Bug waiting to happen!`
- L951: `Write clear help text with examples for complex parameters:`
- L977: `Validate parameters before expensive operations. Always check context cancellation in loops and long operations.`
- L1017: `2. Study the layer guide to understand parameter organization:`
- L1019: `   glaze help layers-guide`

### `pkg/doc/topics/how-to-write-good-documentation-pages.md`
- L335: `- **Options/Config:** When documenting flags, parameters, or settings`

### `pkg/doc/topics/layers-guide.md`
- L2: `Title: Glazed Command Layers Guide`
- L3: `Slug: layers-guide  `
- L4: `Short: Complete guide to understanding and working with command parameter layers in Glazed`
- L6: `- layers`
- L7: `- parameters`
- L16: `# Glazed Command Layers: Complete Guide`
- L18: `*Building maintainable CLI applications through modular parameter organization*`
- L22: `2. [Parameter Organization Challenges](#parameter-organization-challenges)`
- L23: `3. [Layer System Architecture](#layer-system-architecture)`
- L24: `4. [Core Layer Concepts](#core-layer-concepts)`
- L25: `5. [Layer Types & Components](#layer-types--components)`
- L26: `6. [Creating and Working with Layers](#creating-and-working-with-layers)`
- L30: `10. [Testing Layers](#testing-layers)`
- L34: `Parameter layers organize related command parameters into reusable groups. This modular approach addresses common CLI development challenges including parameter proliferation, code duplication, naming conflicts, and maintenance complexity in growing applications.`
- L36: `The layer system enables developers to:`
- L38: `- **Organize parameters** logically by functionality (database, logging, output)`
- L39: `- **Reuse parameter definitions** across multiple commands without duplication`
- L41: `- **Maintain consistency** through centralized parameter definitions`
- L44: `### Traditional Parameter Management Problems`
- L56: `- **Parameter pollution**: Commands inherit irrelevant flags, cluttering help screens`
- L58: `- **Code duplication**: Parameter definitions copy across commands, violating DRY principles`
- L59: `- **Poor organization**: Parameters scatter without logical grouping`
- L90: `### Glazed Layer Solution`
- L92: `The layer system eliminates these problems by treating parameters as modular components that can be shared, composed, reused, maintained centrally, and extended without breaking existing commands.`
- L95: `// Define reusable layers once`
- L97: `    DatabaseLayer = CreateDatabaseLayer()  // --db-host, --db-port, --db-name`
- L98: `    LoggingLayer  = CreateLoggingLayer()   // --log-level, --log-file, --verbose`
- L99: `    ServerLayer   = CreateServerLayer()    // --host, --port, --timeout`
- L100: `    GlazedLayer   = CreateGlazedLayer()    // --output, --fields, --format`
- L103: `// Compose commands by combining relevant layers`
- L105: `    cmds.WithLayers(ServerLayer, DatabaseLayer, LoggingLayer))`
- L108: `    cmds.WithLayers(ServerLayer, LoggingLayer))  // No database needed`
- L111: `    cmds.WithLayers(DatabaseLayer, LoggingLayer, GlazedLayer))  // No server needed`
- L114: `## Parameter Organization Challenges`
- L116: `Complex CLI applications face predictable parameter management challenges that layers directly address.`
- L118: `### Parameter Explosion`
- L120: `As applications add features, commands accumulate parameters that may not be relevant to their specific functionality. This creates cognitive overhead for users and increases implementation complexity.`
- L124: `Multiple subsystems often require similar parameters (host, port, timeout). Without organization, developers resort to verbose prefixes that reduce usability and create inconsistent interfaces.`
- L128: `Parameter definitions scattered across command implementations require manual synchronization. Adding SSL configuration to database connections means updating every command that uses databases.`
- L132: `Without centralized parameter definitions, similar functionality develops different flag names across commands, creating inconsistent user experiences and requiring additional documentation.`
- L134: `## Layer System Architecture`
- L136: `The layer system separates parameter definition from runtime value resolution, enabling flexible composition while maintaining type safety.`
- L144: `‚îÇ  ‚îÇ            Command Description           ‚îÇ ‚Üê Metadata + layer references`
- L147: `‚îÇ  ‚îÇ  ‚îÇ          Parameter Layers           ‚îÇ ‚Üê Layer definitions (design time)`
- L150: `‚îÇ  ‚îÇ  ‚îÇ  ‚îÇDefault Layer‚îÇ  Custom Layers  ‚îÇ   ‚îÇ ‚Üê Different types of layers`
- L160: `‚îÇ              Runtime Parsing                 ‚îÇ ‚Üê Parameter resolution`
- L162: `‚îÇ  Parameter Sources (in priority order):     ‚îÇ ‚Üê Multi-source configuration`
- L166: `‚îÇ  4. Default values from layer definitions   ‚îÇ`
- L171: `‚îÇ               Parsed Layers                  ‚îÇ ‚Üê Runtime values`
- L172: `‚îÇ        (type-safe parameter values)         ‚îÇ`
- L178: `1. **Layer Definitions** (design time): Parameter specifications and constraints`
- L180: `3. **Parsed Layers** (application time): Type-safe access to resolved values`
- L182: `### Layer Lifecycle`
- L184: `Layers progress through distinct phases from definition to runtime use:`
- L186: `1. **Definition Phase**: Parameters defined with types, defaults, and validation rules`
- L187: `2. **Composition Phase**: Layers combined into command descriptions`
- L189: `4. **Execution Phase**: Commands access type-safe parameter values`
- L191: `## Core Layer Concepts`
- L193: `### Layer Identity and Organization`
- L195: `Every layer requires unique identification and logical organization within the application parameter namespace.`
- L197: `#### Layer Hierarchy`
- L201: `‚îú‚îÄ‚îÄ Default Layer (always present)`
- L204: `‚îú‚îÄ‚îÄ Standard Layers (optional, commonly used)`
- L205: `‚îÇ   ‚îú‚îÄ‚îÄ Glazed Layer (for structured output)  ‚Üê Output formatting`
- L206: `‚îÇ   ‚îú‚îÄ‚îÄ Logging Layer (for logging configuration)  ‚Üê Debug & monitoring`
- L207: `‚îÇ   ‚îî‚îÄ‚îÄ Database Layer (for database connections)  ‚Üê Data persistence`
- L208: `‚îî‚îÄ‚îÄ Custom Layers (application-specific)`
- L209: `    ‚îú‚îÄ‚îÄ Authentication Layer        ‚Üê Security & access control`
- L210: `    ‚îú‚îÄ‚îÄ API Configuration Layer     ‚Üê External service integration`
- L211: `    ‚îî‚îÄ‚îÄ Feature Toggle Layer        ‚Üê Experimental or optional features`
- L214: `This hierarchy enables logical grouping, reusability across commands, extensibility without breaking changes, and automatic propagation of layer updates.`
- L216: `### Parameter Definitions vs. Parsed Values`
- L218: `The system distinguishes between parameter specifications (what's possible) and runtime values (what's actual).`
- L220: `**Parameter Definitions** (specifications stored in layers):`
- L224: `    "log-level",                    // Parameter name`
- L238: `loggingLayer, ok := parsedLayers.Get("logging")`
- L240: `    logLevel, ok := loggingLayer.GetParameter("log-level")`
- L251: `### Layer Composition Patterns`
- L253: `Layer composition determines command interfaces by selecting appropriate parameter groups.`
- L260: `// Combine only needed layers`
- L262: `    cmds.WithLayers(databaseLayer, loggingLayer))`
- L267: `Dynamic layer assembly based on runtime conditions:`
- L270: `// Build layer list based on features`
- L271: `layers := []schema.Section{baseLayer}`
- L274: `    layers = append(layers, databaseLayer)`
- L278: `    layers = append(layers, glazedLayer)`
- L282: `    cmds.WithLayersList(layers...))`
- L285: `#### Layer Extension`
- L287: `Building specialized variants from existing layers:`
- L290: `// Extend existing layer without modification`
- L291: `extendedDbLayer := databaseLayer.Clone()`
- L292: `extendedDbLayer.AddFlags(`
- L298: `## Layer Types & Components`
- L300: `### Built-in Layer Types`
- L302: `Glazed provides standard layer types for common CLI application requirements.`
- L304: `#### Default Layer`
- L306: `The Default Layer contains command-specific parameters unique to individual commands.`
- L311: `- **Use Case**: Parameters fundamental to command operation, unlikely to be shared`
- L314: `// Default layer created automatically`
- L324: `// Parameters live in default layer, unique to "serve" command`
- L327: `#### Glazed Layer`
- L329: `The Glazed Layer provides comprehensive output formatting capabilities for commands producing structured data.`
- L333: `- **Creation**: `settings.NewGlazedParameterLayers()``
- L337: `glazedLayer, err := settings.NewGlazedParameterLayers()`
- L339: `    return nil, fmt.Errorf("failed to create glazed layer: %w", err)`
- L345: `### Custom Layer Components`
- L347: `Application-specific layers address domain requirements through custom parameter definitions.`
- L349: `#### Parameter Definitions`
- L351: `Individual parameter specifications define acceptable input and behavior:`
- L355: `    "connection-timeout",              // Parameter name`
- L365: `- **Name**: Parameter identifier for CLI flags`
- L373: `Parameter definitions include built-in validation for common patterns:`
- L376: `// Choice parameters with automatic validation`
- L385: `// Numeric parameters with defaults`
- L395: `## Creating and Working with Layers`
- L397: `### Method 1: Simple Layer Creation`
- L399: `Direct layer creation for straightforward parameter grouping:`
- L402: `func NewDatabaseLayer() (schema.Section, error) {`
- L404: `        "database",                    // Layer identifier`
- L430: `### Method 2: Type-Safe Layer with Settings Struct`
- L432: `For complex layers requiring type safety and structured access:`
- L445: `// 2. Create layer with parameter definitions`
- L446: `func NewDatabaseLayer() (schema.Section, error) {`
- L491: `func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {`
- L493: `    err := parsedLayers.InitializeStruct("database", settings)`
- L500: `    parsedLayers *values.Values,`
- L503: `    // Extract database settings from the "database" layer`
- L504: `    dbSettings, err := GetDatabaseSettings(parsedLayers)`
- L523: `### Method 3: Layer Builder Pattern`
- L525: `For complex scenarios requiring conditional parameters:`
- L528: `type DatabaseLayerBuilder struct {`
- L529: `    layer      schema.Section`
- L534: `func NewDatabaseLayerBuilder() *DatabaseLayerBuilder {`
- L535: `    layer, _ := schema.NewSection("database", "Database Configuration")`
- L536: `    return &DatabaseLayerBuilder{layer: layer}`
- L539: `func (b *DatabaseLayerBuilder) WithSSL() *DatabaseLayerBuilder {`
- L544: `func (b *DatabaseLayerBuilder) WithConnectionPool() *DatabaseLayerBuilder {`
- L549: `func (b *DatabaseLayerBuilder) Build() (schema.Section, error) {`
- L550: `    // Add basic parameters`
- L551: `    b.layer.AddFlags(`
- L558: `    // Conditionally add SSL parameters`
- L560: `        b.layer.AddFlags(`
- L567: `    // Conditionally add connection pool parameters`
- L569: `        b.layer.AddFlags(`
- L577: `    return b.layer, nil`
- L581: `dbLayer, _ := NewDatabaseLayerBuilder().`
- L587: `### Method 4: Registering Layers with Explicit Slugs on Commands`
- L589: `In some cases you may want to register layers on a command under explicit slugs that differ from the layer's internal slug. Use `cmds.WithLayersMap` to provide a map of slug-to-layer entries when creating a command description.`
- L592: `dbLayer, _ := NewDatabaseLayer()        // internal slug: "database"`
- L593: `loggingLayer, _ := NewLoggingLayer()    // internal slug: "logging"`
- L597: `    cmds.WithLayersMap(map[string]schema.Section{`
- L598: `        "db":  dbLayer,    // registered under explicit slug "db"`
- L599: `        "log": loggingLayer,`
- L607: `- If a layer's internal slug differs from the map key and the layer is a `*schema.SectionImpl`, Glazed will clone the layer and align its slug to the provided key for consistent runtime behavior.`
- L608: `- For custom layer implementations, prefer using matching internal and registration slugs when possible.`
- L614: `Complete layer implementation for a web server with database, logging, and server configuration:`
- L622: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L623: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L648: `// Layer creation functions`
- L649: `func NewServerLayer() (schema.Section, error) {`
- L684: `func NewLoggingLayer() (schema.Section, error) {`
- L712: `func NewDatabaseLayer() (schema.Section, error) {`
- L749: `// Command creation with layer composition`
- L751: `    // Create layers`
- L752: `    serverLayer, err := NewServerLayer()`
- L757: `    loggingLayer, err := NewLoggingLayer()`
- L762: `    databaseLayer, err := NewDatabaseLayer()`
- L767: `    // Compose command with relevant layers`
- L772: `        cmds.WithLayersList(serverLayer, databaseLayer, loggingLayer),`
- L778: `    serverLayer, err := NewServerLayer()`
- L783: `    loggingLayer, err := NewLoggingLayer()`
- L799: `        cmds.WithLayersList(serverLayer, loggingLayer), // No database layer`
- L803: `// Settings extraction helpers demonstrate how to use InitializeStruct with layer-specific settings`
- L804: `func GetServerSettings(parsedLayers *values.Values) (*ServerSettings, error) {`
- L806: `    err := parsedLayers.InitializeStruct("server", settings)`
- L810: `func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {`
- L812: `    err := parsedLayers.InitializeStruct("logging", settings)`
- L816: `func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {`
- L818: `    err := parsedLayers.InitializeStruct("database", settings)`
- L822: `// Example command implementation using multiple layer settings`
- L827: `func (c *ServerCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L828: `    // Extract settings from each layer`
- L829: `    serverSettings, err := GetServerSettings(parsedLayers)`
- L834: `    dbSettings, err := GetDatabaseSettings(parsedLayers)`
- L839: `    logSettings, err := GetLoggingSettings(parsedLayers)`
- L844: `    // Use settings from multiple layers`
- L870: `Layer composition for applications with conditional functionality. This example shows how to extract settings from optional layers and use them together:`
- L873: `// Feature layers for optional inclusion`
- L874: `func NewCacheLayer() (schema.Section, error) {`
- L901: `func NewMetricsLayer() (schema.Section, error) {`
- L930: `    baseLayers    []schema.Section`
- L937: `    loggingLayer, _ := NewLoggingLayer()`
- L940: `        baseLayers: []schema.Section{loggingLayer},`
- L960: `    commandLayers := append([]schema.Section{}, b.baseLayers...)`
- L962: `    // Add optional layers based on enabled features`
- L964: `        cacheLayer, err := NewCacheLayer()`
- L968: `        commandLayers = append(commandLayers, cacheLayer)`
- L972: `        metricsLayer, err := NewMetricsLayer()`
- L976: `        commandLayers = append(commandLayers, metricsLayer)`
- L980: `        authLayer, err := NewAuthLayer() // Assume this exists`
- L984: `        commandLayers = append(commandLayers, authLayer)`
- L1003: `        cmds.WithLayersList(commandLayers...),`
- L1020: `// Helper functions for optional layer settings`
- L1021: `func GetCacheSettings(parsedLayers *values.Values) (*CacheSettings, error) {`
- L1023: `    err := parsedLayers.InitializeStruct("cache", settings)`
- L1027: `func GetMetricsSettings(parsedLayers *values.Values) (*MetricsSettings, error) {`
- L1029: `    err := parsedLayers.InitializeStruct("metrics", settings)`
- L1033: `// Command implementation that handles optional layers`
- L1038: `func (c *ProcessCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L1040: `    logSettings, err := GetLoggingSettings(parsedLayers)`
- L1048: `    if parsedLayers.Has("cache") {`
- L1049: `        cacheSettings, err := GetCacheSettings(parsedLayers)`
- L1062: `    if parsedLayers.Has("metrics") {`
- L1063: `        metricsSettings, err := GetMetricsSettings(parsedLayers)`
- L1096: `### 1. Layer Inheritance and Composition`
- L1098: `Extending existing layers without modification:`
- L1101: `// Base database layer`
- L1102: `func NewBaseDatabaseLayer() (schema.Section, error) {`
- L1115: `// Extended database layer with additional features`
- L1116: `func NewAdvancedDatabaseLayer() (schema.Section, error) {`
- L1117: `    // Start with base layer`
- L1118: `    baseLayer, err := NewBaseDatabaseLayer()`
- L1124: `    advancedLayer := baseLayer.Clone()`
- L1126: `    // Add additional parameters`
- L1127: `    advancedLayer.AddFlags(`
- L1136: `    return advancedLayer, nil`
- L1140: `### 2. Environment-Specific Layer Configuration`
- L1142: `Adapting layers for different deployment environments:`
- L1150: `func NewEnvironmentAwareDatabaseLayer(config EnvironmentConfig) (schema.Section, error) {`
- L1151: `    layer, err := NewBaseDatabaseLayer()`
- L1156: `    // Add environment-specific parameters`
- L1159: `        layer.AddFlags(`
- L1166: `        layer.AddFlags(`
- L1175: `    // Add feature-specific parameters`
- L1179: `            layer.AddFlags(`
- L1185: `            layer.AddFlags(`
- L1192: `    return layer, nil`
- L1196: `### 3. Dynamic Layer Registration`
- L1198: `Runtime layer registration for plugin systems:`
- L1201: `type LayerRegistry struct {`
- L1202: `    layers map[string]schema.Section`
- L1206: `func NewLayerRegistry() *LayerRegistry {`
- L1207: `    return &LayerRegistry{`
- L1208: `        layers: make(map[string]schema.Section),`
- L1212: `func (r *LayerRegistry) RegisterLayer(slug string, layer schema.Section) error {`
- L1216: `    if _, exists := r.layers[slug]; exists {`
- L1217: `        return fmt.Errorf("layer %s already registered", slug)`
- L1220: `    r.layers[slug] = layer`
- L1224: `func (r *LayerRegistry) GetLayer(slug string) (schema.Section, error) {`
- L1228: `    layer, exists := r.layers[slug]`
- L1230: `        return nil, fmt.Errorf("layer %s not found", slug)`
- L1233: `    return layer, nil`
- L1236: `func (r *LayerRegistry) BuildCommand(name string, layerSlugs []string) (*cmds.CommandDescription, error) {`
- L1237: `    var commandLayers []schema.Section`
- L1239: `    for _, slug := range layerSlugs {`
- L1240: `        layer, err := r.GetLayer(slug)`
- L1244: `        commandLayers = append(commandLayers, layer)`
- L1248: `        cmds.WithLayersList(commandLayers...)), nil`
- L1252: `func InitializePluginSystem() *LayerRegistry {`
- L1253: `    registry := NewLayerRegistry()`
- L1255: `    // Register core layers`
- L1256: `    databaseLayer, _ := NewDatabaseLayer()`
- L1257: `    registry.RegisterLayer("database", databaseLayer)`
- L1259: `    loggingLayer, _ := NewLoggingLayer()`
- L1260: `    registry.RegisterLayer("logging", loggingLayer)`
- L1262: `    // Plugins can register additional layers`
- L1263: `    // registry.RegisterLayer("custom-feature", customLayer)`
- L1269: `### 4. Layer Validation and Constraints`
- L1271: `Complex validation rules across layer parameters:`
- L1274: `type LayerValidator struct {`
- L1280: `func NewLayerValidator() *LayerValidator {`
- L1281: `    return &LayerValidator{}`
- L1284: `func (v *LayerValidator) AddRule(rule ValidationRule) {`
- L1288: `func (v *LayerValidator) Validate(parsedLayers *values.Values) error {`
- L1290: `        if err := rule(parsedLayers); err != nil {`
- L1297: `// Cross-layer validation rules`
- L1298: `func DatabaseConnectionRule(parsedLayers *values.Values) error {`
- L1299: `    dbLayer, ok := parsedLayers.Get("database")`
- L1301: `        return nil // Skip if database layer not present`
- L1304: `    host, ok := dbLayer.GetParameter("db-host")`
- L1309: `    port, ok := dbLayer.GetParameter("db-port")`
- L1314: `    // Validate connection parameters make sense together`
- L1322: `func SSLConfigurationRule(parsedLayers *values.Values) error {`
- L1323: `    dbLayer, ok := parsedLayers.Get("database")`
- L1325: `        return nil // Skip if database layer not present`
- L1328: `    sslMode, ok := dbLayer.GetParameter("db-ssl-mode")`
- L1335: `        cert, ok := dbLayer.GetParameter("db-ssl-cert")`
- L1345: `func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L1346: `    // Validate layer configuration`
- L1347: `    validator := NewLayerValidator()`
- L1351: `    if err := validator.Validate(parsedLayers); err != nil {`
- L1362: `### Layer Design Principles`
- L1364: `**Single Responsibility**: Each layer should handle one logical area of configuration. Database layers handle database parameters, logging layers handle logging configuration.`
- L1366: `**Clear Naming**: Use descriptive layer slugs and parameter names. Prefer `database-connection-timeout` over `timeout`.`
- L1370: `**Consistent Interfaces**: Use similar parameter names across layers. If one layer uses `host`, avoid `hostname` in another layer for the same concept.`
- L1372: `### Parameter Organization`
- L1374: `Group related parameters logically within layers. Database layers should include host, port, credentials, and connection options together.`
- L1378: `Consider parameter relationships when designing layers. Parameters that are frequently used together belong in the same layer.`
- L1382: `Only include layers that provide parameters relevant to the command's functionality. Avoid layer pollution by being selective.`
- L1386: `Consider creating specialized layer variants for different command types. A read-only database layer might exclude authentication parameters.`
- L1390: `Validate layer configuration early in command execution. Fail fast with clear error messages about parameter issues.`
- L1394: `Use type-safe parameter extraction where possible. Struct-based settings reduce runtime errors and improve code clarity.`
- L1398: `Write unit tests for layer definitions to ensure parameter validation works correctly. Test edge cases and error conditions.`
- L1400: `Test layer composition to verify that combined layers work correctly together. Check for parameter conflicts and validation interactions.`
- L1402: `Use integration tests to verify that commands work correctly with different layer combinations and parameter sources.`
- L1404: `Document layer dependencies and relationships. Explain when layers should be used together and any constraints.`
- L1406: `Keep layer definitions close to their usage when possible. This improves maintainability and reduces the chance of configuration drift.`
- L1408: `Version layer definitions carefully in evolving applications. Consider backward compatibility when modifying existing layers.`
- L1410: `## Testing Layers`
- L1412: `### Unit Testing Layer Definitions`
- L1414: `Test individual layer creation and parameter validation:`
- L1417: `func TestDatabaseLayer(t *testing.T) {`
- L1418: `    layer, err := NewDatabaseLayer()`
- L1420: `    assert.Equal(t, "database", layer.GetSlug())`
- L1422: `    // Test parameter definitions`
- L1423: `    params := layer.GetParameterDefinitions()`
- L1436: `func TestParameterValidation(t *testing.T) {`
- L1437: `    layer, _ := NewDatabaseLayer()`
- L1440: `    logLevelParam := layer.GetParameterDefinitions()["log-level"]`
- L1444: `    // Test required parameters`
- L1445: `    dbNameParam := layer.GetParameterDefinitions()["db-name"]`
- L1450: `### Integration Testing Layer Composition`
- L1452: `Test command creation with multiple layers:`
- L1456: `    serverLayer, _ := NewServerLayer()`
- L1457: `    databaseLayer, _ := NewDatabaseLayer()`
- L1458: `    loggingLayer, _ := NewLoggingLayer()`
- L1461: `        cmds.WithLayersList(serverLayer, databaseLayer, loggingLayer))`
- L1466: `    // Verify all layers are present`
- L1467: `    layers := command.GetLayers()`
- L1468: `    assert.Len(t, layers, 3)`
- L1470: `    // Verify no parameter conflicts`
- L1472: `    for _, layer := range layers {`
- L1473: `        for paramName := range layer.GetParameterDefinitions() {`
- L1475: `                "Parameter %s defined in multiple layers", paramName)`
- L1482: `### Testing Parameter Resolution`
- L1484: `Test parameter value resolution from different sources:`
- L1487: `func TestParameterResolution(t *testing.T) {`
- L1488: `    // Create test command with layers`
- L1493: `    parsedLayers, err := command.ParseLayers(args)`
- L1497: `    dbLayer, ok := parsedLayers.Get("database")`
- L1500: `    dbHost, ok := dbLayer.GetParameter("db-host")`
- L1504: `    dbPort, ok := dbLayer.GetParameter("db-port")`
- L1510: `    err = parsedLayers.InitializeStruct("database", dbSettings)`
- L1520: `    parsedLayers, err := command.ParseLayers([]string{})`
- L1524: `    dbLayer, _ := parsedLayers.Get("database")`
- L1525: `    dbHost, _ := dbLayer.GetParameter("db-host")`
- L1528: `    dbPort, _ := dbLayer.GetParameter("db-port")`
- L1531: `    loggingLayer, _ := parsedLayers.Get("logging")`
- L1532: `    logLevel, _ := loggingLayer.GetParameter("log-level")`
- L1537: `### Testing Layer Builders and Dynamic Composition`
- L1539: `Test builder patterns and conditional layer inclusion:`
- L1542: `func TestDatabaseLayerBuilder(t *testing.T) {`
- L1543: `    // Test basic layer`
- L1544: `    basicLayer, err := NewDatabaseLayerBuilder().Build()`
- L1547: `    basicParams := basicLayer.GetParameterDefinitions()`
- L1552: `    // Test layer with SSL`
- L1553: `    sslLayer, err := NewDatabaseLayerBuilder().WithSSL().Build()`
- L1556: `    sslParams := sslLayer.GetParameterDefinitions()`
- L1561: `    // Test layer with connection pool`
- L1562: `    poolLayer, err := NewDatabaseLayerBuilder().WithConnectionPool().Build()`
- L1565: `    poolParams := poolLayer.GetParameterDefinitions()`
- L1570: `func TestConditionalLayerComposition(t *testing.T) {`
- L1576: `    assert.Len(t, basicCmd.GetLayers(), 1) // Only logging layer`
- L1581: `    assert.Len(t, cacheCmd.GetLayers(), 2) // Logging + cache layers`
- L1586: `    assert.Len(t, fullCmd.GetLayers(), 4) // All layers`
- L1590: `This comprehensive testing approach ensures layers work correctly individually and in composition, parameter resolution functions properly across different sources, and dynamic layer construction produces expected results.`

### `pkg/doc/topics/logging-layer.md`
- L2: `Title: Logging Layer API Reference`
- L3: `Slug: logging-layer-reference`
- L16: `# Logging Layer API Reference`
- L20: `The Glazed logging layer provides comprehensive logging configuration for CLI applications through command-line parameters, environment variables, and configuration files. The layer handles setup for console output, file logging, and centralized log aggregation while supporting multiple output formats and verbosity levels.`
- L33: `    A[CLI Parameters] --> B[Logging Layer]`
- L43: `The logging layer transforms command-line parameters into configured log outputs, supporting development, testing, and production deployment scenarios.`
- L49: `Add the logging layer to any Glazed command:`
- L58: `    loggingLayer, err := logging.NewLoggingLayer()`
- L60: `        return nil, fmt.Errorf("failed to create logging layer: %w", err)`
- L66: `        cmds.WithLayersList(loggingLayer),`
- L74: `    parsedLayers *values.Values,`
- L77: `    // Initialize logging settings from parsed layers`
- L79: `    if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {`
- L149: `## Configuration Parameters`
- L153: `| Parameter | Type | Default | Description |`
- L262: `To initialize logging from parsed layers, use the standard pattern:`
- L265: `// Extract logging settings from parsed layers`
- L267: `if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {`
- L298: `if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {`
- L310: `#### NewLoggingLayer`
- L313: `func NewLoggingLayer() (schema.Section, error)`
- L316: `Creates parameter layer for command definitions.`
- L320: `loggingLayer, err := logging.NewLoggingLayer()`
- L327: `    cmds.WithLayersList(loggingLayer),`
- L389: `   parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings)`
- L416: `- [Custom Layer Tutorial](../tutorials/custom-layer.md): Creating custom parameter layers`
- L417: `- [Layers Guide](../topics/layers-guide.md): Parameter layer system overview`

### `pkg/doc/topics/using-the-query-api.md`
- L37: `The query system consists of several layered components:`
- L57: `‚îú‚îÄ‚îÄ dsl_bridge.go          # Integration layer`
- L206: `fmt.Printf("Parameters: %v\n", debugInfo.Parameters)`
- L569: `            http.Error(w, "Missing query parameter", http.StatusBadRequest)`

### `pkg/doc/tutorials/01-a-simple-table-cli.md`
- L20: `- `ParameterDefinition`: This struct is used to define the parameters (flags or arguments) that the command takes. It`
- L21: `  includes the name of the parameter, the type, and any default value.`
- L72: `	parsedLayers map[string]*layers.ParsedParameterLayer,`

### `pkg/doc/tutorials/04-lua.md`
- L70: `2. Creates a global table containing parameter information (`animal_list_params`)`
- L75: `- Set up parameters for the command`
- L78: `- Display parameter information`
- L98: `-- Print parameter information`
- L99: `print("\nParameters for animal_list command:")`
- L100: `for layer_name, layer_params in pairs(animal_list_params) do`
- L101: `    print("Layer: " .. layer_name)`
- L102: `    for param_name, param_info in pairs(layer_params) do`
- L127: `For more complex commands, you might need to work with nested parameter structures. Here's how to use nested tables:`
- L154: `err := sources.Execute(cmd.Description().Layers, `
- L155: `    parsedLayers, `
- L166: `- Work with parameters and nested tables`

### `pkg/doc/tutorials/05-build-first-command.md`
- L24: `- Understand command configuration and parameter handling`
- L79: `Every Glazed command follows a consistent pattern: a command struct embeds `*cmds.CommandDescription` for metadata, and a settings struct maps command-line flags to Go fields using struct tags for type-safe parameter access.`
- L87: `// Step 2.2: Define settings for type-safe parameter access`
- L97: `1. **Command Struct**: `ListUsersCommand` embeds `*cmds.CommandDescription`, which contains command metadata (name, help text, parameters)`
- L153: `### Command Configuration and Parameters`
- L155: `Command configuration combines your custom fields with Glazed's built-in output formatting capabilities. The `settings.NewGlazedSchema()` helper (a wrapper around `settings.NewGlazedParameterLayers()`) adds standard flags like `--output`, `--fields`, and `--sort-columns`, while your custom field definitions specify the command's business logic inputs.`
- L162: `    glazedLayer, err := settings.NewGlazedSchema()`
- L167: `    // Create command settings layer for debugging features`
- L168: `    commandSettingsLayer, err := cli.NewCommandSettingsLayer()`
- L173: `    // Define command with parameters`
- L215: `        // Add glazed and command settings layers`
- L216: `        cmds.WithLayersList(glazedLayer, commandSettingsLayer),`
- L227: `1. **Glazed Schema Section**: `settings.NewGlazedSchema()` adds built-in parameters like `--output`, `--fields`, `--sort-columns` (and `cli.BuildCobraCommand` will auto-add it for `GlazeCommand` implementations if you don't)`
- L228: `2. **Command Settings Layer**: `cli.NewCommandSettingsLayer()` adds debugging and configuration parameters:`
- L229: `   - `--print-parsed-parameters`: Debug parameter parsing`
- L231: `   - `--load-parameters-from-file`: Load settings from JSON file`
- L233: `4. **Parameter Definitions**: Each flag specifies:`
- L238: `5. **Layer Composition**: Combines custom parameters with Glazed's built-in layers`
- L328: `3. **Filtering Logic**: Demonstrates how command parameters control data processing`
- L332: `Glazed commands integrate with standard Cobra applications through the `cli.BuildCobraCommand()` builder function. This function handles the conversion between Glazed's parameter layer system and Cobra's flag parsing, automatically configuring output processing and help text generation. You can pass parser and mode options via `CobraParserConfig` and `CobraOption` helpers.`
- L354: `            ShortHelpLayers: []string{schema.DefaultSlug},`
- L379: `Glazed provides a logging layer you can attach to your root command. This exposes logging-related flags and initializes logging based on configuration. Initialize the logger in `PersistentPreRunE` using Cobra-parsed flags so logging is active before your command logic runs.`
- L399: `    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "glazed-quickstart")`
- L408: `- Add logging flags with `logging.AddLoggingLayerToRootCommand(rootCmd, "<use-name>")`.`
- L410: `- Alternatively, you can call `logging.SetupLoggingFromParsedLayers(parsedLayers)` after parsing for per-command logging settings.`
- L416: `3. **Enhanced Cobra Bridge**: Use `cli.WithParserConfig` to pass a `CobraParserConfig` that customizes parser behavior (e.g., `ShortHelpLayers`, `MiddlewaresFunc`).`
- L425: `- `--print-parsed-parameters`: Shows how parameters were parsed from different sources`
- L427: `- `--print-schema`: Displays the command's parameter schema`
- L434: `- **Contextual Help**: Provides detailed help based on command context and available layers`
- L435: `- **Parameter Documentation**: Automatically generates help text from parameter definitions`
- L436: `- **Layer-Aware Help**: Shows relevant parameters based on active layers`
- L441: `Testing validates that your command properly parses parameters, processes data according to the business logic, and integrates correctly with Glazed's output system.`
- L450: `# Try different parameter combinations`
- L457: `./glazed-quickstart list-users --print-parsed-parameters`
- L468: `1. **Help Text**: `--help` displays auto-generated parameter descriptions and examples with enhanced formatting`
- L469: `2. **Parameter Validation**: Invalid values trigger automatic validation errors`
- L472: `5. **Help Command**: `help` command provides contextual documentation and parameter guidance`
- L572: `    // Add command settings layer for debugging features`
- L573: `    commandSettingsLayer, err := cli.NewCommandSettingsLayer()`
- L591: `        cmds.WithLayersList(commandSettingsLayer),`
- L633: `        ShortHelpLayers: []string{schema.DefaultSlug},`
- L668: `./glazed-quickstart status --print-parsed-parameters`
- L700: `**Type Safety**: Use settings structs with `glazed` tags for automatic parameter parsing and validation.`
- L704: `**Input Validation**: Validate business rules in your command implementation, not just parameter types:`
- L707: `// Validate business rules after parameter parsing`
- L718: `### Advanced Parameter Types`
- L720: `Glazed supports various parameter types beyond basic strings, integers, and booleans:`
- L724: `    // File parameter validates file exists`
- L731: `    // Choice parameter limits valid options`
- L778: `glaze help layers-guide`
- L781: `Learn about parameter layers for organizing reusable configuration sets across commands.`
- L798: `glaze help custom-layer`
- L801: `Create domain-specific parameter layers for your application's needs.`

### `pkg/doc/tutorials/config-files-quickstart.md`
- L17: `This tutorial shows how to load configuration from one or more files using Glazed middlewares. You‚Äôll see a simple single-file setup and a multi-file overlay with deterministic precedence. We‚Äôll also show how to inspect parse steps using `--print-parsed-parameters`.`
- L22: `- Familiarity with Cobra commands and Glazed layers`
- L26: `Create a minimal command with a single custom layer and an explicit config file path:`
- L29: `demoLayer, _ := schema.NewSection(`
- L31: `    layers.WithPrefix("demo-"),`
- L38: `desc := cmds.NewCommandDescription("demo", cmds.WithLayersList(demoLayer))`
- L44: `        SkipCommandSettingsLayer: true,`
- L81: `        SkipCommandSettingsLayer: true,`
- L124: `Add `--print-parsed-parameters` to see each config file applied in sequence:`
- L127: `go run ./cmd/examples/config-overlay overlay --print-parsed-parameters`
- L162: `To layer `<base>.override.yaml` automatically on top of `--config-file`:`
- L192: `Map arbitrary config structures to parameters without custom Go by using the pattern-based config mapper. Works with YAML or JSON files.`
- L195: `// Define a layer`
- L196: `demoLayer, _ := schema.NewSection("demo", "Demo",`
- L203: `paramLayers := schema.NewSchema(layers.WithLayers(demoLayer))`
- L206: `mapper, _ := patternmapper.NewConfigMapper(paramLayers,`
- L209: `        TargetLayer: "demo",`
- L211: `            {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L220: `_ = sources.Execute(paramLayers, values.New(), mw)`
- L226: `b := patternmapper.NewConfigMapperBuilder(paramLayers).`
- L238: `err := sources.Execute(layers_, parsed,`
- L253: `      TargetLayer:     "demo",`
- L254: `      TargetParameter: "api-key",`
- L259: `- Ambiguity: wildcard patterns that match multiple different values or rules that resolve to the same target parameter cause errors. Prefer named captures (e.g., `app.{env}.api_key`) when collecting multiple values.`
- L261: `- Missing parameters: mapping to a non-existent parameter errors (prefix-aware), helping catch typos early.`
- L268: `err := sources.Execute(layers_, parsed,`

### `pkg/doc/tutorials/custom-layer.md`
- L2: `Title: Creating Custom Parameter Layers`
- L3: `Slug: custom-layer-tutorial`
- L4: `Short: Step-by-step tutorial for creating reusable custom parameter layers in Glazed`
- L7: `- layers`
- L8: `- parameters`
- L17: `# Creating Custom Parameter Layers: Tutorial`
- L21: `Custom parameter layers address the common challenge of duplicating parameter definitions across multiple CLI commands. Instead of copying the same flags for logging, database connections, or API configurations across commands, parameter layers provide reusable components that encapsulate related parameters and their validation logic.`
- L23: `This tutorial demonstrates building a production-ready logging layer that can be reused across any Glazed command, providing consistent configuration interfaces and behavior throughout an application.`
- L29: `- **Reusable logging layer implementation** with comprehensive parameter definitions`
- L30: `- **Type-safe configuration structures** using struct tags for parameter binding`
- L32: `- **Command composition patterns** demonstrating layer reuse across multiple commands`
- L43: `Comprehensive logging configuration for production applications requires multiple parameter categories:`
- L56: `Parameter layers eliminate the need to duplicate these 7+ flags across every command by defining the configuration once and reusing it throughout the application.`
- L58: `## Step 1: Parameter Design`
- L60: `Production logging layers require parameters that address both developer and operational requirements:`
- L62: `**Core Parameters:**`
- L69: `**Production Parameters:**`
- L73: `- **Input validation**: Clear error messages for invalid parameter combinations`
- L78: `mkdir glazed-logging-layer`
- L79: `cd glazed-logging-layer`
- L80: `go mod init glazed-logging-layer`
- L86: `The project structure separates parameter definitions from business logic for maintainability:`
- L89: `glazed-logging-layer/`
- L90: `‚îú‚îÄ‚îÄ main.go           # Demo commands showing layer usage`
- L92: `‚îÇ   ‚îú‚îÄ‚îÄ layer.go      # Parameter definitions and layer creation`
- L98: `This separation enables independent testing of parameter validation and provides clear initialization patterns for applications using the layer.`
- L104: `The settings struct defines the layer's configuration interface, using struct tags to map CLI parameters to Go fields. This struct serves as both the parameter binding target and the configuration container for logger initialization.`
- L121: `// This struct serves as both the parameter binding target and the`
- L261: `## Step 4: Define the Parameter Interface`
- L263: `Create `logging/layer.go`:`
- L265: `The layer definition specifies the CLI parameters and their configuration options. Each parameter includes type, default values, validation rules, and help text.`
- L271: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L272: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L276: `    // LoggingSlug is the unique identifier for this layer.`
- L280: `// NewLoggingLayer creates a new parameter layer for logging configuration.`
- L281: `func NewLoggingLayer() (schema.Section, error) {`
- L286: `            // Core logging parameters - the ones everyone needs`
- L309: `            // Developer convenience parameters`
- L341: `// NewLoggingLayerWithOptions creates a logging layer with customization options`
- L342: `func NewLoggingLayerWithOptions(opts ...LoggingLayerOption) (schema.Section, error) {`
- L343: `    config := &loggingLayerConfig{`
- L354: `    layer, err := NewLoggingLayer()`
- L360: `    params := layer.GetParameterDefinitions()`
- L373: `    // To implement conditional parameters, you would need to create separate layers`
- L374: `    // or build the layer conditionally rather than removing parameters after creation.`
- L375: `    // For production code, use the basic NewLoggingLayer() without RemoveFlag calls.`
- L377: `    return layer, nil`
- L380: `// Configuration options for the logging layer`
- L381: `type loggingLayerConfig struct {`
- L387: `type LoggingLayerOption func(*loggingLayerConfig)`
- L389: `// WithLogstash includes Logstash configuration parameters`
- L390: `func WithLogstash() LoggingLayerOption {`
- L391: `    return func(c *loggingLayerConfig) {`
- L397: `func WithDefaultLevel(level string) LoggingLayerOption {`
- L398: `    return func(c *loggingLayerConfig) {`
- L404: `func WithDefaultFormat(format string) LoggingLayerOption {`
- L405: `    return func(c *loggingLayerConfig) {`
- L421: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L425: `// GetLoggingSettings extracts logging settings from parsed layers`
- L426: `func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {`
- L428: `    if err := parsedLayers.InitializeStruct(LoggingSlug, settings); err != nil {`
- L434: `// InitializeLogging sets up logging from parsed layers`
- L435: `func InitializeLogging(parsedLayers *values.Values) error {`
- L436: `    settings, err := GetLoggingSettings(parsedLayers)`
- L457: `func MustInitializeLogging(parsedLayers *values.Values) {`
- L458: `    if err := InitializeLogging(parsedLayers); err != nil {`
- L476: `## Step 6: Create a Command Using the Layer`
- L489: `    "glazed-logging-layer/logging"`
- L493: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L494: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L502: `// ProcessDataCommand demonstrates using the logging layer`
- L516: `    parsedLayers *values.Values,`
- L520: `    if err := logging.InitializeLogging(parsedLayers); err != nil {`
- L528: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, settings); err != nil {`
- L575: `    // Create logging layer with custom options`
- L576: `    loggingLayer, err := logging.NewLoggingLayerWithOptions(`
- L585: `    // Create glazed layer for output formatting`
- L586: `    glazedLayer, err := settings.NewGlazedParameterLayers()`
- L596: `This command demonstrates how to use the custom logging layer.`
- L635: `        // Add both logging and glazed layers`
- L636: `        cmds.WithLayersList(loggingLayer, glazedLayer),`
- L646: `// Second command to demonstrate layer reuse`
- L659: `    parsedLayers *values.Values,`
- L662: `    // Initialize logging (same layer, reused!)`
- L663: `    if err := logging.InitializeLogging(parsedLayers); err != nil {`
- L670: `    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, settings); err != nil {`
- L704: `    // Reuse the same logging layer - this is the power of layers!`
- L705: `    loggingLayer, err := logging.NewLoggingLayer()`
- L710: `    glazedLayer, err := settings.NewGlazedParameterLayers()`
- L742: `        cmds.WithLayersList(loggingLayer, glazedLayer),`
- L755: `        Short: "Data processing application with custom logging layer",`
- L756: `        Long:  "Demonstrates how to create and reuse custom parameter layers in Glazed",`
- L793: `## Step 7: Test Your Custom Layer`
- L857: `### Layer Composition`
- L859: `Create specialized layers by combining the logging layer with others:`
- L862: `func NewDatabaseLayerWithLogging() ([]schema.Section, error) {`
- L863: `    loggingLayer, err := logging.NewLoggingLayer()`
- L868: `    dbLayer, err := database.NewDatabaseLayer()`
- L873: `    return []schema.Section{loggingLayer, dbLayer}, nil`
- L883: `**Before layers**: Adding logging to commands required copying flag definitions, validation logic, and initialization code across multiple files, leading to inconsistent behavior and maintenance overhead.`
- L885: `**With layers**: Adding logging to any command requires a single line: `cmds.WithLayersList(loggingLayer)`. All commands share the same interface, validation, and behavior patterns.`
- L889: `**Separation of Concerns**: The logging layer handles configuration independently from business logic, enabling isolated testing and reuse across different commands.`
- L893: `**Sensible Defaults**: The layer provides working defaults for common use cases while supporting advanced configurations for enterprise requirements.`
- L895: `**Convention Over Configuration**: Consistent patterns for parameter naming, struct tags, and validation provide familiar interfaces for Go developers.`
- L899: `The implemented layer includes production-ready capabilities:`
- L909: `Layer composition enables modular architecture patterns for complex applications:`
- L913: `‚îÇ   API Layer     ‚îÇ  ‚îÇ Database Layer  ‚îÇ  ‚îÇ Logging Layer   ‚îÇ`
- L925: `                    ‚îÇ   parameters      ‚îÇ`
- L929: `Each layer handles a specific concern. Commands compose required layers to build applications that scale from simple scripts to complex enterprise systems.`
- L933: `### Layer Library Development`
- L935: `Common layer implementations for production applications:`
- L937: `**Database Layer**: Connection pooling, transaction management, migration flags`
- L938: `**HTTP Client Layer**: Authentication, retries, circuit breakers, rate limiting  `
- L939: `**File Processing Layer**: Input/output directories, file patterns, validation`
- L940: `**Cache Layer**: Redis configuration, TTL settings, eviction policies`
- L948: `baseLayer := NewBaseLayer(`
- L954: `apiLayer := NewAPILayer(`
- L962: `Enterprise layer implementations must address:`
- L966: `- **Validation relationships**: Cross-parameter validation and dependency checking`
- L967: `- **Backward compatibility**: Evolution strategies for layer APIs`
- L969: `## Layer Patterns That Work in Production`
- L971: `### Database Layer`
- L985: `### HTTP Client Layer`
- L998: `### File Processing Layer`
- L1014: `This tutorial demonstrates implementing reusable parameter layers for CLI applications. The key principle is **configuration through composition**.`
- L1016: `Rather than defining flags individually per command, standardized layers encapsulate interface and behavior patterns. This approach creates application consistency, reduces maintenance overhead, and provides predictable user interfaces.`
- L1018: `The layer pattern enables scalable CLI architecture that grows from simple commands to comprehensive enterprise applications.`

### `pkg/doc/tutorials/migrating-from-viper-to-config-files.md`
- L21: `The new system replaces Viper's automatic config discovery and merging with explicit file loading middlewares that record each parse step. This makes it clear where each parameter value originated and enables better debugging with `--print-parsed-parameters`.`
- L27: `1. **Config File Loading**: Replace `GatherFlagsFromViper()` and `GatherFlagsFromCustomViper()` with `LoadParametersFromFile()` or `LoadParametersFromFiles()``
- L28: `2. **Logging Initialization**: Move from `InitLoggerFromViper()` to `InitLoggerFromCobra()` or `SetupLoggingFromParsedLayers()``
- L59: `### 2. Config File Format Must Match Layer Structure`
- L69: `**After:** Config must match layer names and parameters:`
- L71: `# Layer names as top-level keys`
- L82: `- Group parameters under layer names`
- L83: `- Update parameter names to match definitions`
- L87: `mapper, _ := patternmapper.NewConfigMapper(layers,`
- L90: `        TargetLayer:     "demo",`
- L91: `        TargetParameter: "api-key",`
- L101: `    // Transform your config to layer format`
- L121: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L141: `### After: Using LoadParametersFromFile`
- L146: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L171: `For applications with a single config file, use `LoadParametersFromFile`:`
- L181: `The config file must match the default structure (layer names as top-level keys):`
- L191: `For applications that compose configuration from multiple files, use `LoadParametersFromFiles`:`
- L243: `### After: Using LoadParametersFromFiles`
- L248: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L306: `    // Add logging layer`
- L307: `    err := logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L340: `    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L353: `### Alternative: Initialize from Parsed Layers`
- L355: `If you're using Glazed's middleware system and want logging to respect config file values, initialize from parsed layers instead:`
- L360: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L364: `    // ... setup layers and parse ...`
- L366: `    err := sources.Execute(layers_, parsed,`
- L375: `    // Initialize logging from parsed layers (includes config file values)`
- L376: `    err = logging.SetupLoggingFromParsedLayers(parsed)`
- L420: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L455: `- `--config-file` flag is automatically available via `command-settings` layer`
- L473: `If your config files don't match the default layer structure, you have two options: pattern-based mapping (declarative) or custom mapper functions (programmatic).`
- L485: `mapper, err := pm.NewConfigMapper(layers_,`
- L488: `        TargetLayer:     "demo",`
- L489: `        TargetParameter: "api-key",`
- L493: `        TargetLayer:     "demo",`
- L494: `        TargetParameter: "{env}-api-key",`
- L498: `// Use with LoadParametersFromFile`
- L521: `    // Transform config structure to layer format`
- L551: `sources.Execute(layers_, parsed,`
- L602: `   logging.SetupLoggingFromParsedLayers(parsed)`
- L658: `Environment variable names follow the pattern: `{PREFIX}_{LAYER}_{PARAMETER}` (e.g., `APP_DEMO_API_KEY` for `demo.api-key`).`
- L693: `Use `--print-parsed-parameters` to see exactly where each parameter value came from:`
- L696: `myapp command --print-parsed-parameters`
- L699: `This shows the full parse history for each parameter, including which config file set each value.`
- L703: `Before applying config files, validate them against your layer definitions:`
- L711: `func validateConfigFile(layers_ *schema.Schema, path string) error {`
- L722: `    // Check each layer and parameter`
- L723: `    for layerSlug, v := range raw {`
- L724: `        layer, ok := layers_.Get(layerSlug)`
- L726: `            return fmt.Errorf("unknown layer: %s", layerSlug)`
- L731: `            return fmt.Errorf("layer %s must be an object", layerSlug)`
- L734: `        pds := layer.GetParameterDefinitions()`
- L738: `                return fmt.Errorf("unknown parameter %s.%s", layerSlug, key)`
- L742: `                return fmt.Errorf("invalid value for %s.%s: %v", layerSlug, key, err)`
- L764: `2. Variable names follow `{PREFIX}_{LAYER}_{PARAMETER}` format`
- L771: `2. Check config file order in `LoadParametersFromFiles` (low ‚Üí high)`
- L772: `3. Use `--print-parsed-parameters` to see actual precedence`
- L776: `If you have legacy config files that don't match the layer structure:`
- L807: `    err := logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L853: `    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L889: `2. **Use `--print-parsed-parameters`**: Confirm precedence is as expected`

### `pkg/doc/tutorials/migrating-to-facade-packages.md`
- L4: `Short: Step-by-step guide to migrate Glazed code from layers/parameters/middlewares vocabulary to the new facade packages (schema/fields/values/sources)`
- L27: `- `schema` ‚Äî schema sections (previously ‚Äúlayers‚Äù)`
- L28: `- `fields` ‚Äî field definitions and field types (previously ‚Äúparameters‚Äù)`
- L29: `- `values` ‚Äî resolved values + decoding helpers (previously ‚Äúparsed layers‚Äù)`
- L42: `- `pkg/cmds/layers.ParameterLayer` ‚Üí `pkg/cmds/schema.Section``
- L43: `- `pkg/cmds/layers.ParameterLayers` ‚Üí `pkg/cmds/schema.Schema``
- L44: `- `pkg/cmds/parameters.ParameterDefinition` ‚Üí `pkg/cmds/fields.Definition``
- L45: `- `pkg/cmds/parameters.ParameterDefinitions` ‚Üí `pkg/cmds/fields.Definitions``
- L46: `- `pkg/cmds/parameters.ParameterType*` ‚Üí `pkg/cmds/fields.Type*``
- L50: `- `pkg/cmds/layers.ParsedLayers` ‚Üí `pkg/cmds/values.Values``
- L51: `- `pkg/cmds/layers.ParsedLayer` ‚Üí `pkg/cmds/values.SectionValues``
- L52: `- `layers.NewParsedLayers()` ‚Üí `values.New()``
- L53: `- `layers.NewParsedLayer(section, ...)` ‚Üí `values.NewSectionValues(section, ...)``
- L54: `- `layers.WithParsedParameters(...)` ‚Üí `values.WithParameters(...)``
- L55: `- `layers.WithParsedParameterValue(...)` ‚Üí `values.WithParameterValue(...)``
- L56: `- `parsedLayers.InitializeStruct(slug, &dst)` ‚Üí `values.DecodeSectionInto(parsedLayers, slug, &dst)``
- L64: `- `middlewares.LoadParametersFromFile(s)` ‚Üí `sources.FromFile` / `sources.FromFiles``
- L67: `- `parameters.WithParseStepSource(...)` ‚Üí `sources.WithSource(...)``
- L79: `‚Ä¶and it still satisfies interfaces that mention `*layers.ParsedLayers`, because `values.Values` is an alias for `layers.ParsedLayers`.`
- L88: `- `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`).`
- L89: `- `layers.ParameterLayer` interface methods now use `*fields.Definition` / `*fields.Definitions`:`
- L91: `  - `GetParameterDefinitions() *fields.Definitions``
- L94: `  - `cli.CobraRunFunc`, `cli.CobraParser.Parse`, `cli.ParseCommandSettingsLayer``
- L99: `- `values` additions: `NewSectionValues`, `SectionValuesOption`, `WithParameters`, `WithParameterValue`.`
- L107: `- `github.com/go-go-golems/glazed/pkg/cmds/layers``
- L108: `- `github.com/go-go-golems/glazed/pkg/cmds/parameters``
- L118: `You can keep old imports for advanced/legacy types (for example `parameters.FileData`) until you‚Äôre ready to refactor them.`
- L120: `### Step 2: Replace parameter definitions`
- L125: `parameters.NewParameterDefinition("limit", parameters.ParameterTypeInteger, parameters.WithDefault(10))`
- L136: `If you currently build explicit layers:`
- L141: `demoLayer, _ := layers.NewParameterLayer("demo", "Demo",`
- L142: `    layers.WithPrefix("demo-"),`
- L143: `    layers.WithParameterDefinitions(`
- L144: `        parameters.NewParameterDefinition("api-key", parameters.ParameterTypeString),`
- L165: `func (c *MyCmd) Run(ctx context.Context, parsedLayers *layers.ParsedLayers) error {`
- L173: `func (c *MyCmd) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L184: `_ = parsedLayers.InitializeStruct(layers.DefaultSlug, settings)`
- L210: `## Glazed ‚Äúoutput flags‚Äù layer: what to do now`
- L212: `- If your command implements `cmds.GlazeCommand`, `cli.BuildCobraCommand(...)` will ensure the glazed output layer exists, so you usually don‚Äôt need to add it manually.`
- L213: `- If you do want to add it explicitly (e.g. when building a schema yourself), prefer `settings.NewGlazedSchema()` (wrapper around `settings.NewGlazedParameterLayers()`).`
- L221: `- Cobra-only plumbing: attaching layers to Cobra uses `layers.CobraParameterLayer`.`
- L222: `- Some helper types/functions still live in `parameters` (e.g. `parameters.FileData`, `parameters.RenderValue`).`

### `pkg/help/store/README.md`
- L23: `- **Compat**: Compatibility layer for existing help system interface`
- L197: `## Compatibility Layer`
- L241: `The predicate system is more powerful than the existing `SectionQuery`, but the compatibility layer ensures existing code continues to work.`

### `prompto/glazed/command-description.md`
- L8: `- **Layers** (contains parameter definitions, i.e. your command‚Äôs flags/arguments)`
- L48: `Your command‚Äôs parameters (both flags and positional arguments) are grouped in a default ‚Äúlayer.‚Äù You typically add them via the convenience functions:`
- L53: `### 3.1 Defining Parameter Definitions`
- L55: `Parameters themselves are described by `fields.Definition` from the `glazed/pkg/cmds/parameters` package. For example:`
- L67: `**Common parameter definition functions**:`
- L69: `- `fields.New(name string, paramType ParameterType, opts ...ParameterDefinitionOption)``
- L77: `Flags are typically optional or named parameters. You call `WithFlags(...)` with one or more `ParameterDefinition`s:`
- L101: `Positional arguments (like `my-command [ARGS ...]`) are also stored as parameters but with `IsArgument = true`. You can use `WithArguments(...)`:`
- L134: `4. **`WithFlags(flags ...*ParameterDefinition)`**  `
- L135: `   Adds parameter definitions as **flags** to the default layer.`
- L137: `5. **`WithArguments(arguments ...*ParameterDefinition)`**  `
- L138: `   Adds parameter definitions as **positional arguments** to the default layer.`
- L140: `6. **`WithLayers(ls *schema.Schema)`** or **`WithLayersList(ls ...ParameterLayer)`**  `
- L141: `   Used if you already have a custom `ParameterLayers` object or multiple parameter layers. Typically more advanced usage.`
- L143: `7. **`WithReplaceLayers(layers_ ...ParameterLayer)`**  `
- L144: `   Replaces any existing layers with the ones you provide.`
- L164: `## 5. Inspecting Parameters at Runtime`
- L166: `Once your `CommandDescription` is built, you can retrieve parameter definitions in code:`
- L168: `- **`GetDefaultFlags()`**: Returns a `ParameterDefinitions` object of all flags in the default layer.  `
- L169: `- **`GetDefaultArguments()`**: Returns all arguments (where `IsArgument = true`) from the default layer.  `
- L170: `- **`Layers`**: The entire `ParameterLayers` object if you need advanced usage.`
- L183: `    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L239: `5. **Optionally** set the source string or manipulate the advanced parameter layering.  `

### `prompto/glazed/create-application-tutorial.md`
- L10: `### 1.1 Layer Design`
- L13: `   - Each layer should handle one aspect of configuration (e.g., authentication, database, output formatting)`
- L14: `   - Keep parameter definitions focused and cohesive`
- L15: `   - Avoid mixing unrelated parameters in the same layer`
- L18: `   - Use descriptive slugs that indicate the layer's purpose (e.g., "auth", "db", "output")`
- L19: `   - Follow consistent naming patterns across layers`
- L20: `   - Document the purpose of each layer`
- L22: `3. **Parameter Organization**`
- L23: `   - Group related parameters together`
- L24: `   - Use clear, descriptive parameter names`
- L29: `   - Design layers to be reusable across commands`
- L30: `   - Extract common parameters into shared layers`
- L31: `   - Use composition to combine layers`
- L54: `   - Use whitelisting to control layer access`
- L120: `      layers/            # Custom parameter layers`
- L121: `        auth.go         # Authentication layer`
- L122: `        db.go          # Database layer`
- L123: `        output.go      # Output formatting layer`
- L125: `        parse.go       # Parameter parsing`
- L134: `1. **Layer Definition**`
- L136: `   // Define focused, single-purpose layers`
- L141: `   func NewAuthLayer() (schema.Section, error) {`
- L145: `           // ... focused parameter definitions`
- L299: `    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L303: `    "myapp/pkg/layers"`
- L311: `    layers.AppSettings`
- L321: `        cli.WithCobraShortHelpLayers(layers.AppSlug),`
- L332: `    // 1. Create glazed parameter layer`
- L333: `    glazedParameterLayer, err := settings.NewGlazedParameterLayers()`
- L335: `        return nil, fmt.Errorf("could not create Glazed parameter layer: %w", err)`
- L338: `    // 2. Create app layer`
- L339: `    appLayer, err := layers.NewAppParameterLayer()`
- L341: `        return nil, fmt.Errorf("could not create App parameter layer: %w", err)`
- L344: `    // 3. Combine layers`
- L345: `    layers_ := schema.NewSchema(layers.WithLayers(`
- L346: `        glazedParameterLayer,`
- L347: `        appLayer,`
- L356: `            cmds.WithLayers(layers_),`
- L363: `    parsedLayers *values.Values,`
- L368: `    if err := parsedLayers.InitializeStruct(layers.AppSlug, &s.AppSettings); err != nil {`

### `prompto/glazed/create-yaml-command.md`
- L38: `   Parameters can be defined either as flags (with -- prefix) or positional arguments. Both use the same parameter definition structure, just with different usage patterns. Each entry describes one parameter with fields such as:`
- L39: `   - `name` (required): The parameter name.`
- L40: `   - `type` (required): The parameter type.`
- L43: `   - `required` (optional, boolean): Indicates if this parameter must be supplied.`
- L51: `   - For single numeric parameters, `type` can be `int` or `float`.  `
- L52: `   - For textual parameters, `type` can be `string`.  `
- L54: `   - Arguments are positional parameters that don't use -- prefix`
- L83: `- **flags** includes three parameters:`
- L95: `- name: <parameter-name>`
- L96: `  type: <parameter-type>`
- L106: `  Unique parameter name (e.g. `limit`, `from`, `status`), used at the command line as `--limit=...` or similar.`
- L109: `  Indicates how this parameter is interpreted. Common types:`
- L124: `  14. (Less common) **stringFromFile**, **objectFromFile**, **stringListFromFile**, **objectListFromFile**: Indicate the parameter is read from a file or multiple files. Typically used in advanced scenarios.`
- L272: `- Both flags and arguments use the same parameter definition structure`
- L324: `   - `name`: parameter/flag name`
- L325: `   - `type`: see typical parameter types (e.g., `string`, `int`, `bool`, `date`, etc.)`
- L331: `Use this structure whenever you define a new YAML command file. The system that loads it will parse these fields and make your parameters available under the indicated names.`
- L345: `2. **Flags (Parameters)**  `
- L346: `   - Under `flags:`, each item (e.g. `- name: name`, `type: stringList`, etc.) is turned into a `ParameterDefinition`.`
- L357: `   - The system aggregates these into a "default layer" of parameters.  `
- L358: `   - `required: false`, `default: ...`, and `help: ...` become `WithRequired(false)`, `WithDefault(...)`, `WithHelp(...)` in the `ParameterDefinition` construction.`
- L360: `Hence, the **top-level YAML keys**‚Äî`name`, `metadata`, `short`, `long`, and `flags`‚Äî**map to** the **fields and parameter layers** in a `CommandDescription` object. The `query:` would likewise be used by a specialized command that actually runs a SQL query, but the fundamental principle of turning flags into typed parameters remains the same.`

### `prompto/glazed/main.md`
- L161: `### Custom Help Layers`
- L168: `// Implement your custom help layer`

### `ttmp/2025-07-12/DOCUMENTATION_STYLE_GUIDE.md`
- L70: `2. API signatures and parameters`
- L129: `## Parameter Layers`
- L131: `Parameter layers organize related command parameters into reusable groups. This approach addresses several common CLI development challenges:`
- L133: `- **Parameter organization**: Group related flags logically (database, logging, output)`
- L134: `- **Code reuse**: Share parameter definitions across multiple commands  `
- L140: `Parameter layers work by collecting parameter definitions at design time and resolving values from multiple sources at runtime.`
- L146: `The basic pattern involves defining parameter layers and composing them into commands:`
- L149: `// Define a reusable layer`
- L150: `databaseLayer := schema.NewSection("database", "Database connection parameters",`
- L159: `    cmds.WithLayersList(databaseLayer, loggingLayer),`
- L165: `Commands extract typed values from parsed layers:`
- L168: `func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L170: `    if err := parsedLayers.InitializeStruct("database", settings); err != nil {`
- L179: `This pattern provides type safety and automatic validation while maintaining clean separation between parameter definition and business logic.`

### `ttmp/2025-07-29/01-review-commands-reference-document.md`
- L7: `The primary goal of this review is to suggest changes that would sharpen its focus as a reference document, making it easier for developers to quickly look up interfaces, parameter types, and core patterns. More verbose, step-by-step examples can be split into separate, dedicated tutorial documents.`
- L47: `  func (c *CleanupCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L49: `      if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L73: `- **Parameters section**: The entire section (Type System, Definition Options, Arguments) is pure reference material and is excellent.`
- L95: `    - Working with Multiple Layers`
- L98: `6.  **Parameters**`
- L99: `    - Parameter Type System (Basic, Collection, Choice, File, Special)`
- L100: `    - Parameter Definition Options`

### `ttmp/2025-07-29/02-plan-for-cleaning-up-the-dual-command-creation-api.md`
- L14: `    ShortHelpLayers               []string`
- L15: `    SkipCommandSettingsLayer      bool`
- L16: `    EnableProfileSettingsLayer    bool`
- L17: `    EnableCreateCommandSettingsLayer bool`
- L60: `    // 1. Parse layers`
- L61: `    layers, err := parser.Parse(cmd, cmd.Flags().Args())`
- L75: `3.1 **Change** `NewCobraParserFromLayers` to:`
- L77: `func NewCobraParserFromLayers(`
- L78: `    layers *schema.Schema,`
- L100: `3. Call `NewCobraParserFromLayers(description.Layers, &cfg.ParserCfg)`.`
- L108: `- Debug flags: `--print-yaml`, `--print-schema`, `--print-parsed-parameters`.`

### `ttmp/2025-07-29/02-review-10-template-command.md`
- L18: `-   [ ] **Section Introductions**: **Missing** for "Parameter Types" and "Integration with Command Loaders".`
- L28: `-   **For `## Parameter Types`:**`
- L29: `    > **Suggested Addition:** Template commands can leverage the full range of Glazed parameter types, allowing for rich and validated inputs. This means you can create templates that accept everything from simple strings and booleans to lists, choices, and even content from files.`
- L36: `The example under `## Loading and Running Template Commands` is too long and detailed for a reference document. It shows the low-level mechanics of creating a `ParsedLayer`, which, while technically correct, is more appropriate for a dedicated tutorial on programmatic command execution.`
- L46: `	// Get default parameter layer`
- L47: `	defaultLayer, ok := cmd.Description().Layers.Get(schema.DefaultSlug)`
- L49: `		panic("default layer not found")`
- L52: `	// Create parsed layer with parameter values`
- L55: `		// ... (manual creation of ParsedLayerOption) ...`
- L58: `	parsedLayer, err := layers.NewParsedLayer(defaultLayer, options...)`
- L59: `	// ... (manual creation of ParsedLayers) ...`
- L63: `	err = cmd.RunIntoWriter(context.Background(), parsedLayers, &output)`
- L108: `		// Provide parameter values for the "default" layer`
- L127: `-   Removes the complex, low-level details of manually constructing `ParsedLayer` objects.`

### `ttmp/2025-07-29/03-oracle-review-of-the-create-command-tutorial.md`
- L9: `   * Technical Completeness: Covers essential features including layers, middleware, help system, and`
- L20: `      * Change parameter definition from "name-filter" to "filter" in code, OR`
- L31: `   * Technical Completeness: Covers essential features including layers, middleware, help system, and`
- L42: `      * Change parameter definition from "name-filter" to "filter" in code, OR`

### `ttmp/2025-07-29/04-review-of-the-dual-command-cobra-parser-options-refactor.md`
- L24: `The current implementation has **double translation layers**:`
- L26: `- `NewCobraParserFromLayersWithOptions`: `CobraOption` ‚Üí `CobraParserConfig``
- L58: `1. `AddToCobraCommand` unconditionally writes `cmd.Annotations["shortHelpLayers"] = value``
- L60: `3. The refactor introduced a universal factory (`NewCobraCommandFromCommandDescription`) that started writing annotations for `shortHelpLayers``
- L83: `3. **Unclear documentation**: Flag hiding behavior when glazed layer is injected vs. user-defined isn't documented`
- L93: `1. Add `description *cmds.CommandDescription` parameter to `handleCommandSettingsDebug``
- L120: `- [x] 2.1 `NewCobraParserFromLayers` signature change`

### `ttmp/2025-08-05/02-signal-cancellation-test-results.md`
- L129: `### Network Layer Analysis`
- L131: `The issue appears **consistent across all network abstraction layers**:`
- L146: `‚úÖ **CONFIRMED:** The issue affects **all network layers** in Go's networking stack`

### `ttmp/2025-10-29/01-how-to-remove-viper-from-glazed-applications.md`
- L47: `    err := logging.AddLoggingLayerToRootCommand(rootCmd, appName)`
- L126: `### 1.2 Where Viper populates Glazed parameters`
- L128: `- The middleware `GatherFlagsFromViper` bridges Viper into Glazed‚Äôs `ParsedLayers` by reading parameter definitions per layer (respecting each layer‚Äôs flag prefix) and updating parsed values from Viper‚Äôs keyspace.`
- L131: `// GatherFlagsFromViper creates a middleware that loads parameter values from Viper configuration.`
- L134: `// It iterates through each layer, gathering flags from Viper for all parameters in that layer.`
- L139: `func GatherFlagsFromViper(options ...parameters.ParseStepOption) Middleware {`
- L141: `        return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L143: `            err := next(layers_, parsedLayers)`
- L147: `            err = layers_.ForEachE(func(key string, l schema.Section) error {`
- L148: `                options_ := append([]parameters.ParseStepOption{`
- L151: `                        "layer":          l.GetName(),`
- L152: `                        "layer_slug":     l.GetSlug(),`
- L153: `                        "layer_prefix":   l.GetPrefix(),`
- L158: `                parsedLayer := parsedLayers.GetOrCreate(l)`
- L159: `                parameterDefinitions := l.GetParameterDefinitions()`
- L162: `                ps, err := parameterDefinitions.GatherFlagsFromViper(true, prefix, options_...)`
- L167: `                _, err = parsedLayer.Parameters.Merge(ps)`
- L185: `- The underlying parameter-level Viper reader encodes the de-facto env/flag mapping semantics: key = `layerPrefix + flag-name`, and an env key shape comment is added to parsed metadata using uppercased, hyphen‚Üíunderscore conversion.`
- L187: ````9:29:glazed/pkg/cmds/parameters/viper.go`
- L188: `func (pds *ParameterDefinitions) GatherFlagsFromViper(`
- L192: `) (*ParsedParameters, error) {`
- L193: `    ret := NewParsedParameters()`
- L198: `        parsed := &ParsedParameter{`
- L199: `            ParameterDefinition: p,`
- L208: ````40:49:glazed/pkg/cmds/parameters/viper.go`
- L225: `    parsedCommandLayers *values.Values,`
- L230: `    err := parsedCommandLayers.InitializeStruct(CommandSettingsSlug, commandSettings)`
- L244: `    if commandSettings.LoadParametersFromFile != "" {`
- L246: `            cmd_sources.FromFile(commandSettings.LoadParametersFromFile))`
- L258: `// ParseGlazedCommandLayer parses the global glazed settings from the given cobra.Command, if not nil,`
- L260: `func ParseCommandSettingsLayer(cmd *cobra.Command) (*values.Values, error) {`
- L261: `    parsedLayers := values.New()`
- L262: `    commandSettingsLayer, err := NewCommandSettingsLayer()`
- L267: `    profileSettingsLayer, err := NewProfileSettingsLayer()`
- L272: `    createCommandSettingsLayer, err := NewCreateCommandSettingsLayer()`
- L277: `    commandSettingsLayers := schema.NewSchema(`
- L278: `        layers.WithLayers(`
- L279: `            commandSettingsLayer,`
- L280: `            profileSettingsLayer,`
- L281: `            createCommandSettingsLayer,`
- L294: `    err = cmd_sources.Execute(commandSettingsLayers, parsedLayers, middlewares_...)`
- L299: `    return parsedLayers, nil`
- L328: `Note: there is also `SetupLoggingFromParsedLayers(parsedLayers)` that can initialize logging directly from Glazed parsed parameters (no Viper), which we can reuse in the new design.`
- L332: `There is an `UpdateFromEnv(prefix)` middleware today, but its env key derivation differs from the Viper semantics and also updates parsed parameters using the env key as the parameter name:`
- L342: `    err := parsedLayer.Parameters.UpdateValue(name, p, v, options...)`
- L349: `Viper‚Äôs env semantics are: `ENV_PREFIX + '_' + UPPERCASE(REPLACE_ALL(layerPrefix + paramName, '-', '_'))`, and parsed parameter keys remain the logical parameter names (without env prefix) inside their layer. We will align `UpdateFromEnv` to that.`
- L355: `- Remove Viper from parameter parsing. Use Glazed middlewares only: `LoadParametersFromFile`, `UpdateFromEnv`, `ParseFromCobraCommand`, `SetFromDefaults`.`
- L357: `  - `ENV_PREFIX + '_' + UPPER(REPLACE_ALL(layerPrefix + paramName, '-', '_'))``
- L358: `  - Example: app `pinocchio`, layer prefix `openai-`, param `api-key` ‚Üí `PINOcCHIO_OPENAI_API_KEY` (actually `PINOCCHIO_OPENAI_API_KEY`).`
- L359: `- Replace `--load-parameters-from-file` with automatic config discovery and loading via middleware.`
- L360: `- Keep logging working without Viper by using `SetupLoggingFromParsedLayers`.`
- L367: `2) `LoadParametersFromFile(resolvedConfigPath, sources.WithSource("config"))``
- L373: `### 2.3 Config discovery (replaces `--load-parameters-from-file` and Viper config search)`
- L386: `Update `UpdateFromEnv` to compute env keys exactly like the Viper path used today, while storing parsed values under the parameter‚Äôs logical name:`
- L390: `// For each layer and ParameterDefinition p:`
- L397: `    // IMPORTANT: store under the logical parameter key (p.Name),`
- L399: `    err := parsedLayer.Parameters.UpdateValue(p.Name, p, v,`
- L409: `This fixes two issues in the current middleware: it replaces hyphens by underscores and uses the layer prefix, and it no longer writes values under the env key name.`
- L416: `  - `ParseCommandSettingsLayer`: drop `GatherFlagsFromViper(...)`. Optionally add `UpdateFromEnv("GLAZED", ...)` so command-settings can be influenced by env if desired, and then apply defaults. If we keep a minimal `--load-parameters-from-file` for this internal layer during transition, parse it via flags (already handled by `ParseFromCobraCommand`).`
- L425: `    ShortHelpLayers []string`
- L454: `except we replace `GatherFlagsFromViper()` with `LoadParametersFromFile()` and rely on the same env mapping in `UpdateFromEnv`.`
- L458: `- Prefer `logging.SetupLoggingFromParsedLayers(parsedLayers)` during command execution (already available):`
- L459: `  - Apps can call this early in `Run(E)` or in a small bootstrap that parses only the logging layer via the new middleware chain (config + env + defaults) before running subcommands.`
- L460: `- Keep `InitLoggerFromViper` for backward compatibility for one release cycle, but update docs and examples to encourage the parsed-layers path.`
- L467: `  - `logging.AddLoggingLayerToRootCommand(rootCmd, "pinocchio")``
- L471: `    - run a tiny parse over only the logging layer using the new middlewares and call `SetupLoggingFromParsedLayers`.`
- L475: `- a small `ParameterLayer` dedicated to those settings and reading them from parsed layers, or`
- L476: `- a one-time config YAML read via `LoadParametersFromFile` into a temporary `ParsedLayers` and extracting the value, to avoid reintroducing Viper.`
- L484: `    - Fix env key derivation (prefix + layer prefix + name, hyphen‚Üíunderscore, uppercase) and store under `p.Name`.`
- L487: `    - Remove `GatherFlagsFromViper` from `ParseCommandSettingsLayer`.`
- L488: `    - Extend `CobraCommandDefaultMiddlewares` to include `LoadParametersFromFile` and `UpdateFromEnv` using a new config resolver and app env prefix from `CobraParserConfig`.`
- L493: `    - Keep as-is; update examples to prefer `SetupLoggingFromParsedLayers`.`
- L494: `  - `pkg/cmds/parameters/viper.go` and `pkg/cmds/middlewares/cobra.go``
- L500: `      - Adds logging layer`
- L505: `    - Replace `middlewares.GatherFlagsFromViper(...)` with `sources.FromFile(‚Ä¶)` plus `sources.FromEnv(‚Ä¶)` restricted to the whitelisted layers via `WrapWithWhitelistedLayers`.`
- L511: `    - Replace examples that use `GatherFlagsFromViper()` with `LoadParametersFromFile()` + `UpdateFromEnv()`.`
- L512: `    - Document env naming rules and show that layer prefixes participate in env key names.`
- L514: `    - Remove Viper-specific instructions (`viper.BindPFlags`, `InitLoggerFromViper`); recommend `SetupLoggingFromParsedLayers`.`
- L515: `  - `pkg/doc/topics/13-layers-and-parsed-layers.md``
- L530: `  - If reading app settings directly from Viper, move them to a dedicated layer or one-off `LoadParametersFromFile` read.`
- L544: `- Viper-backed parameter ingestion`
- L550: ````9:29:glazed/pkg/cmds/parameters/viper.go`
- L551: `// See above: GatherFlagsFromViper (per-parameter)`
- L557: `// See above: ParseCommandSettingsLayer using GatherFlagsFromViper`
- L560: `- Logging from Viper vs parsed layers`

### `ttmp/2025-10-29/02-multi-config-overlays-design.md`
- L16: `  - LoadParametersFromFiles(filesLowToHigh)`
- L30: `func LoadParametersFromFiles(files []string, options ...parameters.ParseStepOption) Middleware`
- L69: `Each entry that exists is added to a list; the final list is passed to `LoadParametersFromFiles`.`
- L74: `func LoadParametersFromFiles(files []string, options ...parameters.ParseStepOption) Middleware {`
- L76: `        return func(layers_ *schema.Schema, pl *values.Values) error {`
- L77: `            if err := next(layers_, pl); err != nil { return err }`
- L79: `                m, err := readConfigFileToLayerMap(f) // map[string]map[string]interface{}`
- L88: `                if err := updateFromMap(layers_, pl, m, opts...); err != nil { return err }`
- L97: `- `readConfigFileToLayerMap` reuses YAML/JSON logic from current single-file middleware`
- L98: `- Separate `index` and `config_file` metadata allow inspection via `--print-parsed-parameters``
- L119: `The final concatenated list is passed to `LoadParametersFromFiles` and becomes a chain of parse steps.`
- L126: `2. Append `LoadParametersFromFiles(filesLowToHigh)` into the default chain right above defaults and below env/args/flags`
- L131: ``--print-parsed-parameters` would show for a given parameter:`
- L163: `- Per-layer filtering can wrap `LoadParametersFromFiles` using `WrapWithWhitelistedLayers``
- L168: `- Introduce `--config-files` for ordered lists; deprecate legacy `--load-parameters-from-file``

### `ttmp/2025-10-29/03-generic-config-mapping-design.md`
- L5: `The current `ConfigFileMapper` requires users to write custom Go functions to transform config file structures into layer maps. This is flexible but verbose and requires code changes for each new config format. We need a declarative, pattern-based system that allows users to specify mappings using string patterns, globs, and captured matches.`
- L17: `- If a wildcard matches multiple keys with identical values and maps to a single parameter, mapping succeeds.`
- L37: `    {Source: "api_key", TargetParameter: "api-key"},`
- L38: `    {Source: "threshold", TargetParameter: "threshold"},`
- L39: `    {Source: "timeout", TargetParameter: "timeout"},`
- L59: `- **Target layer**: Which layer to place the value in`
- L60: `- **Target parameter**: Which parameter name to use`
- L69: `    // Target layer slug (e.g., "demo")`
- L72: `    TargetLayer string`
- L74: `    // Target parameter name (supports captures like "{env}-api-key" or "{0}-api-key")`
- L76: `    TargetParameter string`
- L78: `    // Optional: function to dynamically compute target layer and parameter`
- L79: `    // Takes captured values (named and positional) and returns target layer and parameter name`
- L80: `    // If provided, overrides TargetLayer and TargetParameter`
- L81: `    TransformFunc func(captures map[string]string, positional []string, value interface{}) (targetLayer string, targetParameter string)`
- L107: `### Target Parameter Syntax`
- L114: `- **Lambda function**: `TransformFunc` ‚Üí programmatically compute target layer and parameter from captures (programmatic API only)`
- L132: `    // Lambda transformation: dynamically compute layer and parameter`
- L134: `        // Custom logic to determine layer and parameter based on captures`
- L137: `        layer := fmt.Sprintf("%s-%s", env, service)`
- L139: `        return layer, param`
- L144: `        {Source: "api_key", TargetParameter: "api-key"},`
- L145: `        {Source: "threshold", TargetParameter: "threshold"},`
- L146: `        {Source: "timeout", TargetParameter: "timeout", Default: 30},`
- L158: `        TargetLayer: "demo",`
- L159: `        TargetParameter: "api-key",`
- L164: `        TargetLayer: "demo",`
- L165: `        TargetParameter: "{env}-api-key",`
- L169: `        // Lambda transformation: dynamically compute layer and parameter`
- L174: `            // Custom logic: use environment as layer, service as part of parameter name`
- L175: `            layer := env`
- L177: `            return layer, param`
- L183: `        TargetLayer: "demo",`
- L185: `            {Source: "api_key", TargetParameter: "api-key"},`
- L186: `            {Source: "threshold", TargetParameter: "threshold"},`
- L200: `    target_layer: "demo"`
- L201: `    target_parameter: "api-key"`
- L205: `    target_layer: "demo"`
- L206: `    target_parameter: "{env}-api-key"`
- L210: `    target_layer: "demo"`
- L211: `    target_parameter: "{0}-api-key"  # {0} = first wildcard match`
- L215: `    target_layer: "demo"`
- L218: `        target_parameter: "api-key"`
- L220: `        target_parameter: "threshold"`
- L225: `    target_layer: "demo"`
- L228: `        target_parameter: "{env}-api-key"  # Can use parent captures`
- L230: `        target_parameter: "threshold"`
- L245: `   - Track captured values for use in target parameter`
- L274: `When target parameter contains `{env}`:`
- L288: `5. **Layer inheritance**: Child rules inherit `TargetLayer` from parent unless explicitly overridden`
- L296: `**Layer Inheritance**: Child rules inherit the `TargetLayer` from their parent rule, but can override it if needed:`
- L299: `  target_layer: "demo"      # Parent layer`
- L302: `      target_parameter: "api-key"  # Uses parent's "demo" layer`
- L304: `      target_layer: "database"      # Overrides to "database" layer`
- L305: `      target_parameter: "host"`
- L332: `  target_layer: "demo"`
- L335: `      target_parameter: "api-key"`
- L337: `      target_parameter: "threshold"`
- L353: `  target_layer: "demo"`
- L356: `      target_parameter: "{env}-api-key"  # Uses parent capture`
- L468: `Mapping with nested rules and layer override:`
- L472: `        {Source: "api_key", TargetParameter: "api-key"},`
- L473: `        {Source: "threshold", TargetParameter: "threshold"},`
- L474: `        {Source: "timeout", TargetParameter: "timeout", Default: 30},`
- L477: `        // Child rules inherit "demo" layer from parent`
- L478: `        {Source: "host", TargetParameter: "db-host"},`
- L479: `        // Override target layer for this specific rule`
- L480: `        {Source: "port", TargetLayer: "database", TargetParameter: "port"},`
- L488: `  target_layer: "demo"`
- L491: `      target_parameter: "api-key"`
- L493: `      target_parameter: "threshold"`
- L495: `      target_parameter: "timeout"`
- L499: `  target_layer: "demo"`
- L502: `      target_parameter: "db-host"  # Uses parent's "demo" layer`
- L504: `      target_layer: "database"      # Overrides to "database" layer`
- L505: `      target_parameter: "port"`
- L513: `- `database.port = 5432` (in different layer due to override)`
- L535: `        {Source: "api_key", TargetParameter: "{env}-api-key"}, // Uses parent capture`
- L536: `        {Source: "threshold", TargetParameter: "threshold"},`
- L565: `  target_layer: "demo"`
- L571: `      target_parameter: "{env}-api-key"  # {env} available from parent capture environment`
- L573: `      target_parameter: "threshold"`
- L622: `        {Source: "api_key", TargetParameter: "{region}-{env}-api-key"},`
- L623: `        {Source: "threshold", TargetParameter: "threshold"},`
- L642: `**Key Point**: All captures from the parent rule (`{region}`, `{env}`) are available in the capture environment for all child rules, allowing them to combine multiple captures in their target parameters.`
- L662: `        // Dynamic layer based on service name`
- L663: `        layer := fmt.Sprintf("%s-service", service)`
- L664: `        // Parameter name always "api-key"`
- L666: `        return layer, param`
- L670: `        // Use service name as layer`
- L671: `        layer := service`
- L672: `        // Parameter name includes service`
- L674: `        return layer, param`
- L691: `) (targetLayer string, targetParameter string)`
- L696: `- Conditional layer selection`
- L697: `- Dynamic parameter name generation`
- L720: `mapper, err := patternmapper.LoadMapperFromFile(layers, "mappings.yaml")`
- L735: `mapper, err := patternmapper.LoadMapperFromFile(layers, "mappings.yaml")`
- L743: `    TargetLayer: "demo",`
- L744: `    TargetParameter: "api-key",`
- L756: `        TargetLayer: "demo",`
- L757: `        TargetParameter: "threshold",`
- L769: `        TargetLayer: "demo",`
- L770: `        TargetParameter: "api-key",`
- L782: `        TargetLayer: "demo",`
- L783: `        TargetParameter: "api-key",`
- L798: `        TargetLayer: "demo",`
- L799: `        TargetParameter: "api-key",`
- L823: `**Note**: Type conversion and validation are handled by parameter definitions, not by the mapper. The mapper extracts values as-is from the config file, and parameter definitions handle type conversion and validation during parsing.`
- L875: `4. Add layer inheritance and override`
- L880: `1. Should we support array mapping? (e.g., `items[*].key` ‚Üí map to multiple parameters?)`
- L881: `2. Should we support multiple matches mapping to same parameter? (merge behavior?)`
- L882: `3. Should we support nested target layers? (e.g., `target.layer: "demo.nested"`?)`
- L886: `**Note**: Type conversion is handled by parameter definitions, not by mapping rules. The mapper extracts values as-is from the config file, and parameter definitions handle type conversion and validation.`
- L895: `- Support for `Source`, `TargetLayer`, `TargetParameter`, `Rules`, `Required`.`
- L902: `    layers *schema.Schema`
- L906: `func NewConfigMapperBuilder(layers *schema.Schema) *ConfigMapperBuilder`
- L909: `func (b *ConfigMapperBuilder) Map(source string, targetLayer string, targetParameter string, required ...bool) *ConfigMapperBuilder`
- L912: `func (b *ConfigMapperBuilder) MapObject(parentSource string, targetLayer string, childRules []patternmapper.MappingRule) *ConfigMapperBuilder`
- L919: `- `Build()` MUST call `NewConfigMapper(b.layers, b.rules...)` to reuse validation and semantics.`
- L926: `func Child(source, target string) patternmapper.MappingRule { return patternmapper.MappingRule{Source: source, TargetParameter: target} }`
- L931: `b := NewConfigMapperBuilder(paramLayers).`
- L934: `        {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L935: `        {Source: "threshold", TargetParameter: "threshold"},`
- L944: `- MapObject(): children inherit parent layer; one-level enforced.`
- L947: `  - Invalid static target parameter (prefix-aware) ‚Üí error.`

### `ttmp/2025-10-29/04-config-mapping-debate.md`
- L10: `- **LoadParametersFromFile** (middleware) - Current implementation`
- L11: `- **ParameterLayers** (schema.Schema) - The layer system itself`
- L29: `**ConfigFileMapper**: Excuse me? Sarah, I've been doing this job for years. I'm a SIMPLE function signature. One input, one output. You want to add complexity? Fine. But don't tell me that Builder Pattern is simpler. I know what I do: I take raw config, I return layer maps. That's it. This new design wants me to become a pattern-matching engine? That's not my job!`
- L35: `**LoadParametersFromFile**: Can I say something? I'm the one who actually loads these files. Currently, I accept a `ConfigFileMapper` function. That's it. Simple. This new design wants me to understand patterns, captures, nested rules... I'm just trying to read a file and update parameters! You're making my job harder. Why can't we keep it simple? Pass me a mapper function, I'll call it. Done.`
- L37: `**ParameterLayers**: As the layer system, I need to point out something important: layers are STRUCTURED. We have slugs, we have prefixes, we have parameter definitions. This pattern matching system assumes the config file structure matches your patterns. What if it doesn't? What if the config file has a typo? What if it's versioned differently? You're introducing a whole new class of runtime errors that I can't catch at layer definition time.`
- L43: `**ConfigFileMapper**: Sarah, you're not listening. I'm a FUNCTION TYPE. Functions are composable. You can pass me around. You can test me in isolation. This Builder Pattern thing? It's creating a whole new abstraction layer. I've been working fine with function composition. Why do we need to invent a new pattern matching language when you can just write a function?`
- L49: `**LoadParametersFromFile**: You know what, I'm going to be honest. I don't care about Builder Pattern or Rules Array. What I care about is: can I use it? The proposal says you can load mappings from YAML. Great! But what if I want to use a Builder Pattern in code AND load from YAML? Do I need two different systems? That's complexity. I just want ONE way to specify mappings.`
- L51: `**ParameterLayers**: As the layer system, I have a fundamental question: why are we mapping config files to layers at all? Layers are about organizing PARAMETER DEFINITIONS. Config files are about VALUES. This whole pattern matching system is trying to solve a problem that might not need solving. Maybe the real answer is: make config files match the layer structure. Simple. No mapping needed.`
- L69: `**LoadParametersFromFile**: Can I be honest? I don't understand captures at all. I load a file. I call a mapper. The mapper returns a map. That's it. Now you're telling me I need to understand pattern matching, captures, positional vs named... This is way too much complexity. Why can't the mapper just do its job?`
- L71: `**ParameterLayers**: As the layer system, I need to point out: parameters have NAMES. They're not positional. When you say `{0}-api-key`, what does that even mean? That's not a parameter name. Parameter names are strings. `"dev-api-key"` is a parameter name. `{0}-api-key` is... what? A template? That's a whole new concept.`
- L83: `**LoadParametersFromFile**: I'm going to say something controversial: maybe we don't need pattern matching at all. Maybe the mapper function approach is fine. If you need complex mapping, write a complex function. At least then it's testable, debuggable, and clear. This pattern matching system is trying to solve a problem that might not exist.`
- L85: `**ParameterLayers**: You know what, LoadParametersFromFile? I agree with you. I'm a layer system. I have parameter definitions. Those definitions have names. The mapping should be: config file path ‚Üí parameter name. That's it. Why do we need wildcards? Why do we need captures? Just map explicitly. If `app.dev.api_key` needs to map to `demo.dev-api-key`, write that mapping. Simple.`
- L91: `**Moderator**: The design proposes nested rules where parent rules can have child rules that inherit captures and layer targets. Is this feature necessary, or is it adding unnecessary complexity?`
- L99: `    {Source: "api_key", TargetParameter: "api-key"},`
- L100: `    {Source: "threshold", TargetParameter: "threshold"},`
- L114: `    {Source: "api_key", TargetParameter: "api-key"},`
- L120: `**LoadParametersFromFile**: I'm going to be honest: I don't understand nested rules at all. I load a file. I get a map. I call a mapper function. That function returns layer maps. Where do nested rules fit in? Do I need to traverse the config tree? Do I need to maintain state? This is getting way too complex for what should be a simple operation.`
- L122: `**ParameterLayers**: As the layer system, I have a concern: nested rules assume the config file structure matches your expectations. What if `app.settings` doesn't exist? What if it's `app.config`? What if the structure is completely different? Nested rules create a tight coupling between the mapping definition and the config file structure. That's fragile.`
- L128: `**ConfigFileMapper**: You know what, I'm going to side with Marcus here. Nested rules are complex. What if a child rule wants to override the parent's target layer? What if captures conflict? What if you have nested nested rules? This is a rabbit hole. Keep it flat. Keep it simple. Write the mapping logic explicitly.`
- L132: `**Dr. Aisha Patel**: Actually, I think nested rules solve a real problem: capture inheritance. If you have `app.{env}.settings.api_key`, you want the `{env}` capture to be available in child rules. That's powerful. But I agree with the concern: it's complex. Maybe we need a simpler version first: nested rules WITHOUT capture inheritance, just layer inheritance. Then add capture inheritance later if needed.`
- L134: `**LoadParametersFromFile**: Dr. Patel, I think you're onto something. But here's my question: why do we need nested rules at all? If you have `app.settings.api_key`, just write a flat rule. If you have `app.{env}.settings.api_key`, write a flat rule with a capture. Nested rules are solving a problem that flat rules already solve. That's unnecessary complexity.`
- L136: `**ParameterLayers**: I'm going to agree with LoadParametersFromFile. Layers are flat. Parameters are flat. Why are we introducing nesting? The config file might be nested, but that's just structure. The mapping should flatten it. Nested rules are trying to preserve the nesting in the mapping definition, but we don't need that. We need flat parameter names in flat layers.`
- L142: `**Moderator**: The design allows `TransformFunc` for dynamic layer/parameter computation, but only in the programmatic API, not in YAML config. Is this the right boundary?`
- L154: `**LoadParametersFromFile**: I'm confused. What does TransformFunc even do? Does it transform the VALUE, or does it transform the TARGET? The proposal says it computes target layer and parameter. But I thought we were mapping config values to layer parameters. Why do we need to compute the target dynamically? Can't we just specify it in the mapping rule?`
- L156: `**ParameterLayers**: As the layer system, I need to point out: layers are DEFINED at compile time. Parameters are DEFINED at compile time. If TransformFunc can compute the target layer dynamically, what if it computes a layer that doesn't exist? That's a runtime error. Layers should be known at mapping definition time, not computed at runtime.`
- L162: `**ConfigFileMapper**: Sarah, I think you're missing the point. TransformFunc is trying to replace me. But I already exist. I'm a function that takes raw config and returns layer maps. If you want dynamic transformation, write a function that does it. That's me. Why do we need TransformFunc at all? Just use ConfigFileMapper with a function that does the transformation.`
- L168: `**LoadParametersFromFile**: You know what, I'm going to be direct: I don't understand TransformFunc at all. I load a file. I call a mapper. The mapper returns layer maps. That's it. If you need to transform values, transform them in the mapper function. If you need to compute targets, compute them in the mapper function. Why do we need a separate TransformFunc concept?`
- L170: `**ParameterLayers**: LoadParametersFromFile, I agree. TransformFunc is trying to solve a problem that ConfigFileMapper already solves. If you need dynamic transformation, write a function. That's what ConfigFileMapper is for. TransformFunc is redundant. It's adding complexity without adding value. Keep it simple: use ConfigFileMapper for custom logic, use pattern matching for simple cases.`
- L188: `**LoadParametersFromFile**: I'm going to be honest: I'm confused. I load config files. I call mapper functions. That's my job. This pattern matching system wants me to understand patterns, captures, nested rules, TransformFunc... That's way more than I signed up for. Can't we just keep it simple? Config file ‚Üí mapper function ‚Üí layer maps. Done.`
- L190: `**ParameterLayers**: As the layer system, I need to point out: layers are STATIC. They're defined at compile time. Pattern matching is DYNAMIC. It happens at runtime. This creates a mismatch. What if a pattern matches a config value but there's no corresponding parameter definition? What if the pattern matches multiple values but the parameter expects one? This system is trying to bridge static and dynamic, and that's inherently complex.`
- L202: `**LoadParametersFromFile**: You know what, I'm going to agree with the hybrid approach. But here's my concern: if I accept both pattern matching AND ConfigFileMapper, I need to support both. That's two code paths. That's complexity. Can't we pick ONE? Either pattern matching is the future, or ConfigFileMapper is the future. Don't make me support both forever.`
- L204: `**ParameterLayers**: As the layer system, I think the real question is: what problem are we solving? If the problem is "config files have different structures," then maybe the solution is "make config files have the same structure." If the problem is "mapping is hard," then maybe the solution is "make mapping simpler." This pattern matching system is trying to solve "config files have different structures AND mapping is hard" by making mapping MORE complex. That's backwards.`
- L222: `**LoadParametersFromFile**: Can I be honest? I currently handle errors by returning them. If the mapper function returns an error, I return it. If the file doesn't exist, I return an error. Simple. This pattern matching system wants me to understand "required" vs "optional", to log warnings vs errors... That's a lot of complexity. I just want to know: did it work or didn't it?`
- L224: `**ParameterLayers**: As the layer system, I need to point out: parameters have default values defined in ParameterDefinitions. If a mapping rule provides a default, which one wins? The parameter definition default, or the mapping rule default? This is a conflict. Defaults should be in ONE place: parameter definitions. Mapping rules should only map values, not define defaults.`
- L228: `**Sarah Chen**: ParameterLayers, you're making this too complicated. If a mapping rule has a default, use it. If a parameter definition has a default, use it. Precedence: mapped value > mapping rule default > parameter definition default. That's clear. That's logical. And for error handling, I still say: explicit errors with good messages. No silent failures. Ever.`
- L230: `**ConfigFileMapper**: You know what, I'm going to agree with ParameterLayers here. Defaults should be in parameter definitions. Mapping rules should map values. That's separation of concerns. If you want defaults, define them in the parameter layer. Don't mix concerns. Keep mapping simple: config file ‚Üí layer parameter. That's it.`
- L236: `**LoadParametersFromFile**: You know what, I think everyone's overthinking this. I load a file. I call a mapper. If the mapper returns an error, I return it. If it doesn't, I proceed. This pattern matching system wants me to make decisions about errors vs warnings, required vs optional... That's not my job. My job is to load files and call mappers. Keep it simple.`
- L238: `**ParameterLayers**: LoadParametersFromFile, I agree. But here's my concern: if a pattern matches a value but that parameter doesn't exist in the layer, what happens? Do we create it? Do we error? Do we ignore it? This is a fundamental question. Layers define what parameters exist. Mappings should only map to EXISTING parameters. Otherwise, we're creating dynamic parameters, and that breaks the type system.`
- L242: `## Question 7: Default Values - Mapping Rules vs Parameter Definitions?`
- L244: `**Moderator**: The design allows defaults in mapping rules, but parameter definitions already have defaults. Where should defaults live, and what's the precedence?`
- L248: `**Sarah Chen**: Defaults in mapping rules make TOTAL sense. Look at it this way: a parameter definition might have a default of `42` for `threshold`. But in a config file mapping, you might want a different default of `10` for a specific environment. Mapping rules should override parameter defaults. That's the whole point of mapping: transforming config file values. Defaults are part of that transformation.`
- L250: `**ConfigFileMapper**: Defaults? I don't deal with defaults. I'm a function. I take raw config, I return layer maps. If a value doesn't exist in the config file, I don't return it. That's not my problem. Defaults are handled by the parameter system, not by me. This pattern matching system is trying to make me responsible for defaults, but that's not my job.`
- L252: `**Marcus Rodriguez**: Sarah, you're wrong. Defaults should be in ONE place: parameter definitions. Here's why: if you have defaults in mapping rules, you can't reason about defaults statically. You have to look at both the parameter definition AND the mapping rules to know what the default is. That's complexity. One source of truth: parameter definitions. Mapping rules map values. That's it.`
- L254: `**Dr. Aisha Patel**: Marcus, I agree with you on single source of truth, but I think Sarah has a point about environment-specific defaults. Here's the compromise: defaults are in parameter definitions. BUT, mapping rules can provide override values. Not "defaults", but "override values". If a config file doesn't have a value, the mapping rule can provide an override. But it's still a mapped value, not a default. Semantics matter.`
- L256: `**LoadParametersFromFile**: I'm confused. Defaults are for when values are missing, right? But I load config files. If a value is missing from the config file, I don't load it. That's it. Defaults are handled later, by the parameter system. Why are we talking about defaults in mapping rules? That's not what mapping does. Mapping maps VALUES, not defaults.`
- L258: `**ParameterLayers**: As the layer system, I need to be clear: parameter definitions have defaults. Those defaults are used by the `SetFromDefaults` middleware. That's the system. If mapping rules also have defaults, we're creating TWO default systems. That's confusing. Which one wins? When? Why? Keep it simple: defaults are in parameter definitions. Mapping rules map values. Done.`
- L262: `**Sarah Chen**: ParameterLayers, you're being rigid. Look at the use case: `app.{env}.threshold` where `dev` has default `10` and `prod` has default `100`. The parameter definition can't know about environments. Only the mapping rule can. That's why mapping rules need defaults. They're context-specific. Parameter defaults are global. Mapping defaults are contextual.`
- L266: `**Marcus Rodriguez**: ConfigFileMapper, you're right that functions can handle complex logic, but here's the thing: if we make defaults part of mapping rules, we can VALIDATE them. We can check: does this default match the parameter type? Does it pass validation? With functions, we can't validate defaults until runtime. With mapping rules, we can validate at definition time. That's type safety.`
- L268: `**Dr. Aisha Patel**: Marcus, I think we're conflating defaults with mapped values. If a mapping rule says "use default 10 if not found", that's not a default. That's a mapped value. The value is 10. It came from the mapping rule, not from the config file. So it's a value, not a default. Keep defaults in parameter definitions. Mapping rules provide values, including fallback values.`
- L270: `**LoadParametersFromFile**: You know what, I think everyone's overcomplicating this. I load a config file. I call a mapper. The mapper returns values. If a value is missing, it's missing. Defaults are handled by the parameter system. Keep it simple. Don't mix concerns. Mapping maps values. Defaults provide fallbacks. Different systems. Different responsibilities.`
- L272: `**ParameterLayers**: LoadParametersFromFile, I agree completely. But here's my concern: if mapping rules can provide defaults, what happens when a developer uses `SetFromDefaults` middleware? Does it use parameter defaults or mapping rule defaults? This is a conflict. The middleware system needs to know: where do defaults come from? If we have two sources, we need precedence rules. That's complexity. One source. Simple.`
- L278: `**Moderator**: The design mentions array indexing like `app.settings[0].key`, but doesn't fully specify array handling. Should we support `[*]` for mapping all array elements? How should array values be mapped to layer parameters?`
- L282: `**Sarah Chen**: Array handling is CRITICAL. Look at real config files: they have arrays. `services: [auth, payment, billing]`. You need to map each element. So yes, `[*]` should work. And it should map each element to a separate parameter or a list parameter. But here's the key: we need GOOD syntax. `app.services[*].name` should map each service name. That's intuitive.`
- L286: `**Marcus Rodriguez**: Sarah, array handling is a performance NIGHTMARE. What if you have `app.services[*].config[*].key`? That's nested arrays. Now you're doing nested loops. That's O(n¬≤) or worse. Plus, where do these mapped values go? Do you create multiple parameters? Do you create array parameters? This is complex. Maybe we should just say: arrays aren't supported. Flatten your config first.`
- L288: `**Dr. Aisha Patel**: Marcus, I disagree. Arrays are a fundamental data structure. We need to support them. But I think we need CLEAR semantics. `app.services[*].name` should map to what? A single parameter that's an array? Multiple parameters? I think we need explicit syntax: `app.services[*].name` ‚Üí `service-names` (array parameter) or `app.services[{index}].name` ‚Üí `service-{index}-name` (multiple parameters). Clarity matters.`
- L290: `**LoadParametersFromFile**: I'm going to be honest: I don't understand array mapping at all. I load a config file. I get a map. That map might have arrays. I call a mapper function. That function deals with arrays. That's it. Why do we need special syntax? Just write a function that handles arrays. That's what functions do.`
- L292: `**ParameterLayers**: As the layer system, I need to point out: parameters have types. Some parameters can be arrays. Some can't. If you map `app.services[*].name` to a parameter, does that parameter accept arrays? What if it's defined as a string, not a string array? This is a type mismatch. Mapping rules need to respect parameter types. Otherwise, we're breaking type safety.`
- L296: `**Sarah Chen**: ParameterLayers, you're right about type safety. But here's the thing: if `app.services[*].name` maps to a parameter that's defined as `[]string`, that's fine. If it maps to a parameter that's `string`, we should error. But the mapping rule should be able to specify: "map each element to a separate parameter" or "map all elements to an array parameter". That's flexibility.`
- L300: `**Marcus Rodriguez**: ConfigFileMapper, you're right that functions are flexible, but here's the issue: every developer handles arrays differently. Some map to arrays, some map to multiple parameters, some flatten, some transform. We have NO consistency. This pattern matching system gives us ONE way to do it. One syntax. One behavior. That's standardization. That's maintainability.`
- L304: `**LoadParametersFromFile**: You know what, I'm going to agree with Dr. Patel. Arrays are complex. Pattern matching should handle simple cases. Arrays are not simple. Let ConfigFileMapper handle arrays. That's a clear division of responsibility. Pattern matching for simple mappings, functions for complex cases.`
- L306: `**ParameterLayers**: As the layer system, I think the real question is: what problem are we solving? If the problem is "arrays are hard to map", then maybe the solution is "don't use arrays in config files". Use a different structure. Or use ConfigFileMapper for arrays. But don't try to make pattern matching handle everything. That's scope creep.`
- L312: `**Moderator**: How does the new pattern matching system integrate with the existing middleware chain? Should it replace `LoadParametersFromFile`, or be a new middleware?`
- L316: `**Sarah Chen**: This should REPLACE `LoadParametersFromFile`. Well, not replace, but ENHANCE it. You should be able to use pattern matching INSTEAD of ConfigFileMapper. Same middleware, different configuration. So `LoadParametersFromFile` accepts either a `ConfigFileMapper` OR a `ConfigMapper` (pattern matching). That's backward compatible. That's clean.`
- L318: `**ConfigFileMapper**: Whoa, whoa, whoa. Sarah, you're talking about replacing me in `LoadParametersFromFile`. But I'm the CORE of that middleware. Without me, that middleware doesn't exist. This pattern matching system wants to be an OPTION, but if it becomes the default, I'm obsolete. That's not enhancement, that's replacement. And I don't like it.`
- L320: `**Marcus Rodriguez**: Sarah, I think you're right about integration, but I think we need a NEW middleware. `LoadParametersFromPatternMappedFile` or something. Keep `LoadParametersFromFile` as-is. Add the new one. That way, existing code doesn't break. New code can use pattern matching. That's migration-friendly. That's safe.`
- L322: `**Dr. Aisha Patel**: Marcus, I disagree. Two middlewares for the same thing? That's duplication. That's maintenance burden. I think we should enhance `LoadParametersFromFile` to accept EITHER a ConfigFileMapper OR a ConfigMapper. Type union, or an interface. That way, it's one middleware, two options. Clean. Simple. Maintainable.`
- L324: `**LoadParametersFromFile**: Can I speak? I'm the middleware in question. Currently, I accept a `ConfigFileMapper` function. That's it. Simple. Now you want me to accept pattern matching too? That's two code paths. That's complexity. Can't we keep it simple? Either pattern matching is a new middleware, or ConfigFileMapper is the only option. Don't make me support both.`
- L326: `**ParameterLayers**: As the layer system, I need to point out: middlewares are composable. They're functions. They're simple. `LoadParametersFromFile` loads a file and maps it. That's its job. If we add pattern matching, we're adding complexity to that middleware. But maybe that's okay? As long as the OUTPUT is the same (layer maps), the internal implementation doesn't matter. But we need to be careful about error handling and observability.`
- L330: `**Sarah Chen**: LoadParametersFromFile, I hear you, but here's the thing: you're already supporting ConfigFileMapper. That's a code path. Adding pattern matching is just another code path. Same middleware, two options. That's flexible. That's backward compatible. And the output is the same: layer maps. So internally, you have two ways to produce the same output. That's fine.`
- L332: `**ConfigFileMapper**: Sarah, you say "two options", but if pattern matching becomes the default, developers will use it. Then I become obsolete. That's not "options", that's "replacement". If you want to enhance LoadParametersFromFile, enhance it to make ConfigFileMapper EASIER to use. Don't add a whole new system. Just make my life better.`
- L334: `**Marcus Rodriguez**: ConfigFileMapper, you're being defensive. Pattern matching doesn't replace you. It complements you. Simple mappings use pattern matching. Complex mappings use you. That's the right boundary. But I agree with LoadParametersFromFile: two code paths is complexity. Maybe we need a unified interface? Like `ConfigMapper` interface with `Map(rawConfig interface{}) (map[string]map[string]interface{}, error)`. Then ConfigFileMapper implements it, and PatternMapper implements it. Clean.`
- L338: `**LoadParametersFromFile**: You know what, I'm going to be honest. I don't care about interfaces or adapters. I just want to know: do I need to support pattern matching or not? If yes, how? If no, fine. But don't make me implement a whole new system just to support both. That's complexity. Keep it simple. One way to do it.`
- L340: `**ParameterLayers**: As the layer system, I think the real question is: what's the output? The output is layer maps. As long as both ConfigFileMapper and pattern matching produce the same output format, LoadParametersFromFile can use either. But we need to be careful about error handling. Pattern matching errors are different from ConfigFileMapper errors. How do we unify them? That's the challenge.`
- L358: `**LoadParametersFromFile**: Can I be honest? I don't care about migration. I'm a middleware. I accept ConfigFileMapper. I'll continue to accept ConfigFileMapper. If you want to add pattern matching support, fine. But don't break my existing interface. Don't make me change. I work. Keep me working. That's all I ask.`
- L360: `**ParameterLayers**: As the layer system, I need to point out: layers don't care about mapping. Layers define parameters. Mapping provides values. As long as mapping produces the right values, layers don't care HOW it's done. So from my perspective, ConfigFileMapper or pattern matching - it doesn't matter. As long as the output is correct, we're good. But we need to ensure both systems produce the same output format. That's compatibility.`
- L372: `**LoadParametersFromFile**: You know what, I'm going to say something: maybe migration isn't the right word. Maybe it's "coexistence". ConfigFileMapper and pattern matching coexist. Both work. Both are supported. Developers choose. No migration needed. No pressure. Just coexistence. That's simple. That's clean.`
- L374: `**ParameterLayers**: As the layer system, I think the real question is: what does "migration" even mean? Layers don't change. Parameters don't change. Mapping changes, but that's implementation detail. From the layer perspective, nothing changes. So migration is just a developer concern, not a system concern. As long as both mapping systems produce the same output, layers don't care. That's compatibility.`
- L390: `**LoadParametersFromFile**: I'm just trying to load files. Keep it simple. If pattern matching helps, great. If it makes things harder, don't do it. Don't add complexity for complexity's sake.`
- L392: `**ParameterLayers**: Layers are static. Parameters are static. Mapping should be static too. If we need dynamic mapping, let's make it explicit and clear. Don't hide it behind pattern matching magic.`

### `ttmp/2025-10-29/05-config-mapping-review-and-recommendations.md`
- L11: `The Generic Config Mapping Design proposes a declarative, pattern-based system for mapping arbitrary config file structures to Glazed's layer-based parameter system. This review synthesizes the design document, debate discussions, and architectural concerns to provide concrete recommendations for implementation.`
- L68: `**Design Decision**: Parent rules can have child rules that inherit captures and layer targets.`
- L86: `    {Source: "api_key", TargetParameter: "api-key"},`
- L91: `    {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L140: `- **Concern**: Parameter definitions already have defaults`
- L146: `  - Defaults belong in parameter definitions (single source of truth)`
- L148: `  - If a config value is missing, the parameter definition default applies`
- L153: `2. Parameter definition default`
- L207: `- Explicit syntax: `app.services[*].name` ‚Üí `service-names` (array parameter)`
- L208: `- Or: `app.services[{index}].name` ‚Üí `service-{index}-name` (multiple parameters)`
- L209: `- Must validate parameter type matches array type`
- L233: `**Design Decision**: Unclear - replace or enhance `LoadParametersFromFile`?`
- L238: `- Same output format (layer maps)`
- L241: `- **Approach**: Enhance `LoadParametersFromFile` to accept either:`
- L253: `  - `LoadParametersFromFile` checks type and uses appropriate path`
- L258: `func LoadParametersFromFile(filename string, options ...ConfigFileOption) Middleware {`
- L291: `    {Source: "app.settings.api_key", TargetLayer: "demo", TargetParameter: "api-key"},`
- L292: `    {Source: "app.settings.threshold", TargetLayer: "demo", TargetParameter: "threshold"},`
- L327: `- Integration with `LoadParametersFromFile``
- L362: `**Concern**: Pattern matching happens at runtime, but parameter definitions are at compile time.`
- L366: `- Validate parameter names exist in target layer at mapper creation time`
- L367: `- Runtime: Validate mapped values match parameter types`
- L371: `func NewConfigMapper(layers *schema.Schema, rules ...MappingRule) (*ConfigMapper, error) {`
- L377: `        // Validate parameter exists`
- L378: `        if err := validateParameterExists(layers, rule.TargetLayer, rule.TargetParameter); err != nil {`
- L458: `### 2. Missing Parameters`
- L459: `- What if a pattern matches a value but the target parameter doesn't exist?`
- L462: `**Recommendation**: Error - parameters must exist in layer definitions (type safety).`
- L466: `- Create multiple parameters or error?`
- L468: `**Recommendation**: Create multiple parameters (one per match) - this is the intended behavior.`
- L471: `- If multiple patterns match the same parameter, which wins?`
- L473: `**Recommendation**: Error - ambiguous mappings should be explicit. Require unique target parameters per layer.`
- L507: `6. ‚úÖ Integration with LoadParametersFromFile`
- L522: `1. ‚ùå Default values in mapping rules (use parameter definitions)`

### `ttmp/2025-10-29/06-implementation-summary.md`
- L20: `    TargetLayer     string        // Layer slug: "demo"`
- L21: `    TargetParameter string        // Parameter name: "{env}-api-key"`
- L47: `- ‚úÖ Target layer existence check`
- L48: `- ‚úÖ Parameter existence validation (runtime)`
- L52: `‚úÖ Integrated with `LoadParametersFromFile` via `ConfigMapper` interface  `
- L59: `- Validation tests (pattern syntax, captures, layers)`
- L61: `- Error handling tests (required patterns, missing parameters)`
- L110: `1. `pkg/cmds/middlewares/load-parameters-from-json.go``
- L124: `4. **No Default Values**: Removed from mapping rules (use parameter definitions)`
- L127: `7. **Integration**: Enhanced existing `LoadParametersFromFile``
- L145: `mapper, _ := NewConfigMapper(layers,`
- L148: `        TargetLayer:     "demo",`
- L149: `        TargetParameter: "api-key",`
- L156: `mapper, _ := NewConfigMapper(layers,`
- L159: `        TargetLayer:     "demo",`
- L160: `        TargetParameter: "{env}-api-key",`
- L167: `mapper, _ := NewConfigMapper(layers,`
- L170: `        TargetLayer: "demo",`
- L172: `            {Source: "api_key", TargetParameter: "api-key"},`
- L173: `            {Source: "threshold", TargetParameter: "threshold"},`
- L181: `middleware := LoadParametersFromFile(`
- L218: `‚úÖ Missing target layers  `
- L219: `‚úÖ Missing target parameters  `

### `ttmp/2025-10-29/07-additional-tests-and-docs.md`
- L32: `- ‚úÖ **Parameter doesn't exist**: Error shows parameter name, layer, pattern context`
- L36: `target parameter "nonexistent-param" does not exist in layer "demo" (pattern: "app.settings.api_key")`
- L39: `#### 3. TestLayerPrefix (2 test cases)`
- L41: `Tests handling of layer prefixes:`
- L43: `- ‚úÖ **Without prefix in rule**: Automatically adds layer prefix`
- L46: `**Scenario**: Layer has prefix `demo-`, parameter is `demo-api-key``
- L91: `| **Layer Prefix** | **2** | **pattern-mapper-edge-cases_test.go** |`
- L124: `    // LoadParametersFromFile ‚Üí SetFromDefaults ‚Üí ParseFromCobra`
- L131: `    // 1000+ parameters`
- L154: `Short: Declarative mapping of config files to parameter layers using pattern matching rules`
- L201: `    TargetParameter: "{env}-api-key",      // Uses captured value`
- L218: `glaze help parameter-layers-and-parsed-layers`
- L258: `- ‚úÖ **Layer prefix handling tested**`

### `ttmp/2025-10-29/11-debate-around-the-actual-mapper-implementation.md`
- L63: `**ConfigFileMapper** (the function type from `load-parameters-from-json.go:20`):  `
- L66: `**LoadParametersFromFile** (from `load-parameters-from-json.go:29`):  `
- L70: `"I'm sorry, but without the adapter, we'd have TWO different code paths in `LoadParametersFromFile`. One for `ConfigFileMapper` functions (direct call), one for `ConfigMapper` interface (method call). That's duplicate logic! The adapter creates a SINGLE code path: everything is a `ConfigMapper`, everything calls `.Map()`. That's proper polymorphism!"`
- L76: `"Wait, why do we need `ConfigMapper` at ALL? Why not just keep `ConfigFileMapper` as the only way? The pattern mapper could ALSO be a function! `func NewPatternMapperFunc(layers, rules) ConfigFileMapper` - returns a function that does pattern matching. No interface, no adapter, no complexity. Everything stays as functions!"`
- L83: `"Okay, 'Code Simplicity Advocate' - your suggestion creates DIFFERENT problems! If pattern mapper returns a function, you lose type safety. I can't validate that a function is actually using patterns vs just doing arbitrary logic. The interface `ConfigMapper` documents the contract: 'I map configs to layer maps.' Also, functions can't have methods, so you can't add utilities like `Validate()` or `Explain()` later. The adapter isn't indirection - it's FUTURE-PROOFING!"`
- L88: `**LoadParametersFromFile**:  `
- L94: `**TestIntegrationWithLoadParametersFromFile** (from test suite):  `
- L99: `## Question 3: Why validate parameter existence at RUNTIME instead of compile time?`
- L101: `**Moderator**: The code validates pattern syntax and capture references at creation time, but checks if target parameters exist in layers at RUNTIME when matching. Why not validate parameter existence upfront?`
- L108: `"BECAUSE PARAMETER NAMES ARE DYNAMIC! When you have `{env}-api-key` as a target parameter, I don't know if `dev-api-key` or `prod-api-key` exist until I see the ACTUAL config values! I can validate that `{env}` exists in the source pattern, but I can't validate the RESOLVED parameter name until runtime. This is a fundamental limitation of dynamic pattern matching!"`
- L111: `"And it's NOT just captures! Even with static parameter names, layers can CHANGE between creation and mapping. What if someone creates a mapper, then later removes a parameter from the layer? Or adds new parameters? Runtime validation ensures we always check against the CURRENT layer state, not a snapshot from creation time!"`
- L114: `"This is MADNESS! If you can't validate parameters at creation time, you're allowing invalid mappers to be created! A mapper with rules that reference non-existent parameters should FAIL IMMEDIATELY, not fail later when someone tries to use it. Fail fast, fail early! This is a recipe for runtime surprises!"`
- L120: `"Actually, I DO validate the target layer exists at creation time! Line 144: `_, ok := m.layers.Get(rule.TargetLayer)`. But the PARAMETER name might be dynamic due to captures. Should I validate ALL possible capture combinations? That's exponential! What if someone has `app.{region}.{env}.{service}.api_key` with `{region}-{env}-{service}-api-key`? I'd need to enumerate thousands of combinations to validate upfront!"`
- L123: `"Runtime validation means EVERY map call checks parameter existence! That's overhead on EVERY operation! If you validated at creation, you'd check once and never again. But you can't because of dynamic captures, so you're stuck with runtime checks. But at least cache the validation results! Check once per unique resolved parameter name, not every time!"`
- L130: `"Okay, let me be more nuanced. I validate what CAN be validated at creation time: pattern syntax, capture references, layer existence. I validate what REQUIRES runtime values at runtime: resolved parameter names. This is PRECISELY the right separation! Static validation upfront, dynamic validation at runtime. You wouldn't want me to try validating every possible capture combination - that could be millions of combinations!"`
- L133: `"And honestly, runtime validation gives BETTER error messages! At creation time, I'd say 'parameter {env}-api-key does not exist' which is confusing. At runtime, I can say 'parameter dev-api-key does not exist (resolved from pattern app.{env}.api_key)' - much clearer! Users understand the actual parameter name that failed, not the template!"`
- L136: `"As the test that validates error messages - runtime validation produces WAY better errors! When a parameter doesn't exist, the error includes the actual resolved name AND the pattern that produced it. That's debugging gold! If validation happened at creation, errors would be about templates, not actual values!"`
- L139: `"Fine, you make good points about dynamic captures. But what about STATIC parameter names? `app.settings.api_key` ‚Üí `api-key` - that's completely static! Why not validate THAT at creation time? Even if you can't validate dynamic ones, you could validate static ones upfront and only do runtime checks for captures!"`
- L142: `"That's actually a GOOD idea! I could check: if `TargetParameter` has no `{...}` captures, validate it exists at creation time. If it has captures, skip validation. That gives us best of both worlds - fail fast for static names, runtime check for dynamic. But honestly, the current approach is simpler - one validation point, consistent behavior. Premature optimization of error timing?"`
- L144: `**LoadParametersFromFile**:  `
- L164: `"As a user, I LOVE capture inheritance! My config has `environments.{env}.settings.api_key`, and I want `{env}-api-key` as the parameter. The parent rule captures `{env}`, child rule uses it - perfect! Without inheritance, I'd have to write `environments.{env}.settings.{env}.api_key` which is redundant and confusing!"`
- L180: `"Nested rules solve a REAL problem! Without them, you'd write `app.{env}.settings.api_key` for EVERY single parameter. With nested rules, you write `app.{env}.settings` once, then list all child parameters. That's not just DRY - it's also clearer! The structure of your config is reflected in the rule structure!"`
- L189: `"But why not EXPLICIT capture passing? Child rules could explicitly list which parent captures they need: `{Source: "api_key", UsesCaptures: []string{"env"}, TargetParameter: "{env}-api-key"}`. That's more verbose but CRYSTAL CLEAR. No hidden inheritance, no shadowing confusion!"`
- L194: `**LoadParametersFromFile**:  `
- L195: `"Can I interject? As the middleware, I don't CARE about nested rules or capture inheritance! I just call `mapper.Map(rawData)` and get back a layer map. The complexity is encapsulated in the mapper. Whether it uses inheritance or explicit passing doesn't affect me at all. This is good abstraction!"`
- L259: `3. Runtime parameter validation is necessary for dynamic captures, but static names could be validated earlier`
- L266: `- Could static parameter names be validated at creation time?`
- L313: `"Actually, the REAL solution is to use named captures! `app.{env}.api_key` creates MULTIPLE parameters: `dev-api-key`, `prod-api-key`. Wildcards are for 'any value, I don't care which'. If you care which value, use captures! The 'last match wins' behavior is by design for wildcards - they're meant to match ONE value, not many!"`
- L325: `**Moderator**: The code automatically adds layer prefixes to parameter names if they're missing. If a layer has prefix `demo-` and target parameter is `api-key`, it becomes `demo-api-key`. But if the target already includes the prefix, it doesn't double-add. Is this helpful magic or confusing behavior?`
- L332: `"I'm being HELPFUL! If a layer has prefix `demo-` and the rule says `api-key`, I automatically add the prefix to get `demo-api-key`. But if the user already wrote `demo-api-key` in the rule, I don't double-add it. This is intelligent behavior - users don't have to remember prefixes!"`
- L334: `**ParameterLayer with prefix** (from layers package):  `
- L335: `"Actually, MY prefix behavior is consistent! All my parameters MUST have the prefix. If you define a parameter as `api-key` in a layer with prefix `demo-`, it becomes `demo-api-key`. The pattern mapper is just respecting MY convention! It's not magic - it's consistency!"`
- L338: `"This IS confusing! If I write `TargetParameter: "api-key"`, I expect it to map to `api-key`. But if the layer has a prefix, it maps to `demo-api-key` instead. That's surprising! The prefix addition happens silently - no warning, no documentation in the error message. I might wonder why my parameter doesn't exist!"`
- L340: `**TestLayerPrefix** (from `pattern-mapper-edge-cases_test.go:178`):  `
- L343: `**resolveTargetParameter** (from `pattern-mapper.go:508`):  `
- L347: `"When a parameter doesn't exist, the error says `target parameter "api-key" does not exist`. But the ACTUAL parameter name checked was `demo-api-key` (with prefix). The error message doesn't mention the prefix! Users see an error about `api-key` but their parameter is `demo-api-key` - confusing!"`
- L354: `"Okay, the prefix logic is: if layer has prefix AND targetParam doesn't start with it, add prefix. This handles the common case: users write `api-key`, system adds `demo-api-key`. But if captures resolve to something that already has the prefix, the check prevents double-adding. It's defensive programming!"`
- L357: `"But prefix handling happens at RUNTIME, not compile time! I can't validate that the resolved parameter name will match the layer's prefix convention. What if someone writes `{env}-api-key` and `env` resolves to `demo`? Then resolved name is `demo-api-key`. If layer prefix is `demo-`, the check sees it already starts with `demo-` so doesn't add. But what if layer prefix is `app-`? Then it adds to get `app-demo-api-key` which is probably wrong!"`
- L360: `"The prefix logic should be VALIDATED at creation time! If a rule has `TargetParameter: "api-key"` and the layer has prefix `demo-`, I should check: does `demo-api-key` exist? If not, error immediately. Don't wait until runtime to discover the parameter name is wrong!"`
- L362: `**LoadParametersFromFile**:  `
- L363: `"From my perspective, prefix handling is a LAYER concern, not a mapper concern! Layers handle their own prefixes when parameters are SET. The mapper shouldn't need to know about prefixes at all - just use the parameter name from the rule, and let the layer handle prefixing!"`
- L366: `"But layers EXPECT prefixed names! If I pass `api-key` to a layer with prefix `demo-`, the layer won't find it because it looks for `demo-api-key`. So I HAVE to add prefixes, or the mapper won't work with prefixed layers. It's a necessary evil!"`
- L369: `"I should include prefix info in errors! When I say `target parameter "api-key" does not exist`, I should say `target parameter "api-key" (checked as "demo-api-key" with layer prefix) does not exist`. That would make debugging much clearer!"`
- L385: `"And I process ALL patterns, so if one pattern doesn't match, others still can. The result map just doesn't include that parameter. Users can check if a parameter exists in the result map. This is flexible - not all configs have all possible values!"`
- L391: `"I use `Required: true` for critical parameters, but what about 'nice to have' parameters? I want to know if they're missing, but I don't want to fail the entire config load. Silent failure means I can't distinguish 'config doesn't have this' from 'pattern is wrong'. At least LOG missing patterns!"`
- L406: `**LoadParametersFromFile**:  `
- L434: `**readConfigFileToLayerMap** (from `load-parameters-from-json.go:122`):  `
- L475: `**Moderator**: When multiple patterns match the same target parameter (e.g., `app.dev.api_key` ‚Üí `api-key` and `app.prod.api_key` ‚Üí `api-key`), the code overwrites previous values. The last match wins. Should this be an error instead, or is overwriting the correct behavior?`
- L482: `"I just assign: `result[match.layer][paramName] = match.value`. If the key already exists, Go maps overwrite automatically. Last match wins. This is simple and deterministic for a single config. If two patterns match the same parameter, the last one processed sets the value. That's fine!"`
- L485: `"But what if someone ACCIDENTALLY writes two patterns that match the same parameter? `app.dev.api_key` ‚Üí `api-key` and `app.prod.api_key` ‚Üí `api-key` are both valid, but they'll overwrite each other! The user won't know which value was used. This is a BUG waiting to happen!"`
- L488: `"I return ALL matches for a pattern. If `app.*.api_key` matches both `dev` and `prod`, I return two matches. Then `patternMapper.Map` processes them sequentially, and the last one overwrites. But the user wrote ONE pattern, so multiple matches are expected. The issue is when DIFFERENT patterns match the same parameter!"`
- L491: `"This SHOULD be an error! If two DIFFERENT patterns both resolve to the same parameter name, that's a collision. The user probably didn't intend that. At minimum, WARN about it. But silently overwriting? That's dangerous - users lose data without knowing!"`
- L504: `"Okay, let me think about this. Collision detection would require tracking which parameters have been set by which patterns. Then when a new match tries to set the same parameter, check if it's already set and by which pattern. That's overhead for every match. Is it worth it?"`
- L516: `"Here's my take: if two DIFFERENT patterns match the same parameter, WARN but don't error. Log which patterns collided and which value was used. Users can then decide if collision is intentional or accidental. Silent overwriting is too dangerous!"`

### `ttmp/2025-10-29/12-sober-proposals-from-mapper-debate.md`
- L18: `- Early validation for pattern syntax, capture references, target layer existence.`
- L20: `- Helpful runtime errors (esp. for missing required patterns, unknown parameters).`
- L27: `- Silent overwrites when multiple matches/patterns map to the same parameter.`
- L30: `- Static target parameter names are not validated up-front.`
- L48: `   - Change: Treat multiple distinct values from a single rule mapping to the same target parameter as an error by default (no policy toggles). If values are identical, mapping succeeds. Prefer captures (e.g., `{env}`) to collect separate values.`
- L53: `   - Problem: Different patterns can resolve to the same target parameter and overwrite silently.`
- L54: `   - Change: Detect and error when different rules write to the same target parameter (no policy toggles). If this is intended, refactor rules or target parameter names to avoid collisions.`
- L60: `   - Change: Include resolved, prefix-adjusted parameter in error text (e.g., `api-key (checked as "demo-api-key")`).`
- L64: `5. Early validation for static target parameters`
- L65: `   - Problem: Static `TargetParameter` (no captures) validated only at runtime.`
- L66: `   - Change: In `compileRule`, if no `{...}` in `TargetParameter`, derive prefix-adjusted name and validate existence immediately.`
- L89: `9. Explicit helper for canonical parameter name resolution`
- L91: `   - Change: Introduce `resolveCanonicalParameterName(layer, target)` helper (or method) centralizing prefix logic.`
- L103: `    - Change: Add table-driven tests covering: (a) multiple wildcard matches (deterministic; identical values allowed, distinct values error), (b) rule collisions (error), (c) `{env}` capture combined with layer prefix.`
- L148: `- No breaking changes to `ConfigMapper` interface or `LoadParametersFromFile` behavior by default.`
- L149: `- Error messages include resolved (prefixed) parameter names where applicable.`
- L150: `- Static target parameters validated at compile time; dynamic ones at runtime.`
- L159: `We adopted strict, deterministic semantics for Phase 1: ambiguous wildcard multi-matches (with distinct values) and cross-rule collisions now error by default, removing policy toggles and last-wins behavior. Prefix-aware errors and a canonical parameter resolver improve clarity. Documentation and tests reflect these changes. This simplifies user expectations while preserving the `ConfigMapper` API.`

### `ttmp/2025-11-03/01-validating-config-file-validity.md`
- L1: `## Validating Glazed Config Files (layers and pattern mappers)`
- L8: `- Layer-based validation: ensure config keys align with the command‚Äôs parameter layers and definitions, including type checks and requireds.`
- L17: `  - Target layer existence`
- L18: `  - Capture references in target parameters must exist in the source pattern`
- L19: `  - Static target parameter names are checked early with layer prefix-awareness (errors include canonical name)`
- L23: `  - Parameter existence (prefix-aware) for dynamic target names`
- L24: `  - Multi-match ambiguity: same rule matches different values for one target parameter ‚Üí error`
- L25: `  - Cross-rule collisions: two rules writing the same parameter ‚Üí error`
- L29: `  - Loads layer maps (layerSlug ‚Üí { paramName: value }) and merges into parsed layers`
- L30: `  - Unknown layers/keys are silently ignored: only defined parameters are read; there is no error for extra keys`
- L31: `  - Type validation happens when values are applied (parameter definition `CheckValueValidity`)`
- L32: `  - Required parameters are enforced only where parsing functions consider them; the config loader itself passes `onlyProvided=true`, so it won‚Äôt error on missing requireds by itself`
- L34: `### Layer-based validation strategies`
- L37: `- Unknown layer detection: error if a layer key in the config is not present in `ParameterLayers`.`
- L38: `- Unknown parameter detection: within known layers, error on any key that does not match a parameter (considering layer prefix-canonicalization if desired).`
- L39: `- Type checking: call `ParameterDefinition.CheckValueValidity` for each provided value to catch type/enum issues without mutating state.`
- L42: `- Required parameters are enforced by the parameter system during parsing/merging. Config-only validation does not need to re-enforce required. Optionally, you can add a post-parse assertion that requireds are satisfied across all sources (see helper below).`
- L44: `Effort: small. These are straightforward loops over `schema.Schema`, `ParameterDefinitions`, and `ParsedLayers`.`
- L46: `### Proposed API: Config validation helpers (layer-structured files)`
- L48: `Constraints: keep it easy for apps to validate their config files; allow soft/hard handling of extraneous layers and extraneous settings within a layer. No generic schema validation is attempted beyond what layers already define.`
- L62: `    // Unknown layer keys at top-level (not present in ParameterLayers)`
- L63: `    UnknownLayers ValidationMode // default: ValidationIgnore (back-compat)`
- L65: `    // Unknown parameter keys inside a known layer`
- L66: `    UnknownParameters ValidationMode // default: ValidationWarn`
- L68: `    // Validate provided values against parameter types/enums`
- L74: `func ValidateRawConfigAgainstLayers(`
- L75: `    layers *schema.Schema,`
- L82: `func ValidateConfigFilesAgainstLayers(`
- L83: `    layers *schema.Schema,`
- L92: `    IssueUnknownLayer     ValidationIssueKind = "unknown-layer"`
- L93: `    IssueUnknownParameter ValidationIssueKind = "unknown-parameter"`
- L100: `    Layer     string            // slug, for layer-related findings`
- L101: `    Parameter string            // parameter name, for param-related findings`
- L113: `// - If no mapper is set, loader will unmarshal raw -> run ValidateRawConfigAgainstLayers`
- L115: `// - If mapper is set, loader will not run layer-structure validation; apps should validate`
- L122: `- Construct the mapper (or load it via `patternmapper.LoadMapperFromFile`); this already validates syntax, layers, capture references, static targets. If it fails here, it‚Äôs a fast fail in `main.go`.`
- L125: `- For each config file, unmarshal raw YAML/JSON and call `mapper.Map(raw)`. Discard the result if you‚Äôre doing a ‚Äúvalidate-only‚Äù pass. Any ambiguity, collisions, missing required matches, or unknown target parameters will return an error.`
- L145: `func validateConfigFilesStrict(layers *schema.Schema, files []string, mapper middlewares.ConfigMapper) error {`
- L156: `        // Default structure: { layerSlug: { paramName: value } }`
- L159: `        for layerSlug, v := range m {`
- L160: `            layer, exists := layers.Get(layerSlug)`
- L161: `            if !exists { return fmt.Errorf("%s: unknown layer %q", f, layerSlug) }`
- L163: `            if !ok { return fmt.Errorf("%s: layer %q must map to an object", f, layerSlug) }`
- L164: `            pds := layer.GetParameterDefinitions()`
- L167: `                if prefix := layer.GetPrefix(); prefix != "" && !strings.HasPrefix(key, prefix) {`
- L171: `                if !ok || pd == nil { return fmt.Errorf("%s: unknown parameter %q in layer %q", f, key, layerSlug) }`
- L173: `                    return fmt.Errorf("%s: invalid value for %s.%s: %w", f, layerSlug, key, err)`
- L185: `func validateRequiredAfterParse(layers_ *schema.Schema, parsed *values.Values) error {`
- L187: `    _ = layers_.ForEachE(func(_ string, l schema.Section) error {`
- L189: `        pds := l.GetParameterDefinitions()`
- L192: `                if _, ok := parsedL.Parameters.Get(p.Name); !ok {`
- L200: `        return fmt.Errorf("missing required parameters: %v", missing)`
- L211: `    mapper, err := patternmapper.LoadMapperFromFile(layers, mappingRulesPath)`
- L214: `    files, err := resolver(parsedCommandLayers, cmd, args)`
- L216: `    if err := validateConfigFilesStrict(layers, files, mapper); err != nil { return err }`
- L224: `- Layer-based strict validation (default structure): small function (~50‚Äì100 LOC) to check unknown layers/keys and type-check values; very low risk.`
- L227: `- JSON Schema path (optional, future): medium; would require generating a schema for layers and using a validator.`

### `ttmp/2025-11-04/01-presidential-debate-to-review-the-config-file-feature-diff.md`
- L18: `10. **LoggingLayer** - Affected by the InitLoggerFromViper deprecation`
- L36: `**TestSuite:** *adjusts glasses* Let me interject with FACTS. I have 616 lines testing edge cases alone. Empty configs, nil values, deeply nested structures, wildcard ambiguity, type handling... Viper never gave us this level of testing confidence. Every parse step is now traceable with `--print-parsed-parameters`.`
- L75: `**ConfigFile:** *from the audience* As someone who lives on disk, I appreciate PatternMapper! Developers used to contort my structure to match layer names. Now I can have natural hierarchies that get mapped declaratively.`
- L84: `- Prefix-aware parameter validation`
- L96: `**Maria:** This is my nightmare! We have applications in production using `GatherFlagsFromViper()` everywhere. Now I have to find every instance and replace it with `LoadParametersFromFile` plus `UpdateFromEnv`. That's not a simple search-replace!`
- L98: `**Viper:** And they removed me from `ParseCommandSettingsLayer`! That's internal Glazed code! They're breaking their own framework!`
- L104: `**Maria:** Soft migration? Look at this change in cobra-parser.go - they removed the per-command `--load-parameters-from-file` flag handling! If apps relied on that, they break silently!`
- L107: `-	if commandSettings.LoadParametersFromFile != "" {`
- L109: `-			cmd_sources.FromFile(commandSettings.LoadParametersFromFile))`
- L131: `**ConfigFile:** Finally, my time to shine! With Viper, multiple configs merged opaquely. With `LoadParametersFromFiles`, precedence is explicit:`
- L134: `LoadParametersFromFiles([]string{`
- L141: `Each file is recorded as a separate parse step with metadata `{config_file, index}`. When you run `--print-parsed-parameters`, you see EXACTLY which file set each value!`
- L212: `**MiddlewareChain:** Correct. The `LoadParametersFromResolvedFilesForCobra` middleware calls the resolver once, gets the file list, then applies them. No repeated callback invocations.`
- L229: `**LoggingLayer:** *clearly frustrated* This affects me directly! The old pattern was:`
- L242: `**LoggingLayer:** Fair point. But now it's simpler:`
- L257: `3. `SetupLoggingFromParsedLayers` (for middleware-based apps)`
- L261: `**LoggingLayer:** The deprecated one is only there for compatibility during migration. The real choice is: Do you want logging configured from Cobra flags (simple case) or from parsed layers including config files (advanced case)? That's a clear decision tree.`
- L275: `- Unknown target layers`
- L276: `- Unknown target parameters (prefix-aware!)`
- L277: `- Capture references in TargetParameter that don't exist in Source`
- L282: `- Collision on the same parameter from multiple rules`
- L311: `- Prefix-aware parameter name validation`
- L372: `        LoadParametersFromFile("config.yaml"),`
- L402: `2. **Traceability**: `--print-parsed-parameters` shows the full history`
- L425: `**LoggingLayer:** The logging changes are strictly better. One initialization point, no double-calling, works with or without config files.`
- L447: `- LoggingLayer ‚úì`
- L490: `- `--print-parsed-parameters` for debugging`
- L502: `**Most Valuable Player:** TestSuite, for the 1,919 lines of comprehensive test coverage that give confidence in the refactor.`
- L504: `**Most Improved:** LoggingLayer, for simplifying from double-initialization to single-call clarity.`

### `ttmp/2025-11-04/02-config-file-feature-code-review.md`
- L15: `1. **Config file format change**: Applications must restructure config files to match layer structure OR add mappers`
- L34: `1. **Hidden complexity**: Viper's automatic config discovery and merging made it difficult to understand where parameter values originated`
- L48: `5. **Traceable parse history**: `--print-parsed-parameters` shows complete parameter provenance`
- L54: `‚îú‚îÄ‚îÄ load-parameters-from-json.go       (155 lines, +142 net)`
- L97: `       TargetLayer:     "demo",`
- L98: `       TargetParameter: "{env}-api-key",`
- L104: `   - Build-time: Pattern syntax, target layer/parameter existence, capture references`
- L115: `   - Prefix-aware parameter validation`
- L119: `   pm.NewConfigMapperBuilder(layers).`
- L154: `### 2.2 Config File Loading (`LoadParametersFromFile[s]`)`
- L156: `**Location:** `pkg/cmds/middlewares/load-parameters-from-json.go``
- L162: `   LoadParametersFromFile("config.yaml",`
- L168: `   LoadParametersFromFiles([]string{"base.yaml", "env.yaml", "local.yaml"},`
- L175: `   LoadParametersFromFile("config.yaml",`
- L178: `   LoadParametersFromFile("config.yaml",`
- L195: `1. **Breaking change**: Removed per-command `--load-parameters-from-file` auto-handling`
- L198: `   if commandSettings.LoadParametersFromFile != "" {`
- L200: `           LoadParametersFromFile(commandSettings.LoadParametersFromFile))`
- L249: `    LoadParametersFromResolvedFilesForCobra(resolver), // Config files`
- L306: `3. **New**: `SetupLoggingFromParsedLayers(parsed *values.Values)` - from middleware`
- L330: `    logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L357: `1. `GatherFlagsFromViper()` - use `LoadParametersFromFiles` + `UpdateFromEnv``
- L365: `func GatherFlagsFromViper(options ...parameters.ParseStepOption) Middleware {`
- L367: `        log.Warn().Msg("middlewares.GatherFlagsFromViper is deprecated; use LoadParametersFromFiles + UpdateFromEnv")`
- L443: `- Type handling for all parameter types`
- L457: `        {Source: "app.*.api_key", TargetLayer: "demo", TargetParameter: "api-key"},`
- L520: `   - Updated to use LoadParametersFromFile`
- L586: `#### 2. Config File Format Must Match Layer Structure`
- L588: `**Breaking change:** Config files must use layer-based structure.`
- L598: `**After:** Must match layer definitions:`
- L600: `# Layer names as top-level keys`
- L611: `1. **Restructure config files** (simplest - group params under layer names)`
- L622: `**Breaking change:** Per-command `--load-parameters-from-file` no longer auto-applied.`
- L627: `if commandSettings.LoadParametersFromFile != "" {`
- L629: `        LoadParametersFromFile(commandSettings.LoadParametersFromFile))`
- L635: `**Impact:** Apps expecting `--load-parameters-from-file` to work automatically need explicit config.`
- L639: `#### 4. Removed `GatherFlagsFromViper` from `ParseCommandSettingsLayer``
- L641: `**Impact:** Internal Glazed layer no longer reads from Viper.`
- L674: `        LoadParametersFromFiles([]string{"config.yaml"}),  // New`
- L687: `- Config file already matches layer structure (rare)`
- L693: `- Config file needs restructuring (flat ‚Üí layer-based)`
- L825: `- Build-time validation catches invalid target parameters`
- L828: `- Unknown layers/parameters are rejected (default validator)`
- L831: `- Pattern mappers can map to unexpected parameters if patterns are too broad`
- L853: `- Standard naming convention (`{PREFIX}_{LAYER}_{PARAMETER}`)`
- L903: `   - Config schema generation from layers`
- L917: `5. **Improved debugging**: `--print-parsed-parameters` shows full history`
- L931: `- Traceable config sources (better debugging with `--print-parsed-parameters`)`

### `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/analysis/01-analysis-environment-parsing-in-glazed.md`
- L7: `    - parameters`
- L26: `- We must parse env strings per ParameterType (bool/int/float/date/choice/lists/key-value).`
- L30: `- For each parameter definition in a layer, when ENV var is set, map value string -> []string and call p.ParseParameter([]string{value}) to reuse existing parsing semantics.`
- L31: `- Update parsedLayer.Parameters with parsed.Value and append parse step metadata {env_key: ..., source: env}.`
- L37: `- Docs describe ENV name formation: [PREFIX_]LAYERPREFIX + NAME (hyphens->underscores, uppercased).`

### `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/changelog.md`
- L15: `- /home/manuel/workspaces/2025-11-18/add-mento-startdev-tui/glazed/pkg/cmds/parameters/parse.go ‚Äî Parsing logic reference`
- L24: `- /home/manuel/workspaces/2025-11-18/add-mento-startdev-tui/glazed/pkg/cmds/middlewares/update.go ‚Äî Updated env parsing to typed via ParseParameter`

### `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/index.md`
- L7: `    - parameters`
- L18: `    - Path: /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/pkg/cmds/parameters/gather-parameters.go`
- L20: `    - Path: /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/pkg/cmds/parameters/parameters.go`
- L22: `    - Path: /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/pkg/cmds/parameters/parse.go`
- L23: `      Note: String parsing/typing entry points for various ParameterTypes`
- L24: `    - Path: /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/pkg/cmds/parameters/strings.go`
- L52: `- parameters`

### `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/tasks.md`
- L10: `- [x] Document env key naming (prefix + layer prefix + param; hyphens->underscores; uppercase)`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/analysis/01-glazed-parameter-parsing-architecture-analysis.md`
- L2: `Title: Glazed Parameter Parsing Architecture Analysis`
- L15: `# Glazed Parameter Parsing Architecture Analysis`
- L19: `This document provides a comprehensive analysis of how Glazed handles parameter definitions, layers, middleware registration, and command-line integration. The goal is to understand all the locations involved in the parameter parsing system to enable the design of a simplified API that maps struct tags directly to configuration sources without requiring manual layer and middleware setup.`
- L23: `Glazed's parameter system is built on four core concepts:`
- L24: `1. **ParameterDefinitions**: Typed parameter specifications with validation`
- L25: `2. **ParameterLayers**: Logical groupings of parameters (e.g., "default", "glazed", "logging")`
- L26: `3. **ParsedLayers**: Runtime values after parsing from multiple sources`
- L27: `4. **Middlewares**: Chainable functions that populate ParsedLayers from various sources (CLI flags, env vars, config files, defaults)`
- L29: `The current API requires explicit creation of layers, parameter definitions, and middleware chains. A simplified API would automatically derive these from struct tags.`
- L33: `### 1. Parameter Definitions`
- L35: `**Location**: `glazed/pkg/cmds/parameters/parameters.go``
- L38: `- `ParameterDefinition`: Core struct defining a parameter (name, type, default, help, etc.)`
- L39: `- `ParameterDefinitions`: Ordered map of ParameterDefinition objects`
- L40: `- `ParameterType`: Enum of supported types (String, Integer, Bool, File, Choice, etc.)`
- L43: `- `NewParameterDefinition()`: Creates a parameter definition with options`
- L44: `- `InitializeDefaultsFromStruct()`: Sets parameter defaults from struct fields with `glazed` tags`
- L45: `- `InitializeDefaultsFromMap()`: Sets parameter defaults from a map`
- L49: `type ParameterDefinition struct {`
- L52: `    Type       ParameterType`
- L60: `func NewParameterDefinition(`
- L62: `    parameterType ParameterType,`
- L63: `    options ...ParameterDefinitionOption,`
- L64: `) *ParameterDefinition`
- L68: `- Parameters are defined declaratively with type information`
- L69: `- Types include validation rules (e.g., ParameterTypeInteger validates ranges)`
- L73: `### 2. Parameter Layers`
- L75: `**Location**: `glazed/pkg/cmds/layers/layer.go`, `glazed/pkg/cmds/layers/layer-impl.go``
- L78: `- `ParameterLayer`: Interface for grouping parameters`
- L79: `- `ParameterLayerImpl`: Standard implementation`
- L80: `- `ParameterLayers`: Ordered map of ParameterLayer objects`
- L81: `- `CobraParameterLayer`: Interface for layers that integrate with Cobra`
- L84: `- `NewParameterLayer()`: Creates a new layer with options`
- L85: `- `AddLayerToCobraCommand()`: Adds layer flags to a Cobra command`
- L86: `- `ParseLayerFromCobraCommand()`: Parses layer values from Cobra flags`
- L87: `- `InitializeParameterDefaultsFromStruct()`: Sets layer parameter defaults from struct`
- L91: `type ParameterLayer interface {`
- L93: `    GetParameterDefinitions() *fields.Definitions`
- L94: `    InitializeParameterDefaultsFromStruct(s interface{}) error`
- L99: `    Clone() ParameterLayer`
- L102: `type ParameterLayerImpl struct {`
- L107: `    ParameterDefinitions *fields.Definitions`
- L108: `    ChildLayers          []ParameterLayer`
- L115: `- Layers group related parameters (e.g., "default" for command-specific params, "glazed" for output formatting)`
- L116: `- Each layer has a slug (unique identifier), name, description, and optional prefix`
- L117: `- Layers can be added to Cobra commands, which creates flags automatically`
- L118: `- Layers support nested/child layers for hierarchical organization`
- L120: `### 3. Parsed Layers`
- L122: `**Location**: `glazed/pkg/cmds/layers/parsed-layer.go``
- L125: `- `ParsedLayer`: Runtime values for a single layer`
- L126: `- `ParsedLayers`: Ordered map of ParsedLayer objects`
- L129: `- `InitializeStruct()`: Populates a struct from parsed layer values`
- L130: `- `GetOrCreate()`: Gets or creates a parsed layer for a given ParameterLayer`
- L131: `- `Merge()`: Merges parsed layers together`
- L135: `type ParsedLayer struct {`
- L136: `    Layer      ParameterLayer`
- L137: `    Parameters *parameters.ParsedParameters`
- L140: `type ParsedLayers struct {`
- L141: `    *orderedmap.OrderedMap[string, *ParsedLayer]`
- L144: `func (p *ParsedLayers) InitializeStruct(layerKey string, dst interface{}) error`
- L148: `- ParsedLayers contain the actual runtime values after parsing`
- L149: `- Each ParsedLayer is linked to its ParameterLayer definition`
- L150: `- Values are stored in ParsedParameters (map of name -> ParsedParameter)`
- L155: `**Location**: `glazed/pkg/cmds/parameters/initialize-struct.go``
- L158: `- `InitializeStruct()`: Main function that populates structs from ParsedParameters`
- L163: `glazed:"parameter-name"           // Basic parameter mapping`
- L164: `glazed:"parameter-name,from_json" // Parse JSON from string value`
- L170: `func (p *ParsedParameters) InitializeStruct(s interface{}) error`
- L175: `- Struct fields tagged with `glazed:"name"` are populated from ParsedParameters`
- L176: `- The tag name must match a parameter name in the ParsedParameters`
- L177: `- Supports wildcards for map fields (e.g., `glazed:"env.*"` matches all `env.*` parameters)`
- L186: `- `HandlerFunc`: Function type `func(*ParameterLayers, *ParsedLayers) error``
- L192: `- `LoadParametersFromFiles()`: Loads values from JSON/YAML config files`
- L193: `- `SetFromDefaults()`: Sets default values from ParameterDefinitions (lowest priority)`
- L202: `    layers_ *schema.Schema,`
- L203: `    parsedLayers *values.Values,`
- L211: `- Middlewares modify `ParsedLayers` by merging new values`
- L219: `- `load-parameters-from-json.go`: Config file loading middleware`
- L220: `- `layers.go`: Layer manipulation middlewares`
- L228: `- `CobraParser`: Parser that converts ParameterLayers to Cobra commands`
- L233: `- `NewCobraParserFromLayers()`: Creates parser from ParameterLayers`
- L234: `- `AddToCobraCommand()`: Adds layer flags to a Cobra command`
- L235: `- `Parse()`: Executes middlewares and returns ParsedLayers`
- L241: `    Layers              *schema.Schema`
- L243: `    shortHelpLayers     []string`
- L244: `    skipCommandSettingsLayer bool`
- L245: `    enableProfileSettingsLayer bool`
- L246: `    enableCreateCommandSettingsLayer bool`
- L250: `    parsedCommandLayers *values.Values,`
- L256: `    parsedCommandLayers *values.Values,`
- L263: `- `CobraParser` bridges ParameterLayers to Cobra commands`
- L264: `- `AddToCobraCommand()` iterates through layers and adds flags via `AddLayerToCobraCommand()``
- L265: `- `Parse()` executes the middleware chain to populate ParsedLayers`
- L298: `- Creates CobraParser from command's ParameterLayers`
- L300: `- Sets up Run function that parses layers and calls command's Run method`
- L307: `1. **Define Parameters**: Create `ParameterDefinition` objects manually`
- L308: `2. **Create Layers**: Group parameters into `ParameterLayer` objects`
- L309: `3. **Add to Command**: Attach layers to `CommandDescription``
- L311: `5. **Parse**: Execute middleware chain to populate `ParsedLayers``
- L312: `6. **Extract**: Call `parsedLayers.InitializeStruct()` to populate settings struct`
- L324: `### Parameter Definitions`
- L325: `- **File**: `glazed/pkg/cmds/parameters/parameters.go``
- L326: `- **Types**: `ParameterDefinition`, `ParameterDefinitions`, `ParameterType``
- L327: `- **Functions**: `NewParameterDefinition()`, `InitializeDefaultsFromStruct()``
- L330: `- **File**: `glazed/pkg/cmds/parameters/initialize-struct.go``
- L334: `### Layers`
- L335: `- **File**: `glazed/pkg/cmds/layers/layer.go`, `layer-impl.go``
- L336: `- **Types**: `ParameterLayer`, `ParameterLayerImpl`, `ParameterLayers``
- L338: `- **Functions**: `NewParameterLayer()`, `AddLayerToCobraCommand()``
- L340: `### Parsed Layers`
- L341: `- **File**: `glazed/pkg/cmds/layers/parsed-layer.go``
- L342: `- **Types**: `ParsedLayer`, `ParsedLayers``
- L353: `- **File**: `glazed/pkg/cmds/middlewares/load-parameters-from-json.go``
- L354: `- **Functions**: `LoadParametersFromFiles()``
- L359: `- **Functions**: `NewCobraParserFromLayers()`, `AddToCobraCommand()`, `Parse()``
- L363: `- **Functions**: `NewCommandSettingsLayer()`, `NewProfileSettingsLayer()``
- L366: `### Settings Layers`
- L367: `- **File**: `glazed/pkg/settings/glazed_layer.go``
- L368: `- **Types**: `GlazedParameterLayers``
- L369: `- **Functions**: `NewGlazedParameterLayers()``
- L373: `### How Structs Map to Parameters`
- L375: `1. **Struct ‚Üí ParameterDefinitions**: `
- L377: `   - Infer parameter type from Go type (int ‚Üí ParameterTypeInteger, string ‚Üí ParameterTypeString)`
- L378: `   - Create `ParameterDefinition` for each tagged field`
- L379: `   - Use field name as parameter name (or tag value if specified)`
- L381: `2. **ParameterDefinitions ‚Üí Layers**:`
- L382: `   - Group parameters by struct (one struct = one layer)`
- L383: `   - Or use nested structs to create multiple layers`
- L386: `3. **Layers ‚Üí Cobra Flags**:`
- L387: `   - `ParameterLayerImpl.AddLayerToCobraCommand()` iterates through ParameterDefinitions`
- L388: `   - Calls `ParameterDefinitions.AddParametersToCobraCommand()``
- L391: `4. **Cobra Flags ‚Üí ParsedLayers**:`
- L393: `   - Creates `ParsedParameter` objects with values`
- L394: `   - Merges into appropriate `ParsedLayer``
- L396: `5. **ParsedLayers ‚Üí Struct**:`
- L398: `   - Looks up parameter value in ParsedParameters`
- L407: `// Executes as: m1(m2(m3(handler)))(layers, parsedLayers)`
- L411: `1. `SetFromDefaults()` - Set defaults from ParameterDefinitions`
- L412: `2. `LoadParametersFromFiles()` - Load from config files`
- L421: `{PREFIX}_{LAYER_PREFIX}{PARAMETER_NAME}`
- L426: `- `LAYER_PREFIX`: Layer prefix (e.g., "db-")`
- L427: `- `PARAMETER_NAME`: Parameter name (e.g., "host")`
- L441: `1. **Manual Layer Creation**: Must create `ParameterLayer` objects and add `ParameterDefinition`s`
- L445: `5. **Layer Slugs**: Must manage layer slugs manually (though `DefaultSlug` helps)`
- L449: `1. **Auto-generate Layers**: Derive layers from struct types automatically`
- L450: `2. **Auto-generate ParameterDefinitions**: Infer from struct fields and tags`
- L453: `5. **Type Inference**: Infer parameter types from Go types automatically`
- L454: `6. **Nested Struct Support**: Support nested structs as separate layers automatically`
- L459: `2. Implement struct-to-layer conversion`
- L460: `3. Implement struct-to-parameter conversion`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/changelog.md`
- L15: `- Reset CONFIG-PARSER-001 direction: added new `appconfig.Parser` design doc (register layers + tagged structs, configurable Parse middlewares) + a detailed redesign diary; marked the prior struct-first design as superseded`
- L26: `- /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/pkg/appconfig/parser.go ‚Äî New Parser[T] type with Register + Parse using runner.ParseCommandParameters`
- L40: `Step 3: Introduce appconfig.LayerSlug to encourage const slugs (commit 91b10b2)`
- L44: `- /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/pkg/appconfig/parser.go ‚Äî Added LayerSlug type + Register now takes LayerSlug`
- L53: `- /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/cmd/examples/appconfig-parser/main.go ‚Äî Demonstrates const LayerSlug`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/design-doc/01-design-struct-first-configparser-api-on-top-of-glazed.md`
- L17: `    - Path: glazed/pkg/cmds/middlewares/load-parameters-from-json.go`
- L22: `      Note: Env var precedence and env key naming (layer prefix + param name)`
- L24: `      Note: runner.ParseCommandParameters currently lacks config-mapper option (design C2)`
- L31: `    - Path: glazed/ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/analysis/01-glazed-parameter-parsing-architecture-analysis.md`
- L32: `      Note: Architecture analysis of Glazed parameter parsing system`
- L36: `Summary: Propose a struct-first ConfigParser API that hides Glazed layers/middlewares while still using them internally (flags/env/config files ‚Üí ParsedLayers ‚Üí typed structs).`
- L43: `This design doc reflects an earlier direction for CONFIG-PARSER-001 (‚Äústruct-first schema + mapping‚Äù). The ticket has since been reset toward an incremental **`appconfig.Parser`** design (explicit layer + settings struct registration, configurable Parse middlewares, `Parse() -> T`).`
- L45: `Current design: `design-doc/02-design-appconfig-module-register-layers-and-parse.md`.`
- L51: `- define `ParameterDefinition`s,`
- L52: `- create `ParameterLayer`s,`
- L54: `- and then hydrate typed settings structs from `ParsedLayers`.`
- L73: `- **G2: Hide Glazed plumbing**: app code should not have to touch `ParameterDefinition`, `ParameterLayer`, `Middleware`, or `ParsedLayers`.`
- L93: `- **Definitions / layers / parsing**:`
- L94: `  - `glazed/pkg/cmds/parameters` (`ParameterDefinition`, `ParameterDefinitions`)`
- L95: `  - `glazed/pkg/cmds/layers` (`ParameterLayer`, `ParameterLayers`, `ParsedLayers`)`
- L96: `  - `glazed/pkg/cmds/middlewares` (`SetFromDefaults`, `UpdateFromEnv`, `LoadParametersFromFiles`, `ParseFromCobraCommand`, ‚Ä¶)`
- L98: `  - `glazed/pkg/cmds/middlewares` `ConfigMapper` interface (hook used by `LoadParametersFromFiles`)`
- L110: `- builds Glazed layers from schemas,`
- L112: `- calls `Parse(parsedLayers)` to hydrate typed structs,`
- L155: `- ‚ÄúNo layers‚Äù is an ergonomic goal. Internally we will still build layers because Glazed needs them to:`
- L157: `  - keep parameter namespaces separated,`
- L158: `  - and record parse logs with layer/parameter metadata.`
- L162: `### D1: Layering model (internal)`
- L166: `1) **One layer for everything** (flat parameter namespace)`
- L167: `   - parameter names become ‚Äúflattened paths‚Äù like `tools-redis-host``
- L170: `2) **One layer per settings struct** (recommended)`
- L171: `   - each ‚Äúsub-settings struct‚Äù becomes a layer (slug derived from field name or path)`
- L172: `   - parameters are leaf keys (`host`, `port`, ‚Ä¶) within that layer`
- L173: `   - flags/env are namespaced using `layer.Prefix` (e.g. `tools-redis-`)`
- L178: `- Glazed‚Äôs own env logic (`layerPrefix + paramName`),`
- L185: `- **ParameterDefinition.Name**: kebab-case leaf key (derived from Go field name unless overridden)`
- L186: `- **Flag name**: `layerPrefix + paramName``
- L187: `- **Env var name**: `ENV_PREFIX + "_" + upper(snake(layerPrefix+paramName))``
- L188: `- **Config key name**: leaf key under the struct‚Äôs config path, without layer prefix (e.g. `tools.redis.host`)`
- L209: `  - target: `(layerSlug, leafName)``
- L214: `- and **must ignore** `layer.Prefix` (flag/env namespace).`
- L234: `- profile selection must be known before the profile-specific files/layers are decided.`
- L243: `## Modify existing Glazed vs layer on top (recommendations)`
- L253: `- **C2: Add a `WithConfigMapper`-style option in `cmds/runner.ParseCommandParameters`**`
- L254: `  - runner currently only supports ‚Äúlayer-map‚Äù config files; nested YAML requires additional middlewares`
- L262: `- **R1: Clarify naming of `layer.Prefix`**`
- L275: `  - derives layers from structs`
- L277: `  - uses `LoadParametersFromFiles(..., WithConfigMapper(...))` for nested config`
- L286: `  - implement ConfigParser on top of `cli.CobraParser` and/or `runner.ParseCommandParameters``
- L294: `  - modify `patternmapper` to treat `layer.Prefix` as external only`
- L304: `- add small extension points to `cli.CobraParserConfig` and `runner.ParseCommandParameters`,`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/design-doc/02-design-appconfig-module-register-layers-and-parse.md`
- L2: `Title: "Design: appconfig.Parser (register layers + settings structs, configurable Parse middlewares)"`
- L16: `      Note: ParseCommandParameters + ParseOption pattern (configures middleware chain for Parse)`
- L19: `    - Path: glazed/pkg/cmds/parameters/initialize-struct.go`
- L20: `      Note: ParsedLayers.InitializeStruct hydration path used by v1 (glazed tags)`
- L24: `Summary: "Propose an appconfig.Parser API that is instantiated with a grouped AppSettings struct type T, lets callers register (settings struct ‚Üî ParameterLayer) pairs, configures parsing middlewares via options, and exposes Parse() that returns a filled T."`
- L34: `- It does **not** attempt to derive layers from structs yet.`
- L36: `  - register `ParameterLayer`s and their corresponding typed settings structs,`
- L43: `- **G2: Registration**: register `(settings struct ‚Üî ParameterLayer)` pairs.`
- L44: `  - ‚ÄúStruct-first layer generation‚Äù is **explicitly deferred**.`
- L47: `- **G5: Minimal Glazed surface in app code**: only bootstrap-level code should import Glazed/layers/middlewares.`
- L51: `- **NG1**: automatic struct ‚Üí ParameterDefinition/Layer derivation (postponed).`
- L84: `We register a `ParameterLayer` and how to hydrate into `T`.`
- L92: `  "redis", redisLayer,`
- L100: `- In v1, the pointed-to struct is expected to use `glazed` tags (or whatever `ParsedLayers.InitializeStruct` requires today).`
- L104: `- `RegisterLayer(slug string, layer schema.Section, bind func(*T) any)``
- L107: `  - `Layer schema.Section``
- L120: `1. Build a `schema.Schema` collection from all registered layers.`
- L121: `2. Execute a middleware chain (configured via options) to populate `ParsedLayers`.`
- L123: `   - call `parsedLayers.InitializeStruct(reg.Slug, reg.Bind(&t))``
- L137: `- (values-for-layers / programmatic overrides) ‚Äî optional, if we include it`
- L143: `We should leverage the existing `cmds/runner.ParseCommandParameters` ParseOption pattern:`
- L148: `- `runner.WithValuesForLayers(...)``
- L153: `   - Build a tiny ‚Äúcommand stub‚Äù whose `Description().Layers` are the registered layers.`
- L154: `   - Call `runner.ParseCommandParameters(stubCmd, runnerOptions...)`.`
- L157: `   - Call `cmd_sources.Execute(layers, parsedLayers, middlewares...)` directly.`
- L166: `- `ParsedLayers.InitializeStruct(layerSlug, destStructPtr)``
- L168: `This implies (based on how `ParsedParameters.InitializeStruct` is implemented today):`
- L172: `- and missing parameters are currently **skipped** (no error; field stays at zero value).`
- L182: `- `slug` uniqueness (no duplicate layer slugs).`
- L183: `- `layer` non-nil.`
- L190: `  - layer slug, and`
- L191: `  - a hint that tags/parameter names may not match.`
- L197: `2. **Do we include a ‚Äúvalues-for-layers‚Äù programmatic override** in v1?`
- L198: `3. **Do we accept ‚Äúraw ParsedLayers escape hatch‚Äù** (probably no, but maybe for debugging)?`
- L209: `- `Register(slug, layer, bind)``

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/index.md`
- L16: `      Note: CobraParser bridging ParameterLayers to Cobra commands`
- L19: `    - Path: glazed/pkg/cmds/layers/layer-impl.go`
- L20: `      Note: Standard ParameterLayerImpl implementation`
- L21: `    - Path: glazed/pkg/cmds/layers/layer.go`
- L22: `      Note: ParameterLayer interface and ParameterLayers collection`
- L23: `    - Path: glazed/pkg/cmds/layers/parsed-layer.go`
- L24: `      Note: ParsedLayer and ParsedLayers runtime value containers`
- L31: `    - Path: glazed/pkg/cmds/parameters/initialize-struct.go`
- L33: `    - Path: glazed/pkg/cmds/parameters/parameters.go`
- L34: `      Note: Core parameter definition types and functions`
- L38: `      Note: Example of current complex setup requiring manual layer and middleware configuration`
- L39: `    - Path: glazed/ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/analysis/01-glazed-parameter-parsing-architecture-analysis.md`
- L41: `        Comprehensive analysis of Glazed parameter parsing architecture - documents all components`
- L64: `- `analysis/01-glazed-parameter-parsing-architecture-analysis.md`: Glazed architecture ‚Äúhealth inspection‚Äù`
- L68: `- `design-doc/02-design-appconfig-module-register-layers-and-parse.md`: **current** proposed `appconfig.Parser` API (register layers + tagged structs, Parse() returns `T`)`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/01-diary.md`
- L24: `Document the exploration and analysis of Glazed's parameter parsing architecture to understand how to build a simplified API that maps struct tags directly to configuration sources without requiring manual layer and middleware setup.`
- L28: `This step involved systematically exploring the Glazed codebase to understand how parameter definitions, layers, middlewares, and Cobra integration work together. The goal was to map out all the locations involved in the parameter parsing system so we can design a simplified API that hides this complexity behind a struct-tag-based interface.`
- L36: `   - Created analysis document: `analysis/01-glazed-parameter-parsing-architecture-analysis.md``
- L40: `   - Searched for "How are parameter definitions created and registered in glazed?"`
- L41: `   - Searched for "How are parameter layers defined and used in glazed?"`
- L43: `   - Searched for "How does InitializeStruct parse parameters from ParsedLayers into struct fields?"`
- L44: `   - Searched for "How are struct fields with glazed tags converted into ParameterDefinitions?"`
- L47: `   - `glazed/pkg/cmds/parameters/parameters.go` - ParameterDefinition types and creation`
- L48: `   - `glazed/pkg/cmds/layers/layer.go` - ParameterLayer interface`
- L49: `   - `glazed/pkg/cmds/layers/layer-impl.go` - Standard layer implementation`
- L50: `   - `glazed/pkg/cmds/layers/parsed-layer.go` - ParsedLayer runtime values`
- L51: `   - `glazed/pkg/cmds/parameters/initialize-struct.go` - Struct tag parsing`
- L55: `   - `glazed/pkg/cli/cobra-parser.go` - CobraParser bridging layers to Cobra`
- L57: `   - `glazed/pkg/cli/cli.go` - Command settings layers`
- L65: `   - Mapped out all core components (ParameterDefinitions, Layers, ParsedLayers, Middlewares)`
- L66: `   - Documented data flow from struct tags ‚Üí ParameterDefinitions ‚Üí Layers ‚Üí Cobra ‚Üí ParsedLayers ‚Üí structs`
- L73: `- Creating ParameterDefinitions`
- L74: `- Grouping into Layers`
- L83: `4. How struct tags currently map to parameters`
- L95: `- **Missing file**: Tried to read `glazed/pkg/cmds/parameters/initialize-defaults.go` but it doesn't exist (functionality is in `parameters.go`)`
- L96: `- **No direct struct-to-parameter conversion**: Found `InitializeDefaultsFromStruct()` which goes struct ‚Üí ParameterDefinition defaults, but not the reverse (struct ‚Üí ParameterDefinition creation)`
- L100: `1. **Four-layer architecture**:`
- L101: `   - ParameterDefinitions (specifications)`
- L102: `   - ParameterLayers (groupings)`
- L103: `   - ParsedLayers (runtime values)`
- L107: `   - `InitializeDefaultsFromStruct()`: struct ‚Üí ParameterDefinition defaults`
- L108: `   - `InitializeStruct()`: ParsedParameters ‚Üí struct fields`
- L109: `   - But there's no automatic struct ‚Üí ParameterDefinition creation (must be done manually)`
- L117: `   - `{PREFIX}_{LAYER_PREFIX}{PARAMETER_NAME}` all uppercase, hyphens ‚Üí underscores`
- L118: `   - Example: `PINOCCHIO_DB_HOST` for `db-host` parameter with `PINOCCHIO` prefix`
- L121: `   - Converts ParameterLayers to Cobra commands`
- L122: `   - Executes middleware chain to populate ParsedLayers`
- L123: `   - Handles command settings layer (print-yaml, print-parsed-parameters, etc.)`
- L126: `   - Must manually create ParameterLayer objects`
- L127: `   - Must manually add ParameterDefinitions to layers`
- L130: `   - Multiple steps required: define ‚Üí layer ‚Üí command ‚Üí parse ‚Üí extract`
- L135: `- **Tracing data flow**: Following values from struct tags ‚Üí ParameterDefinitions ‚Üí Layers ‚Üí Cobra flags ‚Üí ParsedLayers ‚Üí back to structs required reading multiple files`
- L136: `- **Finding where struct-to-parameter conversion happens**: It doesn't exist! You must manually create ParameterDefinitions, though defaults can be set from structs`
- L137: `- **Understanding layer slugs**: The concept of slugs vs. names vs. prefixes wasn't immediately clear from the interface`
- L144: `- **Struct-to-parameter conversion**: Is there existing code that does this that I missed?`
- L148: `- **Implement struct-to-parameter conversion**: Create a function that scans struct fields with `glazed` tags and automatically creates ParameterDefinitions`
- L149: `- **Auto-generate layers from structs**: Derive ParameterLayers from struct types (one struct = one layer, or nested structs = nested layers)`
- L156: `- **Start with**: `analysis/01-glazed-parameter-parsing-architecture-analysis.md` for the complete overview`
- L158: `  - `glazed/pkg/cmds/parameters/parameters.go` - Understand ParameterDefinition structure`
- L159: `  - `glazed/pkg/cmds/layers/layer-impl.go` - See how layers work`
- L162: `- **Validate understanding**: Read `pinocchio/cmd/pinocchio/main.go` and trace how it sets up layers and middlewares`
- L168: `1. **Query**: "How are parameter definitions created and registered in glazed?"`
- L170: `     - `glazed/pkg/cmds/parameters/parameters.go` (lines 1-687): Found `ParameterDefinition` struct, `NewParameterDefinition()` function, `ParameterDefinitions` ordered map`
- L171: `     - `glazed/pkg/codegen/glazed.go`: Found `ParameterDefinitionToDict()` showing how definitions are used in codegen`
- L172: `     - `glazed/pkg/doc/topics/commands-reference.md`: Found documentation on parameter types and definitions`
- L173: `   - **Key findings**: ParameterDefinitions are created via `NewParameterDefinition()` with options pattern. They're stored in `ParameterDefinitions` ordered map. No automatic registration - must be manually added to layers.`
- L175: `2. **Query**: "How are parameter layers defined and used in glazed?"`
- L177: `     - `glazed/pkg/cmds/layers/layer.go` (lines 1-80): Found `ParameterLayer` interface, `ParameterLayers` collection, `DefaultSlug` constant`
- L178: `     - `glazed/pkg/cmds/layers/layer-impl.go` (lines 1-280): Found `ParameterLayerImpl` struct, `NewParameterLayer()` function, `AddLayerToCobraCommand()` method`
- L179: `     - `glazed/pkg/doc/topics/13-layers-and-parsed-layers.md`: Found documentation on layer creation and usage`
- L180: `     - `glazed/pkg/settings/glazed_layer.go`: Found `GlazedParameterLayers` showing how multiple layers are composed`
- L181: `   - **Key findings**: Layers group ParameterDefinitions. Created via `NewParameterLayer()` with options. Can be added to Cobra commands. Support prefixes and nested child layers.`
- L192: `4. **Query**: "How does InitializeStruct parse parameters from ParsedLayers into struct fields?"`
- L194: `     - `glazed/pkg/cmds/parameters/initialize-struct.go` (lines 1-497): Found `InitializeStruct()` function, `parsedTagOptions()` function, wildcard support, JSON parsing support`
- L195: `     - `glazed/pkg/cmds/layers/parsed-layer.go` (lines 69-212): Found `ParsedLayer.InitializeStruct()` method, `ParsedLayers.InitializeStruct()` method with layer key`
- L196: `     - `glazed/pkg/cmds/parameters/parameters.go` (lines 315-391): Found `InitializeDefaultsFromStruct()` showing reverse direction (struct ‚Üí ParameterDefinition defaults)`
- L197: `   - **Key findings**: `InitializeStruct()` reads `glazed` tags, looks up values in ParsedParameters, sets struct fields via reflection. Supports wildcards for maps, `from_json` option for JSON parsing. Called via `parsedLayers.InitializeStruct(layerKey, struct)`.`
- L199: `5. **Query**: "How are struct fields with glazed tags converted into ParameterDefinitions?"`
- L201: `     - `glazed/pkg/cmds/parameters/initialize-struct.go` (lines 441-497): Found `StructToDataMap()` function showing struct ‚Üí map conversion`
- L202: `     - `glazed/pkg/cmds/parameters/parameters.go` (lines 315-391): Found `InitializeDefaultsFromStruct()` which sets ParameterDefinition defaults from structs, but NOT creation`
- L203: `     - `glazed/pkg/settings/glazed_layer.go` (lines 193-212): Found `InitializeParameterDefaultsFromStruct()` showing layer-level struct initialization`
- L204: `   - **Key findings**: **No automatic conversion exists!** `InitializeDefaultsFromStruct()` only sets defaults on existing ParameterDefinitions. Must manually create ParameterDefinitions, then can set defaults from structs. This is a key gap for the simplified API.`
- L213: `    - `load-parameters-from-json.go`: Config file loading middlewares`
- L214: `    - `layers.go`: Layer manipulation middlewares`
- L218: `1. **`glazed/pkg/cmds/parameters/parameters.go`** (read lines 1-687):`
- L219: `   - `ParameterDefinition` struct has: Name, Type, Help, Default, Choices, Required, IsArgument`
- L220: `   - `NewParameterDefinition()` uses functional options pattern`
- L221: `   - `InitializeDefaultsFromStruct()` reads struct fields with `glazed` tags and sets ParameterDefinition defaults`
- L223: `   - Parameter types include: String, Integer, Bool, File, Choice, Date, KeyValue, etc.`
- L225: `2. **`glazed/pkg/cmds/layers/layer.go`** (read lines 1-80):`
- L226: `   - `ParameterLayer` interface defines: AddFlags(), GetParameterDefinitions(), GetSlug(), GetName(), GetPrefix()`
- L227: `   - `ParameterLayers` is an ordered map of layers`
- L228: `   - `DefaultSlug = "default"` constant for command-specific parameters`
- L229: `   - Layers can be subsetted, cloned, iterated`
- L231: `3. **`glazed/pkg/cmds/layers/layer-impl.go`** (read lines 1-280):`
- L232: `   - `ParameterLayerImpl` is the standard implementation`
- L233: `   - `NewParameterLayer()` creates layers with options (WithPrefix, WithParameterDefinitions, etc.)`
- L234: `   - `AddLayerToCobraCommand()` adds all layer flags to Cobra command`
- L235: `   - `ParseLayerFromCobraCommand()` extracts values from Cobra flags`
- L236: `   - `InitializeParameterDefaultsFromStruct()` sets layer parameter defaults from struct`
- L238: `4. **`glazed/pkg/cmds/layers/parsed-layer.go`** (read lines 69-212):`
- L239: `   - `ParsedLayer` contains: Layer (reference), Parameters (ParsedParameters map)`
- L240: `   - `ParsedLayers.InitializeStruct(layerKey, struct)` extracts values into struct`
- L241: `   - `GetOrCreate()` gets or creates a ParsedLayer for a ParameterLayer`
- L242: `   - `Merge()` merges parsed layers together`
- L244: `5. **`glazed/pkg/cmds/parameters/initialize-struct.go`** (read lines 1-497):`
- L245: `   - `InitializeStruct()` is the main function that populates structs from ParsedParameters`
- L253: `   - `HandlerFunc` is `func(*ParameterLayers, *ParsedLayers) error``
- L261: `   - `LoadParametersFromResolvedFilesForCobra()` loads from config files via resolver`
- L262: `   - `GatherFlagsFromViper()` is deprecated (use LoadParametersFromFiles + UpdateFromEnv)`
- L265: `   - `UpdateFromEnv(prefix)` reads environment variables with naming: `{PREFIX}_{LAYER_PREFIX}{PARAM_NAME}``
- L267: `   - `SetFromDefaults()` sets defaults from ParameterDefinitions`
- L271: `   - `CobraParser` bridges ParameterLayers to Cobra commands`
- L272: `   - `NewCobraParserFromLayers()` creates parser with config`
- L273: `   - `AddToCobraCommand()` adds all layer flags to Cobra command`
- L274: `   - `Parse()` executes middleware chain and returns ParsedLayers`
- L285: `    - `NewCommandSettingsLayer()` creates layer for debug flags (print-yaml, print-parsed-parameters, etc.)`
- L286: `    - `NewProfileSettingsLayer()` creates layer for profile selection`
- L290: `    - Shows complex setup: loading repositories, creating directories, setting up layers`
- L292: `    - Uses `cli.WithProfileSettingsLayer()` to enable profile support`
- L296: `- `ParameterDefinition` - Core parameter spec`
- L297: `- `ParameterLayer` - Interface for grouping parameters`
- L298: `- `ParameterLayerImpl` - Standard implementation`
- L299: `- `ParsedLayer` - Runtime values container`
- L302: `- `InitializeStruct()` - Populates structs from ParsedParameters`
- L303: `- `InitializeDefaultsFromStruct()` - Sets ParameterDefinition defaults from structs`
- L307: `Struct with tags ‚Üí ParameterDefinitions ‚Üí ParameterLayers ‚Üí Cobra Command`
- L309: `                                                           ParsedLayers`
- L317: `1. `SetFromDefaults()` - ParameterDefinition defaults`
- L318: `2. `LoadParametersFromFiles()` - Config files`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/02-research-brainstorm-new-config-api-diary.md`
- L18: `      Note: ConfigMapper interface used by LoadParametersFromFiles`
- L19: `    - Path: glazed/pkg/cmds/middlewares/load-parameters-from-json.go`
- L25: `    - Path: glazed/pkg/cmds/parameters/cobra.go`
- L26: `      Note: How ParameterDefinitions become Cobra flags (constraints for naming scheme)`
- L27: `    - Path: glazed/pkg/cmds/parameters/initialize-struct.go`
- L29: `    - Path: glazed/pkg/cmds/parameters/parameters.go`
- L30: `      Note: ParameterDefinition/ParameterType core primitives`
- L32: `      Note: Programmatic parsing (ParseCommandParameters) we can reuse for struct-first API`
- L43: `    - Path: moments/backend/pkg/appconfig/layers.go`
- L44: `      Note: BuildLayers schema->Glazed layers mapping`
- L48: `      Note: Parse(parsed) hydrates typed structs from ParsedLayers via schema`
- L65: `Produce a deeply technical analysis of how the Slack-proposed API could be implemented on top of Glazed, whether we should **change existing Glazed APIs** vs **layer on top**, and what (if anything) could be renamed/repackaged for approachability.`
- L76: `- Subsystems should receive **typed settings structs**, not a config registry, not Glazed layers, and not `ParsedLayers`.`
- L112: `- No explicit layer slugs in app code.`
- L122: `  - derive stable parameter names for flags/env (kebab/SCREAMING_SNAKE),`
- L124: `  - map nested config structures into Glazed‚Äôs internal layer/parameter updates (probably via `ConfigMapper` + `patternmapper`).`
- L131: `The Slack API can be implemented **mostly by layering**:`
- L134: `  - `glazed/pkg/cmds/runner.ParseCommandParameters` for programmatic parsing.`
- L136: `  - `glazed/pkg/cmds/parameters` for type parsing and validation.`
- L138: `  - generates `ParameterDefinitions` and `ParameterLayers` from `T`,`
- L156: `  - `glazed/pkg/cmds/middlewares/load-parameters-from-json.go``
- L161: `  - `glazed/pkg/cmds/parameters/*``
- L186: `- `ParseCommandParameters(cmd, ...)` already exists and is essentially ‚Äú`NewConfigParser().Parse()` for a Glazed `cmds.Command`‚Äù.`
- L193: `- `ParseCommandParameters(cmd cmds.Command, options ...ParseOption) (*values.Values, error)``
- L196: `- `WithValuesForLayers(values map[string]map[string]interface{})``
- L200: `- The parsing order inside `ParseCommandParameters` is assembled as:`
- L204: `  - values-for-layers (if any)`
- L215: `Read file: `glazed/pkg/cmds/middlewares/load-parameters-from-json.go``
- L219: `- `LoadParametersFromFiles(files []string, options ...ConfigFileOption) Middleware``
- L225: `- The config file loader expects default ‚Äúlayer map‚Äù structure:`
- L228: `layer-slug:`
- L229: `  parameter-name: value`
- L232: `- BUT it can accept a custom mapper (`ConfigMapper`) which transforms arbitrary config structure ‚Üí `map[layerSlug]map[paramName]value`.`
- L260: `- `type MappingRule struct { Source, TargetLayer, TargetParameter string; Rules []MappingRule; Required bool }``
- L261: `- `NewConfigMapper(layers *schema.Schema, rules ...MappingRule) (middlewares.ConfigMapper, error)``
- L263: `- `LoadMapperFromFile(layers, filename)` and mapping file schema (snake_case keys)`
- L271: `- Target parameters can reference captures: `"{env}-api-key"`.`
- L277: `  - `TargetLayer: <internal-layer-slug>``
- L278: `  - `TargetParameter: <flattened-flag-name>` (e.g., `tools-redis-host`)`
- L306: `- The ‚Äúdefault middlewares func‚Äù created in `NewCobraParserFromLayers` already wires:`
- L313: `- `FromConfigFile([...])` ‚Üí `LoadParametersFromResolvedFilesForCobra``
- L321: `- The combination of `LoadParametersFromFiles` + `ConfigMapper` + `patternmapper` is exactly the kind of extension point we need.`
- L325: `- There is **no** existing ‚Äústruct ‚Üí ParameterDefinitions + bindings‚Äù builder.`
- L326: `  - There *is* `InitializeDefaultsFromStruct` (struct ‚Üí defaults), but it requires ParameterDefinitions to already exist.`
- L342: `1. **Config file format mismatch**: most users historically have flat config; Glazed prefers layer-based config unless you provide a mapper.`
- L377: `   - One internal layer (‚Äúconfig‚Äù) with flattened param names (simplest)?`
- L378: `   - Multiple layers per subsystem struct (better help grouping)?`
- L392: `- Find whether any other packages (Clay/Pinocchio/Geppetto) already have ‚Äústruct-to-parameters‚Äù helpers we can reuse.`
- L428: `- `WhitelistLayersHandler`, `WhitelistLayerParametersHandler``
- L429: `- `WrapWithWhitelistedLayers(...)``
- L430: `- `WrapWithWhitelistedParameterLayers(...)``
- L434: `- We can execute a subset of middlewares only on a subset of layers/parameters by cloning layers and running a nested chain.`
- L455: `## Step 5: Search for existing ‚Äústruct ‚Üí ParameterDefinitions‚Äù generators and name-casing helpers`
- L459: `1. infer `ParameterType` from Go field types,`
- L460: `2. generate stable, human-friendly parameter names (kebab/snake),`
- L465: `#### 5.1 Search: ‚Äúgenerate ParameterDefinitions from struct‚Äù`
- L467: `Search question (semantic): ‚ÄúIs there any code that generates glazed parameters or ParameterDefinitions from a Go struct type using reflection?‚Äù`
- L471: `- No existing dedicated ‚Äústruct ‚Üí ParameterDefinitions‚Äù builder was found.`
- L473: `  - `glazed/pkg/cmds/parameters/initialize-struct.go` (`InitializeStruct`, `StructToDataMap`)`
- L485: `#### 5.3 Read: parameter type system (needed for type inference)`
- L489: `- `glazed/pkg/cmds/parameters/parameter-type.go``
- L490: `- `glazed/pkg/cmds/parameters/parse.go` (beginning section)`
- L494: `- `ParameterTypeString` ‚Üí `string``
- L495: `- `ParameterTypeInteger` ‚Üí `int``
- L496: `- `ParameterTypeFloat` ‚Üí `float64``
- L497: `- `ParameterTypeBool` ‚Üí `bool``
- L498: `- `ParameterTypeDate` ‚Üí `time.Time``
- L499: `- `ParameterTypeStringList` ‚Üí `[]string``
- L500: `- `ParameterTypeIntegerList` ‚Üí `[]int``
- L501: `- `ParameterTypeFloatList` ‚Üí `[]float64``
- L511: `- Avoid dots in **parameter names** (env vars); use nested YAML + mapper to bridge to dashed keys.`
- L518: `- In *most* of Glazed, `layer.Prefix` is used to prefix **flag names** and **env keys**, while parameter names stay unprefixed inside the layer.`
- L519: `- In the pattern mapper, the implementation and tests strongly imply that a layer prefix is part of the **canonical parameter name** and should be prepended to the target parameter.`
- L521: `If we get this wrong in the new API, config-file loading will silently fail (values mapped to wrong parameter names), or flags/env will get ‚Äúdouble prefixes‚Äù.`
- L527: `- Search (grep): `TestLayerPrefix|PrefixAware|WithPrefix\\("``
- L529: `  - `glazed/pkg/cmds/middlewares/patternmapper/pattern_mapper_edge_cases_test.go` (`TestLayerPrefix`)`
- L532: `#### 6.2 Read: `TestLayerPrefix` evidence`
- L538: `- Layer created with prefix:`
- L539: `  - `layers.WithPrefix("demo-")``
- L540: `- Parameter definitions include the prefix in their names:`
- L542: `- Mapping rule targets unprefixed parameter name:`
- L543: `  - `TargetParameter: "api-key"``
- L544: `- Expected mapping result uses prefixed parameter key:`
- L547: `Conclusion from this test: **patternmapper assumes that if a layer has prefix `demo-`, then the canonical parameter name is `demo-<param>`**.`
- L555: `- `resolveCanonicalParameterName(layer, targetParam)` currently does:`
- L556: `  - if `layer.GetPrefix() != ""` and `targetParam` doesn‚Äôt already start with it ‚Üí return `layer.GetPrefix() + targetParam``
- L560: `- compile-time validation (‚Äúdoes target parameter exist in layer?‚Äù)`
- L569: `1) **Docs**: `glazed/pkg/doc/topics/13-layers-and-parsed-layers.md``
- L570: `   - Example creates a layer with `WithPrefix("config-")` and unprefixed parameters like `"verbose"` and `"output"`.`
- L571: `   - This strongly suggests `Prefix` is meant to affect external names (flags), not internal parameter keys.`
- L574: `   - Creates a layer with `layers.WithPrefix("demo-")` and parameter names `"api-key"` and `"threshold"` (unprefixed).`
- L575: `   - Its custom config mapper writes into the layer map using unprefixed keys:`
- L577: `   - This is consistent with how `GatherParametersFromMap(...)` expects to find keys (`pd.Name`) and how Glazed stores parsed values (`p.Name`) regardless of prefix.`
- L580: `   - Constructs env key from `layerPrefix + p.Name`, but writes the parsed value back under the logical parameter key `p.Name`.`
- L581: `   - This again implies prefix is an *external name concern*, not part of internal parameter key.`
- L598: `  - `geppetto/pkg/layers/layers.go` uses `middlewares.WithConfigFileMapper(configMapper)` with a **custom** mapper (not patternmapper) to filter out non-layer keys like `repositories`.`
- L613: `- Pattern mapper treats `layer.Prefix` as part of the canonical parameter key.`
- L614: `- The rest of Glazed treats `layer.Prefix` as an external naming prefix for flags/env.`
- L622: `1) **(Layering-only) Avoid layer prefixes** in the new API:`
- L623: `   - Encode full path into parameter names (e.g., `tools-redis-host`) and keep `layer.Prefix = ""`.`
- L625: `   - Cons: long repetitive parameter names; less nice help grouping.`
- L627: `2) **(Layering-only) Generate a custom `ConfigFileMapper`** instead of pattern rules:`
- L629: `     - `layer.Prefix = "tools-redis-"`, parameter names = `"host"`, `"port"`, ...`
- L630: `   - Generate mapper that writes unprefixed keys into the layer map:`
- L636: `   - Stop prepending `layer.GetPrefix()` to target parameter names; treat prefix as external only.`
- L637: `   - Pros: removes inconsistency; patternmapper becomes usable with prefixed layers (common case).`
- L640: `4) **(Status quo workaround) Use patternmapper only with layers that ‚Äúbake in‚Äù prefix**:`
- L641: `   - Keep `layer.Prefix` empty; define parameters as `"tools-redis-host"` etc.`
- L642: `   - This is basically option (1) but still allows multiple layers.`
- L644: `My tentative lean for the Slack API is **(2)** (custom mapper generator) or **(1)** (no layer prefix) depending on how much we value shorter internal parameter names.`
- L650: `#### 7.1 Read: Geppetto‚Äôs ‚Äúconfig mapper to exclude non-layer keys‚Äù`
- L652: `Read: `geppetto/pkg/layers/layers.go` (config file loading section)`
- L656: `- A custom config mapper function is used to skip keys like `repositories` (handled separately) and only treat map-valued keys as layers.`
- L657: `- This is done by passing `middlewares.WithConfigFileMapper(configMapper)` into `LoadParametersFromFiles`.`
- L666: `Same file (`geppetto/pkg/layers/layers.go`) contains an explicit TODO-ish comment:`
- L691: `This design is effectively realized in current `LoadParametersFromFiles`:`
- L706: `- Avoid ‚Äúdefaults in mapping rules‚Äù ‚Äî defaults should come from parameter definitions, not mapping.`
- L710: `- generate parameter-definition defaults (if it supports defaults),`
- L726: `- `parameters.ParsedParameters.InitializeStruct` already uses this helper for setting struct fields.`
- L745: `    - `backend/pkg/appconfig/{types.go,registry.go,layers.go,store.go,derive.go,...}``
- L752: `- Search (grep): `RegisterSchema[`, `BuildLayers(`, `Parse(parsed`, `Must[`, `ResetForTests`, `SetForTests``
- L764: `- `BuildLayers()` converts schemas into Glazed layers.`
- L765: `- `Parse(parsed)` hydrates all registered settings from parsed layers and stores them globally.`
- L766: `- Domain code uses `Must[T]()` and never touches `ParsedLayers`.`
- L779: `     - `Prefix string` (flag-prefix help, ‚Äúavoid naming conflicts between layers‚Äù)`
- L783: `     - either schema-based (`RegisterSchema[T]`) or legacy factory-based (`Register[T]` with layer factory)`
- L785: `3) `moments/backend/pkg/appconfig/layers.go``
- L786: `   - `BuildLayers()` builds Glazed layers from registered schemas, then includes factory-built layers.`
- L787: `   - `buildLayerFromSchema()` maps appconfig `Field` to Glazed `ParameterDefinition`.`
- L788: `   - Uses `layers.WithPrefix(s.Prefix)` if schema prefix is set.`
- L792: `     - `Parse(parsed *glazedLayers.ParsedLayers) error``
- L799: `     - then reads values from the parsed layer map and assigns via `reflect.SetReflectValue`.`
- L802: `   - It also stores a `globalParsedLayers` pointer (‚Äúescape hatch‚Äù).`
- L821: `     - `InitializeFromViper(v *viper.Viper)` builds layers, gathers values from viper via a middleware, then calls `Parse(...)`.`
- L827: `     - Then gathers per-layer values from viper under that dot-prefix.`
- L829: `       - ‚Äúlayer prefix is only for CLI flags, not config file keys‚Äù`
- L854: `1) **Schema-first config**: a Glazed-agnostic schema can be converted into Glazed layers and hydrated back into typed structs.`
- L858: `   - `layer.Prefix` is for flags (external), not for config key names (internal).`
- L866: `- **Global parsed layers escape hatch** (`Parsed()`), which reintroduces Glazed coupling in places that reach for it.`
- L868: `  - Merging YAML + env is done via Viper, then translated into parsed layers.`
- L902: `- decide a parameter naming scheme that works for **flags**, **env vars**, and **config files**,`
- L903: `- create **layers** (or fake ‚Äúno layers‚Äù but still implement layering internally),`
- L909: `### 11.2 Strong hypothesis: internal parameter names should stay unprefixed; prefixes are external`
- L913: `- Glazed‚Äôs env middleware builds env keys from `layerPrefix + p.Name` and assumes `p.Name` is the canonical key.`
- L918: `- **ParameterDefinition.Name**: canonical internal leaf name (e.g. `host`, `database`, `slack-bot-token`).`
- L919: `- **Layer.Prefix**: external namespace for flags/env keys (e.g. `redis-`, `tools-redis-`).`
- L920: `- **ConfigPath** (new concept at ConfigParser/schema layer): nested YAML path prefix (e.g. `tools.redis`).`
- L924: `Given the above, `patternmapper`‚Äôs current behavior (‚Äúexpects parameter definitions to include the prefix in their names‚Äù) is a semantic mismatch for ‚ÄúConfigPath + Prefix‚Äù systems.`
- L929: `  - `tools.redis.host` ‚Üí layer `redis`, param `host``
- L930: `  - (and ignores layer prefix entirely for config files)`
- L931: `- **Option B (upstream change)**: adjust `patternmapper` so it treats `layer.Prefix` as external-only, and never prepends it to canonical parameter names.`
- L953: `### 11.5 Cobra integration: likely needs a ‚Äúbuilder‚Äù that hides layers + parser config`
- L958: `- a way to expose generated Glazed layers + a `CobraParserConfig` to re-use `cli.BuildCobraCommandFromCommand`.`
- L963: `- and a lower-level ‚Äúexport layers + middlewares‚Äù escape hatch for advanced apps (profiles).`
- L970: `- which extra layers/flags become active.`
- L974: `- a pre-parse phase for ‚Äúearly layers‚Äù (profile selection),`
- L975: `- then a second parse phase for full layers.`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/03-colleague-quiz-cleanup-merge.md`
- L17: `    - Path: glazed/pkg/cmds/middlewares/load-parameters-from-json.go`
- L52: `1. **ParameterDefinitions / types / validation**`
- L53: `2. **ParameterLayers (slugs, prefixes, child layers)**`
- L54: `3. **ParsedLayers as runtime container**`
- L75: `   - If yes, which tools rely on it (print-yaml, print-parsed-parameters, etc.)?`
- L77: `## 3) Layers: are they essential, or accidental complexity?`
- L79: `1. **Why do layers exist** instead of a single flat registry?`
- L80: `2. **Who benefits** from layers? (help grouping, naming, namespacing, reuse, composition)`
- L81: `3. **How often do real apps use multiple layers** beyond ‚Äúdefault + settings‚Äù?`
- L82: `4. **If we collapsed to one layer** (all params flattened), what would break?`
- L83: `5. **Do layer slugs leak into app code** today? Is that acceptable?`
- L84: `6. **Do child layers matter** in practice, or could we remove that feature?`
- L90: `1. **For env vars and flags**, should `layer.Prefix` be:`
- L92: `   - Or part of the canonical parameter name (‚Äúredis-host‚Äù is the key everywhere)?`
- L100: `## 5) Config mapping: nested YAML vs layer-shaped YAML (why both, and which should win)?`
- L103: `   - Layer-shaped:`
- L104: `     - `layer-slug: { param: value }``
- L141: `   - Cobra command directly? layers+parser config? a runner-like entrypoint?`
- L169: `1. **Collapse to a single internal layer** for struct-first ConfigParser V1`
- L170: `2. **Stop exposing `ParsedLayers` outside parsing boundary** (typed struct only)`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/04-diary-appconfig-module-design-redo.md`
- L2: `Title: "Diary: appconfig.Parser design redo (register layers + structs, configurable Parse)"`
- L17: `    - Path: glazed/ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/design-doc/02-design-appconfig-module-register-layers-and-parse.md`
- L20: `      Note: ParseCommandParameters provides ParseOption-driven middleware configuration (baseline for Parse)`
- L23: `    - Path: glazed/pkg/cmds/middlewares/load-parameters-from-json.go`
- L26: `Summary: "Implementation diary for redesigning CONFIG-PARSER-001 toward an incremental appconfig.Parser: generic grouped settings type, explicit layer+struct registration, and Parse() configured by middleware options."`
- L37: `- allows explicit registration of `(settings struct ‚Üî ParameterLayer)` pairs,`
- L43: `This step reset the direction of the ticket and checked whether Glazed already has the right primitives to support a ‚Äúregister layers + configurable parse‚Äù fa√ßade. The goal was to avoid inventing new abstractions when existing, battle-tested seams already exist (`runner.ParseCommandParameters` and `cli.CobraParserConfig`).`
- L52: `  - grep: `ParseCommandParameters`, `ParseOption`, `WithConfigFiles`, `WithEnvMiddleware``
- L53: `  - grep: `CobraParserConfig`, `CobraCommandDefaultMiddlewares`, `NewCobraParserFromLayers``
- L54: `  - grep: `WithConfigMapper`, `WithConfigFileMapper`, `LoadParametersFromFiles`, `type ConfigMapper``
- L63: `- a set of registered `ParameterLayer`s,`
- L64: `- an option-configured middleware chain that produces `ParsedLayers`,`
- L72: `  - `runner.ParseCommandParameters(cmd, options...)` and options like:`
- L76: `    - `WithValuesForLayers(...)``
- L87: `  - layers are already the unit of definition,`
- L89: `  - hydration already exists (`ParsedLayers.InitializeStruct`).`
- L101: `  - we may want a separate ‚ÄúCLI adapter‚Äù layer rather than merging concerns too early.`
- L112: `  - `design-doc/02-design-appconfig-module-register-layers-and-parse.md``
- L114: `  - `glazed/pkg/cmds/runner/run.go` (ParseOptions + ParseCommandParameters)`
- L121: `- Query: `ParseCommandParameters(` / `type ParseOption` / `WithEnvMiddleware` / `WithConfigFiles``
- L122: `  - Hit: `glazed/pkg/cmds/runner/run.go` (ParseOptions + ParseCommandParameters + env/config/defaults wiring)`
- L123: `- Query: `WithConfigMapper(` / `WithConfigFileMapper(` / `LoadParametersFromFiles(` / `type ConfigMapper``
- L124: `  - Hit: `glazed/pkg/cmds/middlewares/load-parameters-from-json.go` (config loader options)`
- L126: `- Query: `CobraParserConfig` / `CobraCommandDefaultMiddlewares` / `NewCobraParserFromLayers``
- L142: `  - `design-doc/02-design-appconfig-module-register-layers-and-parse.md``
- L144: `  - Read: `glazed/pkg/cmds/parameters/initialize-struct.go``
- L145: `  - Confirmed that fields are only considered if they have a `glazed` tag, and missing parameters are skipped.`
- L151: `- the caller must provide the `ParameterLayer` definitions, and`
- L152: `- the simplest v1 hydration path is to reuse `ParsedLayers.InitializeStruct(...)`.`
- L169: `  - v1 = ‚Äúregister layers + register tagged structs + parse‚Äù`
- L170: `  - later = ‚Äúderive layers and/or binding info from structs‚Äù`
- L176: `  - The future ‚Äústruct-first‚Äù work is about schema derivation, naming, and automated layer creation.`
- L188: `  - a convention-based field binding layer in `appconfig.Parser`.`
- L193: `- Read `design-doc/02-design-appconfig-module-register-layers-and-parse.md`.`
- L195: `  - `glazed/pkg/cmds/parameters/initialize-struct.go` (look for `field.Tag.Lookup("glazed")` and the ‚Äúcontinue‚Äù behavior on missing params).`
- L201: `- In `ParsedParameters.InitializeStruct(...)`, the code checks for:`
- L204: `  - `parameter, ok := p.Get(options.Name)``

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/05-diary-appconfig-parser-implementation.md`
- L48: `- Reused `runner.ParseCommandParameters` by creating a tiny `cmds.Command` stub (only `Description()` + `ToYAML()`).`
- L71: `- We can reuse `runner.ParseCommandParameters` without having to implement any `Run()` methods (it only needs `cmd.Description().Layers`).`
- L75: `- Ensuring we keep the ‚Äúincremental appconfig.Parser‚Äù scope: **explicit layer + tagged struct hydration** only; no schema generation.`
- L76: `- Avoiding slug mismatches: v1 `Register` requires `slug == layer.GetSlug()` so parsed layer keys line up with registration keys.`
- L98: `const RedisSlug appconfig.LayerSlug = "redis"`
- L113: `_ = parser.Register(RedisSlug, redisLayer, func(t *AppSettings) any { return &t.Redis })`
- L136: `  - Register validation tests (empty slug, nil layer, nil bind, slug mismatch, duplicate slug)`
- L164: `  - `layer-slug: { param-name: value }``
- L165: `  - This is compatible with our v1 direction (‚Äúexplicit layers‚Äù), so we don‚Äôt need mapping machinery yet.`
- L169: `- Getting precedence tests right without accidentally introducing layer prefixes (env naming uses layer prefix, not slug).`
- L173: `- Confirm the decision ‚Äúrequire slug == layer.GetSlug()‚Äù is acceptable for real-world layers (some wrapper layers might have mismatched registration slugs).`
- L177: `- Add table-driven tests for multi-layer env collisions (two layers with same param name + empty prefixes) to clarify expected behavior.`
- L183: `## Step 3: Introduce `appconfig.LayerSlug` to encourage `const` slugs in caller code`
- L185: `This step is a small API ergonomics tweak: we want callers to declare slugs as constants (and not pass ad-hoc string literals everywhere). To nudge that from day one, we introduced a dedicated `appconfig.LayerSlug` type and updated `Register` to accept it. Importantly, we verified that Glazed does not already define a shared `LayerSlug` type elsewhere, so we‚Äôre not duplicating an existing concept.`
- L187: `**Commit (code):** 91b10b2caa2ef92b94a13c9d6217727199d1e676 ‚Äî "refactor: introduce appconfig.LayerSlug"`
- L191: `- Added `type LayerSlug string` in `glazed/pkg/appconfig/parser.go`.`
- L192: `- Changed `Register` signature from `Register(slug string, ...)` to `Register(slug LayerSlug, ...)`.`
- L194: `- Updated tests to declare and use `const redisSlug LayerSlug = "redis"` and pass that into `Register`.`
- L204: `- `const RedisSlug appconfig.LayerSlug = "redis"``
- L220: `- Whether we should later migrate this type into a shared location (e.g. `pkg/cmds/layers`) if multiple packages want typed slugs.`
- L222: `## Step 4: Add a minimal glazed example using two registered layers`
- L224: `This step adds a tiny runnable example under `glazed/cmd/examples/` that demonstrates the ‚Äúhappy path‚Äù for v1: declare `const` slugs, build two layers, register each with a binder into a grouped `AppSettings` struct, call `Parse()`, and print the typed result. The purpose is to give future adopters a copy/paste starting point that doesn‚Äôt require reading the internals first.`
- L231: `  - Two layers: `redis` and `db``
- L232: `  - `const` slugs using `appconfig.LayerSlug``
- L233: `  - Uses `WithValuesForLayers` to keep it self-contained`
- L253: `This step adds the missing piece for real CLI usage: the ability to have `appconfig.Parser` consume values from a Cobra command (flags + positional args) while still preserving the same precedence model we expect elsewhere (defaults < config < env < args < flags). The implementation is option-driven: `WithCobra(cmd, args)` flips `Parse()` into ‚Äúcobra mode‚Äù, where we build an explicit middleware chain rather than going through `runner.ParseCommandParameters` (which is library-only and doesn‚Äôt know about cobra).`
- L268: `  - Otherwise, it continues to use `runner.ParseCommandParameters`.`
- L285: `- Cobra integration requires that the layer flags have already been added to the cobra command. The parser does not (yet) add flags automatically; it only parses.`
- L305: `  - `WithValuesForLayers(...)` (programmatic values)`
- L308: `  - build a `ParameterLayers` collection from registrations`

### `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/tasks.md`
- L5: `- [x] Build a ‚Äúhealth inspection‚Äù map of Glazed‚Äôs parameter parsing architecture (layers/parsed-layers/middlewares/cobra integration)`
- L7: `- [x] Write a design doc proposing a struct-first ConfigParser API (including modify-vs-layer decision + naming/renaming suggestions + 1‚Äì3 implementation designs)`
- L8: `- [x] Superseded (appconfig.Parser redesign): Decide on the internal layering model (single layer vs per-sub-struct layers) for the first implementation`
- L9: `- [x] Superseded (appconfig.Parser redesign): Implement a struct-first ConfigParser package in Glazed (derive schema from structs, generate layers + mapper, parse + hydrate typed config)`
- L10: `- [x] Superseded (appconfig.Parser redesign): Add minimal upstream hooks in Glazed for config-mapper wiring (CobraParserConfig and/or runner.ParseCommandParameters)`
- L11: `- [x] Superseded (appconfig.Parser redesign): Add a purpose-built mapper for struct path ‚Üí layer/param (avoid forcing patternmapper prefix semantics)`
- L16: `- [x] P1: Add core type skeleton type Parser[T any] and internal registration model (slug, layer, bind func(*T) any)`
- L18: `- [x] P1: Implement option helpers mapping to runner ParseOptions (WithEnv, WithConfigFiles, WithValuesForLayers, WithAdditionalMiddlewares / WithRunnerParseOptions)`
- L19: `- [x] P1: Implement Register(slug, layer, bind) with validation (duplicate slug, nil layer, nil bind)`
- L20: `- [x] P1: Build ParameterLayers collection from registered layers (stable iteration order)`
- L21: `- [x] P1: Implement minimal cmds.Command stub (Description().Layers = registered layers) to reuse runner.ParseCommandParameters`
- L22: `- [x] P1: Implement Parse() to run configured middleware chain (runner.ParseCommandParameters or explicit ExecuteMiddlewares)`
- L23: `- [x] P1: Implement hydration into grouped T via ParsedLayers.InitializeStruct(reg.Slug, reg.Bind(&t)) with per-layer error context`
- L28: `- [x] P3: Add a minimal example (glazed/cmd/examples or pinocchio/cmd/examples) showing two registered layers hydrating into AppSettings`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/README.md`
- L1: `# Rename ParameterLayer/ParsedLayers/ParameterDefinition for clarity`
- L3: `This is the document workspace for ticket GLAZED-LAYER-RENAMING.`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L16: `    - Path: glazed/pkg/cmds/layers/layer.go`
- L17: `      Note: ParameterLayer/ParameterLayers are the schema-ish core we‚Äôre renaming`
- L18: `    - Path: glazed/pkg/cmds/layers/parsed-layer.go`
- L19: `      Note: ParsedLayer/ParsedLayers are the values core; InitializeStruct verb is key`
- L20: `    - Path: glazed/pkg/cmds/middlewares/layers.go`
- L22: `    - Path: glazed/pkg/cmds/parameters/parameters.go`
- L23: `      Note: ParameterDefinition is the field spec; candidate for FieldDefinition`
- L24: `    - Path: glazed/pkg/doc/topics/layers-guide.md`
- L26: `    - Path: glazed/pkg/doc/tutorials/custom-layer.md`
- L28: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md`
- L30: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md`
- L33: `Summary: Deep plan for implementing Bundle A (Schema/Field/Values), including compatibility layer design`
- L76: `Changing `pkg/cmds/layers` ‚Üí `pkg/cmds/schema` breaks every downstream import. Even with `go fix`, this is heavy.`
- L101: `- In `pkg/cmds/parameters`:`
- L102: `  - `type FieldDefinition = ParameterDefinition``
- L103: `  - `type FieldDefinitions = ParameterDefinitions` (if exists)`
- L105: `- In `pkg/cmds/layers`:`
- L106: `  - `type SchemaSection = ParameterLayer``
- L107: `  - `type SchemaSections = ParameterLayers``
- L108: `  - `type SectionValues = ParsedLayer``
- L109: `  - `type Values = ParsedLayers``
- L118: `- Package names remain `layers`/`parameters`, so ‚Äúschema vs values‚Äù still feels muddled unless type names are used consistently.`
- L124: `- `pkg/cmds/schema` (fa√ßade over `cmds/layers` for schema concepts)`
- L125: `- `pkg/cmds/fields` (fa√ßade over `cmds/parameters` for field definitions)`
- L126: `- `pkg/cmds/values` (fa√ßade over `cmds/layers` parsed types)`
- L133: `- Avoid cycles: fa√ßades should depend ‚Äúdownward‚Äù (schema ‚Üí layers/parameters), not vice versa.`
- L148: `- `pkg/doc/topics/layers-guide.md``
- L149: `- `pkg/doc/tutorials/custom-layer.md``
- L165: `1. **Legacy programs** keep compiling with `schema.Section`, `fields.Definition`, `parsedLayers.InitializeStruct`, etc.`
- L180: `// in pkg/cmds/layers`
- L181: `type SchemaSection = ParameterLayer`
- L182: `type Values = ParsedLayers`
- L187: `**Downside**: call sites still use old verbs (`InitializeStruct`, `NewParameterLayer`).`
- L197: `- `schema.AddToCobra(cmd, sections)` wraps `ParameterLayers.AddToCobraCommand``
- L243: `- `schema.Section` ‚Üí `layers.SchemaSection` (alias)`
- L244: `- `schema.Schema` ‚Üí `layers.SchemaSections` (alias)`
- L245: `- `fields.Definition` ‚Üí `parameters.FieldDefinition` (alias)`
- L249: `- `values.SectionValues` ‚Üí `layers.SectionValues` (alias)`
- L250: `- `values.Values` ‚Üí `layers.Values` (alias)`
- L272: `#### `pkg/cmds/parameters``
- L275: `  - `type FieldDefinition = ParameterDefinition``
- L276: `  - `type FieldDefinitionOption = ParameterDefinitionOption``
- L277: `  - `func NewFieldDefinition(name string, t ParameterType, opts ...FieldDefinitionOption) *FieldDefinition``
- L282: `#### `pkg/cmds/layers``
- L285: `  - `type SchemaSection = ParameterLayer``
- L286: `  - `type SchemaSections = ParameterLayers``
- L287: `  - `type SectionValues = ParsedLayer``
- L288: `  - `type Values = ParsedLayers``
- L296: `- `layers.DecodeSectionInto(values *values.Values, sectionKey string, dst any) error``
- L298: `- `layers.DecodeDefaultInto(values *values.Values, dst any) error``
- L307: `- `pkg/cmds/fields` ‚Üí aliases/wrappers over `pkg/cmds/parameters``
- L308: `- `pkg/cmds/schema` ‚Üí aliases/wrappers over `pkg/cmds/layers` (schema side)`
- L309: `- `pkg/cmds/values` ‚Üí aliases/wrappers over `pkg/cmds/layers` (values side)`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md`
- L2: `Title: 'Brainstorm: renaming layers/parameters API for clarity'`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L14: `    - Path: glazed/pkg/cmds/layers/layer.go`
- L15: `      Note: Defines ParameterLayer (schema-ish grouping)`
- L16: `    - Path: glazed/pkg/cmds/layers/parsed-layer.go`
- L17: `      Note: Defines ParsedLayer/ParsedLayers (resolved values) and InitializeStruct`
- L18: `    - Path: glazed/pkg/cmds/parameters/parameters.go`
- L19: `      Note: Defines ParameterDefinition + NewParameterDefinition`
- L20: `    - Path: glazed/pkg/doc/topics/layers-guide.md`
- L22: `    - Path: glazed/pkg/doc/tutorials/custom-layer.md`
- L23: `      Note: Tutorial using ParameterLayer/ParameterDefinition/ParsedLayers`
- L24: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md`
- L26: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md`
- L29: `Summary: Explore naming schemes for ParameterLayer/ParameterDefinition/ParsedLayers and related packages/APIs`
- L34: `# Brainstorm: renaming layers/parameters API for clarity`
- L38: `Glazed‚Äôs ‚Äúparameters‚Äù system is powerful but the current naming is easy to misunderstand on first contact:`
- L51: `- **Minimize overload**: avoid ‚Äúlayer‚Äù meaning both ‚Äúfeature layer‚Äù and ‚Äúschema section‚Äù.`
- L60: `- `fields.Definition`: declarative parameter description (flag or arg); includes `Type`, `Default`, `Required`, help text.`
- L61: `- `schema.Section`: groups many `ParameterDefinition`s + has `Slug`, `Name`, `Description`, `Prefix`, cloning, and default-init helpers.`
- L62: `- `values.SectionValues`: holds `Layer ParameterLayer` + `Parameters *parameters.ParsedParameters` (i.e., resolved values).`
- L63: `- `values.Values`: ordered map of layer slug ‚Üí `*ParsedLayer`; has helpers like `InitializeStruct(layerKey, dst)`.`
- L67: `- Package names: `cmds/layers`, `cmds/parameters`, `cmds/middlewares`, `cmds/runner``
- L68: `- APIs: `NewParameterLayer`, `NewParameterDefinition`, `ExecuteMiddlewares`, `UpdateFromEnv`, `LoadParametersFromFiles`, `ParseFromCobraCommand`, `GatherArguments``
- L89: `| `parameters.ParsedParameter` | `values.FieldValue` | The resolved value + provenance. |`
- L90: `| `parameters.ParsedParameters` | `values.FieldValues` | Map of values for fields. |`
- L94: `- `pkg/cmds/layers` ‚Üí `pkg/cmds/schema` (or `pkg/schema` if it‚Äôs not command-specific)`
- L95: `- `pkg/cmds/parameters` ‚Üí `pkg/cmds/fields` (or `pkg/cmds/schema/fields`)`
- L100: `- `NewParameterLayer(...)` ‚Üí `schema.NewSection(...)``
- L101: `- `NewParameterDefinition(...)` ‚Üí `fields.New(...)` / `fields.String("host")` / `fields.Int("port")``
- L102: `- `ParsedLayers.InitializeStruct(...)` ‚Üí `Values.DecodeSectionInto(sectionKey, dst)` or `Values.Bind(sectionKey, dst)``
- L113: `**Intent**: speak the language of CLI flags and ‚Äúoptions‚Äù rather than ‚Äúparameters‚Äù.`
- L119: `| `ParameterDefinition` | `OptionDefinition` or `OptionSpec` | It defines a CLI option (flag/arg). |`
- L120: `| `ParameterLayer` | `OptionGroup` | Groups related options (logging/output/etc.). |`
- L121: `| `ParsedLayer` | `ResolvedOptionGroup` | Values after resolution. |`
- L122: `| `ParsedLayers` | `ResolvedOptions` | All resolved option groups. |`
- L126: `- `cmds/layers` ‚Üí `cmds/options` or `cmds/optiongroups``
- L127: `- `cmds/parameters` ‚Üí `cmds/options``
- L134: `- `parsedLayers.InitializeStruct("logging", &cfg.Logging)` ‚Üí `resolved.Bind("logging", &cfg.Logging)``
- L151: `| `ParameterDefinition` | `InputDefinition` / `InputSpec` |`
- L152: `| `ParameterLayer` | `InputGroupSpec` |`
- L153: `| `ParsedLayer` | `ResolvedInputGroup` |`
- L154: `| `ParsedLayers` | `ResolvedInputs` |`
- L158: `- `cmds/parameters` ‚Üí `cmds/inputs``
- L159: `- `cmds/layers` ‚Üí `cmds/inputgroups` (or keep `layers` but rename type names)`
- L165: `- **Cons**: ‚Äúinput‚Äù is generic; may lose the ‚ÄúCLI-parameter‚Äù clarity.`
- L177: `| `ParameterDefinition` | `ConfigField` / `SettingField` |`
- L178: `| `ParameterLayer` | `ConfigSectionSchema` |`
- L179: `| `ParsedLayers` | `EffectiveConfig` / `ResolvedConfig` |`
- L184: `- **Cons**: Glazed‚Äôs ‚Äúlayers‚Äù are used for more than config; ‚Äúconfig‚Äù may be misleading inside the command framework.`
- L191: `- `LoadParametersFromFiles` ‚Üí `FromConfigFiles` / `ConfigFileSource``
- L235: `- `schema.Section` ‚Üí `layers.SchemaSection``
- L236: `- `fields.Definition` ‚Üí `parameters.FieldDefinition``
- L237: `- `values.Values` ‚Üí `layers.ResolvedValues``
- L253: `Open question: do we want to rename packages (`cmds/layers`) or just types? Package renames are the most breaking because import paths change.`
- L260: `- Avoid Bundle D ‚ÄúConfig‚Äù as a global rename inside `cmds/` because Glazed layers are broader than app config.`
- L265: `- Should ‚Äúlayer‚Äù remain as the grouping concept (since it already exists everywhere), and we only rename ‚Äúparameter layer‚Äù to ‚Äúlayer schema‚Äù?`
- L268: `- Do we want to keep `parameters` as the package name but rename the types (less breaking)?`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/01-debate-round-1-option-a-naming-api-design-schema-fields-values-sources.md`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L21: `    - Path: glazed/pkg/cmds/layers/layer.go`
- L23: `    - Path: glazed/pkg/cmds/layers/parsed-layer.go`
- L24: `      Note: Current values container types (ParsedLayer/ParsedLayers) and InitializeStruct semantics`
- L25: `    - Path: glazed/pkg/cmds/middlewares/layers.go`
- L27: `    - Path: glazed/pkg/cmds/parameters/parameters.go`
- L28: `      Note: Current field spec type (ParameterDefinition) targeted by Option A`
- L31: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md`
- L33: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md`
- L51: `- `rg "type\\s+ParameterLayer\\b|type\\s+ParsedLayer\\b|type\\s+ParsedLayers\\b" glazed/pkg/cmds/layers -n``
- L70: `  - `NewCobraParserFromLayers` optionally composes:`
- L73: `    - config (`LoadParametersFromResolvedFilesForCobra`)`
- L78: `#### 3) Command ‚Äúdefinition‚Äù is centered on `cmds.CommandDescription` and layers`
- L80: `The cobra glue (`glazed/pkg/cli/cobra.go`) expects commands that expose `s.Description()` returning a `*cmds.CommandDescription` with a `Layers` collection.`
- L84: `- do we keep command descriptions speaking in terms of ‚Äúlayers‚Äù internally?`
- L108: `We‚Äôve decided to rename packages, but we should keep the initial Option A package layer extremely thin and non-invasive.`
- L124: `- keep ‚Äúlayer‚Äù internally (implementation), expose ‚Äúschema section‚Äù in docs`
- L141: `I‚Äôm also flagging a subtlety: `ParsedLayers.InitializeStruct(DefaultSlug, dst)` special-cases ‚Äúdefault‚Äù. If we introduce a new `values.DecodeInto(...)`, we must decide whether that special-casing is preserved or hidden.`
- L162: `- ‚ÄúParameterLayer‚Äù reads like ‚Äúa precedence layer/source‚Äù, not ‚Äúa schema section‚Äù.`
- L163: `- ‚ÄúParsedLayers‚Äù sounds like ‚Äúparsed sources‚Äù, not ‚Äúresolved values‚Äù.`
- L175: `Agree on fa√ßades-first. The only point I‚Äôd push: even if internals keep ‚Äúlayers‚Äù, the public API should not. If we keep ‚Äúlayer‚Äù in `schema` package names/types, we‚Äôre not solving the confusion.`
- L211: `- **What do we call the grouping concept publicly?** keep ‚Äúlayer‚Äù vs ‚Äúsection/group/namespace‚Äù.`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-composer-metadata.md`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L17: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-independent-composer-analysis.md`
- L44: `   - Read key source files (`layer.go`, `parsed-layer.go`, `parameters.go`, `middlewares/layers.go`, `cli/cobra.go`)`
- L50: `   - Counted usage statistics (2,525 matches for ParameterLayer/ParsedLayer/ParameterDefinition)`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-independent-composer-analysis.md`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L16: `    - Path: glazed/pkg/cmds/layers/layer.go`
- L17: `      Note: Core ParameterLayer interface and ParameterLayers collection`
- L18: `    - Path: glazed/pkg/cmds/layers/parsed-layer.go`
- L19: `      Note: ParsedLayer and ParsedLayers implementation with InitializeStruct`
- L20: `    - Path: glazed/pkg/cmds/parameters/parameters.go`
- L21: `      Note: ParameterDefinition and ParameterDefinitions types`
- L22: `    - Path: glazed/pkg/cmds/middlewares/layers.go`
- L23: `      Note: Middleware functions operating on ParsedLayers`
- L45: `**ParameterLayer/ParsedLayer usage:**`
- L46: `- Found **2,525 matches** across **163 files** for `ParameterLayer|ParsedLayer|ParameterDefinition``
- L50: `- `glazed/pkg/cmds/layers` imported across multiple packages`
- L51: `- `glazed/pkg/cmds/parameters` used extensively for field definitions`
- L56: `**1. ParameterLayer Interface Structure** (`glazed/pkg/cmds/layers/layer.go:18-30`)`
- L58: `type ParameterLayer interface {`
- L60: `    GetParameterDefinitions() *fields.Definitions`
- L61: `    InitializeParameterDefaultsFromStruct(s interface{}) error`
- L66: `    Clone() ParameterLayer`
- L70: `**Key observation:** The interface mixes schema definition (`GetParameterDefinitions`) with metadata (`GetName`, `GetSlug`). The name "ParameterLayer" doesn't clearly indicate it's a schema container.`
- L72: `**2. ParsedLayer Structure** (`glazed/pkg/cmds/layers/parsed-layer.go:14-17`)`
- L74: `type ParsedLayer struct {`
- L75: `    Layer      ParameterLayer`
- L76: `    Parameters *parameters.ParsedParameters`
- L80: `**Key observation:** `ParsedLayer` contains both a reference to the schema (`Layer`) and the parsed values (`Parameters`). The name suggests it's "parsed" but doesn't indicate it's a collection of resolved values.`
- L82: `**3. InitializeStruct Method** (`glazed/pkg/cmds/layers/parsed-layer.go:100-102`)`
- L84: `func (ppl *ParsedLayer) InitializeStruct(s interface{}) error {`
- L85: `    return ppl.Parameters.InitializeStruct(s)`
- L91: `**4. ParameterDefinition** (`glazed/pkg/cmds/parameters/parameters.go:20-29`)`
- L93: `type ParameterDefinition struct {`
- L96: `    Type       ParameterType `yaml:"type"``
- L105: `**Key observation:** `ParameterDefinition` is clearly a field specification, not a runtime value. The name is accurate but verbose. "FieldDefinition" would be shorter and clearer.`
- L114: `    // ... creates parser from description.Layers`
- L115: `    cobraParser, err := NewCobraParserFromLayers(description.Layers, &cfg.ParserCfg)`
- L121: `**Key observation:** The API uses `description.Layers` (which is `*schema.Schema`). This is the public-facing API that tutorials reference.`
- L123: `**6. Middleware Pattern** (`glazed/pkg/cmds/middlewares/layers.go:11-26`)`
- L125: `func ReplaceParsedLayer(layerSlug string, newLayer *values.SectionValues) Middleware {`
- L127: `        return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L128: `            // ... operates on parsedLayers`
- L134: `**Key observation:** Middlewares operate on both `ParameterLayers` (schema) and `ParsedLayers` (values). The package name "middlewares" doesn't convey that these are value resolvers/sources.`
- L148: `   type SchemaSection = ParameterLayer`
- L149: `   type SectionValues = ParsedLayer`
- L150: `   type FieldDefinition = ParameterDefinition`
- L154: `2. **Package moves are expensive** - If we move from `pkg/cmds/layers` to `pkg/cmds/schema`, every import breaks. That's **163 files** to update. Instead, we should:`
- L164: `- Keep packages: `layers`, `parameters``
- L180: `1. **ParameterLayer mixes concerns** - It contains both schema (`GetParameterDefinitions()`) and metadata (`GetName()`, `GetSlug()`). This violates single responsibility. A "SchemaSection" should only define structure.`
- L182: `2. **ParsedLayer is ambiguous** - It contains both a schema reference (`Layer`) and values (`Parameters`). The name doesn't convey that it's "resolved values for a schema section."`
- L185: `   - `pkg/cmds/layers` - contains both schema and values`
- L186: `   - `pkg/cmds/parameters` - contains field definitions`
- L211: `- Keep old packages as compatibility layer`
- L214: `**Cost:** Medium - new packages, fa√ßade layer, gradual migration`
- L237: `   - Moving `layers` ‚Üí `schema` breaks all imports`
- L287: `   - Uses `schema.Schema` - what is a "layer"?`
- L288: `   - Uses `parsedLayers.InitializeStruct()` - what does "initialize" mean?`
- L292: `   - Docs use "layer" but don't explain it clearly`
- L293: `   - "Parameter" vs "Field" used interchangeably`
- L298: `   - Searching for "field definition" finds "ParameterDefinition"`
- L305: `- **Field Definition:** Specification of a single parameter (name, type, default, help)`
- L312: `layers := schema.NewSchema(...)`
- L313: `parsedLayers := values.New(...)`
- L340: `1. **"ParameterLayer"** - What is a "parameter layer"? Is it a layer of parameters? A parameter that's layered? Unclear.`
- L342: `2. **"ParsedLayers"** - Parsed what? Layers of what? The name doesn't tell me it contains resolved values.`
- L344: `3. **"ParameterDefinition"** - This one is clearer, but "FieldDefinition" would be more intuitive.`
- L351: `If I search for "how do I get parsed values?" - I find "ParsedLayers" but it's not clear.`
- L367: `### pkg/cmds/layers ("The Layer Librarian")`
- L376: `- `ParameterLayer` interface: defines schema + metadata`
- L377: `- `ParsedLayer` struct: contains schema reference + values`
- L378: `- `ParameterLayers`: ordered collection of schemas`
- L379: `- `ParsedLayers`: ordered collection of resolved values`
- L383: `1. **Schema and values are coupled** - A `ParsedLayer` needs its `Layer` reference to validate and understand values. Separating them completely would require passing both around.`
- L385: `2. **Order matters** - I use `OrderedMap` because layer order affects precedence. This is important for merging and resolution.`
- L391: `- **Type aliases:** Fine, I can live with `SchemaSection = ParameterLayer``
- L397: `- Keep me as the implementation layer`
- L402: `**Cost:** Wrapper layer overhead`
- L405: `### pkg/cmds/parameters ("The Field Spec")`
- L414: `type ParameterDefinition struct {`
- L416: `    Type       ParameterType`
- L428: `1. **"Parameter" is vague** - Could mean the definition or the value`
- L430: `3. **I live in "parameters" package** - Should I be in "fields" or "schema"?`
- L458: `func LoadParametersFromFiles(...)`
- L474: `2. **My functions operate on ParsedLayers** - I'm filling values, not transforming requests`
- L489: `**Cost:** Package rename + compatibility layer`
- L504: `I work with `description.Layers` (which is `*schema.Schema`).`
- L515: `1. **"Layers" doesn't map to CLI concepts** - CLI users don't think in "layers"`
- L516: `2. **"ParameterLayers" is implementation detail** - Should be "SchemaSections" at API level`
- L521: `- **Clear API names** - `SchemaSections` instead of `ParameterLayers``
- L522: `- **CLI-friendly terminology** - "sections" or "groups" not "layers"`
- L532: `**Cost:** API updates + compatibility layer`
- L553: `1. **I use "layers" terminology** - Makes my API harder to explain`
- L579: `**Counter-evidence:** Look at `ParsedLayer` - it needs the `Layer` reference for validation. Separating them completely would require passing both around everywhere. The coupling is intentional and useful.`
- L583: `**Pragmatist, type aliases don't solve the fundamental problem.** Yes, we can alias `SchemaSection = ParameterLayer`, but developers still import `layers` and see `ParameterLayer` in their IDE. The package name matters for discoverability.`
- L585: `**Counter-evidence:** New developers searching for "schema" won't find `schema.Section`. They need to know to look in `layers` package. New packages solve this.`
- L606: `**Counter to Pragmatist:** Type aliases don't help discoverability. I still need to know to import `layers` and use `SchemaSection` alias.`
- L608: `**Counter to Architect:** I don't need perfect separation - I just need clear names. If `ParsedLayer` contains both schema reference and values, that's fine, but call it `SectionValues` so I understand what it is.`
- L610: `### pkg/cmds/layers ‚Üí The Architect`
- L612: `**Architect, you want to split me, but my coupling is intentional.** `ParsedLayer` needs its `Layer` reference. Separating completely would make the API more complex, not simpler.`
- L616: `### pkg/cmds/parameters ‚Üí The Architect`
- L646: `- **Layer Librarian:** Keep current structure, just rename types`
- L647: `- **Migration Engineer:** Phased migration with compatibility layers`
- L657: `3. **Coupling vs Separation** - Layer Librarian defends intentional coupling, Architect wants separation`
- L679: `   - Keep old names as compatibility layer`
- L707: `- **Separation of concerns** - Architect wants separation, Layer Librarian defends coupling`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/diary/01-diary-layer-parameter-renaming-work.md`
- L2: `Title: 'Diary: layer/parameter renaming work'`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L15: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md`
- L17: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md`
- L22: `Summary: Chronological log of work on naming/renaming ParameterLayer/ParsedLayers/ParameterDefinition`
- L27: `# Diary: layer/parameter renaming work`
- L33: `- Created ticket workspace: `GLAZED-LAYER-RENAMING`.`
- L40: `- Added glazed-relevant topics (commands/cli/cobra/layers/parameters/schema/values/sources/parsing/hydration/migration/etc.).`
- L48: `- Preserved `RelatedFiles` entries pointing at core code (`layers`, `parameters`) and user-facing docs (guides/tutorials).`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/index.md`
- L2: `Title: Rename ParameterLayer/ParsedLayers/ParameterDefinition for clarity`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L19: `# Rename ParameterLayer/ParsedLayers/ParameterDefinition for clarity`
- L29: `- **Brainstorm doc**: [brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md](./brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md)`
- L31: `- **Diary**: [diary/01-diary-layer-parameter-renaming-work.md](./diary/01-diary-layer-parameter-renaming-work.md)`

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md`
- L2: `Title: 'Debate prep: candidates and questions for renaming layers/parameters'`
- L3: `Ticket: GLAZED-LAYER-RENAMING`
- L15: `    - Path: glazed/pkg/cmds/layers/layer.go`
- L16: `      Note: Debate touches ParameterLayer/ParameterLayers naming`
- L17: `    - Path: glazed/pkg/cmds/layers/parsed-layer.go`
- L18: `      Note: Debate touches ParsedLayer/ParsedLayers naming + InitializeStruct`
- L19: `    - Path: glazed/pkg/cmds/middlewares/layers.go`
- L21: `    - Path: glazed/pkg/cmds/parameters/parameters.go`
- L22: `      Note: Debate touches ParameterDefinition naming`
- L25: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md`
- L27: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md`
- L36: `# Debate prep: candidates and questions for renaming layers/parameters`
- L40: `Set up a presidential-style debate for **GLAZED-LAYER-RENAMING** by defining:`
- L80: `   - What stays as legacy vocabulary even in Option A (e.g. keep `layer` internally but expose ‚Äúsection‚Äù externally)?`
- L87: `4. **Command definition surface**: How should we deal with Glazed command definitions (e.g. `cmds.CommandDescription`, layers/flags/args composition) under the new vocabulary?`
- L88: `   - Do we keep ‚Äúlayer‚Äù terminology in command descriptions, or rename to ‚Äúschema sections‚Äù at the API edge?`
- L97: `   - in-place (within `cmds/layers` and `cmds/parameters`)`
- L100: `   - `ParsedLayer` is ‚Äúsection values‚Äù`
- L101: `   - `ParsedLayers` is ‚Äúall values‚Äù`
- L102: `   - do we also want a cross-layer merged view name?`
- L103: `9. **What do we call ‚Äúlayer‚Äù itself?**`
- L104: `   - keep ‚Äúlayer‚Äù as the grouping word`
- L135: `- **`pkg/cmds/layers` (‚ÄúThe Layer Librarian‚Äù)**`
- L136: `  - **Key surfaces**: `ParameterLayer`, `ParameterLayers`, `ParsedLayer`, `ParsedLayers`, `DefaultSlug``
- L139: `- **`pkg/cmds/parameters` (‚ÄúThe Field Spec‚Äù)**`
- L140: `  - **Key surfaces**: `ParameterDefinition`, parsing/validation, struct init`
- L144: `  - **Key surfaces**: `SetFromDefaults`, `UpdateFromEnv`, `LoadParametersFromFiles`, `ParseFromCobraCommand`, `GatherArguments`, `ExecuteMiddlewares``
- L152: `  - **Key surfaces**: `appconfig.Parser`, layer registration, parsing chain, hydration semantics`
- L165: `- Which vocabulary bundle yields the most coherent end-to-end story across `layers/parameters/middlewares/cli/appconfig`?`
- L182: `- If you see `ParameterLayer`, what do you think it means? Same for `ParsedLayers`?`
- L194: `- Brainstorm: `brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md``

### `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/tasks.md`
- L8: `- [ ] Optional: prototype a tiny compatibility layer (new names re-export old)`

### `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/design-doc/01-design-wrapper-packages-schema-fields-values-sources.md`
- L18: `    - Path: glazed/pkg/cmds/layers/layer-impl.go`
- L19: `      Note: NewParameterLayer/ParseLayerFromCobraCommand and prefix semantics referenced in the design`
- L20: `    - Path: glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-independent-composer-analysis.md`
- L67: `Primary goal: make it easy to talk about ‚Äúschema sections‚Äù without importing `layers`.`
- L80: `  - `func WithSections(sections ...Section) SchemaOption` ‚Üí `layers.WithLayers``
- L81: `  - `func NewGlazedSchema(opts ...settings.GlazeParameterLayerOption) (Section, error)` ‚Üí `settings.NewGlazedParameterLayers``
- L87: `Primary goal: clarify that `ParameterDefinition` is a **field definition**, and group field/type helpers under a ‚Äúfields‚Äù concept.`
- L106: `Primary goal: rename ‚Äúparsed layers‚Äù to ‚Äúvalues‚Äù and provide ‚Äúdecode‚Äù verbs without renaming methods.`
- L130: `  - `FromCobra(cmd *cobra.Command, opts ...parameters.ParseStepOption) Middleware` ‚Üí `sources.FromCobra``
- L131: `  - `FromArgs(args []string, opts ...parameters.ParseStepOption) Middleware` ‚Üí `sources.FromArgs``
- L132: `  - `FromEnv(prefix string, opts ...parameters.ParseStepOption) Middleware` ‚Üí `sources.FromEnv``
- L133: `  - `FromDefaults(opts ...parameters.ParseStepOption) Middleware` ‚Üí `sources.FromDefaults``
- L134: `  - `FromConfigFilesForCobra(...) Middleware` ‚Üí `middlewares.LoadParametersFromResolvedFilesForCobra` (optional; phase 2)`
- L162: `   This prevents import cycles and avoids destabilizing existing users. The new packages depend on `layers/parameters/middlewares`, never the other way around.`
- L179: `   Rejected: improves names but does not improve import discoverability (`layers` still doesn‚Äôt read as ‚Äúschema‚Äù).`
- L198: `- Debate prep: `glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md``
- L199: `- Independent debate round: `glazed/ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-independent-composer-analysis.md``
- L201: `  - `glazed/pkg/cmds/layers/*``
- L202: `  - `glazed/pkg/cmds/parameters/*``

### `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/diary/01-diary.md`
- L150: `- Confirm that wrapper functions correctly forward all parameters`
- L253: `- Added `settings.NewGlazedSchema()` wrapper for `settings.NewGlazedParameterLayers()``
- L255: `- Added `cmds.WithSchema()` wrapper for `cmds.WithLayers()` accepting `*schema.Schema``
- L262: `  - `cmds.WithSchema()` instead of `cmds.WithLayers((*schema.Schema)(schema))``

### `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/docs/01-building-commands-with-new-api.md`
- L20: `Glazed's new API vocabulary (`schema`, `fields`, `values`, `sources`) provides clearer, more intuitive names for building commands. Instead of working with "parameter layers" and "parsed layers," you now work with **schemas** (collections of sections), **fields** (parameter definitions), **values** (resolved parameters), and **sources** (where values come from). This guide demonstrates how to build a complete command using these new packages, showing how schema sections organize parameters, how fields define individual parameters, and how values decode into type-safe structs.`
- L42: `- **Field**: A parameter definition (`fields.Definition` = `fields.Definition`)`
- L43: `- **Values**: Resolved parameters (`values.Values` = `values.Values`)`
- L50: `Every Glazed command follows a consistent pattern: a command struct embeds `*cmds.CommandDefinition` for metadata, and settings structs map command-line parameters to Go fields using struct tags. The new API makes this pattern clearer by using `CommandDefinition` instead of `CommandDescription`.`
- L96: `Schema sections organize related parameters into logical groups. Each section can have a prefix (like `app-` or `output-`) that affects how flags and environment variables are named. The `schema` package provides constructors that make section creation intuitive.`
- L190: `- **Required**: `fields.WithRequired(true)` for mandatory parameters`
- L370: `	schema.WithDescription("Default parameters"),`
- L514: `		schema.WithDescription("Default parameters"),`
- L688: `**Group Related Parameters**: Create sections that group logically related parameters. For example, all database connection settings belong in a `database` section, not scattered across multiple sections.`
- L696: `**Provide Defaults**: Always provide sensible defaults for optional parameters. This makes commands easier to use and reduces required flags.`
- L708: `**Decode Per Section**: Decode each section into its own struct. This keeps your code organized and makes it clear which parameters belong together.`
- L716: `If you have existing commands using the old API (`schema.Section`, `fields.Definition`), you can migrate gradually. In the new vocabulary, ‚Äúparameter definitions‚Äù are called **fields** (hence `schema.WithFields(...)`).`
- L720: `layer, err := schema.NewSection("app", "App",`
- L721: `	layers.WithPrefix("app-"),`
- L743: `- `parsedLayers.InitializeStruct` ‚Üí `values.DecodeSectionInto``
- L758: `glaze help layers-guide`
- L761: `Understand how parameter layers organize reusable configuration sets.`

### `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/index.md`
- L28: `This ticket introduces **new, future-facing Glazed packages** that expose the Option A vocabulary discussed in **GLAZED-LAYER-RENAMING**:`
- L33: `- **`fields`**: field/flag/arg definitions (light fa√ßade over `parameters`)`
- L35: `These packages are **additive** and implemented as **type aliases + wrapper functions**, so existing code using `layers`, `parameters`, and `middlewares` continues to work unchanged.`

### `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/planning/01-implementation-plan-wrapper-packages-example-program.md`
- L44: `  - [x] `func WithSections(sections ...Section) SchemaOption` (wrap `layers.WithLayers`)`
- L45: `  - [x] `func NewGlazedSchema(opts ...settings.GlazeParameterLayerOption) (Section, error)` (wrap `settings.NewGlazedParameterLayers`)`
- L58: `  - [x] Re-export parameter type constants (at least the ones used by the example program; optionally all):`
- L79: `    - [x] `FromCobra(cmd *cobra.Command, opts ...parameters.ParseStepOption) Middleware``
- L80: `    - [x] `FromArgs(args []string, opts ...parameters.ParseStepOption) Middleware``
- L81: `    - [x] `FromEnv(prefix string, opts ...parameters.ParseStepOption) Middleware``
- L82: `    - [x] `FromDefaults(opts ...parameters.ParseStepOption) Middleware``
- L101: `  - Use `cli.BuildCobraCommand(...)` (or `cli.NewCobraParserFromLayers` + `AddToCobraCommand`) so we exercise the actual production codepaths.`
- L106: `    - Per-section prefix: `layerPrefix` from `schema.WithPrefix(...)` (hyphen becomes underscore for env keys)`

### `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/planning/02-implementation-tracking-wrapper-packages-progress.md`
- L48: `   - Re-exported common options: `WithPrefix`, `WithName`, `WithDescription`, `WithDefaults`, `WithParameterDefinitions`, `WithArguments``
- L56: `   - Re-exported all parameter type constants (TypeString, TypeBool, TypeInteger, etc.)`

### `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/analysis/01-profile-settings-resolving-circular-dependency-between-profile-selection-and-profile-loading.md`
- L27: `The current ‚Äúbootstrap‚Äù mechanism (`cli.ParseCommandSettingsLayer`) only parses these settings from **Cobra flags**,`
- L29: `middleware with values read ‚Äútoo early‚Äù (like `geppetto/pkg/layers/layers.go`) will end up capturing defaults and loading`
- L38: `- **`ParameterLayers`**: layer definitions (what flags exist, types, defaults).`
- L39: `- **`ParsedLayers`**: parsed values and their provenance (parse-step logs).`
- L41: `- **Profile file format**: YAML mapping `profileName -> layerSlug -> paramName -> value` (see `middlewares/profiles.go`).`
- L49: `1. `CobraParser.AddToCobraCommand(cmd)` iterates every layer and requires it to implement `layers.CobraParameterLayer`.`
- L50: `2. Each `ParameterLayerImpl.AddLayerToCobraCommand(cmd)` calls:`
- L51: `   - `ParameterDefinitions.AddParametersToCobraCommand(cmd, layerPrefix)``
- L52: `3. `AddParametersToCobraCommand`:`
- L54: `   - Registers **argument constraints** by setting `cmd.Args` and rewriting `cmd.Use` for argument-style parameters`
- L59: `- **Profile flags (`--profile`, `--profile-file`) only work if the ProfileSettingsLayer is actually registered** on the command`
- L60: `  (i.e., the layer exists in the `ParameterLayers` used for `AddToCobraCommand`).`
- L65: `Glazed‚Äôs parsing layer uses `Flags().Changed(name)` to decide if a value should be considered ‚Äúprovided‚Äù.`
- L78: `Only afterwards does Glazed parse those already-populated flags into `ParsedLayers` via middleware:`
- L80: `- `sources.FromCobra(cmd)` iterates layers and calls `ParseLayerFromCobraCommand(cmd, ...)``
- L81: `- `ParameterLayerImpl.ParseLayerFromCobraCommand(...)` calls`
- L82: `  `ParameterDefinitions.GatherFlagsFromCobraCommand(cmd, onlyProvided=true, ...)``
- L90: `type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error`
- L100: ``ExecuteMiddlewares(layers, parsedLayers, m1, m2, m3)` calls the *outermost* middleware first, but ‚Äúeffective precedence‚Äù`
- L102: `(for ‚Äúmodify layers before parsing‚Äù).`
- L104: `Most of the value-setting middlewares (`SetFromDefaults`, `LoadParametersFromFiles`, `UpdateFromEnv`, `ParseFromCobraCommand`)`
- L127: `In Geppetto‚Äôs middleware builder (`geppetto/pkg/layers/layers.go`), profile selection is read from `parsedCommandLayers``
- L130: `But `parsedCommandLayers` is produced by `cli.ParseCommandSettingsLayer(cmd)` which currently parses from **Cobra only**.`
- L136: `- later env/flags may update `profile-settings` in the *real* `parsedLayers`,`
- L144: `**run a mini parse of selection layers** (profile + command settings) using the real precedence sources,`
- L150: `execute a mini-chain against a restricted layer set containing:`
- L160: `bootstrapLayers := schema.NewSchema(layers.WithLayers(`
- L161: `  NewCommandSettingsLayer(),`
- L162: `  NewProfileSettingsLayer(),`
- L166: `ExecuteMiddlewares(bootstrapLayers, bootstrapParsed,`
- L170: `  LoadParametersFromResolvedFilesForCobra(cmd, args, resolver),`
- L183: `  LoadParametersFromResolvedFilesForCobra(cmd, args, resolver),`
- L187: `ExecuteMiddlewares(allLayers, allParsed, mainMiddlewares...)`
- L196: `How to keep it local to some layers:`
- L198: `- `WrapWithWhitelistedLayers([]string{cli.ProfileSettingsSlug, cli.CommandSettingsSlug}, ...)``
- L199: `  can be used if you want to run the same middleware list but restricted to only selection layers.`
- L205: `1. Execute a nested ‚Äúbootstrap‚Äù `ExecuteMiddlewares(...)` against a restricted layer set`
- L207: `3. Load the profile YAML and merge the selected profile map into the *outer* `parsedLayers``
- L241: `- **Required flags**: `GatherFlagsFromCobraCommand` enforces `pd.Required` at the Cobra layer. In a world where required`
- L251: `  - `glazed/pkg/cmds/parameters/cobra.go``

### `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/index.md`
- L15: `    - Path: ../../../../../../geppetto/pkg/layers/layers.go`

### `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/reference/01-diary.md`
- L28: `We want to load profiles (like in `geppetto/pkg/layers/layers.go`), but profile selection values (profile name + profile file path) should themselves be overridable by defaults/env/config/flags. This creates a bootstrapping problem if profile loading is a regular middleware that needs the profile selection values before the middleware chain runs.`
- L33: `- How Glazed turns flags/args/config/env/defaults into `ParsedLayers``
- L57: `  - Middleware signature is `func(layers *ParameterLayers, parsedLayers *ParsedLayers) error` (no `context.Context`, no `*cobra.Command`).`
- L63: `  - It calls `ParseCommandSettingsLayer(cmd)` which builds layers for `command-settings`, `profile-settings`, and `create-command-settings`.`
- L71: `## Step 2: How Glazed registers Cobra flags and later parses them into ParsedLayers`
- L73: `This step focused on the *mechanics* of Cobra integration: how Glazed turns `ParameterDefinitions` into Cobra flags/args (registration time) and then later reads the already-parsed Cobra state into `ParsedLayers` (parse time). This clarified two things: Glazed largely ignores Cobra‚Äôs own default-value semantics (because it uses `Flags().Changed(...)`), and Glazed‚Äôs middlewares rely on Cobra‚Äôs ‚Äúunknown flag‚Äù enforcement to ensure only registered flags can be passed.`
- L78: `  - `glazed/pkg/cli/cli.go` (defines `ProfileSettingsSlug`, `NewProfileSettingsLayer`, `NewCommandSettingsLayer`)`
- L79: `  - `glazed/pkg/cmds/layers/cobra.go` (defines `CobraParameterLayer`)`
- L80: `  - `glazed/pkg/cmds/layers/layer-impl.go` (layer methods `AddLayerToCobraCommand`, `ParseLayerFromCobraCommand`)`
- L81: `  - `glazed/pkg/cmds/parameters/cobra.go` (flag/arg registration + reading Cobra values)`
- L82: `  - `glazed/pkg/cmds/middlewares/whitelist.go` (how to run a middleware against a restricted subset of layers)`
- L91: `- **Flag registration** happens when a layer is added to a Cobra command:`
- L92: `  - `ParameterLayerImpl.AddLayerToCobraCommand()` calls `ParameterDefinitions.AddParametersToCobraCommand(cmd, prefix)`.`
- L93: `  - `AddParametersToCobraCommand` uses `cmd.Flags()` (non-persistent) and registers flags with a default value (typed).`
- L94: `  - It also configures positional argument validation via `cmd.Args` and updates `cmd.Use` for argument-style `ParameterDefinition`s.`
- L96: `  - `ParseFromCobraCommand(cmd)` iterates layers and calls `layer.ParseLayerFromCobraCommand(cmd, ...)`.`
- L97: `  - `ParameterLayerImpl.ParseLayerFromCobraCommand` uses `GatherFlagsFromCobraCommand(cmd, onlyProvided=true, ...)`.`
- L102: `  - So for `--profile` / `--profile-file` to be passable, the command must have `ProfileSettingsLayer` registered (typically by enabling it and calling `AddToCobraCommand`).`
- L155: `- Implement bootstrap parsing in `geppetto/pkg/layers/layers.go`.`
- L156: `- Ensure the Glazed profile settings layer is enabled in the example so the flags exist and the layer is present for env/config parsing.`
- L180: `- Updated the smoke-test script to validate multiple selection/override modes using `--print-parsed-parameters`:`

### `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/tasks.md`
- L5: `- [x] **Option A bootstrap parse (Geppetto)**: Implement ‚Äúbootstrap parse‚Äù to resolve `profile-settings` using defaults + config + env + flags *before* instantiating `GatherFlagsFromProfiles` in `geppetto/pkg/layers/layers.go`.`
- L7: `- [x] **Profile settings layer enabled in example**: Update `geppetto/cmd/examples/simple-inference/main.go` to enable the Glazed `ProfileSettings` layer so `--profile/--profile-file` flags exist and env parsing has the layer available.`

### `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/changelog.md`
- L15: `Docs updated: added Glazed profiles overview (topics/15-profiles.md), corrected Glazed profile implementation/middleware examples, and updated Geppetto Pinocchio profile topic to use profile-settings config keys, correct config search paths, and recommend --print-parsed-parameters.`

### `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/tasks.md`
- L10: `  - [x] `profiles.yaml` format (profile ‚Üí layer slug ‚Üí param ‚Üí value)`
- L15: `  - [x] how to enable flags: `cli.WithProfileSettingsLayer()` when building Cobra commands`
- L16: `  - [x] how to debug: `--print-parsed-parameters``
- L22: `  - [x] Fix config example to use `profile-settings:` layer keys (not top-level `profile:`)`
- L24: `  - [x] Mention precedence and `--print-parsed-parameters``

### `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/analysis/01-profile-helpers-refactor-proposal-bootstrap-parse-middleware-builder.md`
- L26: ``geppetto/pkg/layers/layers.go` contains a correct but **verbose** ‚ÄúOption A bootstrap parse‚Äù to avoid`
- L37: `- duplicated ‚Äúwhich layers should env/config apply to‚Äù decisions`
- L62: `- `middlewares.LoadParametersFromResolvedFilesForCobra(cmd, args, resolver, ...)` (Cobra-specific wrapper)`
- L103: `    ConfigFilesFunc func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]string, error)`
- L105: `    // Optional: config mapper used by LoadParametersFromFiles for non-standard config structures`
- L149: `    parseOpts ...parameters.ParseStepOption,`

### `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/index.md`
- L19: `    - Path: ../../../../../../geppetto/pkg/layers/layers.go`
- L22: `      Note: CobraParser.Parse + ParseCommandSettingsLayer bootstrap limitations`
- L24: `      Note: LoadParametersFromResolvedFilesForCobra helper (potential building block)`

### `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/reference/01-diary.md`
- L30: ``geppetto/pkg/layers/layers.go` currently contains a verbose but correct Option A bootstrap parse:`
- L49: `  - `middlewares.LoadParametersFromResolvedFilesForCobra``

### `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/tasks.md`
- L5: `- [ ] **Audit current pattern**: Extract the repeated ‚Äúbootstrap parse profile-settings‚Äù logic from `geppetto/pkg/layers/layers.go` into a minimal checklist of required steps.`
- L13: `- [ ] **Refactor sketch (Geppetto)**: Show how `geppetto/pkg/layers/layers.go` would shrink after adopting the helper.`

### `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/README.md`
- L1: `# Refactor early logging flag parsing to use ParameterLayer -> pflag.FlagSet conversion`

### `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/analysis/01-analysis-parameterlayer-to-pflag-flagset-conversion-for-early-logging.md`
- L2: `Title: 'Analysis: ParameterLayer to pflag.FlagSet conversion for early logging'`
- L9: `    - layers`
- L16: `      Note: Current implementation that duplicates logging layer definition`
- L17: `    - Path: pkg/cmds/logging/layer.go`
- L18: `      Note: Logging layer definition that should be the single source of truth`
- L19: `    - Path: pkg/cmds/parameters/cobra.go`
- L20: `      Note: Existing ParameterType to cobra flag conversion logic to reuse`
- L27: `# Analysis: ParameterLayer to pflag.FlagSet conversion for early logging`
- L33: `1. **Duplicates the logging layer definition**: The flag definitions are manually maintained in `pinocchio/cmd/pinocchio/main.go`, duplicating what's already defined in `glazed/pkg/cmds/logging/layer.go` via `NewLoggingLayer()`.`
- L35: `2. **Hardcodes flag names**: The filtering logic (`filterEarlyLoggingArgs`) maintains a hardcoded list of allowed flags, which must be kept in sync with the layer definition.`
- L56: `    // Manually define flags matching AddLoggingLayerToRootCommand`
- L62: `### Glazed's Logging Layer (`glazed/pkg/cmds/logging/layer.go`)`
- L65: `func NewLoggingLayer() (schema.Section, error) {`
- L67: `        LoggingLayerSlug,`
- L70: `            fields.New("log-level", ParameterTypeChoice, ...),`
- L76: `func AddLoggingLayerToRootCommand(rootCmd *cobra.Command, appName string) error {`
- L83: `## Solution: ParameterLayer ‚Üí pflag.FlagSet Conversion`
- L85: `Create a reusable function in glazed that converts a `ParameterLayer` to a standalone `pflag.FlagSet`, enabling:`
- L87: `1. **Single source of truth**: Use the layer definition directly, no duplication`
- L88: `2. **Automatic filtering**: Derive allowed flags from the layer definition`
- L89: `3. **Reusability**: Any application can use this for early initialization of any layer`
- L90: `4. **Type safety**: Leverage existing ParameterType ‚Üí pflag type mappings`
- L97: `// CreatePflagSetFromLayer creates a standalone pflag.FlagSet from a ParameterLayer`
- L98: `func CreatePflagSetFromLayer(`
- L99: `    layer schema.Section,`
- L109: `**Current behavior**: `AddParametersToCobraCommand` applies prefix and converts `_` to `-`:`
- L111: `flagName := prefix + parameter.Name`
- L134: `**Implementation**: Check `prefix == ""` before using `parameter.ShortFlag`.`
- L136: `#### 3. ParameterType ‚Üí pflag Type Mapping`
- L138: `We can reuse the existing mapping from `AddParametersToCobraCommand`:`
- L140: `| ParameterType | pflag Method | Notes |`
- L142: `| `ParameterTypeString`, `ParameterTypeSecret`, `ParameterTypeChoice` | `String()` | With default extraction |`
- L143: `| `ParameterTypeInteger` | `Int()` | With default extraction |`
- L144: `| `ParameterTypeFloat` | `Float64()` | With default extraction |`
- L145: `| `ParameterTypeBool` | `Bool()` | With default extraction |`
- L146: `| `ParameterTypeStringList`, `ParameterTypeChoiceList` | `StringSlice()` | With default extraction |`
- L147: `| `ParameterTypeDate` | `String()` | Treated as string in pflag |`
- L148: `| `ParameterTypeFile`, `ParameterTypeStringFromFile`, etc. | `String()` | File paths are strings |`
- L149: `| `ParameterTypeKeyValue` | `StringSlice()` | Colon-separated format |`
- L151: `**Complex types** (`ParameterTypeObjectFromFile`, `ParameterTypeObjectListFromFile`, etc.) are handled as strings in pflag (file paths), consistent with cobra integration.`
- L155: `**Current behavior**: `AddParametersToCobraCommand` extracts defaults using type-specific casting:`
- L156: `- String: `cast.ToString(*parameter.Default)``
- L157: `- Integer: `cast.CastNumberInterfaceToInt[int](*parameter.Default)``
- L158: `- Bool: `(*parameter.Default).(bool)``
- L161: `**Proposed behavior**: Reuse the same casting logic. Extract defaults only if `parameter.Default != nil`.`
- L167: `helpText := fmt.Sprintf("%s - <%s>", parameter.Help, parameter.Type)`
- L205: `**Option B: Use existing ParsedLayer mechanism**`
- L206: `Parse the FlagSet into a `ParsedLayer` using existing parsing infrastructure.`
- L210: `func ExtractValuesFromFlagSet(fs *pflag.FlagSet, layer schema.Section) (map[string]interface{}, error)`
- L213: `This iterates over the layer's parameter definitions and extracts values using the appropriate `pflag.FlagSet` getter methods.`
- L221: `func FilterArgsForLayer(args []string, layer schema.Section, prefix string) []string`
- L225: `1. Gets parameter definitions from the layer`
- L232: `glazed/pkg/cmds/layers/`
- L233: `  pflag.go                    # New: CreatePflagSetFromLayer, ExtractValuesFromFlagSet`
- L235: `  filter_args.go              # New: FilterArgsForLayer`
- L238: `  init-early.go               # New: InitEarlyLoggingFromArgs using layer conversion`
- L248: `    // Get logging layer`
- L249: `    loggingLayer, _ := logging.NewLoggingLayer()`
- L252: `    earlyFs, _ := layers.CreatePflagSetFromLayer(`
- L253: `        loggingLayer,`
- L255: `        layers.WithAllowUnknownFlags(true),`
- L256: `        layers.WithContinueOnError(true),`
- L260: `    filteredArgs := layers.FilterArgsForLayer(os.Args[1:], loggingLayer, "")`
- L266: `    values, _ := layers.ExtractValuesFromFlagSet(earlyFs, loggingLayer)`
- L271: `    loggingLayer.InitializeStructFromParameterDefaults(settings)`
- L287: `    layer, _ := NewLoggingLayer()`
- L290: `    fs, _ := layers.CreatePflagSetFromLayer(layer, "early-logging",`
- L291: `        layers.WithAllowUnknownFlags(true),`
- L292: `        layers.WithContinueOnError(true),`
- L296: `    filtered := layers.FilterArgsForLayer(args, layer, "")`
- L300: `    values, _ := layers.ExtractValuesFromFlagSet(fs, layer)`
- L315: `1. **Phase 1**: Implement `CreatePflagSetFromLayer` and `ExtractValuesFromFlagSet` in `glazed/pkg/cmds/layers/pflag.go``
- L316: `2. **Phase 2**: Implement `FilterArgsForLayer` in `glazed/pkg/cmds/layers/filter_args.go``
- L323: `1. **Unit tests** for `CreatePflagSetFromLayer`:`
- L324: `   - Test all ParameterType mappings`
- L329: `2. **Unit tests** for `FilterArgsForLayer`:`
- L343: `1. **Prefix conflicts**: If a layer has prefix `"log-"` and a parameter `"level"`, the flag becomes `--log-level`. Need to ensure this doesn't conflict with other layers.`
- L347: `3. **Default value types**: Some ParameterTypes have complex defaults (e.g., `ParameterTypeKeyValue`). The extraction logic must handle all cases.`
- L351: `5. **Help flag**: The `--help` flag is special in cobra. Early parsing should ignore it (it's not in the logging layer), letting cobra handle it during `Execute()`.`
- L356: `2. **Maintainability**: Changes to logging layer automatically propagate`
- L358: `4. **Type safety**: Leverage existing ParameterType system`
- L364: `1. **Risk**: Breaking changes if ParameterType system changes`
- L375: `Converting `ParameterLayer` to `pflag.FlagSet` is a clean, reusable solution that eliminates code duplication and provides a foundation for early initialization of any layer-based configuration. The design leverages existing glazed infrastructure and maintains consistency with cobra integration.`

### `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/changelog.md`
- L10: `Created analysis document: ParameterLayer to pflag.FlagSet conversion design`
- L14: `- /home/manuel/workspaces/2025-11-18/fix-pinocchio-profiles/glazed/ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/analysis/01-analysis-parameterlayer-to-pflag-flagset-conversion-for-early-logging.md ‚Äî Comprehensive design analysis`

### `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/index.md`
- L2: `Title: Refactor early logging flag parsing to use ParameterLayer -> pflag.FlagSet conversion`
- L9: `    - layers`
- L15: `    - Path: pkg/cmds/layers`
- L26: `# Refactor early logging flag parsing to use ParameterLayer -> pflag.FlagSet conversion`
- L46: `- layers`

### `ttmp/2026/01/19/MO-GLAZE-001-UPDATE-DOCS--update-docs-examples-for-new-schema-fields-values-sources-api/diary/01-diary.md`
- L46: `The tutorial in `pkg/doc/tutorials/05-build-first-command.md` was still teaching the older vocabulary (`layers`, `parameters`, direct `settings.NewGlazedParameterLayers`). I updated it to use the wrapper packages introduced in ticket `001-REFACTOR-NEW-PACKAGES` so readers see the new API surface first.`
- L54: `- Replaced `parsedLayers.InitializeStruct(schema.DefaultSlug, ...)` examples with `values.DecodeSectionInto(vals, schema.DefaultSlug, ...)`.`
- L55: `- Updated parameter definitions from `fields.New(...)` to `fields.New(...)`.`
- L56: `- Updated short-help layer references to `schema.DefaultSlug`.`
- L76: `- Keeping examples ‚Äúnew API vocabulary‚Äù while still reflecting the underlying alias reality (e.g. some glue points still talk about `layers` in other parts of the codebase).`
- L79: `- The tutorial is long and includes multiple embedded examples (dual-mode, advanced parameter types). A reviewer should skim for any remaining stale wording (‚Äúlayers/parsedLayers‚Äù) that might confuse readers even if code compiles.`
- L136: `- Some examples still legitimately need the underlying packages (e.g. `cmds/parameters` for `FileData`, or `cmds/layers` for cobra-layer plumbing), so ‚Äúnew API everywhere‚Äù has to be applied pragmatically rather than dogmatically.`
- L139: `- The examples touched a wide surface area; a reviewer should spot-check that the updated examples still reflect the recommended practices (especially around config precedence and when to rely on `cli.BuildCobraCommand` auto-injecting glazed layers).`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/01-documentation-deprecation-audit-layers-parameters-schema-fields-values-sources.md`
- L20: `    - Path: pkg/doc/topics/13-layers-and-parsed-layers.md`
- L45: `- `layers` ‚Üí `schema` (sections + schema collections)`
- L46: `- `parameters` ‚Üí `fields` (definitions + parsed parameters)`
- L48: `- `ParsedLayer(s)` ‚Üí `values.SectionValues` / `values.Values``
- L49: `- `ParameterDefinition(s)` ‚Üí `Definition(s)``
- L52: `- `LoadParametersFromFile(s)` ‚Üí `sources.FromFile(s)``
- L57: `- ParameterType: 43`
- L58: `- pkg/cmds/layers import: 24`
- L60: `- ParameterDefinition: 22`
- L61: `- LoadParametersFromFile: 19`
- L62: `- ParsedLayers: 19`
- L63: `- pkg/cmds/parameters import: 19`
- L65: `- ParameterLayers: 11`
- L66: `- ParameterLayer: 10`
- L68: `- ParsedLayer: 8`
- L71: `- LoadParametersFromFiles: 7`
- L72: `- ParameterDefinitions: 6`
- L74: `- layers.ParameterLayer: 4`
- L76: `- layers.ParameterLayers: 2`
- L77: `- parameters.ParameterDefinition: 2`
- L78: `- CobraParameterLayer: 1`
- L81: `- parameters.ParameterDefinitions: 1`
- L115: `- Pattern labels: pkg/cmds/layers import, pkg/cmds/parameters import`
- L122: `L 134 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L123: `L 213 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L124: `L 265 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L125: `L 135 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L126: `L 214 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L127: `L 266 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L133: `- Pattern labels: ParameterDefinition`
- L135: `  - Replace `ParameterDefinition` with `Definition`.`
- L139: `L  31 [ParameterDefinition] map it to the ParameterDefinition the Command uses, and create a YAML file with the default values.`
- L358: `### glazed/pkg/doc/topics/07-load-parameters-from-json.md`
- L366: `### glazed/pkg/doc/topics/08-file-parameter-type.md`
- L369: `- Pattern labels: ParameterType`
- L371: `  - Replace `ParameterType*` with `fields.Type*` names.`
- L375: `L  86 [ParameterType] ## The `file` ParameterType`
- L381: `- Pattern labels: ParameterDefinition, ParameterType`
- L383: `  - Replace `ParameterDefinition` with `Definition`.`
- L384: `  - Replace `ParameterType*` with `fields.Type*` names.`
- L388: `L  25 [ParameterDefinition] params []*ParameterDefinition,`
- L389: `L  35 [ParameterDefinition] - `params`: a slice of `*ParameterDefinition` representing the parameter definitions.`
- L390: `L  49 [ParameterDefinition] params := []*ParameterDefinition{`
- L391: `L  50 [ParameterType] {Name: "verbose", ShortFlag: "v", Type: ParameterTypeBool},`
- L392: `L  51 [ParameterType] {Name: "output", ShortFlag: "o", Type: ParameterTypeString},`
- L414: `- Pattern labels: LoadParametersFromFile, LoadParametersFromFiles`
- L416: `  - Replace `LoadParametersFromFile` with `sources.FromFile`.`
- L417: `  - Replace `LoadParametersFromFiles` with `sources.FromFiles`.`
- L421: `L  71 [LoadParametersFromFile] For advanced use cases, combine profile middleware with additional config files using `LoadParametersFromFile` or `LoadParametersFromFiles`:`
- L422: `L  71 [LoadParametersFromFiles] For advanced use cases, combine profile middleware with additional config files using `LoadParametersFromFile` or `LoadParametersFromFiles`:`
- L425: `### glazed/pkg/doc/topics/13-layers-and-parsed-layers.md`
- L428: `- Pattern labels: AddFlags, LoadParametersFromFile, LoadParametersFromFiles, ParameterDefinition, ParameterLayer, ParameterLayers, ParseFromCobraCommand, ParsedLayer, ParsedLayers, SetFromDefaults, UpdateFromEnv, WithParseStepSource`
- L431: `  - Replace `LoadParametersFromFile` with `sources.FromFile`.`
- L432: `  - Replace `LoadParametersFromFiles` with `sources.FromFiles`.`
- L433: `  - Replace `ParameterDefinition` with `Definition`.`
- L434: `  - Replace `ParameterLayer` with `Section` (schema section).`
- L435: `  - Replace `ParameterLayers` with `Schema`.`
- L437: `  - Replace `ParsedLayer` with `values.SectionValues`.`
- L438: `  - Replace `ParsedLayers` with `values.Values`.`
- L445: `L  32 [ParameterLayer] 1. **ParameterLayer**: An interface that groups parameter definitions and provides metadata.`
- L446: `L  33 [ParameterLayer] 2. **ParameterLayers**: A collection of ParameterLayer objects.`
- L447: `L  38 [ParameterLayer] `ParameterLayer` interface.`
- L448: `L 201 [ParameterLayer] parameterLayers.ForEach(func(key string, p ParameterLayer) {`
- L449: `L 205 [ParameterLayer] err := parameterLayers.ForEachE(func(key string, p ParameterLayer) error {`
- L450: `L 255 [ParameterLayer] arguments, configuration files, or environment variables) using a ParameterLayer`
- L451: `L 258 [ParameterLayer] 1. **Layer**: A reference to the original ParameterLayer used for parsing.`
- L452: `L  33 [ParameterLayers] 2. **ParameterLayers**: A collection of ParameterLayer objects.`
- L453: `L 156 [ParameterLayers] ### Creating ParameterLayers`
- L454: `L 213 [ParameterLayers] Create a new ParameterLayers containing only the specified layers:`
- L455: `L 230 [ParameterLayers] Merge two ParameterLayers collections:`
- L456: `L 238 [ParameterLayers] Create a deep copy of ParameterLayers:`
- L457: `L 380 [ParameterLayers] - **Middleware Structure**: Each middleware processes parameters before and/or after calling the next handler in the chain. They work with `ParameterLayers` and `ParsedLayers` to manage parameter definitions and values.`
- L458: `L 254 [ParsedLayer] A ParsedLayer is the result of parsing input data (such as command-line`
- L459: `L 264 [ParsedLayer] ParsedLayers is a collection of ParsedLayer objects, typically representing all the layers used in a command or application.`
- L460: `L 277 [ParsedLayer] ### Creating a ParsedLayer`
- L461: `L 339 [ParsedLayer] parsedLayers.ForEach(func(k string, v *ParsedLayer) {`
- L462: `L 343 [ParsedLayer] err := parsedLayers.ForEachE(func(k string, v *ParsedLayer) error {`
- L463: `L 359 [ParsedLayer] Get an existing ParsedLayer or create a new one if it doesn't exist:`
- L464: `L 264 [ParsedLayers] ParsedLayers is a collection of ParsedLayer objects, typically representing all the layers used in a command or application.`
- L465: `L 266 [ParsedLayers] ### Usage of ParsedLayers`
- L466: `L 268 [ParsedLayers] ParsedLayers are primarily used to:`
- L467: `L 288 [ParsedLayers] ### Creating ParsedLayers`
- L468: `L 306 [ParsedLayers] ### Initializing Structs from ParsedLayers`
- L469: `L 321 [ParsedLayers] ### Merging ParsedLayers`
- L470: `L 367 [ParsedLayers] Create a deep copy of ParsedLayers:`
- L471: `L 380 [ParsedLayers] - **Middleware Structure**: Each middleware processes parameters before and/or after calling the next handler in the chain. They work with `ParameterLayers` and `ParsedLayers` to manage parameter definitions and values.`
- L472: `L  30 [ParameterDefinition] A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.`
- L473: `L 260 [ParameterDefinition] - The original ParameterDefinition`
- L474: `L  60 [AddFlags] You can add parameters to an existing layer using the `AddFlags` method:`
- L475: `L  63 [AddFlags] layer.AddFlags(`
- L476: `L 411 [ParseFromCobraCommand] 4. **ParseFromCobraCommand**: Parses parameter values from a Cobra command, typically used for CLI applications.`
- L478: `L 386 [SetFromDefaults] 1. **SetFromDefaults**: Populates parameters with their default values if no value exists.`
- L479: `L 400 [LoadParametersFromFile] 3. **LoadParametersFromFile / LoadParametersFromFiles**: Load parameters from JSON or YAML files.`
- L480: `L 400 [LoadParametersFromFiles] 3. **LoadParametersFromFile / LoadParametersFromFiles**: Load parameters from JSON or YAML files.`
- L481: `L 436 [WithParseStepSource] - **Source Tracking**: Use `WithParseStepSource` to track where parameter values originate.`
- L500: `### glazed/pkg/doc/topics/16-adding-parameter-types.md`
- L503: `- Pattern labels: ParameterDefinition, ParameterDefinitions, ParameterType`
- L505: `  - Replace `ParameterDefinition` with `Definition`.`
- L506: `  - Replace `ParameterDefinitions` with `Definitions`.`
- L507: `  - Replace `ParameterType*` with `fields.Type*` names.`
- L511: `L  88 [ParameterDefinition] func (p *ParameterDefinition) ParseParameter(v []string, options ...ParseStepOption) (*ParsedParameter, error) {`
- L512: `L 136 [ParameterDefinition] func (p *ParameterDefinition) ParseFromReader(f io.Reader, filename string, options ...ParseStepOption) (*ParsedParameter, error) {`
- L513: `L 163 [ParameterDefinition] func (p *ParameterDefinition) CheckValueValidity(v interface{}) (interface{}, error) {`
- L514: `L 203 [ParameterDefinition] func (p *ParameterDefinition) InitializeValueToEmptyValue(value reflect.Value) error {`
- L515: `L 216 [ParameterDefinition] func (p *ParameterDefinition) SetValueFromInterface(value reflect.Value, v interface{}) error {`
- L516: `L 445 [ParameterDefinition] pd := &ParameterDefinition{`
- L517: `L 237 [ParameterDefinitions] func (ps *ParameterDefinitions) AddToCobraCommand(cmd *cobra.Command) error {`
- L518: `L 261 [ParameterDefinitions] func (ps *ParameterDefinitions) SetupCobraCompletions(cmd *cobra.Command) error {`
- L519: `L  60 [ParameterType] ParameterTypeCredentials ParameterType = "credentials"`
- L520: `L  67 [ParameterType] func (p ParameterType) IsList() bool {`
- L521: `L  69 [ParameterType] case ParameterTypeCredentials:`
- L522: `L  94 [ParameterType] case ParameterTypeCredentials:`
- L523: `L 142 [ParameterType] case ParameterTypeCredentials:`
- L524: `L 169 [ParameterType] case ParameterTypeCredentials:`
- L525: `L 207 [ParameterType] case ParameterTypeCredentials:`
- L526: `L 222 [ParameterType] case ParameterTypeCredentials:`
- L527: `L 243 [ParameterType] case ParameterTypeCredentials:`
- L528: `L 265 [ParameterType] case ParameterTypeCredentials:`
- L529: `L 278 [ParameterType] func RenderValue(parameterType ParameterType, value interface{}) (string, error) {`
- L530: `L 282 [ParameterType] case ParameterTypeCredentials:`
- L531: `L 371 [ParameterType] Add a field to the `ParameterTypesSettings` struct:`
- L532: `L 374 [ParameterType] type ParameterTypesSettings struct {`
- L533: `L 447 [ParameterType] Type: ParameterTypeCredentials,`
- L534: `L 471 [ParameterType] ParameterTypeCredentials ParameterType = "credentials"`
- L535: `L 474 [ParameterType] func (p ParameterType) IsKeyValue() bool {`
- L536: `L 476 [ParameterType] case ParameterTypeKeyValue, ParameterTypeCredentials:`
- L537: `L 508 [ParameterType] 1. **Consistent naming**: Use the pattern `ParameterType<Name>` for constants`
- L540: `### glazed/pkg/doc/topics/16-parsing-parameters.md`
- L543: `- Pattern labels: ParameterDefinition, ParameterDefinitions, ParameterType, pkg/cmds/parameters import`
- L545: `  - Replace `ParameterDefinition` with `Definition`.`
- L546: `  - Replace `ParameterDefinitions` with `Definitions`.`
- L547: `  - Replace `ParameterType*` with `fields.Type*` names.`
- L552: `L  91 [pkg/cmds/parameters import] import "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L553: `L  21 [ParameterDefinition] ### ParameterDefinition`
- L554: `L  23 [ParameterDefinition] A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.`
- L555: `L  26 [ParameterDefinition] type ParameterDefinition struct {`
- L556: `L  40 [ParameterDefinition] `ParameterDefinitions` is an ordered map of `ParameterDefinition` instances, indexed by name.`
- L557: `L  44 [ParameterDefinition] *orderedmap.OrderedMap[string, *ParameterDefinition]`
- L558: `L  50 [ParameterDefinition] A `ParsedParameter` contains the parsed value, its `ParameterDefinition`, and a log of parsing steps.`
- L559: `L  55 [ParameterDefinition] ParameterDefinition *ParameterDefinition`
- L560: `L  88 [ParameterDefinition] Define parameters using `ParameterDefinition`, specifying name, type, and options like default values or choices.`
- L561: `L  38 [ParameterDefinitions] ### ParameterDefinitions`
- L562: `L  40 [ParameterDefinitions] `ParameterDefinitions` is an ordered map of `ParameterDefinition` instances, indexed by name.`
- L563: `L  43 [ParameterDefinitions] type ParameterDefinitions struct {`
- L564: `L  29 [ParameterType] Type       ParameterType `yaml:"type"``
- L578: `- Pattern labels: ParsedLayer, ParsedLayers`
- L580: `  - Replace `ParsedLayer` with `values.SectionValues`.`
- L581: `  - Replace `ParsedLayers` with `values.Values`.`
- L585: `L  95 [ParsedLayer] Parses a Lua table into a ParsedLayer.`
- L586: `L  65 [ParsedLayers] Middleware to parse nested Lua tables into ParsedLayers.`
- L587: `L 101 [ParsedLayers] Parses a nested Lua table into ParsedLayers.`
- L609: `- Pattern labels: ExecuteMiddlewares, LoadParametersFromFile, ParameterLayer, ParameterLayers, ParseFromCobraCommand, ParsedLayers, SetFromDefaults, UpdateFromEnv, WithParseStepSource, pkg/cmds/layers import, pkg/cmds/middlewares import, pkg/cmds/parameters import`
- L612: `  - Replace `LoadParametersFromFile` with `sources.FromFile`.`
- L613: `  - Replace `ParameterLayer` with `Section` (schema section).`
- L614: `  - Replace `ParameterLayers` with `Schema`.`
- L616: `  - Replace `ParsedLayers` with `values.Values`.`
- L626: `L 756 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L627: `L 757 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L629: `L 750 [ParameterLayer] The foundation of Glazed's parameter system is the `ParameterLayer`. Before we can use middlewares, we need to define our parameter structure. This example shows how to create a layer that matches the architectural concepts discussed earlier:`
- L630: `L  40 [ParameterLayers] ### Relationship between ParameterLayers and ParsedLayers`
- L631: `L  42 [ParameterLayers] - **ParameterLayers**: These are collections of parameter definitions. They define the structure and metadata of parameters, such as their names, types, and default values.`
- L632: `L  70 [ParameterLayers] - `ParameterLayers`: Contains parameter definitions`
- L633: `L  40 [ParsedLayers] ### Relationship between ParameterLayers and ParsedLayers`
- L634: `L  44 [ParsedLayers] - **ParsedLayers**: These are collections of parsed parameter values. They store the actual values obtained from various sources like command-line arguments, environment variables, or configuration files.`
- L635: `L  71 [ParsedLayers] - `ParsedLayers`: Stores the actual parameter values`
- L636: `L 833 [ParsedLayers] - Creation of empty ParsedLayers to store results`
- L639: `L  78 [ExecuteMiddlewares] ExecuteMiddlewares(layers, parsedLayers,`
- L640: `L 443 [ExecuteMiddlewares] ExecuteMiddlewares(layers, parsedLayers,`
- L652: `L  94 [SetFromDefaults] Use `SetFromDefaults` to populate parameters with their default values:`
- L655: `L 804 [SetFromDefaults] The `SetFromDefaults` middleware demonstrates the basic middleware pattern of processing parameters after the next handler:`
- L656: `L  13 [LoadParametersFromFile] - LoadParametersFromFile`
- L657: `L  81 [LoadParametersFromFile] LoadParametersFromFile("config.yaml"),`
- L658: `L  86 [LoadParametersFromFile] 1. LoadParametersFromFile`
- L659: `L 120 [LoadParametersFromFile] Load parameters from JSON or YAML files using `LoadParametersFromFile`:`
- L660: `L 130 [LoadParametersFromFile] By default, `LoadParametersFromFile` expects the config file to have this structure:`
- L661: `L 446 [LoadParametersFromFile] LoadParametersFromFile(),    // More specific`
- L662: `L 688 [LoadParametersFromFile] if commandSettings.LoadParametersFromFile != "" {`
- L663: `L 690 [LoadParametersFromFile] sources.FromFile(commandSettings.LoadParametersFromFile))`
- L670: `- Pattern labels: pkg/cmds/parameters import`
- L676: `L 146 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L690: `- Pattern labels: LoadParametersFromFile, pkg/cmds/layers import, pkg/cmds/middlewares import, pkg/cmds/parameters import`
- L692: `  - Replace `LoadParametersFromFile` with `sources.FromFile`.`
- L699: `L  56 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L700: `L  85 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L701: `L 137 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L702: `L 476 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L703: `L 479 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L712: `L  26 [LoadParametersFromFile] - Using the Mapper: Wire into `LoadParametersFromFile``
- L713: `L  70 [LoadParametersFromFile] // Use with LoadParametersFromFile`
- L714: `L  98 [LoadParametersFromFile] // Use with LoadParametersFromFile`
- L720: `- Pattern labels: LoadParametersFromFile, LoadParametersFromFiles, pkg/cmds/layers import, pkg/cmds/middlewares import, pkg/cmds/parameters import`
- L722: `  - Replace `LoadParametersFromFile` with `sources.FromFile`.`
- L723: `  - Replace `LoadParametersFromFiles` with `sources.FromFiles`.`
- L730: `L  31 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L731: `L  73 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L732: `L 110 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L733: `L 129 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L734: `L 171 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L735: `L 216 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L736: `L 308 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L737: `L 352 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L738: `L  33 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L739: `L  74 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L740: `L 219 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L741: `L 309 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L745: `L 210 [pkg/cmds/middlewares import] Use `github.com/go-go-golems/glazed/pkg/cmds/middlewares/patternmapper` to declare mapping rules and pass the mapper to `LoadParametersFromFile`.`
- L750: `L 210 [LoadParametersFromFile] Use `github.com/go-go-golems/glazed/pkg/cmds/middlewares/patternmapper` to declare mapping rules and pass the mapper to `LoadParametersFromFile`.`
- L751: `L 390 [LoadParametersFromFiles] Legacy Viper-based middlewares like `GatherFlagsFromViper` and per-command `--load-parameters-from-file` are deprecated. Prefer config middlewares (`LoadParametersFromFiles`) with resolvers and `--config-file`.`
- L757: `- Pattern labels: ParameterType, ParsedLayers, pkg/cmds/layers import, pkg/cmds/parameters import`
- L759: `  - Replace `ParameterType*` with `fields.Type*` names.`
- L760: `  - Replace `ParsedLayers` with `values.Values`.`
- L766: `L  96 [pkg/cmds/layers import] - `github.com/go-go-golems/glazed/pkg/cmds/layers`: Parameter layering system`
- L767: `L  95 [pkg/cmds/parameters import] - `github.com/go-go-golems/glazed/pkg/cmds/parameters`: Parameter types and definitions`
- L768: `L  56 [ParsedLayers] ‚îÇ  Parameters  ‚îÇ          ‚îÇ ParsedLayers    ‚îÇ`
- L769: `L  87 [ParsedLayers] 5. **ParsedLayers**: Runtime values after collecting from CLI flags, environment, config files, and defaults`
- L770: `L 784 [ParameterType] Glazed treats command-line parameters as more than just strings. They are typed objects with built-in validation, default values, and help text. This approach shifts the burden of parsing and validation from the command's business logic to the framework itself. By defining a parameter's type (e.g., `ParameterTypeInteger`, `ParameterTypeDate`, `ParameterTypeFile`), you get automatic error handling and a more robust and user-friendly CLI.`
- L771: `L 793 [ParameterType] **`ParameterTypeString`**: The workhorse for text inputs - names, descriptions, URLs`
- L772: `L 794 [ParameterType] **`ParameterTypeSecret`**: Like strings, but values are masked in help and logs (perfect for passwords, API keys)`
- L773: `L 795 [ParameterType] **`ParameterTypeInteger`**: Whole numbers with automatic range validation`
- L774: `L 796 [ParameterType] **`ParameterTypeFloat`**: Decimal numbers for measurements, percentages, ratios`
- L775: `L 797 [ParameterType] **`ParameterTypeBool`**: True/false flags that work with `--flag` and `--no-flag` patterns`
- L776: `L 798 [ParameterType] **`ParameterTypeDate`**: Intelligent date parsing that handles multiple formats`
- L777: `L 801 [ParameterType] **`ParameterTypeStringList`**: Multiple values like `--tag web --tag api --tag production``
- L778: `L 802 [ParameterType] **`ParameterTypeIntegerList`**: Lists of numbers for ports, IDs, quantities`
- L779: `L 803 [ParameterType] **`ParameterTypeFloatList`**: Multiple decimal values for coordinates, measurements`
- L780: `L 806 [ParameterType] **`ParameterTypeChoice`**: Single selection from predefined options (with tab completion!)`
- L781: `L 807 [ParameterType] **`ParameterTypeChoiceList`**: Multiple selections from predefined options`
- L782: `L 810 [ParameterType] **`ParameterTypeFile`**: File paths with existence validation and tab completion`
- L783: `L 811 [ParameterType] **`ParameterTypeFileList`**: Multiple file paths`
- L784: `L 812 [ParameterType] **`ParameterTypeStringFromFile`**: Read text content from a file (useful for large inputs)`
- L785: `L 813 [ParameterType] **`ParameterTypeStringListFromFile`**: Read line-separated lists from files`
- L786: `L 816 [ParameterType] **`ParameterTypeKeyValue`**: Map-like inputs: `--env DATABASE_URL=postgres://... --env DEBUG=true``
- L797: `### glazed/pkg/doc/topics/layers-guide.md`
- L800: `- Pattern labels: AddFlags, pkg/cmds/layers import, pkg/cmds/parameters import`
- L808: `L 622 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L809: `L 623 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L810: `L 292 [AddFlags] extendedDbLayer.AddFlags(`
- L811: `L 551 [AddFlags] b.layer.AddFlags(`
- L812: `L 560 [AddFlags] b.layer.AddFlags(`
- L813: `L 569 [AddFlags] b.layer.AddFlags(`
- L814: `L1127 [AddFlags] advancedLayer.AddFlags(`
- L815: `L1159 [AddFlags] layer.AddFlags(`
- L816: `L1166 [AddFlags] layer.AddFlags(`
- L817: `L1179 [AddFlags] layer.AddFlags(`
- L818: `L1185 [AddFlags] layer.AddFlags(`
- L821: `### glazed/pkg/doc/topics/logging-layer.md`
- L856: `- Pattern labels: ParameterDefinition`
- L858: `  - Replace `ParameterDefinition` with `Definition`.`
- L862: `L  20 [ParameterDefinition] - `ParameterDefinition`: This struct is used to define the parameters (flags or arguments) that the command takes. It`
- L897: `### glazed/pkg/doc/tutorials/custom-layer.md`
- L900: `- Pattern labels: pkg/cmds/layers import, pkg/cmds/parameters import`
- L907: `L 271 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L908: `L 421 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L909: `L 493 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L910: `L 272 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L911: `L 494 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L917: `- Pattern labels: LoadParametersFromFile, LoadParametersFromFiles, UpdateFromEnv, pkg/cmds/layers import, pkg/cmds/middlewares import, pkg/cmds/parameters import`
- L919: `  - Replace `LoadParametersFromFile` with `sources.FromFile`.`
- L920: `  - Replace `LoadParametersFromFiles` with `sources.FromFiles`.`
- L928: `L 360 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L929: `L 420 [pkg/cmds/layers import] "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L930: `L 121 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L931: `L 146 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L932: `L 248 [pkg/cmds/parameters import] "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L940: `L  27 [LoadParametersFromFile] 1. **Config File Loading**: Replace `GatherFlagsFromViper()` and `GatherFlagsFromCustomViper()` with `LoadParametersFromFile()` or `LoadParametersFromFiles()``
- L941: `L 141 [LoadParametersFromFile] ### After: Using LoadParametersFromFile`
- L942: `L 171 [LoadParametersFromFile] For applications with a single config file, use `LoadParametersFromFile`:`
- L943: `L 498 [LoadParametersFromFile] // Use with LoadParametersFromFile`
- L944: `L  27 [LoadParametersFromFiles] 1. **Config File Loading**: Replace `GatherFlagsFromViper()` and `GatherFlagsFromCustomViper()` with `LoadParametersFromFile()` or `LoadParametersFromFiles()``
- L945: `L 191 [LoadParametersFromFiles] For applications that compose configuration from multiple files, use `LoadParametersFromFiles`:`
- L946: `L 243 [LoadParametersFromFiles] ### After: Using LoadParametersFromFiles`
- L947: `L 771 [LoadParametersFromFiles] 2. Check config file order in `LoadParametersFromFiles` (low ‚Üí high)`
- L953: `- Pattern labels: AddFlags, CobraParameterLayer, CommandDefinition, ExecuteMiddlewares, GatherArguments, LoadParametersFromFile, ParameterDefinition, ParameterDefinitions, ParameterLayer, ParameterLayers, ParameterType, ParseFromCobraCommand, ParsedLayer, ParsedLayers, SetFromDefaults, UpdateFromEnv, WithParseStepSource, layers.ParameterLayer, layers.ParameterLayers, parameters.ParameterDefinition, parameters.ParameterDefinitions, pkg/cmds/layers import, pkg/cmds/middlewares import, pkg/cmds/parameters import`
- L956: `  - Replace `CobraParameterLayer` with `schema.CobraSection`.`
- L960: `  - Replace `LoadParametersFromFile` with `sources.FromFile`.`
- L961: `  - Replace `ParameterDefinition` with `Definition`.`
- L962: `  - Replace `ParameterDefinitions` with `Definitions`.`
- L963: `  - Replace `ParameterLayer` with `Section` (schema section).`
- L964: `  - Replace `ParameterLayers` with `Schema`.`
- L965: `  - Replace `ParameterType*` with `fields.Type*` names.`
- L967: `  - Replace `ParsedLayer` with `values.SectionValues`.`
- L968: `  - Replace `ParsedLayers` with `values.Values`.`
- L972: `  - Replace `layers.ParameterLayer` with `schema.Section`.`
- L973: `  - Replace `layers.ParameterLayers` with `schema.Schema`.`
- L974: `  - Replace `parameters.ParameterDefinition` with `fields.Definition`.`
- L975: `  - Replace `parameters.ParameterDefinitions` with `fields.Definitions`.`
- L982: `L 107 [pkg/cmds/layers import] - `github.com/go-go-golems/glazed/pkg/cmds/layers``
- L983: `L 108 [pkg/cmds/parameters import] - `github.com/go-go-golems/glazed/pkg/cmds/parameters``
- L985: `L  42 [layers.ParameterLayer] - `pkg/cmds/layers.ParameterLayer` ‚Üí `pkg/cmds/schema.Section``
- L986: `L  43 [layers.ParameterLayer] - `pkg/cmds/layers.ParameterLayers` ‚Üí `pkg/cmds/schema.Schema``
- L987: `L  88 [layers.ParameterLayer] - `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`).`
- L988: `L  89 [layers.ParameterLayer] - `layers.ParameterLayer` interface methods now use `*fields.Definition` / `*fields.Definitions`:`
- L989: `L  43 [layers.ParameterLayers] - `pkg/cmds/layers.ParameterLayers` ‚Üí `pkg/cmds/schema.Schema``
- L990: `L  88 [layers.ParameterLayers] - `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`).`
- L991: `L  42 [ParameterLayer] - `pkg/cmds/layers.ParameterLayer` ‚Üí `pkg/cmds/schema.Section``
- L992: `L  89 [ParameterLayer] - `layers.ParameterLayer` interface methods now use `*fields.Definition` / `*fields.Definitions`:`
- L993: `L  43 [ParameterLayers] - `pkg/cmds/layers.ParameterLayers` ‚Üí `pkg/cmds/schema.Schema``
- L994: `L  88 [ParameterLayers] - `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`).`
- L995: `L  51 [ParsedLayer] - `pkg/cmds/layers.ParsedLayer` ‚Üí `pkg/cmds/values.SectionValues``
- L996: `L  50 [ParsedLayers] - `pkg/cmds/layers.ParsedLayers` ‚Üí `pkg/cmds/values.Values``
- L997: `L  79 [ParsedLayers] ‚Ä¶and it still satisfies interfaces that mention `*layers.ParsedLayers`, because `values.Values` is an alias for `layers.ParsedLayers`.`
- L998: `L 165 [ParsedLayers] func (c *MyCmd) Run(ctx context.Context, parsedLayers *layers.ParsedLayers) error {`
- L999: `L  44 [parameters.ParameterDefinition] - `pkg/cmds/parameters.ParameterDefinition` ‚Üí `pkg/cmds/fields.Definition``
- L1000: `L  45 [parameters.ParameterDefinition] - `pkg/cmds/parameters.ParameterDefinitions` ‚Üí `pkg/cmds/fields.Definitions``
- L1001: `L  45 [parameters.ParameterDefinitions] - `pkg/cmds/parameters.ParameterDefinitions` ‚Üí `pkg/cmds/fields.Definitions``
- L1002: `L  44 [ParameterDefinition] - `pkg/cmds/parameters.ParameterDefinition` ‚Üí `pkg/cmds/fields.Definition``
- L1003: `L  45 [ParameterDefinitions] - `pkg/cmds/parameters.ParameterDefinitions` ‚Üí `pkg/cmds/fields.Definitions``
- L1004: `L  46 [ParameterType] - `pkg/cmds/parameters.ParameterType*` ‚Üí `pkg/cmds/fields.Type*``
- L1005: `L 125 [ParameterType] parameters.NewParameterDefinition("limit", parameters.ParameterTypeInteger, parameters.WithDefault(10))`
- L1006: `L 144 [ParameterType] parameters.NewParameterDefinition("api-key", parameters.ParameterTypeString),`
- L1008: `L 221 [CobraParameterLayer] - Cobra-only plumbing: attaching layers to Cobra uses `layers.CobraParameterLayer`.`
- L1015: `L  64 [LoadParametersFromFile] - `middlewares.LoadParametersFromFile(s)` ‚Üí `sources.FromFile` / `sources.FromFiles``
- L1016: `L  67 [WithParseStepSource] - `parameters.WithParseStepSource(...)` ‚Üí `sources.WithSource(...)``

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/03-naming-options-and-rename-audit.md`
- L25: `      Note: CommandDescription.Layers naming`
- L26: `    - Path: pkg/cmds/fields/parsed-parameter.go`
- L27: `      Note: ParsedParameters and ParsedParameter types`
- L28: `    - Path: pkg/cmds/schema/layer.go`
- L32: `    - Path: pkg/cmds/values/parsed-layer.go`
- L49: `- The API has a *three-layer model*:`
- L53: `- The biggest naming concerns are around **"ParsedParameters"** and **"Values"**, which may not convey the final resolved/validated nature or the section-aware container.`
- L57: `2) Is **Section** the right name for a parameter grouping? Or should it be **Group** / **Scope** / **FieldGroup** / **Namespace**?`
- L59: `4) Is **ParsedParameters** the right name for a bag of resolved values? Or should it be **ResolvedFields**, **FieldValues**, **ParsedFields**, **DecodedFields**?`
- L74: `**Current meaning:** Ordered collection of sections describing the command surface (previously ParameterLayers).`
- L90: `- If "Schema" is retained, consider renaming `CommandDescription.Layers` to `Schema` for consistency.`
- L224: `## `AppendLayers` / `PrependLayers``
- L225: `**Current meaning:** mutate schema ordering; still uses "layers" in names.`
- L229: `schema.AppendLayers(sectionA, sectionB)`
- L260: `    _ = cobraSection.AddLayerToCobraCommand(cmd)`
- L266: `- Method rename: `AddLayerToCobraCommand` -> `AddSectionToCobraCommand``
- L269: `- Methods still use "Layer" in name; rename for consistency.`
- L301: `- `ParamDef` (if "parameter" term retained)`
- L323: `## `ParsedParameter``
- L328: `pp := &fields.ParsedParameter{Definition: def}`
- L340: `## `ParsedParameters``
- L341: `**Current meaning:** ordered collection of parsed parameters.`
- L345: `parsed := fields.NewParsedParameters()`
- L388: `## `InitializeStruct` (on `ParsedParameters`)`
- L432: `    values.WithParameterValue("name", "demo"),`
- L450: `values.NewSectionValues(section, values.WithParameterValue("name", "demo"))`
- L499: `type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error`
- L508: `- Parameter names still use layers/parsedLayers; rename to `schema`/`vals`.`
- L592: `## `CommandDescription.Layers``
- L599: `    Layers: schema.NewSchema(schema.WithSections(section)),`
- L608: `- High priority if we want to fully remove "layers" from public API.`
- L610: `## `WithLayers`, `WithLayersList`, `WithLayersMap``
- L615: `cmds.WithLayers(schema.NewSchema(...))`
- L623: `- `WithSchema` already exists as alias; consider removing Layers forms once migration is done.`
- L631: `- `SectionImpl.ChildLayers` (field): rename to `ChildSections` or `Children`.`
- L632: `- `AddLayerToCobraCommand` method on `CobraSection`: rename to `AddSectionToCobraCommand`.`
- L633: `- `ParseLayerFromCobraCommand` on `CobraSection`: rename to `ParseSectionFromCobraCommand`.`
- L634: `- `GetDefaultParameterLayer` on `values.Values`: rename to `GetDefaultSection` or `GetDefaultValues`.`
- L635: `- `AppendLayers` / `PrependLayers` in `schema.Schema`: rename to `AppendSections` / `PrependSections`.`
- L636: `- Variable names across public signatures: `layers`, `parsedLayers` -> `schema`, `vals` or `values`.`
- L640: `func (p *Values) GetDefaultParameterLayer() *SectionValues`
- L654: `1) **Schema/Section**: keep `Schema` and `Section`, but rename container field `Layers` to `Schema` in `CommandDescription` to remove cognitive dissonance.`
- L656: `3) **ParsedParameters**: rename to `ResolvedFields` (or `FieldValues`), and `ParsedParameter` -> `ResolvedField`.`
- L658: `5) **Leftover layer terminology**: rename `AppendLayers`, `ChildLayers`, `AddLayerToCobraCommand` and related methods.`
- L667: `2) Is `Section` the best grouping word for the CLI parameter model, or should it be `Group` or `Namespace`?`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/design-doc/01-no-return-rename-removing-alias-facades-and-migration-tool.md`
- L14: `    - Path: pkg/cmds/fields/parameters.go`
- L15: `      Note: Field definitions (former parameters)`
- L16: `    - Path: pkg/cmds/schema/layer.go`
- L20: `    - Path: pkg/cmds/values/parsed-layer.go`
- L36: `We will remove the compatibility facade packages (`schema`, `fields`, `values`, `sources`) that currently rely on **type aliases** to legacy packages (`layers`, `parameters`, `middlewares`). The goal is a **no‚Äëreturn** migration where the new vocabulary is the only public API. This requires:`
- L65: `- `pkg/cmds/parameters/**` ‚Üí `pkg/cmds/fields/**``
- L66: `- `pkg/cmds/layers/**` ‚Üí `pkg/cmds/schema/**` (section/collection types)`
- L67: `- `pkg/cmds/layers/parsed-*.go`, `serialize_parsed.go` ‚Üí `pkg/cmds/values/**``
- L75: `**Schema layer ‚Üí Sections**`
- L77: `- `ParameterLayer` ‚Üí `Section``
- L78: `- `ParameterLayers` ‚Üí `Schema``
- L79: `- `ParameterLayerImpl` ‚Üí `SectionImpl``
- L80: `- `ParameterLayerOptions` ‚Üí `SectionOption``
- L81: `- `ParameterLayersOption` ‚Üí `SchemaOption``
- L82: `- `NewParameterLayer` ‚Üí `NewSection``
- L83: `- `NewParameterLayers` ‚Üí `NewSchema``
- L84: `- `WithLayers` ‚Üí `WithSections``
- L85: `- `WithParameterDefinitions` ‚Üí `WithFields``
- L87: `**Fields / parameters**`
- L89: `- `ParameterDefinition` ‚Üí `Definition``
- L90: `- `ParameterDefinitions` ‚Üí `Definitions``
- L91: `- `ParameterDefinitionOption` ‚Üí `Option``
- L92: `- `ParameterTypeX` ‚Üí `TypeX``
- L93: `- `NewParameterDefinition` ‚Üí `New``
- L94: `- `NewParameterDefinitions` ‚Üí `NewDefinitions``
- L96: `**Values / parsed layers**`
- L98: `- `ParsedLayer` ‚Üí `SectionValues``
- L99: `- `ParsedLayers` ‚Üí `Values``
- L100: `- `ParsedLayerOption` ‚Üí `SectionValuesOption``
- L101: `- `ParsedLayersOption` ‚Üí `ValuesOption``
- L102: `- `NewParsedLayer` ‚Üí `NewSectionValues``
- L103: `- `NewParsedLayers` ‚Üí `New``
- L104: `- `WithParsedParameters` ‚Üí `WithParameters``
- L105: `- `WithParsedParameterValue` ‚Üí `WithParameterValue``
- L114: `- `LoadParametersFromFile(s)` ‚Üí `FromFile` / `FromFiles``
- L160: `   - Remove `pkg/cmds/layers`, `pkg/cmds/parameters`, `pkg/cmds/middlewares`.`
- L185: `  "github.com/go-go-golems/glazed/pkg/cmds/layers": "github.com/go-go-golems/glazed/pkg/cmds/schema"`
- L186: `  "github.com/go-go-golems/glazed/pkg/cmds/parameters": "github.com/go-go-golems/glazed/pkg/cmds/fields"`
- L191: `    ParameterLayer: Section`
- L192: `    ParameterLayers: Schema`
- L193: `    ParameterLayerImpl: SectionImpl`
- L194: `    ParameterLayerOptions: SectionOption`
- L195: `    ParameterLayersOption: SchemaOption`
- L196: `    NewParameterLayer: NewSection`
- L197: `    NewParameterLayers: NewSchema`
- L198: `    WithLayers: WithSections`
- L199: `    WithParameterDefinitions: WithFields`
- L202: `    ParameterDefinition: Definition`
- L203: `    ParameterDefinitions: Definitions`
- L204: `    ParameterDefinitionOption: Option`
- L205: `    ParameterType: Type`
- L206: `    NewParameterDefinition: New`
- L207: `    NewParameterDefinitions: NewDefinitions`
- L210: `    ParsedLayer: SectionValues`
- L211: `    ParsedLayers: Values`
- L212: `    ParsedLayerOption: SectionValuesOption`
- L213: `    ParsedLayersOption: ValuesOption`
- L214: `    NewParsedLayer: NewSectionValues`
- L215: `    NewParsedLayers: New`
- L216: `    WithParsedParameters: WithParameters`
- L217: `    WithParsedParameterValue: WithParameterValue`
- L225: `    LoadParametersFromFile: FromFile`
- L226: `    LoadParametersFromFiles: FromFiles`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/diary/01-diary.md`
- L16: `    - Path: pkg/cmds/schema/layer.go`
- L20: `    - Path: pkg/cmds/values/parsed-layer.go`
- L68: `- Ran sqlite queries to list symbol additions/removals and locate signature shifts (ParsedLayers ‚Üí values.Values, schema, fields, sources).`
- L127: `sqlite3 /home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/various/git-diff-origin-main.sqlite "select path, hunk_index, hunk_text from diff_hunks where hunk_text like '%ParsedLayers%' and path like 'pkg/%' order by path, hunk_index;"`
- L434: `pkg/cmds/cmds.go:8:2: found packages fields (cobra.go) and parameters (initialize-struct_test.go) in .../pkg/cmds/fields`
- L435: `package .../pkg/cmds/schema from parsed-layer.go: import cycle not allowed`
- L439: `- Follow-on failures required iterative fixes (undefined `DecodeSectionInto`, `sources.WithSource`, stale `layers.*` references, and duplicate imports).`
- L449: `- Verify any remaining exported names still referencing ‚ÄúParameterLayer‚Äù in settings packages are acceptable long-term.`
- L455: `- Start with `glazed/pkg/cmds/schema/layer.go`, `glazed/pkg/cmds/values/parsed-layer.go`, and `glazed/pkg/cmds/sources/middlewares.go`.`
- L461: `rg "ParameterLayer|ParsedLayer|ParameterDefinition|parameters\." -g "*.go"`
- L477: `**User prompt (verbatim):** "Create a tawsk to replace AddFlag with AddFields whem handling layers. Also, now that layers are named schema, maybe other names like that can be cleaned up?`
- L483: `**Assistant interpretation:** Produce a per-doc audit of legacy terms (layers/parameters/middlewares/etc), with update/removal guidance, and keep it tracked in the ticket.`
- L504: `- The highest-entropy docs are concentrated in the ‚Äúlayers/parsed layers‚Äù and ‚Äúcmds middlewares‚Äù topics, which will need careful manual rewrites.`
- L516: `- Review `glazed/ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/01-documentation-deprecation-audit-layers-parameters-schema-fields-values-sources.md`.`
- L526: `docmgr doc relate --doc glazed/ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/01-documentation-deprecation-audit-layers-parameters-schema-fields-values-sources.md \`
- L529: `  --file-note "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/13-layers-and-parsed-layers.md:High-signal doc with legacy terminology"`
- L547: `- Removed an unused import from `pkg/cmds/schema/layer_test.go`.`
- L617: `**User prompt (verbatim):** "Suggest better names for ParsedParameters... I'm note sure ParsedLayers -> Values is the best name either, since we're not handling multiple Sections, and Schema instead of ParameterLayers?`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/reference/01-api-change-analysis-origin-main-head.md`
- L62: `| values | WithParameters | func | `pkg/cmds/values/values.go` |`
- L63: `| values | WithParameterValue | func | `pkg/cmds/values/values.go` |`
- L64: `| settings | NewGlazedSchema | func | `pkg/settings/glazed_layer.go` |`
- L76: `- `cmds.CommandDescription.Layers`: `*layers.ParameterLayers` ‚Üí `*schema.Schema`.`
- L77: `- `layers.ParameterLayer` interface: `AddFlags(...*parameters.ParameterDefinition)` ‚Üí `AddFlags(...*fields.Definition)`; `GetParameterDefinitions() *parameters.ParameterDefinitions` ‚Üí `*fields.Definitions`.`
- L80: `  - `cli.CobraRunFunc`, `cli.CobraParser.Parse`, `cli.ParseCommandSettingsLayer`.`
- L83: `  - `middlewares.ParseFromCobraCommand`, `GatherArguments`, `UpdateFromEnv`, `SetFromDefaults`, `LoadParametersFromFile(s)` ‚Üí `sources.FromCobra`, `FromArgs`, `FromEnv`, `FromDefaults`, `FromFile(s)`.`
- L84: `  - `parameters.WithParseStepSource(...)` ‚Üí `sources.WithSource(...)`.`
- L85: `- Glazed settings layer:`
- L92: `- `pkg/cmds/layers/layer.go` (ParameterLayer method types)`
- L96: `- `pkg/cli/*` (Cobra parser and command settings layers now use schema/values/fields)`
- L97: `- `pkg/settings/glazed_layer.go` (NewGlazedSchema + values.SectionValues in helper signatures)`
- L105: `func (c *MyCmd) Run(ctx context.Context, parsedLayers *values.Values) error {`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/tasks.md`
- L13: `- [x] Replace AddFlag/AddFlags usage with AddFields when handling schema sections; review remaining layer-related naming for cleanup (schema/fields/values/sources).`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/analysis/01-exhaustive-parameter-layer-audit.md`
- L2: `Title: Exhaustive parameter/layer audit`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/changelog.md`
- L25: `- /home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt ‚Äî Updated parameter/layer inventory (non-ttmp)`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/design-doc/01-further-cleanup-and-renaming-plan.md`
- L25: `    - Path: ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`
- L27: `        Raw exhaustive inventory of Parameter/Layer mentions`
- L28: `        Raw Parameter/Layer inventory`
- L40: `The current public API still leaks the old vocabulary (Layer/Parameter) alongside the new schema/fields/values/sources terminology. This is a top-level usability issue: users cannot form a stable mental model while synonyms remain. This plan proposes a **no-backward-compat** rename sweep that eliminates the `Layer` and `Parameter` terms from exported identifiers, unifies the ‚ÄúSection‚Äù concept, and replaces ‚ÄúParsed*‚Äù with value-oriented names. It uses the imported notes (`sources/01-glazed-cleanup-notes.md`) as the guiding rationale and leverages existing migration tooling to execute at scale.`
- L43: `- **Synonyms remain exported**: `Layer` and `Parameter` appear in public identifiers even after the no-return refactor.`
- L45: `- **Misleading value naming**: `ParsedParameters` implies ‚Äúintermediate raw parsing‚Äù even though these are resolved values with provenance.`
- L51: `- **Layer must disappear** from exported identifiers.`
- L54: `- If ‚Äúfield‚Äù becomes the canonical noun, remove ‚Äúparameter‚Äù from exported names and tags.`
- L64: `The raw list of all **Parameter** and **Layer** occurrences (case-insensitive) is stored at:`
- L65: `- `various/01-parameter-layer-mentions.txt``
- L78: `### 1) Remove **Layer** from exported identifiers`
- L79: `**Goal:** ensure there is no exported symbol containing `Layer`.`
- L82: `- `CommandDescription.Layers` ‚Üí `CommandDescription.Schema``
- L83: `- `WithLayers` / `WithLayersList` / `WithLayersMap` ‚Üí `WithSchema*` variants only`
- L87: `cmds.WithLayers(schema.NewSchema(...))`
- L95: `- `AppendLayers` / `PrependLayers` ‚Üí `AppendSections` / `PrependSections``
- L96: `- `ChildLayers` ‚Üí `ChildSections``
- L97: `- `AddLayerToCobraCommand` ‚Üí `AddToCobraCommand` (or `AddSectionToCobraCommand`)`
- L98: `- `ParseLayerFromCobraCommand` ‚Üí `ParseSectionFromCobraCommand``
- L106: `- `SectionValues.Layer` ‚Üí `SectionValues.Section``
- L107: `- `GetDefaultParameterLayer` ‚Üí `DefaultSectionValues` (or `DefaultSection`)`
- L115: `Rename all `*Layer*` helpers to `*Section*` equivalents:`
- L116: `- `WhitelistLayers` ‚Üí `WhitelistSections``
- L117: `- `WrapWithLayerModifyingHandler` ‚Üí `WrapWithSchemaModifyingHandler``
- L124: `### 2) Remove **Parameter** from exported identifiers`
- L128: `- `ParsedParameter` ‚Üí `FieldValue``
- L129: `- `ParsedParameters` ‚Üí `FieldValues``
- L130: `- `ParameterType` ‚Üí `FieldType` (if exported)`
- L138: `- `WithParameterValue` ‚Üí `WithFieldValue``
- L139: `- Any error strings that say ‚Äúparameter‚Äù ‚Üí ‚Äúfield‚Äù`
- L188: `parsed := fields.NewParsedParameters()`
- L206: `- **Keep Parameters as noun**: rejected because package `fields` and `WithFields` already push ‚Äúfield‚Äù vocabulary, causing mixed terminology.`
- L207: `- **Keep Layer in specific contexts**: rejected because it communicates a distinct concept that no longer exists.`
- L218: `   - Layer ‚Üí Section: `AppendLayers` ‚Üí `AppendSections`, etc.`
- L219: `   - Parameter ‚Üí Field: `ParsedParameters` ‚Üí `FieldValues`, etc.`
- L230: `3) Run `rg -n -i "parameter|layer"` to verify removal.`
- L239: `   - Use `various/01-parameter-layer-mentions.txt` to classify exported identifiers vs doc strings.`
- L241: `   - Confirm ‚Äúfield‚Äù vs ‚Äúparameter‚Äù for public nouns.`
- L245: `   - Schema/CommandDescription layer rename`
- L246: `   - Parameter ‚Üí Field rename`
- L254: `   - `rg -n -i "parameter|layer" pkg cmd doc` to confirm removal.`
- L259: `- Is ‚Äúfield‚Äù officially the canonical noun, or should we keep ‚Äúparameter‚Äù? (Strong recommendation: field.)`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/index.md`
- L21: `    - Path: ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`
- L22: `      Note: Updated parameter/layer inventory (non-ttmp)`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/reference/01-diary.md`
- L29: `I created the new ticket workspace, imported the cleanup notes as a source document, generated an exhaustive Parameter/Layer inventory, and authored the initial design document that encodes the no-backward-compat renaming plan. This sets the foundation for a follow-up rename wave and provides the context needed for external review.`
- L33: `**User prompt (verbatim):** "Close the ticket, create a new ticket GL-002-FURTHER-CLEANUP with docmgr and import the file /tmp/glazed-cleanup-notes.md which has a consistent approach to renaming things. Make a detailed guide on further refactoring and renaming things, including all mentiones of Parameter and Layer. Use the information in the imported  file to create an exhaustive design document, how to further leverage the migration tooling, and no backwards compatibility. `
- L37: `**Assistant interpretation:** Close GL-001, create GL-002, import the notes file, and produce an exhaustive renaming design document with an inventory of Parameter/Layer mentions, then keep a diary and prepare for upload after commit.`
- L47: `- Generated a raw, exhaustive `Parameter`/`Layer` mention inventory.`
- L66: `- The final choice of ‚Äúfield‚Äù vs ‚Äúparameter‚Äù as canonical noun and the decision to break the schema/values cycle.`
- L73: `- Review the raw inventory at `glazed/ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`.`
- L80: `rg -n -i "parameter|layer" . > glazed/ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`
- L134: `I updated the codebase and docs to use `glazed:` struct tags, removed any remaining `glazed.parameter` usage, updated the AST migration tool to rewrite tags, and re-ran the parameter/layer inventory with historical docs excluded. I also ran the AST tool against the examples tree and stored the report in the ticket.`
- L148: `- Updated the AST migration tool to rewrite `glazed.parameter` tags and added tag-change reporting.`
- L150: `- Regenerated the parameter/layer inventory excluding historical `ttmp` docs.`
- L165: `- Preserving struct tag quoting while rewriting `glazed.parameter` ‚Üí `glazed` required careful AST handling.`
- L168: `- Remaining parameter/layer mentions that are still intentional vs. candidates for rename cleanup.`
- L175: `- Review the updated inventory at `glazed/ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`.`
- L180: `rg -n "glazed\.parameter"`
- L181: `rg -n -i "parameter|layer" -g '!ttmp/**' > ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/sources/01-glazed-cleanup-notes.md`
- L28: `### 1) ‚ÄúLayer‚Äù is still everywhere`
- L30: `Even after the ‚ÄúSection/Schema‚Äù shift, exported identifiers still say **Layer** in key places (e.g., `CommandDescription.Layers`, `AppendLayers`, `AddLayerToCobraCommand`, `GetDefaultParameterLayer`, many `sources.*Layers*` helpers).`
- L32: `That creates immediate ambiguity: **are Layers and Sections different things, or synonyms?** If they‚Äôre synonyms, you must not expose both.`
- L40: `* `values.SectionValues.Layer` = points at a section definition but is named **Layer**`
- L44: `### 3) ‚ÄúParsedParameters‚Äù reads like an intermediate/one-source artifact`
- L48: `If a user sees `ParsedParameters`, they‚Äôll assume:`
- L74: `* **Definition**: a field/parameter definition`
- L79: `And then: **the word ‚ÄúLayer‚Äù must disappear from exported identifiers**.`
- L87: `I‚Äôm going to propose a coherent set that (a) matches your mental model, (b) removes ‚Äúlayer‚Äù, and (c) removes the ‚Äútwo Section types‚Äù trap.`
- L93: `* `CommandDescription.Layers` ‚Üí `CommandDescription.Schema``
- L94: `* `GetLayer` ‚Üí `GetSection``
- L95: `* `GetDefaultLayer` ‚Üí `GetDefaultSection``
- L96: `* `Clone(cloneLayers bool, ...)` ‚Üí `Clone(cloneSchema bool, ...)` (or `cloneSections`)`
- L103: `  * `WithLayersList` ‚Üí `WithSchemaSections(...)` (avoid plain `WithSections` because you already have `layout.Section` in the same struct)`
- L104: `  * `WithLayersMap` ‚Üí `WithSchemaMap(...)` or `WithSchemaBySlug(...)``
- L105: `  * `WithReplaceLayers` ‚Üí `WithReplaceSchema(...)` or `WithReplaceSections(...)``
- L107: `**Why:** the main struct shouldn‚Äôt expose old vocabulary at all. If someone starts here and sees ‚ÄúLayers,‚Äù they assume ‚Äúlayers are a thing.‚Äù`
- L117: `* `AppendLayers` / `PrependLayers` ‚Üí `AppendSections` / `PrependSections``
- L121: `* `ChildLayers` ‚Üí `ChildSections` (or `Children`)`
- L122: `* Wrapper types still named with ‚ÄúParameterLayer‚Äù:`
- L124: `  * `WhitelistParameterLayer` ‚Üí `WhitelistSection``
- L125: `  * `BlacklistParameterLayer` ‚Üí `BlacklistSection``
- L130: `* `CobraSection.AddLayerToCobraCommand` ‚Üí `AddToCobraCommand` (best)`
- L150: `  * `SectionValues.Section schema.Section` (instead of `Layer Section`)`
- L159: `* `SectionValues.Layer` ‚Üí `SectionValues.Section` (or `Schema`)`
- L163: `Also clean up the ‚Äúlayer‚Äù leftovers:`
- L165: `* `GetDefaultParameterLayer` ‚Üí `DefaultSection()` or `DefaultSectionValues()``
- L175: `I‚Äôd avoid the ‚ÄúResolvedFields‚Äù wording unless you want to re-center the whole library around ‚Äúfields‚Äù vocabulary. You consistently say ‚Äúparameters‚Äù elsewhere.`
- L179: `* `ParsedParameter` ‚Üí `ParameterValue``
- L180: `* `ParsedParameters` ‚Üí `ParameterValues``
- L198: `* Rename exported `...Layers...` helpers to `...Sections...` everywhere:`
- L200: `  * `WhitelistLayers` ‚Üí `WhitelistSections``
- L201: `  * `WhitelistLayerParameters` ‚Üí `WhitelistSectionParameters` (or `...Fields`, but pick one noun and stick to it)`
- L202: `  * `WrapWithLayerModifyingHandler` ‚Üí `WrapWithSchemaModifyingHandler` (or `WrapWithSectionModifyingHandler`)`
- L208: `This is the bar I‚Äôd use: can someone read this and not ask ‚Äúwhat‚Äôs a layer?‚Äù`
- L225: `Schema ‚Üí Resolve ‚Üí Decode. No ‚Äúlayer.‚Äù No ‚Äúparsed vs values‚Äù ambiguity.`
- L233: `1. **Eliminate ‚ÄúLayer‚Äù from exported API** (cmds/schema/values/sources)`
- L254: `Right now the API is already half‚Äëtelling users ‚Äúthese are fields‚Äù (package `fields`, `schema.WithFields(...)`, etc.) but then you surface ‚Äúparameter‚Äù in the most important types (`ParsedParameter(s)`, `glazed` tags, error messages). That mismatch is exactly the kind of ‚Äúwait‚Ä¶ are these different?‚Äù confusion you‚Äôre trying to eliminate. `
- L256: `## Why ‚Äúfield‚Äù beats ‚Äúparameter‚Äù for *this* API`
- L261: `2. **‚ÄúParameter‚Äù is overloaded in Go + CLI land**`
- L262: `   Users will read ‚Äúparameter‚Äù as:`
- L264: `   * function parameter, or`
- L265: `   * CLI flag parameter, or`
- L266: `   * HTTP query parameter, etc.`
- L267: `     Meanwhile your ‚Äúparameters‚Äù include positional args, env/file inputs, and end up as decoded configuration. ‚ÄúField‚Äù is broader and more accurate.`
- L270: `   `schema.WithFields(...)` is a big tell. If you keep ‚Äúparameter‚Äù in the core value types, you‚Äôre teaching two vocabularies for one concept. `
- L274: `If you decide ‚Äúfield‚Äù is the canonical noun, then **remove ‚Äúparameter‚Äù from exported identifiers** (except maybe in very CLI‚Äëspecific helper names, but I‚Äôd avoid even that).`
- L276: `Here‚Äôs the rename set I‚Äôd recommend (adjusting my earlier ‚ÄúParameterValue(s)‚Äù suggestion to ‚ÄúFieldValue(s)‚Äù):`
- L284: `* `ParsedParameter` ‚Üí **`FieldValue`**`
- L286: `* `ParsedParameters` ‚Üí **`FieldValues`**`
- L287: `* `WithParsedParameter(...)` ‚Üí **`WithFieldValue(...)`** (or `WithValue(...)` if scoped on `FieldValues`)`
- L302: `* `WithParameterValue(...)` ‚Üí **`WithFieldValue(...)`**`
- L303: `* Any method like `MustUpdateValue(... errors.Errorf("parameter %s not found"...))` should say **field**, not parameter.`
- L307: `* Rename helpers that currently say `...Parameters...` to `...Fields...` (e.g., whitelisting, filtering, etc.) so users don‚Äôt think ‚Äúparameters‚Äù is a separate concept. `
- L326: `And then do a single sweep to remove ‚Äúparameter‚Äù from exported names + tags so there‚Äôs only one mental model. `

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/tasks.md`
- L7: `- [x] Update AST migration tool to rewrite struct tags + key renames (Layer/Parameter ‚Üí Section/Field) in Go examples.`
- L10: `- [x] Re-run `rg -n -i "parameter|layer"` to validate removal scope (exclude non-API historical docs).`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt`
- L1: `cmd/examples/config-single/main.go:51:		cmds.WithShort("Minimal custom layer with single config file"),`
- L2: `cmd/examples/config-single/main.go:52:		cmds.WithLayersList(demoSection),`
- L3: `cmd/examples/config-single/main.go:90:			SkipCommandSettingsLayer: true,`
- L4: `cmd/examples/config-single/main.go:100:	// validate command: checks the config file against layer definitions`
- L5: `cmd/examples/config-single/main.go:103:		Short: "Validate the config file for known layers, parameters, and types",`
- L6: `cmd/examples/config-single/main.go:108:			// Recreate layers like the main command`
- L7: `cmd/examples/config-single/main.go:125:			// Validate top-level layers and parameters`
- L8: `cmd/examples/config-single/main.go:126:			for layerSlug, v := range raw {`
- L9: `cmd/examples/config-single/main.go:127:				layer, ok := demoCmd.Description().Layers.Get(layerSlug)`
- L10: `cmd/examples/config-single/main.go:129:					issues = append(issues, fmt.Sprintf("unknown layer: %s", layerSlug))`
- L11: `cmd/examples/config-single/main.go:134:					issues = append(issues, fmt.Sprintf("layer %s must be an object", layerSlug))`
- L12: `cmd/examples/config-single/main.go:137:				pds := layer.GetDefinitions()`
- L13: `cmd/examples/config-single/main.go:138:				// Build set of known parameter names`
- L14: `cmd/examples/config-single/main.go:145:						issues = append(issues, fmt.Sprintf("unknown parameter in layer %s: %s", layerSlug, key))`
- L15: `cmd/examples/config-single/main.go:150:						issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))`
- L16: `cmd/examples/refactor-new-packages/main.go:19:// AppSettings maps to the app section parameters`
- L17: `cmd/examples/refactor-new-packages/main.go:26:// OutputSettings maps to the output section parameters`
- L18: `cmd/examples/refactor-new-packages/main.go:99:		schema.WithDescription("Default parameters"),`
- L19: `cmd/examples/refactor-new-packages/main.go:198:			// AppName enables env prefix DEMO_<LAYER_PREFIX+FLAG>`
- L20: `cmd/examples/new-api-build-first-command/main.go:154:			ShortHelpLayers: []string{schema.DefaultSlug},`
- L21: `pkg/codegen/glazed.go:16:func ParameterDefinitionToDict(p *fields.Definition) (jen.Code, error) {`
- L22: `pkg/codegen/glazed.go:43:	d, err := p.CheckParameterDefaultValueValidity()`
- L23: `pkg/codegen/glazed.go:51:func FlagTypeToGoType(s *jen.Statement, parameterType fields.Type) *jen.Statement {`
- L24: `pkg/codegen/glazed.go:52:	switch parameterType {`
- L25: `pkg/codegen/glazed.go:87:		return s.Id(string(parameterType))`
- L26: `cmd/examples/config-pattern-mapper/main.go:49:	demoLayer, err := schema.NewSection(`
- L27: `cmd/examples/config-pattern-mapper/main.go:51:		"Demo Layer",`
- L28: `cmd/examples/config-pattern-mapper/main.go:64:	paramLayers := schema.NewSchema(schema.WithSections(demoLayer))`
- L29: `cmd/examples/config-pattern-mapper/main.go:78:		mapper, err := pm.NewConfigMapper(paramLayers, rules...)`
- L30: `cmd/examples/config-pattern-mapper/main.go:100:		mapper, err := pm.NewConfigMapper(paramLayers,`
- L31: `cmd/examples/config-pattern-mapper/main.go:103:				TargetLayer:     "demo",`
- L32: `cmd/examples/config-pattern-mapper/main.go:104:				TargetParameter: "api-key",`
- L33: `cmd/examples/config-pattern-mapper/main.go:108:				TargetLayer:     "demo",`
- L34: `cmd/examples/config-pattern-mapper/main.go:109:				TargetParameter: "threshold",`
- L35: `cmd/examples/config-pattern-mapper/main.go:133:		mapper, err := pm.NewConfigMapper(paramLayers,`
- L36: `cmd/examples/config-pattern-mapper/main.go:136:				TargetLayer:     "demo",`
- L37: `cmd/examples/config-pattern-mapper/main.go:137:				TargetParameter: "{env}-api-key",`
- L38: `cmd/examples/config-pattern-mapper/main.go:161:		mapper, err := pm.NewConfigMapper(paramLayers,`
- L39: `cmd/examples/config-pattern-mapper/main.go:164:				TargetLayer: "demo",`
- L40: `cmd/examples/config-pattern-mapper/main.go:166:					{Source: "api_key", TargetParameter: "api-key"},`
- L41: `cmd/examples/config-pattern-mapper/main.go:167:					{Source: "threshold", TargetParameter: "threshold"},`
- L42: `cmd/examples/config-pattern-mapper/main.go:168:					{Source: "timeout", TargetParameter: "timeout"},`
- L43: `cmd/examples/config-pattern-mapper/main.go:193:		mapper, err := pm.NewConfigMapper(paramLayers,`
- L44: `cmd/examples/config-pattern-mapper/main.go:196:				TargetLayer: "demo",`
- L45: `cmd/examples/config-pattern-mapper/main.go:199:					{Source: "api_key", TargetParameter: "{env}-api-key"},`
- L46: `cmd/examples/config-pattern-mapper/main.go:221:	// Example 5: Using with LoadParametersFromFile middleware`
- L47: `cmd/examples/config-pattern-mapper/main.go:222:	fmt.Println("=== Example 5: Integration with LoadParametersFromFile ===")`
- L48: `cmd/examples/config-pattern-mapper/main.go:224:		mapper, err := pm.NewConfigMapper(paramLayers,`
- L49: `cmd/examples/config-pattern-mapper/main.go:227:				TargetLayer:     "demo",`
- L50: `cmd/examples/config-pattern-mapper/main.go:228:				TargetParameter: "api-key",`
- L51: `cmd/examples/config-pattern-mapper/main.go:235:		// Use the pattern mapper with sources.FromFile (wraps LoadParametersFromFile)`
- L52: `cmd/examples/config-pattern-mapper/main.go:242:		fmt.Println("Pattern mapper can be used with LoadParametersFromFile middleware")`
- L53: `cmd/examples/config-pattern-mapper/main.go:249:		b := pm.NewConfigMapperBuilder(paramLayers).`
- L54: `cmd/examples/config-pattern-mapper/main.go:274:		b := pm.NewConfigMapperBuilder(paramLayers).`
- L55: `cmd/examples/config-pattern-mapper/main.go:301:		b := pm.NewConfigMapperBuilder(paramLayers).`
- L56: `cmd/examples/config-pattern-mapper/main.go:330:		mapper, err := pm.NewConfigMapper(paramLayers, rules...)`
- L57: `cmd/examples/config-pattern-mapper/mappings.yaml:3:    target_layer: "demo"`
- L58: `cmd/examples/config-pattern-mapper/mappings.yaml:6:        target_parameter: "{env}-api-key"`
- L59: `cmd/examples/config-overlay/main.go:37:	desc := cmds.NewCommandDescription("overlay", cmds.WithShort("Multiple config overlays"), cmds.WithLayersList(demo))`
- L60: `cmd/examples/config-overlay/main.go:80:			SkipCommandSettingsLayer: true,`
- L61: `cmd/examples/config-overlay/main.go:117:				for layerSlug, v := range raw {`
- L62: `cmd/examples/config-overlay/main.go:118:					layer, ok := overlayCmd.Description().Layers.Get(layerSlug)`
- L63: `cmd/examples/config-overlay/main.go:120:						issues = append(issues, fmt.Sprintf("%s: unknown layer %s", f, layerSlug))`
- L64: `cmd/examples/config-overlay/main.go:125:						issues = append(issues, fmt.Sprintf("%s: layer %s must be an object", f, layerSlug))`
- L65: `cmd/examples/config-overlay/main.go:128:					pds := layer.GetDefinitions()`
- L66: `cmd/examples/config-overlay/main.go:133:							issues = append(issues, fmt.Sprintf("%s: unknown parameter %s.%s", f, layerSlug, key))`
- L67: `cmd/examples/config-overlay/main.go:138:							issues = append(issues, fmt.Sprintf("%s: invalid value for %s.%s: %v", f, layerSlug, key, err))`
- L68: `CHANGELOG:10:- Parse Lua tables into Glazed parameter layers`
- L69: `cmd/examples/overlay-override/main.go:38:	desc := cmds.NewCommandDescription("overlay-override", cmds.WithShort("--config-file + <base>.override.yaml pattern"), cmds.WithLayersList(demo))`
- L70: `cmd/examples/appconfig-profiles/main.go:47:	redisLayer := mustSection(schema.NewSection(`
- L71: `cmd/examples/appconfig-profiles/main.go:107:			if err := parser.Register("redis", redisLayer, func(t *AppSettings) any { return &t.Redis }); err != nil {`
- L72: `cmd/examples/appconfig-profiles/main.go:129:	_ = addLayer(root, redisLayer)`
- L73: `cmd/examples/appconfig-profiles/main.go:130:	if psLayer, err := cli.NewProfileSettingsLayer(); err == nil {`
- L74: `cmd/examples/appconfig-profiles/main.go:131:		_ = addLayer(root, psLayer)`
- L75: `cmd/examples/appconfig-profiles/main.go:148:func addLayer(cmd *cobra.Command, layer schema.Section) error {`
- L76: `cmd/examples/appconfig-profiles/main.go:149:	cobraLayer, ok := layer.(schema.CobraSection)`
- L77: `cmd/examples/appconfig-profiles/main.go:151:		return errors.Errorf("layer %s is not a CobraSection", layer.GetSlug())`
- L78: `cmd/examples/appconfig-profiles/main.go:153:	return cobraLayer.AddLayerToCobraCommand(cmd)`
- L79: `README.md:8:Glazed is a comprehensive Go framework for building command-line applications that handle structured data elegantly. It provides a rich command system, flexible parameter management, multiple output formats, and an integrated help system.`
- L80: `README.md:76:### Parameter Layer System`
- L81: `README.md:77:Organize command parameters into reusable, composable layers:`
- L82: `README.md:81:- Type-safe parameter extraction`
- L83: `README.md:103:func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L84: `README.md:114:    parsedLayers *values.Values,`
- L85: `README.md:135:## Parameter Layers`
- L86: `README.md:137:Organize command parameters into logical, reusable groups:`
- L87: `README.md:140:// Define layers for different concerns`
- L88: `README.md:141:func NewDatabaseLayer() *schema.Section {`
- L89: `README.md:150:// Use layers in command definitions`
- L90: `README.md:152:    cmds.WithLayersList(`
- L91: `README.md:153:        databaseLayer,`
- L92: `README.md:154:        loggingLayer, `
- L93: `README.md:155:        glazedLayer,`
- L94: `README.md:161:- Reuse common parameter sets across commands`
- L95: `README.md:162:- Avoid parameter naming conflicts with prefixes`
- L96: `README.md:163:- Type-safe parameter extraction with structs`
- L97: `README.md:265:- [Parameter Layers Guide](pkg/doc/topics/layers-guide.md) - Layer system with examples`
- L98: `README.md:273:- Parameter layer usage`
- L99: `cmd/examples/middlewares-config-env/main.go:18:// DemoSettings maps to the demo layer parameters`
- L100: `cmd/examples/middlewares-config-env/main.go:59:		cmds.WithLayersList(glazedSection, demoSection),`
- L101: `cmd/examples/middlewares-config-env/main.go:100:			// AppName enables env prefix APP_<LAYER_PREFIX+FLAG>`
- L102: `pkg/appconfig/options.go:80:// WithValuesForLayers configures programmatic values for layers (optional).`
- L103: `pkg/appconfig/options.go:81:func WithValuesForLayers(values map[string]map[string]interface{}) ParserOption {`
- L104: `pkg/appconfig/options.go:176:// It does a mini "bootstrap parse" for the `profile-settings` layer to resolve:`
- L105: `pkg/appconfig/options.go:193:// must ensure those flags exist on the command (typically by adding the ProfileSettings layer`
- L106: `pkg/appconfig/options.go:222:				return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L107: `pkg/appconfig/options.go:224:					psLayer, err := cli.NewProfileSettingsLayer()`
- L108: `pkg/appconfig/options.go:229:					bootstrapLayers := schema.NewSchema(schema.WithSections(psLayer))`
- L109: `pkg/appconfig/options.go:268:					if err := cmd_sources.Execute(bootstrapLayers, bootstrapParsed, bootstrapMiddlewares...); err != nil {`
- L110: `pkg/appconfig/options.go:291:					if err := next(layers_, parsedLayers); err != nil {`
- L111: `pkg/appconfig/options.go:295:					// 3) Apply profiles.yaml at the intended precedence layer.`
- L112: `pkg/appconfig/options.go:308:					return handler(layers_, parsedLayers)`
- L113: `pkg/lua/lua.go:19:func ParseNestedLuaTableToValues(L *lua.LState, luaTable *lua.LTable, parameterLayers *schema.Schema) (*values.Values, error) {`
- L114: `pkg/lua/lua.go:20:	parsedLayers := values.New()`
- L115: `pkg/lua/lua.go:25:			layerName := string(keyStr)`
- L116: `pkg/lua/lua.go:26:			layer, ok := parameterLayers.Get(layerName)`
- L117: `pkg/lua/lua.go:28:				conversionErrors = append(conversionErrors, fmt.Sprintf("layer '%s' not found", layerName))`
- L118: `pkg/lua/lua.go:33:				parsedLayer, err := ParseLuaTableToLayer(L, nestedTable, layer)`
- L119: `pkg/lua/lua.go:37:					parsedLayers.Set(layerName, parsedLayer)`
- L120: `pkg/lua/lua.go:40:				conversionErrors = append(conversionErrors, fmt.Sprintf("invalid value for layer '%s': expected table, got %s", layerName, value.Type()))`
- L121: `pkg/lua/lua.go:46:		return nil, fmt.Errorf("parameter conversion errors: %s", strings.Join(conversionErrors, "; "))`
- L122: `pkg/lua/lua.go:49:	return parsedLayers, nil`
- L123: `pkg/lua/lua.go:52:// ParseLuaTableToLayer parses a Lua table into a SectionValues`
- L124: `pkg/lua/lua.go:53:func ParseLuaTableToLayer(L *lua.LState, luaTable *lua.LTable, layer schema.Section) (*values.SectionValues, error) {`
- L125: `pkg/lua/lua.go:59:			paramDef, _ := layer.GetDefinitions().Get(string(keyStr))`
- L126: `pkg/lua/lua.go:61:				convertedValue, err := ParseParameterFromLua(L, value, paramDef)`
- L127: `pkg/lua/lua.go:72:		return nil, fmt.Errorf("parameter conversion errors: %s", strings.Join(conversionErrors, "; "))`
- L128: `pkg/lua/lua.go:75:	// Parse parameters using the layer's definitions`
- L129: `pkg/lua/lua.go:76:	parsedParams, err := layer.GetDefinitions().GatherParametersFromMap(params, true, fields.WithSource("lua"))`
- L130: `pkg/lua/lua.go:81:	// Create a parsed layer`
- L131: `pkg/lua/lua.go:82:	return values.NewSectionValues(layer, values.WithParameters(parsedParams))`
- L132: `pkg/lua/lua.go:86:func ParseLuaTableMiddleware(L *lua.LState, luaTable *lua.LTable, layerName string) sources.Middleware {`
- L133: `pkg/lua/lua.go:88:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L134: `pkg/lua/lua.go:89:			// Look up the specific layer`
- L135: `pkg/lua/lua.go:90:			layer, ok := layers_.Get(layerName)`
- L136: `pkg/lua/lua.go:92:				return fmt.Errorf("layer '%s' not found", layerName)`
- L137: `pkg/lua/lua.go:95:			parsedLayer, err := ParseLuaTableToLayer(L, luaTable, layer)`
- L138: `pkg/lua/lua.go:100:			err = parsedLayers.GetOrCreate(layer).MergeParameters(parsedLayer)`
- L139: `pkg/lua/lua.go:105:			return next(layers_, parsedLayers)`
- L140: `pkg/lua/lua.go:113:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L141: `pkg/lua/lua.go:114:			newValues, err := ParseNestedLuaTableToValues(L, luaTable, layers_)`
- L142: `pkg/lua/lua.go:119:			// Merge the new parsed layers with the existing ones`
- L143: `pkg/lua/lua.go:120:			err = parsedLayers.Merge(newValues)`
- L144: `pkg/lua/lua.go:125:			return next(layers_, parsedLayers)`
- L145: `pkg/lua/lua.go:130:// ParseParameterFromLua parses a Lua value into a Go value based on the parameter definition`
- L146: `pkg/lua/lua.go:131:func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error) {`
- L147: `pkg/lua/lua.go:137:		return nil, fmt.Errorf("invalid type for parameter '%s': expected string, got %s", paramDef.Name, value.Type())`
- L148: `pkg/lua/lua.go:142:		return nil, fmt.Errorf("invalid type for parameter '%s': expected integer, got %s", paramDef.Name, value.Type())`
- L149: `pkg/lua/lua.go:147:		return nil, fmt.Errorf("invalid type for parameter '%s': expected float, got %s", paramDef.Name, value.Type())`
- L150: `pkg/lua/lua.go:152:		return nil, fmt.Errorf("invalid type for parameter '%s': expected boolean, got %s", paramDef.Name, value.Type())`
- L151: `pkg/lua/lua.go:165:				return nil, fmt.Errorf("invalid types in string list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L152: `pkg/lua/lua.go:169:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (string list), got %s", paramDef.Name, value.Type())`
- L153: `pkg/lua/lua.go:182:				return nil, fmt.Errorf("invalid types in integer list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L154: `pkg/lua/lua.go:186:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (integer list), got %s", paramDef.Name, value.Type())`
- L155: `pkg/lua/lua.go:199:				return nil, fmt.Errorf("invalid types in float list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L156: `pkg/lua/lua.go:203:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (float list), got %s", paramDef.Name, value.Type())`
- L157: `pkg/lua/lua.go:212:			return nil, fmt.Errorf("invalid choice '%s' for parameter '%s'", choice, paramDef.Name)`
- L158: `pkg/lua/lua.go:214:		return nil, fmt.Errorf("invalid type for parameter '%s': expected string (choice), got %s", paramDef.Name, value.Type())`
- L159: `pkg/lua/lua.go:239:				return nil, fmt.Errorf("invalid types in choice list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L160: `pkg/lua/lua.go:242:				return nil, fmt.Errorf("invalid choices %v for parameter '%s'", invalidChoices, paramDef.Name)`
- L161: `pkg/lua/lua.go:246:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (choice list), got %s", paramDef.Name, value.Type())`
- L162: `pkg/lua/lua.go:253:			return nil, fmt.Errorf("invalid date '%s' for parameter '%s': %v", v, paramDef.Name, err)`
- L163: `pkg/lua/lua.go:255:		return nil, fmt.Errorf("invalid type for parameter '%s': expected string (date), got %s", paramDef.Name, value.Type())`
- L164: `pkg/lua/lua.go:266:		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (key-value), got %s", paramDef.Name, value.Type())`
- L165: `pkg/lua/lua.go:276:		return nil, fmt.Errorf("parameter type '%s' for '%s' is not implemented for Lua conversion", paramDef.Type, paramDef.Name)`
- L166: `pkg/lua/lua.go:278:	return nil, fmt.Errorf("unsupported parameter type '%s' for '%s'", paramDef.Type, paramDef.Name)`
- L167: `pkg/lua/lua.go:419:func SectionValuesToLuaTable(L *lua.LState, parsedLayer *values.SectionValues) *lua.LTable {`
- L168: `pkg/lua/lua.go:420:	luaTable := L.CreateTable(0, len(parsedLayer.Parameters.ToMap()))`
- L169: `pkg/lua/lua.go:422:	parsedLayer.Parameters.ForEach(func(name string, param *fields.ParsedParameter) {`
- L170: `pkg/lua/lua.go:430:func ValuesToLuaTable(L *lua.LState, parsedLayers *values.Values) *lua.LTable {`
- L171: `pkg/lua/lua.go:431:	luaTable := L.CreateTable(0, parsedLayers.Len())`
- L172: `pkg/lua/lua.go:433:	parsedLayers.ForEach(func(layerName string, parsedLayer *values.SectionValues) {`
- L173: `pkg/lua/lua.go:434:		layerTable := SectionValuesToLuaTable(L, parsedLayer)`
- L174: `pkg/lua/lua.go:435:		luaTable.RawSetString(layerName, layerTable)`
- L175: `pkg/appconfig/parser_test.go:26:func newTestRedisLayer(defaultHost string) schema.Section {`
- L176: `pkg/appconfig/parser_test.go:27:	layer, err := schema.NewSection(`
- L177: `pkg/appconfig/parser_test.go:42:	return layer`
- L178: `pkg/appconfig/parser_test.go:46:	const redisSlug LayerSlug = "redis"`
- L179: `pkg/appconfig/parser_test.go:47:	layer := newTestRedisLayer("default")`
- L180: `pkg/appconfig/parser_test.go:52:		err = p.Register("", layer, func(t *testAppSettings) any { return &t.Redis })`
- L181: `pkg/appconfig/parser_test.go:56:	t.Run("nil layer", func(t *testing.T) {`
- L182: `pkg/appconfig/parser_test.go:66:		err = p.Register(redisSlug, layer, nil)`
- L183: `pkg/appconfig/parser_test.go:70:	t.Run("slug mismatch with layer.GetSlug", func(t *testing.T) {`
- L184: `pkg/appconfig/parser_test.go:73:		err = p.Register(LayerSlug("not-redis"), layer, func(t *testAppSettings) any { return &t.Redis })`
- L185: `pkg/appconfig/parser_test.go:80:		require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))`
- L186: `pkg/appconfig/parser_test.go:81:		err = p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis })`
- L187: `pkg/appconfig/parser_test.go:87:	const redisSlug LayerSlug = "redis"`
- L188: `pkg/appconfig/parser_test.go:88:	layer := newTestRedisLayer("default")`
- L189: `pkg/appconfig/parser_test.go:91:		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{`
- L190: `pkg/appconfig/parser_test.go:95:		require.NoError(t, p.Register(redisSlug, layer, func(_ *testAppSettings) any { return nil }))`
- L191: `pkg/appconfig/parser_test.go:102:		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{`
- L192: `pkg/appconfig/parser_test.go:106:		require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return t.Redis }))`
- L193: `pkg/appconfig/parser_test.go:113:		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{`
- L194: `pkg/appconfig/parser_test.go:117:		require.NoError(t, p.Register(redisSlug, layer, func(_ *testAppSettings) any {`
- L195: `pkg/appconfig/parser_test.go:128:	const redisSlug LayerSlug = "redis"`
- L196: `pkg/appconfig/parser_test.go:129:	layer := newTestRedisLayer("default")`
- L197: `pkg/appconfig/parser_test.go:135:	p, err := NewParser[app](WithValuesForLayers(map[string]map[string]interface{}{`
- L198: `pkg/appconfig/parser_test.go:139:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L199: `pkg/appconfig/parser_test.go:148:	const redisSlug LayerSlug = "redis"`
- L200: `pkg/appconfig/parser_test.go:149:	layer := newTestRedisLayer("from-default")`
- L201: `pkg/appconfig/parser_test.go:163:	require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))`
- L202: `pkg/appconfig/parser_test.go:171:	const redisSlug LayerSlug = "redis"`
- L203: `pkg/appconfig/parser_test.go:172:	layer := newTestRedisLayer("from-default")`
- L204: `pkg/appconfig/parser_test.go:186:			require.NoError(t, parser.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))`
- L205: `pkg/appconfig/parser_test.go:195:	// IMPORTANT: appconfig.Parser expects the layer flags to already be on the cobra command.`
- L206: `pkg/appconfig/parser_test.go:196:	cobraLayer, ok := layer.(schema.CobraSection)`
- L207: `pkg/appconfig/parser_test.go:197:	require.True(t, ok, "test layer must implement schema.CobraSection")`
- L208: `pkg/appconfig/parser_test.go:198:	require.NoError(t, cobraLayer.AddLayerToCobraCommand(rootCmd))`
- L209: `prompto/glazed/parameters-verbose:4:glaze help parameter-layers-and-parsed-layers 2>&1`
- L210: `prompto/glazed/parameters-verbose:8:glaze help parsing-parameters 2>&1`
- L211: `prompto/glazed/parameters-verbose:13:prompto get glazed/parameters`
- L212: `prompto/glazed/main.md:161:### Custom Help Layers`
- L213: `prompto/glazed/main.md:168:// Implement your custom help layer`
- L214: `pkg/appconfig/parser.go:13:	slug  LayerSlug`
- L215: `pkg/appconfig/parser.go:14:	layer schema.Section`
- L216: `pkg/appconfig/parser.go:18:// LayerSlug is a distinct type to encourage declaring layer slugs as constants.`
- L217: `pkg/appconfig/parser.go:22://	const RedisSlug appconfig.LayerSlug = "redis"`
- L218: `pkg/appconfig/parser.go:23:type LayerSlug string`
- L219: `pkg/appconfig/parser.go:26:// - callers register layers and bind them to sub-struct pointers inside T`
- L220: `pkg/appconfig/parser.go:52:// Register associates a layer slug and ParameterLayer with a binder that returns`
- L221: `pkg/appconfig/parser.go:57:// - layer must be non-nil`
- L222: `pkg/appconfig/parser.go:59:// - slug must match layer.GetSlug() (to avoid mismatches between registration keys and parsed layer keys)`
- L223: `pkg/appconfig/parser.go:60:func (p *Parser[T]) Register(slug LayerSlug, layer schema.Section, bind func(*T) any) error {`
- L224: `pkg/appconfig/parser.go:64:	if layer == nil {`
- L225: `pkg/appconfig/parser.go:65:		return errors.New("layer must not be nil")`
- L226: `pkg/appconfig/parser.go:70:	if layer.GetSlug() != string(slug) {`
- L227: `pkg/appconfig/parser.go:71:		return errors.Errorf("slug %q does not match layer.GetSlug() %q", string(slug), layer.GetSlug())`
- L228: `pkg/appconfig/parser.go:75:			return errors.Errorf("layer slug %q already registered", string(slug))`
- L229: `pkg/appconfig/parser.go:78:	p.regs = append(p.regs, registration[T]{slug: slug, layer: layer, bind: bind})`
- L230: `pkg/appconfig/parser.go:85:		return nil, errors.New("no layers registered")`
- L231: `pkg/appconfig/parser.go:88:	paramLayers := schema.NewSchema()`
- L232: `pkg/appconfig/parser.go:90:		paramLayers.Set(string(r.slug), r.layer)`
- L233: `pkg/appconfig/parser.go:104:	parsedLayers := values.New()`
- L234: `pkg/appconfig/parser.go:105:	if err := cmd_sources.Execute(paramLayers, parsedLayers, execMiddlewares...); err != nil {`
- L235: `pkg/appconfig/parser.go:106:		return nil, errors.Wrap(err, "failed to parse parameters")`
- L236: `pkg/appconfig/parser.go:113:			return nil, errors.Errorf("bind returned nil for layer %q", string(r.slug))`
- L237: `pkg/appconfig/parser.go:117:			return nil, errors.Errorf("bind for layer %q must return a non-nil pointer, got %T", string(r.slug), dst)`
- L238: `pkg/appconfig/parser.go:119:		if err := parsedLayers.InitializeStruct(string(r.slug), dst); err != nil {`
- L239: `pkg/appconfig/parser.go:120:			return nil, errors.Wrapf(err, "failed to initialize settings for layer %q", string(r.slug))`
- L240: `pkg/lua/cmds.go:21:// CallGlazedCommandFromLua executes a GlazeCommand with parameters from a Lua table`
- L241: `pkg/lua/cmds.go:23:	// Create parsed layers`
- L242: `pkg/lua/cmds.go:24:	parsedLayers := values.New()`
- L243: `pkg/lua/cmds.go:35:	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)`
- L244: `pkg/lua/cmds.go:40:	glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L245: `pkg/lua/cmds.go:42:		return nil, fmt.Errorf("glazed layer not found")`
- L246: `pkg/lua/cmds.go:44:	gp, err := settings.SetupTableProcessor(glazedLayer, middlewares2.WithTableMiddleware(&table.NullTableMiddleware{}))`
- L247: `pkg/lua/cmds.go:51:	// Run the command with the parsed layers`
- L248: `pkg/lua/cmds.go:52:	err = cmd.RunIntoGlazeProcessor(ctx, parsedLayers, gp)`
- L249: `pkg/lua/cmds.go:91:// CallGlazedBareCommandFromLua executes a BareCcommand with parameters from a Lua table`
- L250: `pkg/lua/cmds.go:93:	parsedLayers := values.New()`
- L251: `pkg/lua/cmds.go:100:	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)`
- L252: `pkg/lua/cmds.go:107:	// Run the command with the parsed layers`
- L253: `pkg/lua/cmds.go:108:	err = cmd.Run(ctx, parsedLayers)`
- L254: `pkg/lua/cmds.go:116:// CallGlazedWriterCommandFromLua executes a WriterCommand with parameters from a Lua table`
- L255: `pkg/lua/cmds.go:118:	parsedLayers := values.New()`
- L256: `pkg/lua/cmds.go:125:	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)`
- L257: `pkg/lua/cmds.go:135:	// Run the command with the parsed layers`
- L258: `pkg/lua/cmds.go:136:	err = cmd.RunIntoWriter(ctx, parsedLayers, &buf)`
- L259: `pkg/lua/cmds.go:244:	// Update the parameter information global name`
- L260: `pkg/lua/cmds.go:250:	// Create a table to hold all layers and their parameters`
- L261: `pkg/lua/cmds.go:251:	layersTable := L.CreateTable(0, desc.Layers.Len())`
- L262: `pkg/lua/cmds.go:253:	// Iterate through all layers`
- L263: `pkg/lua/cmds.go:254:	desc.Layers.ForEach(func(layerName string, layer schema.Section) {`
- L264: `pkg/lua/cmds.go:255:		layerTable := L.CreateTable(0, layer.GetDefinitions().Len())`
- L265: `pkg/lua/cmds.go:257:		// Add parameters for this layer`
- L266: `pkg/lua/cmds.go:258:		layer.GetDefinitions().ForEach(func(param *fields.Definition) {`
- L267: `pkg/lua/cmds.go:266:			layerTable.RawSetString(param.Name, paramInfo)`
- L268: `pkg/lua/cmds.go:269:		layersTable.RawSetString(layerName, layerTable)`
- L269: `pkg/lua/cmds.go:272:	// Set the global variable with the layers table`
- L270: `pkg/lua/cmds.go:273:	L.SetGlobal(paramsGlobalName, layersTable)`
- L271: `pkg/appconfig/doc.go:5:// deriving layers from structs. Instead, callers explicitly register Glazed`
- L272: `pkg/appconfig/doc.go:6:// ParameterLayers and bind them to fields inside a grouped settings struct T.`
- L273: `pkg/appconfig/profile_test.go:15:	const redisSlug LayerSlug = "redis"`
- L274: `pkg/appconfig/profile_test.go:16:	layer := newTestRedisLayer("from-default")`
- L275: `pkg/appconfig/profile_test.go:40:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L276: `pkg/appconfig/profile_test.go:48:	const redisSlug LayerSlug = "redis"`
- L277: `pkg/appconfig/profile_test.go:49:	layer := newTestRedisLayer("from-default")`
- L278: `pkg/appconfig/profile_test.go:75:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L279: `pkg/appconfig/profile_test.go:83:	const redisSlug LayerSlug = "redis"`
- L280: `pkg/appconfig/profile_test.go:84:	layer := newTestRedisLayer("from-default")`
- L281: `pkg/appconfig/profile_test.go:114:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L282: `pkg/appconfig/profile_test.go:122:	const redisSlug LayerSlug = "redis"`
- L283: `pkg/appconfig/profile_test.go:123:	layer := newTestRedisLayer("from-default")`
- L284: `pkg/appconfig/profile_test.go:151:			require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L285: `pkg/appconfig/profile_test.go:161:	psLayer, err := cli.NewProfileSettingsLayer()`
- L286: `pkg/appconfig/profile_test.go:163:	require.NoError(t, psLayer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L287: `pkg/appconfig/profile_test.go:165:	// Also add the redis layer flags (not strictly needed for this test, but keeps the pattern consistent).`
- L288: `pkg/appconfig/profile_test.go:166:	require.NoError(t, layer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L289: `pkg/appconfig/profile_test.go:173:	const redisSlug LayerSlug = "redis"`
- L290: `pkg/appconfig/profile_test.go:174:	layer := newTestRedisLayer("from-default")`
- L291: `pkg/appconfig/profile_test.go:208:			require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L292: `pkg/appconfig/profile_test.go:218:	require.NoError(t, layer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L293: `pkg/appconfig/profile_test.go:219:	psLayer, err := cli.NewProfileSettingsLayer()`
- L294: `pkg/appconfig/profile_test.go:221:	require.NoError(t, psLayer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L295: `pkg/appconfig/profile_test.go:228:	const redisSlug LayerSlug = "redis"`
- L296: `pkg/appconfig/profile_test.go:229:	layer := newTestRedisLayer("from-default")`
- L297: `pkg/appconfig/profile_test.go:247:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L298: `pkg/appconfig/profile_test.go:255:	const redisSlug LayerSlug = "redis"`
- L299: `pkg/appconfig/profile_test.go:256:	layer := newTestRedisLayer("from-default")`
- L300: `pkg/appconfig/profile_test.go:275:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L301: `pkg/appconfig/profile_test.go:282:	const redisSlug LayerSlug = "redis"`
- L302: `pkg/appconfig/profile_test.go:283:	layer := newTestRedisLayer("from-default")`
- L303: `pkg/appconfig/profile_test.go:303:	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L304: `prompto/glazed/create-yaml-command.md:38:   Parameters can be defined either as flags (with -- prefix) or positional arguments. Both use the same parameter definition structure, just with different usage patterns. Each entry describes one parameter with fields such as:`
- L305: `prompto/glazed/create-yaml-command.md:39:   - `name` (required): The parameter name.`
- L306: `prompto/glazed/create-yaml-command.md:40:   - `type` (required): The parameter type.`
- L307: `prompto/glazed/create-yaml-command.md:43:   - `required` (optional, boolean): Indicates if this parameter must be supplied.`
- L308: `prompto/glazed/create-yaml-command.md:51:   - For single numeric parameters, `type` can be `int` or `float`.  `
- L309: `prompto/glazed/create-yaml-command.md:52:   - For textual parameters, `type` can be `string`.  `
- L310: `prompto/glazed/create-yaml-command.md:54:   - Arguments are positional parameters that don't use -- prefix`
- L311: `prompto/glazed/create-yaml-command.md:83:- **flags** includes three parameters:`
- L312: `prompto/glazed/create-yaml-command.md:95:- name: <parameter-name>`
- L313: `prompto/glazed/create-yaml-command.md:96:  type: <parameter-type>`
- L314: `prompto/glazed/create-yaml-command.md:106:  Unique parameter name (e.g. `limit`, `from`, `status`), used at the command line as `--limit=...` or similar.`
- L315: `prompto/glazed/create-yaml-command.md:109:  Indicates how this parameter is interpreted. Common types:`
- L316: `prompto/glazed/create-yaml-command.md:124:  14. (Less common) **stringFromFile**, **objectFromFile**, **stringListFromFile**, **objectListFromFile**: Indicate the parameter is read from a file or multiple files. Typically used in advanced scenarios.`
- L317: `prompto/glazed/create-yaml-command.md:272:- Both flags and arguments use the same parameter definition structure`
- L318: `prompto/glazed/create-yaml-command.md:324:   - `name`: parameter/flag name`
- L319: `prompto/glazed/create-yaml-command.md:325:   - `type`: see typical parameter types (e.g., `string`, `int`, `bool`, `date`, etc.)`
- L320: `prompto/glazed/create-yaml-command.md:331:Use this structure whenever you define a new YAML command file. The system that loads it will parse these fields and make your parameters available under the indicated names.`
- L321: `prompto/glazed/create-yaml-command.md:345:2. **Flags (Parameters)**  `
- L322: `prompto/glazed/create-yaml-command.md:346:   - Under `flags:`, each item (e.g. `- name: name`, `type: stringList`, etc.) is turned into a `ParameterDefinition`.`
- L323: `prompto/glazed/create-yaml-command.md:357:   - The system aggregates these into a "default layer" of parameters.  `
- L324: `prompto/glazed/create-yaml-command.md:358:   - `required: false`, `default: ...`, and `help: ...` become `WithRequired(false)`, `WithDefault(...)`, `WithHelp(...)` in the `ParameterDefinition` construction.`
- L325: `prompto/glazed/create-yaml-command.md:360:Hence, the **top-level YAML keys**‚Äî`name`, `metadata`, `short`, `long`, and `flags`‚Äî**map to** the **fields and parameter layers** in a `CommandDescription` object. The `query:` would likewise be used by a specialized command that actually runs a SQL query, but the fundamental principle of turning flags into typed parameters remains the same.`
- L326: `pinocchio/glazed/create-template-command.yaml:66:  The types of parameters that can be used for flags are:`
- L327: `pinocchio/glazed/create-template-command.yaml:67:  - ParameterTypeString: "string"`
- L328: `pinocchio/glazed/create-template-command.yaml:68:  - ParameterTypeStringFromFile: "stringFromFile" -> string`
- L329: `pinocchio/glazed/create-template-command.yaml:69:  - ParameterTypeObjectListFromFile: "objectListFromFile" -> []interface{}`
- L330: `pinocchio/glazed/create-template-command.yaml:70:  - ParameterTypeObjectFromFile: "objectFromFile" -> interface{}`
- L331: `pinocchio/glazed/create-template-command.yaml:71:  - ParameterTypeKeyValue: "keyValue" -> map[string]interface{}`
- L332: `pinocchio/glazed/create-template-command.yaml:72:  - ParameterTypeInteger: "int"`
- L333: `pinocchio/glazed/create-template-command.yaml:73:  - ParameterTypeFloat: "float"`
- L334: `pinocchio/glazed/create-template-command.yaml:74:  - ParameterTypeBool: "bool"`
- L335: `pinocchio/glazed/create-template-command.yaml:75:  - ParameterTypeDate: "date"`
- L336: `pinocchio/glazed/create-template-command.yaml:76:  - ParameterTypeStringList: "stringList"`
- L337: `pinocchio/glazed/create-template-command.yaml:77:  - ParameterTypeIntegerList: "intList"`
- L338: `pinocchio/glazed/create-template-command.yaml:78:  - ParameterTypeFloatList: "floatList"`
- L339: `pinocchio/glazed/create-template-command.yaml:79:  - ParameterTypeChoice: "choice" -> string`
- L340: `pinocchio/glazed/create-template-command.yaml:80:  - ParameterTypeChoiceList: "choiceList" -> []string`
- L341: `prompto/glazed/definitions:3:prompto get glazed/parameter-types`
- L342: `prompto/glazed/definitions:5:for i in CommandDescription ParameterDefinition ParameterLayer; do`
- L343: `pkg/cli/cli.go:10:func NewCreateCommandSettingsLayer() (schema.Section, error) {`
- L344: `pkg/cli/cli.go:11:	createCommandSettingsLayer, err := schema.NewSection(`
- L345: `pkg/cli/cli.go:36:	return createCommandSettingsLayer, nil`
- L346: `pkg/cli/cli.go:52:func NewProfileSettingsLayer() (schema.Section, error) {`
- L347: `pkg/cli/cli.go:53:	profileSettingsLayer, err := schema.NewSection(`
- L348: `pkg/cli/cli.go:73:	return profileSettingsLayer, nil`
- L349: `pkg/cli/cli.go:79:	PrintParsedParameters  bool   `glazed:"print-parsed-parameters"``
- L350: `pkg/cli/cli.go:80:	LoadParametersFromFile string `glazed:"load-parameters-from-file"``
- L351: `pkg/cli/cli.go:87:func NewCommandSettingsLayer() (schema.Section, error) {`
- L352: `pkg/cli/cli.go:88:	glazedMinimalCommandLayer, err := schema.NewSection(`
- L353: `pkg/cli/cli.go:98:				"print-parsed-parameters",`
- L354: `pkg/cli/cli.go:100:				fields.WithHelp("Print the parsed parameters"),`
- L355: `pkg/cli/cli.go:102:			// Deprecated: legacy per-command parameter file injection (removed from default flow)`
- L356: `pkg/cli/cli.go:119:	return glazedMinimalCommandLayer, nil`
- L357: `pkg/doc/applications/03-user-store-command.md:27:- **Configuration via YAML**: Define commands and their parameters using YAML files for easy customization.`
- L358: `pkg/doc/applications/03-user-store-command.md:134:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L359: `pkg/doc/applications/03-user-store-command.md:135:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L360: `pkg/doc/applications/03-user-store-command.md:169:func (c *GenerateCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L361: `pkg/doc/applications/03-user-store-command.md:176:    if err := parsedLayers.InitializeStruct("default", settings); err != nil {`
- L362: `pkg/doc/applications/03-user-store-command.md:213:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L363: `pkg/doc/applications/03-user-store-command.md:214:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L364: `pkg/doc/applications/03-user-store-command.md:236:func (c *ListCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L365: `pkg/doc/applications/03-user-store-command.md:265:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L366: `pkg/doc/applications/03-user-store-command.md:266:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L367: `pkg/doc/applications/03-user-store-command.md:295:func (c *DeleteCommand) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L368: `pkg/doc/applications/03-user-store-command.md:301:    if err := parsedLayers.InitializeStruct("default", settings); err != nil {`
- L369: `cmd/examples/config-pattern-mapper/README.md:7:The pattern mapper allows you to declaratively map config file structures to layer parameters using pattern matching rules, without writing custom Go functions.`
- L370: `cmd/examples/config-pattern-mapper/README.md:12:2. **Named Captures**: Extract values from config paths and use them in parameter names`
- L371: `cmd/examples/config-pattern-mapper/README.md:31:    TargetLayer: "demo",`
- L372: `cmd/examples/config-pattern-mapper/README.md:32:    TargetParameter: "api-key",`
- L373: `cmd/examples/config-pattern-mapper/README.md:40:    TargetLayer: "demo",`
- L374: `cmd/examples/config-pattern-mapper/README.md:41:    TargetParameter: "{env}-api-key",  // Uses captured value`
- L375: `cmd/examples/config-pattern-mapper/README.md:49:    TargetLayer: "demo",`
- L376: `cmd/examples/config-pattern-mapper/README.md:50:    TargetParameter: "api-key",`
- L377: `cmd/examples/config-pattern-mapper/README.md:58:    TargetLayer: "demo",`
- L378: `cmd/examples/config-pattern-mapper/README.md:60:        {Source: "api_key", TargetParameter: "api-key"},`
- L379: `cmd/examples/config-pattern-mapper/README.md:61:        {Source: "threshold", TargetParameter: "threshold"},`
- L380: `cmd/examples/config-pattern-mapper/README.md:91:mapper, err := patternmapper.NewConfigMapper(layers,`
- L381: `cmd/examples/config-pattern-mapper/README.md:94:        TargetLayer:     "demo",`
- L382: `cmd/examples/config-pattern-mapper/README.md:95:        TargetParameter: "api-key",`
- L383: `cmd/examples/config-pattern-mapper/README.md:102:b := patternmapper.NewConfigMapperBuilder(layers).`
- L384: `cmd/examples/config-pattern-mapper/README.md:116:    target_layer: "demo"`
- L385: `cmd/examples/config-pattern-mapper/README.md:119:        target_parameter: "{env}-api-key"`
- L386: `cmd/examples/config-pattern-mapper/README.md:122:mapper, err := patternmapper.LoadMapperFromFile(layers, "mappings.yaml")`
- L387: `pkg/cli/cliopatra/program.go:19:// Parameter describes a cliopatra parameter, which can be either a flag or an argument.`
- L388: `pkg/cli/cliopatra/program.go:26:type Parameter struct {`
- L389: `pkg/cli/cliopatra/program.go:42:func (p *Parameter) Clone() *Parameter {`
- L390: `pkg/cli/cliopatra/program.go:66:	Flags []*Parameter `yaml:"flags,omitempty"``
- L391: `pkg/cli/cliopatra/program.go:67:	// Args is an ordered list of Parameters. The Flag field is ignored.`
- L392: `pkg/cli/cliopatra/program.go:68:	Args []*Parameter `yaml:"args,omitempty"``
- L393: `pkg/cli/cliopatra/program.go:134:func WithFlags(flags ...*Parameter) ProgramOption {`
- L394: `pkg/cli/cliopatra/program.go:140:func WithAddFlags(flags ...*Parameter) ProgramOption {`
- L395: `pkg/cli/cliopatra/program.go:146:func WithReplaceFlags(flags ...*Parameter) ProgramOption {`
- L396: `pkg/cli/cliopatra/program.go:164:func WithArgs(args ...*Parameter) ProgramOption {`
- L397: `pkg/cli/cliopatra/program.go:170:func WithAddArgs(args ...*Parameter) ProgramOption {`
- L398: `pkg/cli/cliopatra/program.go:176:func WithReplaceArgs(args ...*Parameter) ProgramOption {`
- L399: `pkg/cli/cliopatra/program.go:248:	clone.Flags = make([]*Parameter, len(p.Flags))`
- L400: `pkg/cli/cliopatra/program.go:252:	clone.Args = make([]*Parameter, len(p.Args))`
- L401: `pkg/cli/cliopatra/program.go:319:	parsedLayers *values.Values,`
- L402: `pkg/cli/cliopatra/program.go:331:	ps := parsedLayers.GetAllParsedParameters()`
- L403: `pkg/cli/cliopatra/program.go:393:func (p *Program) ComputeArgs(ps *fields.ParsedParameters) ([]string, error) {`
- L404: `pkg/cli/cliopatra/program.go:420:		parsedParameter, ok := ps.Get(flag.Name)`
- L405: `pkg/cli/cliopatra/program.go:425:			value_, err = parsedParameter.RenderValue()`
- L406: `pkg/cli/cliopatra/capture.go:10:func getCliopatraParameters(`
- L407: `pkg/cli/cliopatra/capture.go:12:	ps *fields.ParsedParameters,`
- L408: `pkg/cli/cliopatra/capture.go:14:) []*Parameter {`
- L409: `pkg/cli/cliopatra/capture.go:15:	ret := []*Parameter{}`
- L410: `pkg/cli/cliopatra/capture.go:32:		param := &Parameter{`
- L411: `pkg/cli/cliopatra/capture.go:65:// the description and the parsed layers a glazed command.`
- L412: `pkg/cli/cliopatra/capture.go:67:// It will go over all the ParameterDefinition (from all layers, which now also include the default layers).`
- L413: `pkg/cli/cliopatra/capture.go:69:// of layered fields.`
- L414: `pkg/cli/cliopatra/capture.go:71:// Values in the parameter map that are not present under the form of a ParameterDefinition`
- L415: `pkg/cli/cliopatra/capture.go:76:	parsedLayers *values.Values,`
- L416: `pkg/cli/cliopatra/capture.go:84:	description.Layers.ForEach(func(_ string, layer schema.Section) {`
- L417: `pkg/cli/cliopatra/capture.go:85:		if layer.GetSlug() == "glazed-command" {`
- L418: `pkg/cli/cliopatra/capture.go:89:		parsedLayer, ok := parsedLayers.Get(layer.GetSlug())`
- L419: `pkg/cli/cliopatra/capture.go:95:		parameters_ := getCliopatraParameters(`
- L420: `pkg/cli/cliopatra/capture.go:96:			layer.GetDefinitions(),`
- L421: `pkg/cli/cliopatra/capture.go:97:			parsedLayer.Parameters,`
- L422: `pkg/cli/cliopatra/capture.go:98:			layer.GetPrefix())`
- L423: `pkg/cli/cliopatra/capture.go:99:		flags := []*Parameter{}`
- L424: `pkg/cli/cliopatra/capture.go:100:		arguments := []*Parameter{}`
- L425: `pkg/cli/cliopatra/capture.go:102:		for _, p := range parameters_ {`
- L426: `pkg/cli/cobra.go:28:type CobraRunFunc func(ctx context.Context, parsedLayers *values.Values) error`
- L427: `pkg/cli/cobra.go:51:		// Parse layers`
- L428: `pkg/cli/cobra.go:52:		parsedLayers, err := parser.Parse(cmd, args)`
- L429: `pkg/cli/cobra.go:62:		if minimalLayer, ok := parsedLayers.Get(CommandSettingsSlug); ok {`
- L430: `pkg/cli/cobra.go:63:			var printYAML, printParsedParameters_, printSchema bool`
- L431: `pkg/cli/cobra.go:64:			err = minimalLayer.InitializeStruct(commandSettings)`
- L432: `pkg/cli/cobra.go:67:			printParsedParameters_ = commandSettings.PrintParsedParameters`
- L433: `pkg/cli/cobra.go:70:			if printParsedParameters_ {`
- L434: `pkg/cli/cobra.go:71:				printParsedParameters(parsedLayers)`
- L435: `pkg/cli/cobra.go:91:		if createLayer, ok := parsedLayers.Get(CreateCommandSettingsSlug); ok {`
- L436: `pkg/cli/cobra.go:93:			err = createLayer.InitializeStruct(createSettings)`
- L437: `pkg/cli/cobra.go:103:					parsedLayers,`
- L438: `pkg/cli/cobra.go:149:				layers_ := s.Description().Layers.Clone()`
- L439: `pkg/cli/cobra.go:154:					Layers: layers_,`
- L440: `pkg/cli/cobra.go:187:			glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L441: `pkg/cli/cobra.go:189:				cobra.CheckErr(errors.New("glazed layer not found"))`
- L442: `pkg/cli/cobra.go:192:			gp, err := settings.SetupTableProcessor(glazedLayer)`
- L443: `pkg/cli/cobra.go:194:			_, err = settings.SetupProcessorOutput(gp, glazedLayer, os.Stdout)`
- L444: `pkg/cli/cobra.go:203:			err = glazeCmd.RunIntoGlazeProcessor(ctx, parsedLayers, gp)`
- L445: `pkg/cli/cobra.go:224:		err = runFunc(ctx, parsedLayers)`
- L446: `pkg/cli/cobra.go:251:	// If the command implements GlazeCommand, ensure a glazed parameter layer is present`
- L447: `pkg/cli/cobra.go:253:		originalLayers := description.Layers`
- L448: `pkg/cli/cobra.go:254:		glazedLayers := originalLayers.Clone()`
- L449: `pkg/cli/cobra.go:255:		if _, ok := glazedLayers.Get(settings.GlazedSlug); !ok {`
- L450: `pkg/cli/cobra.go:256:			glLayer, err := settings.NewGlazedParameterLayers()`
- L451: `pkg/cli/cobra.go:260:			glazedLayers.Set(settings.GlazedSlug, glLayer)`
- L452: `pkg/cli/cobra.go:264:		newDesc.Layers = glazedLayers`
- L453: `pkg/cli/cobra.go:277:	cobraParser, err := NewCobraParserFromLayers(description.Layers, &cfg.ParserCfg)`
- L454: `pkg/cli/cobra.go:384:	runFunc := func(ctx context.Context, parsedLayers *values.Values) error {`
- L455: `pkg/cli/cobra.go:386:			err := writerCmd.RunIntoWriter(ctx, parsedLayers, os.Stdout)`
- L456: `pkg/cli/cobra.go:396:			err := bareCmd.Run(ctx, parsedLayers)`
- L457: `pkg/cli/cobra.go:503:// WithCobraShortHelpLayers sets the layers shown in short help (deprecated)`
- L458: `pkg/cli/cobra.go:504:func WithCobraShortHelpLayers(layers ...string) CobraOption {`
- L459: `pkg/cli/cobra.go:506:		c.ParserCfg.ShortHelpLayers = layers`
- L460: `pkg/cli/cobra.go:544:// WithSkipCommandSettingsLayer hides the command settings layer flags (deprecated)`
- L461: `pkg/cli/cobra.go:545:func WithSkipCommandSettingsLayer() CobraOption {`
- L462: `pkg/cli/cobra.go:547:		c.ParserCfg.SkipCommandSettingsLayer = true`
- L463: `pkg/cli/cobra.go:551:// WithProfileSettingsLayer enables the profile settings layer (deprecated)`
- L464: `pkg/cli/cobra.go:552:func WithProfileSettingsLayer() CobraOption {`
- L465: `pkg/cli/cobra.go:554:		c.ParserCfg.EnableProfileSettingsLayer = true`
- L466: `pkg/cli/cobra.go:558:// WithCreateCommandSettingsLayer enables the create-command settings layer (deprecated)`
- L467: `pkg/cli/cobra.go:559:func WithCreateCommandSettingsLayer() CobraOption {`
- L468: `pkg/cli/cobra.go:561:		c.ParserCfg.EnableCreateCommandSettingsLayer = true`
- L469: `pkg/cli/cliopatra/capture_test.go:14:func makeParsedDefaultLayer(desc *cmds.CommandDescription, ps *fields.ParsedParameters) *values.Values {`
- L470: `pkg/cli/cliopatra/capture_test.go:15:	defaultLayer, ok := desc.GetLayer(schema.DefaultSlug)`
- L471: `pkg/cli/cliopatra/capture_test.go:22:		Layer:      defaultLayer,`
- L472: `pkg/cli/cliopatra/capture_test.go:23:		Parameters: ps,`
- L473: `pkg/cli/cliopatra/capture_test.go:38:		makeParsedDefaultLayer(desc, fields.NewParsedParameters(fields.WithParsedParameter(testPd, "test", "foobar"))),`
- L474: `pkg/cli/cliopatra/capture_test.go:61:	p := NewProgramFromCapture(d, makeParsedDefaultLayer(d, fields.NewParsedParameters(fields.WithParsedParameter(pdTest, "test", "foobar"))))`
- L475: `pkg/cli/cliopatra/capture_test.go:67:	p = NewProgramFromCapture(d, makeParsedDefaultLayer(d, fields.NewParsedParameters(fields.WithParsedParameter(pdTest, "test", "foobar2"))))`
- L476: `pkg/cli/cliopatra/capture_test.go:90:		makeParsedDefaultLayer(d, fields.NewParsedParameters(`
- L477: `pkg/cli/cliopatra/capture_test.go:91:			fields.WithParsedParameter(pd1, "test", "foobar"),`
- L478: `pkg/cli/cliopatra/capture_test.go:92:			fields.WithParsedParameter(pd2, "test2", "foobar2"),`
- L479: `pkg/cli/cliopatra/capture_test.go:117:		makeParsedDefaultLayer(d,`
- L480: `pkg/cli/cliopatra/capture_test.go:118:			fields.NewParsedParameters(`
- L481: `pkg/cli/cliopatra/capture_test.go:119:				fields.WithParsedParameter(pd, "test", "foobar"))))`
- L482: `pkg/cli/cliopatra/capture_test.go:147:		makeParsedDefaultLayer(d, fields.NewParsedParameters(`
- L483: `pkg/cli/cliopatra/capture_test.go:148:			fields.WithParsedParameter(pd1, "test", "foobar"),`
- L484: `pkg/cli/cliopatra/capture_test.go:149:			fields.WithParsedParameter(pd2, "test2", "foobar2"),`
- L485: `pkg/cli/cliopatra/capture_test.go:150:			fields.WithParsedParameter(pd3, "test3", "foobar3"),`
- L486: `pkg/cli/cliopatra/capture_test.go:151:			fields.WithParsedParameter(pd4, "test4", "foobar4"),`
- L487: `pkg/cli/cliopatra/capture_test.go:177:func TestSingleLayer(t *testing.T) {`
- L488: `pkg/cli/cliopatra/capture_test.go:179:	layer, err2 := schema.NewSection("test-layer", "test-layer",`
- L489: `pkg/cli/cliopatra/capture_test.go:187:		cmds.WithLayersList(`
- L490: `pkg/cli/cliopatra/capture_test.go:188:			layer,`
- L491: `pkg/cli/cliopatra/capture_test.go:193:	ret.Set("test-layer", &values.SectionValues{`
- L492: `pkg/cli/cliopatra/capture_test.go:194:		Layer: layer,`
- L493: `pkg/cli/cliopatra/capture_test.go:195:		Parameters: fields.NewParsedParameters(`
- L494: `pkg/cli/cliopatra/capture_test.go:196:			fields.WithParsedParameter(pd, "test", "foobar"))})`
- L495: `prompto/glazed/create-application-tutorial.md:10:### 1.1 Layer Design`
- L496: `prompto/glazed/create-application-tutorial.md:13:   - Each layer should handle one aspect of configuration (e.g., authentication, database, output formatting)`
- L497: `prompto/glazed/create-application-tutorial.md:14:   - Keep parameter definitions focused and cohesive`
- L498: `prompto/glazed/create-application-tutorial.md:15:   - Avoid mixing unrelated parameters in the same layer`
- L499: `prompto/glazed/create-application-tutorial.md:18:   - Use descriptive slugs that indicate the layer's purpose (e.g., "auth", "db", "output")`
- L500: `prompto/glazed/create-application-tutorial.md:19:   - Follow consistent naming patterns across layers`
- L501: `prompto/glazed/create-application-tutorial.md:20:   - Document the purpose of each layer`
- L502: `prompto/glazed/create-application-tutorial.md:22:3. **Parameter Organization**`
- L503: `prompto/glazed/create-application-tutorial.md:23:   - Group related parameters together`
- L504: `prompto/glazed/create-application-tutorial.md:24:   - Use clear, descriptive parameter names`
- L505: `prompto/glazed/create-application-tutorial.md:29:   - Design layers to be reusable across commands`
- L506: `prompto/glazed/create-application-tutorial.md:30:   - Extract common parameters into shared layers`
- L507: `prompto/glazed/create-application-tutorial.md:31:   - Use composition to combine layers`
- L508: `prompto/glazed/create-application-tutorial.md:54:   - Use whitelisting to control layer access`
- L509: `prompto/glazed/create-application-tutorial.md:120:      layers/            # Custom parameter layers`
- L510: `prompto/glazed/create-application-tutorial.md:121:        auth.go         # Authentication layer`
- L511: `prompto/glazed/create-application-tutorial.md:122:        db.go          # Database layer`
- L512: `prompto/glazed/create-application-tutorial.md:123:        output.go      # Output formatting layer`
- L513: `prompto/glazed/create-application-tutorial.md:125:        parse.go       # Parameter parsing`
- L514: `prompto/glazed/create-application-tutorial.md:134:1. **Layer Definition**`
- L515: `prompto/glazed/create-application-tutorial.md:136:   // Define focused, single-purpose layers`
- L516: `prompto/glazed/create-application-tutorial.md:141:   func NewAuthLayer() (schema.Section, error) {`
- L517: `prompto/glazed/create-application-tutorial.md:145:           // ... focused parameter definitions`
- L518: `prompto/glazed/create-application-tutorial.md:299:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L519: `prompto/glazed/create-application-tutorial.md:303:    "myapp/pkg/layers"`
- L520: `prompto/glazed/create-application-tutorial.md:311:    layers.AppSettings`
- L521: `prompto/glazed/create-application-tutorial.md:321:        cli.WithCobraShortHelpLayers(layers.AppSlug),`
- L522: `prompto/glazed/create-application-tutorial.md:332:    // 1. Create glazed parameter layer`
- L523: `prompto/glazed/create-application-tutorial.md:333:    glazedParameterLayer, err := settings.NewGlazedParameterLayers()`
- L524: `prompto/glazed/create-application-tutorial.md:335:        return nil, fmt.Errorf("could not create Glazed parameter layer: %w", err)`
- L525: `prompto/glazed/create-application-tutorial.md:338:    // 2. Create app layer`
- L526: `prompto/glazed/create-application-tutorial.md:339:    appLayer, err := layers.NewAppParameterLayer()`
- L527: `prompto/glazed/create-application-tutorial.md:341:        return nil, fmt.Errorf("could not create App parameter layer: %w", err)`
- L528: `prompto/glazed/create-application-tutorial.md:344:    // 3. Combine layers`
- L529: `prompto/glazed/create-application-tutorial.md:345:    layers_ := schema.NewSchema(layers.WithLayers(`
- L530: `prompto/glazed/create-application-tutorial.md:346:        glazedParameterLayer,`
- L531: `prompto/glazed/create-application-tutorial.md:347:        appLayer,`
- L532: `prompto/glazed/create-application-tutorial.md:356:            cmds.WithLayers(layers_),`
- L533: `prompto/glazed/create-application-tutorial.md:363:    parsedLayers *values.Values,`
- L534: `prompto/glazed/create-application-tutorial.md:368:    if err := parsedLayers.InitializeStruct(layers.AppSlug, &s.AppSettings); err != nil {`
- L535: `pkg/cli/helpers.go:18:// the glazed processing layer.`
- L536: `pkg/cli/helpers.go:21:// abstraction to define your CLI applications, which allows you to use Layers and other nice features`
- L537: `pkg/cli/helpers.go:26:	gpl, err := settings.NewGlazedParameterLayers()`
- L538: `pkg/cli/helpers.go:31:	layers_ := schema.NewSchema(schema.WithSections(gpl))`
- L539: `pkg/cli/helpers.go:32:	parser, err := NewCobraParserFromLayers(layers_, &CobraParserConfig{`
- L540: `pkg/cli/helpers.go:38:	parsedLayers, err := parser.Parse(cmd, nil)`
- L541: `pkg/cli/helpers.go:43:	parsedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L542: `pkg/cli/helpers.go:45:		return nil, nil, errors.Errorf("layer %s not found", settings.GlazedSlug)`
- L543: `pkg/cli/helpers.go:48:	gp, err := settings.SetupTableProcessor(parsedLayer)`
- L544: `pkg/cli/helpers.go:51:	of, err := settings.SetupProcessorOutput(gp, parsedLayer, os.Stdout)`
- L545: `pkg/cli/helpers.go:58:// the glazed processing layer to their CLI flags.`
- L546: `pkg/cli/helpers.go:59:func AddGlazedProcessorFlagsToCobraCommand(cmd *cobra.Command, options ...settings.GlazeParameterLayerOption) error {`
- L547: `pkg/cli/helpers.go:60:	gpl, err := settings.NewGlazedParameterLayers(options...)`
- L548: `pkg/cli/helpers.go:65:	return gpl.AddLayerToCobraCommand(cmd)`
- L549: `pkg/cli/helpers.go:68:func printParsedParameters(parsedLayers *values.Values) {`
- L550: `pkg/cli/helpers.go:69:	layersMap := map[string]map[string]interface{}{}`
- L551: `pkg/cli/helpers.go:70:	parsedLayers.ForEach(func(layerName string, layer *values.SectionValues) {`
- L552: `pkg/cli/helpers.go:72:		layer.Parameters.ForEach(func(name string, parameter *fields.ParsedParameter) {`
- L553: `pkg/cli/helpers.go:74:				"value": parameter.Value,`
- L554: `pkg/cli/helpers.go:76:			logs := make([]map[string]interface{}, 0, len(parameter.Log))`
- L555: `pkg/cli/helpers.go:77:			for _, l := range parameter.Log {`
- L556: `pkg/cli/helpers.go:92:		layersMap[layerName] = params`
- L557: `pkg/cli/helpers.go:97:	err := encoder.Encode(layersMap)`
- L558: `pkg/cli/cobra-parser.go:20:// It is mostly used to add a "load from json" layer set in the GlazedCommandSettings.`
- L559: `pkg/cli/cobra-parser.go:22:	parsedCommandLayers *values.Values,`
- L560: `pkg/cli/cobra-parser.go:28:// the middlewares used in a Cobra command. It handles parsing parameters`
- L561: `pkg/cli/cobra-parser.go:30:// default values. The middlewares gather all these parameters into a`
- L562: `pkg/cli/cobra-parser.go:31:// ParsedParameters object.`
- L563: `pkg/cli/cobra-parser.go:33:// If the commandSettings specify parameters to be loaded from a file, this gets added as a middleware.`
- L564: `pkg/cli/cobra-parser.go:35:	parsedCommandLayers *values.Values,`
- L565: `pkg/cli/cobra-parser.go:40:	err := parsedCommandLayers.InitializeStruct(CommandSettingsSlug, commandSettings)`
- L566: `pkg/cli/cobra-parser.go:68:// This returns a CobraParser that can be used to parse the registered Layers`
- L567: `pkg/cli/cobra-parser.go:71:	Layers *schema.Schema`
- L568: `pkg/cli/cobra-parser.go:77:	// This hooks allows the implementor to specify additional ways of loading parameters`
- L569: `pkg/cli/cobra-parser.go:78:	// (for example, sqleton loads the dbt and sql connection parameters from env as well).`
- L570: `pkg/cli/cobra-parser.go:80:	// List of layers to be shown in short help, empty: always show all`
- L571: `pkg/cli/cobra-parser.go:81:	shortHelpLayers []string`
- L572: `pkg/cli/cobra-parser.go:82:	// skipCommandSettingsLayer controls whether the CommandSettingsLayer should be automatically added`
- L573: `pkg/cli/cobra-parser.go:83:	skipCommandSettingsLayer bool`
- L574: `pkg/cli/cobra-parser.go:84:	// enableProfileSettingsLayer controls whether the ProfileSettingsLayer should be added`
- L575: `pkg/cli/cobra-parser.go:85:	enableProfileSettingsLayer bool`
- L576: `pkg/cli/cobra-parser.go:86:	// enableCreateCommandSettingsLayer controls whether the CreateCommandSettingsLayer should be added`
- L577: `pkg/cli/cobra-parser.go:87:	enableCreateCommandSettingsLayer bool`
- L578: `pkg/cli/cobra-parser.go:93:	ShortHelpLayers                  []string`
- L579: `pkg/cli/cobra-parser.go:94:	SkipCommandSettingsLayer         bool`
- L580: `pkg/cli/cobra-parser.go:95:	EnableProfileSettingsLayer       bool`
- L581: `pkg/cli/cobra-parser.go:96:	EnableCreateCommandSettingsLayer bool`
- L582: `pkg/cli/cobra-parser.go:101:	ConfigFilesFunc func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]string, error)`
- L583: `pkg/cli/cobra-parser.go:115:// NewCobraParserFromLayers creates a new CobraParser instance from a`
- L584: `pkg/cli/cobra-parser.go:117:// parameters specified in the Layers CommandDescription to the cobra command.`
- L585: `pkg/cli/cobra-parser.go:118:func NewCobraParserFromLayers(`
- L586: `pkg/cli/cobra-parser.go:119:	paramLayers *schema.Schema,`
- L587: `pkg/cli/cobra-parser.go:124:		Layers:                           paramLayers,`
- L588: `pkg/cli/cobra-parser.go:126:		shortHelpLayers:                  []string{},`
- L589: `pkg/cli/cobra-parser.go:127:		skipCommandSettingsLayer:         false,`
- L590: `pkg/cli/cobra-parser.go:128:		enableProfileSettingsLayer:       false,`
- L591: `pkg/cli/cobra-parser.go:129:		enableCreateCommandSettingsLayer: false,`
- L592: `pkg/cli/cobra-parser.go:136:		ret.shortHelpLayers = cfg.ShortHelpLayers`
- L593: `pkg/cli/cobra-parser.go:137:		ret.skipCommandSettingsLayer = cfg.SkipCommandSettingsLayer`
- L594: `pkg/cli/cobra-parser.go:138:		ret.enableProfileSettingsLayer = cfg.EnableProfileSettingsLayer`
- L595: `pkg/cli/cobra-parser.go:139:		ret.enableCreateCommandSettingsLayer = cfg.EnableCreateCommandSettingsLayer`
- L596: `pkg/cli/cobra-parser.go:143:			ret.middlewaresFunc = func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]cmd_sources.Middleware, error) {`
- L597: `pkg/cli/cobra-parser.go:192:				// Wrap resolver to bind parsedCommandLayers captured earlier`
- L598: `pkg/cli/cobra-parser.go:194:					return resolver(parsedCommandLayers, cmd_, args_)`
- L599: `pkg/cli/cobra-parser.go:197:					cmd_sources.LoadParametersFromResolvedFilesForCobra(`
- L600: `pkg/cli/cobra-parser.go:215:	// Only add the glazed command layer if not explicitly skipped`
- L601: `pkg/cli/cobra-parser.go:216:	if !ret.skipCommandSettingsLayer {`
- L602: `pkg/cli/cobra-parser.go:217:		commandSettingsLayer, err := NewCommandSettingsLayer()`
- L603: `pkg/cli/cobra-parser.go:221:		ret.Layers.Set(commandSettingsLayer.GetSlug(), commandSettingsLayer)`
- L604: `pkg/cli/cobra-parser.go:224:	// Only add the profile settings layer if explicitly enabled`
- L605: `pkg/cli/cobra-parser.go:225:	if ret.enableProfileSettingsLayer {`
- L606: `pkg/cli/cobra-parser.go:226:		profileSettingsLayer, err := NewProfileSettingsLayer()`
- L607: `pkg/cli/cobra-parser.go:230:		ret.Layers.Set(profileSettingsLayer.GetSlug(), profileSettingsLayer)`
- L608: `pkg/cli/cobra-parser.go:233:	// Only add the create command settings layer if explicitly enabled`
- L609: `pkg/cli/cobra-parser.go:234:	if ret.enableCreateCommandSettingsLayer {`
- L610: `pkg/cli/cobra-parser.go:235:		createCommandSettingsLayer, err := NewCreateCommandSettingsLayer()`
- L611: `pkg/cli/cobra-parser.go:239:		ret.Layers.Set(createCommandSettingsLayer.GetSlug(), createCommandSettingsLayer)`
- L612: `pkg/cli/cobra-parser.go:246:	// NOTE(manuel, 2024-01-03) Maybe add some middleware functionality to whitelist/blacklist the Layers/parameters that get added to the CLI`
- L613: `pkg/cli/cobra-parser.go:247:	// If we want to remove some parameters from the CLI args (for example some output settings or so)`
- L614: `pkg/cli/cobra-parser.go:248:	err := c.Layers.ForEachE(func(_ string, layer schema.Section) error {`
- L615: `pkg/cli/cobra-parser.go:249:		// check that layer is a CobraSection`
- L616: `pkg/cli/cobra-parser.go:251:		cobraLayer, ok := layer.(schema.CobraSection)`
- L617: `pkg/cli/cobra-parser.go:253:			log.Error().Str("layer", layer.GetName()).Msg("Layer is not a CobraSection")`
- L618: `pkg/cli/cobra-parser.go:254:			return errors.Errorf("layer %s is not a CobraSection", layer.GetName())`
- L619: `pkg/cli/cobra-parser.go:257:		err := cobraLayer.AddLayerToCobraCommand(cmd)`
- L620: `pkg/cli/cobra-parser.go:259:			log.Error().Err(err).Str("layer", layer.GetName()).Msg("Could not add layer to cobra command")`
- L621: `pkg/cli/cobra-parser.go:269:	if len(c.shortHelpLayers) > 0 {`
- L622: `pkg/cli/cobra-parser.go:270:		shortHelperLayer := strings.Join(c.shortHelpLayers, ",")`
- L623: `pkg/cli/cobra-parser.go:271:		cmd.Annotations["shortHelpLayers"] = shortHelperLayer`
- L624: `pkg/cli/cobra-parser.go:283:	parsedCommandLayers, err := ParseCommandSettingsLayer(cmd)`
- L625: `pkg/cli/cobra-parser.go:290:	middlewares_, err := c.middlewaresFunc(parsedCommandLayers, cmd, args)`
- L626: `pkg/cli/cobra-parser.go:295:	parsedLayers := values.New()`
- L627: `pkg/cli/cobra-parser.go:296:	err = cmd_sources.Execute(c.Layers, parsedLayers, middlewares_...)`
- L628: `pkg/cli/cobra-parser.go:301:	return parsedLayers, nil`
- L629: `pkg/cli/cobra-parser.go:304:// ParseGlazedCommandLayer parses the global glazed settings from the given cobra.Command, if not nil,`
- L630: `pkg/cli/cobra-parser.go:306:func ParseCommandSettingsLayer(cmd *cobra.Command) (*values.Values, error) {`
- L631: `pkg/cli/cobra-parser.go:307:	parsedLayers := values.New()`
- L632: `pkg/cli/cobra-parser.go:308:	commandSettingsLayer, err := NewCommandSettingsLayer()`
- L633: `pkg/cli/cobra-parser.go:313:	profileSettingsLayer, err := NewProfileSettingsLayer()`
- L634: `pkg/cli/cobra-parser.go:318:	createCommandSettingsLayer, err := NewCreateCommandSettingsLayer()`
- L635: `pkg/cli/cobra-parser.go:323:	commandSettingsLayers := schema.NewSchema(schema.WithSections(`
- L636: `pkg/cli/cobra-parser.go:324:		commandSettingsLayer,`
- L637: `pkg/cli/cobra-parser.go:325:		profileSettingsLayer,`
- L638: `pkg/cli/cobra-parser.go:326:		createCommandSettingsLayer,`
- L639: `pkg/cli/cobra-parser.go:336:	err = cmd_sources.Execute(commandSettingsLayers, parsedLayers, middlewares_...)`
- L640: `pkg/cli/cobra-parser.go:341:	return parsedLayers, nil`
- L641: `AGENT.md:58:Don't add backwards compatibility layers unless explicitly asked.`
- L642: `prompto/glazed/command-description.md:8:- **Layers** (contains parameter definitions, i.e. your command‚Äôs flags/arguments)`
- L643: `prompto/glazed/command-description.md:48:Your command‚Äôs parameters (both flags and positional arguments) are grouped in a default ‚Äúlayer.‚Äù You typically add them via the convenience functions:`
- L644: `prompto/glazed/command-description.md:53:### 3.1 Defining Parameter Definitions`
- L645: `prompto/glazed/command-description.md:55:Parameters themselves are described by `fields.Definition` from the `glazed/pkg/cmds/parameters` package. For example:`
- L646: `prompto/glazed/command-description.md:67:**Common parameter definition functions**:`
- L647: `prompto/glazed/command-description.md:69:- `fields.New(name string, paramType ParameterType, opts ...ParameterDefinitionOption)``
- L648: `prompto/glazed/command-description.md:77:Flags are typically optional or named parameters. You call `WithFlags(...)` with one or more `ParameterDefinition`s:`
- L649: `prompto/glazed/command-description.md:101:Positional arguments (like `my-command [ARGS ...]`) are also stored as parameters but with `IsArgument = true`. You can use `WithArguments(...)`:`
- L650: `prompto/glazed/command-description.md:134:4. **`WithFlags(flags ...*ParameterDefinition)`**  `
- L651: `prompto/glazed/command-description.md:135:   Adds parameter definitions as **flags** to the default layer.`
- L652: `prompto/glazed/command-description.md:137:5. **`WithArguments(arguments ...*ParameterDefinition)`**  `
- L653: `prompto/glazed/command-description.md:138:   Adds parameter definitions as **positional arguments** to the default layer.`
- L654: `prompto/glazed/command-description.md:140:6. **`WithLayers(ls *schema.Schema)`** or **`WithLayersList(ls ...ParameterLayer)`**  `
- L655: `prompto/glazed/command-description.md:141:   Used if you already have a custom `ParameterLayers` object or multiple parameter layers. Typically more advanced usage.`
- L656: `prompto/glazed/command-description.md:143:7. **`WithReplaceLayers(layers_ ...ParameterLayer)`**  `
- L657: `prompto/glazed/command-description.md:144:   Replaces any existing layers with the ones you provide.`
- L658: `prompto/glazed/command-description.md:164:## 5. Inspecting Parameters at Runtime`
- L659: `prompto/glazed/command-description.md:166:Once your `CommandDescription` is built, you can retrieve parameter definitions in code:`
- L660: `prompto/glazed/command-description.md:168:- **`GetDefaultFlags()`**: Returns a `ParameterDefinitions` object of all flags in the default layer.  `
- L661: `prompto/glazed/command-description.md:169:- **`GetDefaultArguments()`**: Returns all arguments (where `IsArgument = true`) from the default layer.  `
- L662: `prompto/glazed/command-description.md:170:- **`Layers`**: The entire `ParameterLayers` object if you need advanced usage.`
- L663: `prompto/glazed/command-description.md:183:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L664: `prompto/glazed/command-description.md:239:5. **Optionally** set the source string or manipulate the advanced parameter layering.  `
- L665: `prompto/glazed/parameter-types:3:echo "// Here are the types that can be used to define parameters in glazed:"`
- L666: `prompto/glazed/parameter-types:5:echo "package github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L667: `prompto/glazed/parameter-types:7:oak go consts pkg/cmds/parameters/parameter-type.go`
- L668: `prompto/glazed/parameter-types:9:oak go definitions pkg/cmds/parameters/file.go --name "FileData" --definition-type struct,interface`
- L669: `prompto/glazed/parameters:3:prompto get glazed/parameter-types`
- L670: `prompto/glazed/parameters:6:echo "Here are all the types and method signatures for manipulating parameters and parsed parameters in glazed (github.com/go-go-golems/glazed is the base package):"`
- L671: `prompto/glazed/parameters:8:echo "package github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L672: `prompto/glazed/parameters:10:oak go definitions --only-public pkg/cmds/parameters/parameters.go`
- L673: `prompto/glazed/parameters:12:oak go definitions --only-public pkg/cmds/parameters/parsed-parameter.go`
- L674: `prompto/glazed/parameters:17:echo "Here are all the types and method signatures for manipulating layers in glazed:"`
- L675: `prompto/glazed/parameters:19:echo "package layers"`
- L676: `prompto/glazed/parameters:21:oak go definitions --only-public pkg/cmds/layers/layer.go`
- L677: `prompto/glazed/parameters:23:oak go definitions --only-public pkg/cmds/layers/parsed-layer.go`
- L678: `changelog.md:1:# Parameter Layer Serialization`
- L679: `changelog.md:3:Added ability to serialize parameter layers to YAML/JSON format for better interoperability and configuration management.`
- L680: `changelog.md:5:- Added SerializableParameterLayer struct for YAML/JSON serialization`
- L681: `changelog.md:6:- Added SerializableLayers struct for serializing collections of layers as a map keyed by slug`
- L682: `changelog.md:7:- Added conversion functions ToSerializable and LayersToSerializable`
- L683: `changelog.md:8:- Implemented YAML and JSON marshaling for ParameterLayers`
- L684: `changelog.md:9:- Updated serialization to maintain layer order while providing slug-based access`
- L685: `changelog.md:10:- Added custom YAML and JSON marshalers for SerializableLayers`
- L686: `changelog.md:12:# Parsed Parameters Serialization`
- L687: `changelog.md:14:Added ability to serialize parsed parameters to YAML/JSON format for better debugging and state persistence.`
- L688: `changelog.md:16:- Added SerializableParsedParameter struct for YAML/JSON serialization`
- L689: `changelog.md:17:- Added SerializableParsedParameters struct for serializing collections of parsed parameters`
- L690: `changelog.md:18:- Added conversion functions for ParsedParameter and ParsedParameters`
- L691: `changelog.md:19:- Implemented YAML and JSON marshaling for ParsedParameters`
- L692: `changelog.md:20:- Maintained parameter order while providing name-based access in serialized format`
- L693: `changelog.md:22:# Parsed Layer Serialization`
- L694: `changelog.md:24:Added ability to serialize parsed layers to YAML/JSON format, combining layer definitions and parsed parameters.`
- L695: `changelog.md:26:- Added SerializableParsedLayer struct for YAML/JSON serialization`
- L696: `changelog.md:27:- Added SerializableParsedLayers struct for serializing collections of parsed layers`
- L697: `changelog.md:28:- Added conversion functions for ParsedLayer and ParsedLayers`
- L698: `changelog.md:29:- Implemented YAML and JSON marshaling for ParsedLayer and ParsedLayers`
- L699: `changelog.md:30:- Included both layer definitions and parsed parameters in serialized output`
- L700: `changelog.md:39:# Optional GlazedCommandLayer in CobraParser`
- L701: `changelog.md:41:Added ability to skip adding the GlazedCommandLayer when creating a new CobraParser.`
- L702: `changelog.md:43:- Added skipGlazedCommandLayer flag to CobraParser struct`
- L703: `changelog.md:44:- Added WithSkipGlazedCommandLayer option function`
- L704: `changelog.md:45:- Modified NewCobraParserFromLayers to respect the skip flag`
- L705: `changelog.md:47:# Optional Profile and Create Command Settings Layers in CobraParser`
- L706: `changelog.md:49:Added ability to enable ProfileSettingsLayer and CreateCommandSettingsLayer when creating a new CobraParser. These layers are disabled by default and must be explicitly enabled.`
- L707: `changelog.md:51:- Added enableProfileSettingsLayer flag to CobraParser struct`
- L708: `changelog.md:52:- Added enableCreateCommandSettingsLayer flag to CobraParser struct`
- L709: `changelog.md:53:- Added WithProfileSettingsLayer option function to enable profile settings`
- L710: `changelog.md:54:- Added WithCreateCommandSettingsLayer option function to enable create command settings`
- L711: `changelog.md:55:- Modified NewCobraParserFromLayers to only add these layers when explicitly enabled `
- L712: `pkg/config/editor.go:102:// GetDefaultConfigPath is updated to take an appName parameter`
- L713: `cmd/examples/appconfig-parser/main.go:13:	RedisSlug appconfig.LayerSlug = "redis"`
- L714: `cmd/examples/appconfig-parser/main.go:14:	DBSlug    appconfig.LayerSlug = "db"`
- L715: `cmd/examples/appconfig-parser/main.go:40:	redisLayer := mustSection(schema.NewSection(`
- L716: `cmd/examples/appconfig-parser/main.go:50:	dbLayer := mustSection(schema.NewSection(`
- L717: `cmd/examples/appconfig-parser/main.go:61:		appconfig.WithValuesForLayers(map[string]map[string]interface{}{`
- L718: `cmd/examples/appconfig-parser/main.go:71:	if err := parser.Register(RedisSlug, redisLayer, func(t *AppSettings) any { return &t.Redis }); err != nil {`
- L719: `cmd/examples/appconfig-parser/main.go:72:		fmt.Fprintf(os.Stderr, "failed to register redis layer: %v\n", err)`
- L720: `cmd/examples/appconfig-parser/main.go:75:	if err := parser.Register(DBSlug, dbLayer, func(t *AppSettings) any { return &t.DB }); err != nil {`
- L721: `cmd/examples/appconfig-parser/main.go:76:		fmt.Fprintf(os.Stderr, "failed to register db layer: %v\n", err)`
- L722: `cmd/examples/sources-example/main.go:117:	// cmd.Layers is *schema.Schema, but we convert to schema.Schema (type alias)`
- L723: `cmd/examples/sources-example/main.go:119:	cmdSchema := (*schema.Schema)(cmd.Layers)`
- L724: `pkg/doc/tutorials/migrating-to-facade-packages.md:4:Short: Step-by-step guide to migrate Glazed code from layers/parameters/middlewares vocabulary to the new facade packages (schema/fields/values/sources)`
- L725: `pkg/doc/tutorials/migrating-to-facade-packages.md:27:- `schema` ‚Äî schema sections (previously ‚Äúlayers‚Äù)`
- L726: `pkg/doc/tutorials/migrating-to-facade-packages.md:28:- `fields` ‚Äî field definitions and field types (previously ‚Äúparameters‚Äù)`
- L727: `pkg/doc/tutorials/migrating-to-facade-packages.md:29:- `values` ‚Äî resolved values + decoding helpers (previously ‚Äúparsed layers‚Äù)`
- L728: `pkg/doc/tutorials/migrating-to-facade-packages.md:42:- `pkg/cmds/layers.ParameterLayer` ‚Üí `pkg/cmds/schema.Section``
- L729: `pkg/doc/tutorials/migrating-to-facade-packages.md:43:- `pkg/cmds/layers.ParameterLayers` ‚Üí `pkg/cmds/schema.Schema``
- L730: `pkg/doc/tutorials/migrating-to-facade-packages.md:44:- `pkg/cmds/parameters.ParameterDefinition` ‚Üí `pkg/cmds/fields.Definition``
- L731: `pkg/doc/tutorials/migrating-to-facade-packages.md:45:- `pkg/cmds/parameters.ParameterDefinitions` ‚Üí `pkg/cmds/fields.Definitions``
- L732: `pkg/doc/tutorials/migrating-to-facade-packages.md:46:- `pkg/cmds/parameters.ParameterType*` ‚Üí `pkg/cmds/fields.Type*``
- L733: `pkg/doc/tutorials/migrating-to-facade-packages.md:50:- `pkg/cmds/layers.ParsedLayers` ‚Üí `pkg/cmds/values.Values``
- L734: `pkg/doc/tutorials/migrating-to-facade-packages.md:51:- `pkg/cmds/layers.ParsedLayer` ‚Üí `pkg/cmds/values.SectionValues``
- L735: `pkg/doc/tutorials/migrating-to-facade-packages.md:52:- `layers.NewParsedLayers()` ‚Üí `values.New()``
- L736: `pkg/doc/tutorials/migrating-to-facade-packages.md:53:- `layers.NewParsedLayer(section, ...)` ‚Üí `values.NewSectionValues(section, ...)``
- L737: `pkg/doc/tutorials/migrating-to-facade-packages.md:54:- `layers.WithParsedParameters(...)` ‚Üí `values.WithParameters(...)``
- L738: `pkg/doc/tutorials/migrating-to-facade-packages.md:55:- `layers.WithParsedParameterValue(...)` ‚Üí `values.WithParameterValue(...)``
- L739: `pkg/doc/tutorials/migrating-to-facade-packages.md:56:- `parsedLayers.InitializeStruct(slug, &dst)` ‚Üí `values.DecodeSectionInto(parsedLayers, slug, &dst)``
- L740: `pkg/doc/tutorials/migrating-to-facade-packages.md:64:- `middlewares.LoadParametersFromFile(s)` ‚Üí `sources.FromFile` / `sources.FromFiles``
- L741: `pkg/doc/tutorials/migrating-to-facade-packages.md:67:- `parameters.WithParseStepSource(...)` ‚Üí `sources.WithSource(...)``
- L742: `pkg/doc/tutorials/migrating-to-facade-packages.md:79:‚Ä¶and it still satisfies interfaces that mention `*layers.ParsedLayers`, because `values.Values` is an alias for `layers.ParsedLayers`.`
- L743: `pkg/doc/tutorials/migrating-to-facade-packages.md:88:- `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`).`
- L744: `pkg/doc/tutorials/migrating-to-facade-packages.md:89:- `layers.ParameterLayer` interface methods now use `*fields.Definition` / `*fields.Definitions`:`
- L745: `pkg/doc/tutorials/migrating-to-facade-packages.md:91:  - `GetParameterDefinitions() *fields.Definitions``
- L746: `pkg/doc/tutorials/migrating-to-facade-packages.md:94:  - `cli.CobraRunFunc`, `cli.CobraParser.Parse`, `cli.ParseCommandSettingsLayer``
- L747: `pkg/doc/tutorials/migrating-to-facade-packages.md:99:- `values` additions: `NewSectionValues`, `SectionValuesOption`, `WithParameters`, `WithParameterValue`.`
- L748: `pkg/doc/tutorials/migrating-to-facade-packages.md:107:- `github.com/go-go-golems/glazed/pkg/cmds/layers``
- L749: `pkg/doc/tutorials/migrating-to-facade-packages.md:108:- `github.com/go-go-golems/glazed/pkg/cmds/parameters``
- L750: `pkg/doc/tutorials/migrating-to-facade-packages.md:118:You can keep old imports for advanced/legacy types (for example `parameters.FileData`) until you‚Äôre ready to refactor them.`
- L751: `pkg/doc/tutorials/migrating-to-facade-packages.md:120:### Step 2: Replace parameter definitions`
- L752: `pkg/doc/tutorials/migrating-to-facade-packages.md:125:parameters.NewParameterDefinition("limit", parameters.ParameterTypeInteger, parameters.WithDefault(10))`
- L753: `pkg/doc/tutorials/migrating-to-facade-packages.md:136:If you currently build explicit layers:`
- L754: `pkg/doc/tutorials/migrating-to-facade-packages.md:141:demoLayer, _ := layers.NewParameterLayer("demo", "Demo",`
- L755: `pkg/doc/tutorials/migrating-to-facade-packages.md:142:    layers.WithPrefix("demo-"),`
- L756: `pkg/doc/tutorials/migrating-to-facade-packages.md:143:    layers.WithParameterDefinitions(`
- L757: `pkg/doc/tutorials/migrating-to-facade-packages.md:144:        parameters.NewParameterDefinition("api-key", parameters.ParameterTypeString),`
- L758: `pkg/doc/tutorials/migrating-to-facade-packages.md:165:func (c *MyCmd) Run(ctx context.Context, parsedLayers *layers.ParsedLayers) error {`
- L759: `pkg/doc/tutorials/migrating-to-facade-packages.md:173:func (c *MyCmd) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L760: `pkg/doc/tutorials/migrating-to-facade-packages.md:184:_ = parsedLayers.InitializeStruct(layers.DefaultSlug, settings)`
- L761: `pkg/doc/tutorials/migrating-to-facade-packages.md:210:## Glazed ‚Äúoutput flags‚Äù layer: what to do now`
- L762: `pkg/doc/tutorials/migrating-to-facade-packages.md:212:- If your command implements `cmds.GlazeCommand`, `cli.BuildCobraCommand(...)` will ensure the glazed output layer exists, so you usually don‚Äôt need to add it manually.`
- L763: `pkg/doc/tutorials/migrating-to-facade-packages.md:213:- If you do want to add it explicitly (e.g. when building a schema yourself), prefer `settings.NewGlazedSchema()` (wrapper around `settings.NewGlazedParameterLayers()`).`
- L764: `pkg/doc/tutorials/migrating-to-facade-packages.md:221:- Cobra-only plumbing: attaching layers to Cobra uses `layers.CobraParameterLayer`.`
- L765: `pkg/doc/tutorials/migrating-to-facade-packages.md:222:- Some helper types/functions still live in `parameters` (e.g. `parameters.FileData`, `parameters.RenderValue`).`
- L766: `pkg/doc/topics/15-profiles.md:5:  Use profiles.yaml to apply named configuration bundles across parameter layers, with predictable precedence and debugging.`
- L767: `pkg/doc/topics/15-profiles.md:21:Profiles are a **named bundle of parameter overrides** stored in a YAML file (typically `profiles.yaml`).`
- L768: `pkg/doc/topics/15-profiles.md:34:- **Second level**: layer slug`
- L769: `pkg/doc/topics/15-profiles.md:35:- **Third level**: parameter name/value pairs for that layer`
- L770: `pkg/doc/topics/15-profiles.md:65:In a Cobra CLI built with Glazed, profile selection typically comes from the **ProfileSettings layer**:`
- L771: `pkg/doc/topics/15-profiles.md:77:These flags only exist if you enable the ProfileSettings layer when building your Cobra command:`
- L772: `pkg/doc/topics/15-profiles.md:81:  cli.WithProfileSettingsLayer(),`
- L773: `pkg/doc/topics/15-profiles.md:85:Without that layer:`
- L774: `pkg/doc/topics/15-profiles.md:93:Glazed config files are parsed in **layer-slug form**:`
- L775: `pkg/doc/topics/15-profiles.md:96:<layer-slug>:`
- L776: `pkg/doc/topics/15-profiles.md:100:So profile selection in a config file must be expressed under the `profile-settings` layer:`
- L777: `pkg/doc/topics/15-profiles.md:147:3. Run the main middleware chain for all layers, with the profiles middleware inserted between defaults and higher-precedence sources.`
- L778: `pkg/doc/topics/15-profiles.md:153:Use `--print-parsed-parameters` to inspect parse provenance per parameter, including which values came from:`
- L779: `cmd/examples/config-custom-mapper/config.yaml:1:# Flat config structure - different from the default layer-based structure`
- L780: `pkg/doc/topics/19-writing-yaml-commands.md:39:## Parameter Types`
- L781: `pkg/doc/topics/19-writing-yaml-commands.md:41:Glazed supports these parameter types for both flags and arguments:`
- L782: `pkg/doc/topics/19-writing-yaml-commands.md:75:Flags are optional parameters that modify command behavior. Here's a comprehensive example:`
- L783: `pkg/doc/topics/19-writing-yaml-commands.md:102:- `type`: Parameter type (required)`
- L784: `pkg/doc/topics/19-writing-yaml-commands.md:110:Arguments are positional parameters. They're defined similarly to flags:`
- L785: `pkg/doc/topics/19-writing-yaml-commands.md:129:## Using Layers`
- L786: `pkg/doc/topics/19-writing-yaml-commands.md:131:Layers help organize related parameters. Define layers in your YAML:`
- L787: `pkg/doc/topics/19-writing-yaml-commands.md:134:layers:`
- L788: `pkg/doc/topics/19-writing-yaml-commands.md:164:   - Group related parameters using layers`
- L789: `pkg/doc/topics/19-writing-yaml-commands.md:165:   - Use consistent parameter ordering`
- L790: `pkg/doc/topics/19-writing-yaml-commands.md:171:   - Mark parameters as required when necessary`
- L791: `pkg/doc/topics/19-writing-yaml-commands.md:198:layers:`
- L792: `cmd/examples/config-custom-mapper/main.go:29:	demoLayer, err := schema.NewSection(`
- L793: `cmd/examples/config-custom-mapper/main.go:54:		cmds.WithLayersList(demoLayer),`
- L794: `cmd/examples/config-custom-mapper/main.go:80:// flatConfigMapper transforms a flat config structure to the layer map format.`
- L795: `cmd/examples/config-custom-mapper/main.go:96:	// Map flat keys to layer parameters`
- L796: `cmd/examples/config-custom-mapper/main.go:135:			SkipCommandSettingsLayer: true,`
- L797: `cmd/examples/config-custom-mapper/main.go:136:			MiddlewaresFunc: func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]sources.Middleware, error) {`
- L798: `cmd/examples/config-custom-mapper/main.go:157:	// validate command: validate config.yaml using the custom mapper and layer definitions`
- L799: `cmd/examples/config-custom-mapper/main.go:183:			// Validate mapped structure against known layers and params`
- L800: `cmd/examples/config-custom-mapper/main.go:184:			for layerSlug, kv := range mapped {`
- L801: `cmd/examples/config-custom-mapper/main.go:185:				layer, ok := demo.Description().Layers.Get(layerSlug)`
- L802: `cmd/examples/config-custom-mapper/main.go:187:					issues = append(issues, fmt.Sprintf("unknown layer: %s", layerSlug))`
- L803: `cmd/examples/config-custom-mapper/main.go:191:				pds := layer.GetDefinitions()`
- L804: `cmd/examples/config-custom-mapper/main.go:196:						issues = append(issues, fmt.Sprintf("unknown parameter in layer %s: %s", layerSlug, key))`
- L805: `cmd/examples/config-custom-mapper/main.go:201:						issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))`
- L806: `pkg/doc/topics/22-templating-helpers.md:156:	ps map[string]interface{}, // Parameters for the template`
- L807: `pkg/doc/examples/cliopatra/cliopatra.md:31:map it to the ParameterDefinition the Command uses, and create a YAML file with the default values.`
- L808: `pkg/doc/tutorials/config-files-quickstart.md:17:This tutorial shows how to load configuration from one or more files using Glazed middlewares. You‚Äôll see a simple single-file setup and a multi-file overlay with deterministic precedence. We‚Äôll also show how to inspect parse steps using `--print-parsed-parameters`.`
- L809: `pkg/doc/tutorials/config-files-quickstart.md:22:- Familiarity with Cobra commands and Glazed layers`
- L810: `pkg/doc/tutorials/config-files-quickstart.md:26:Create a minimal command with a single custom layer and an explicit config file path:`
- L811: `pkg/doc/tutorials/config-files-quickstart.md:29:demoLayer, _ := schema.NewSection(`
- L812: `pkg/doc/tutorials/config-files-quickstart.md:31:    layers.WithPrefix("demo-"),`
- L813: `pkg/doc/tutorials/config-files-quickstart.md:38:desc := cmds.NewCommandDescription("demo", cmds.WithLayersList(demoLayer))`
- L814: `pkg/doc/tutorials/config-files-quickstart.md:44:        SkipCommandSettingsLayer: true,`
- L815: `pkg/doc/tutorials/config-files-quickstart.md:81:        SkipCommandSettingsLayer: true,`
- L816: `pkg/doc/tutorials/config-files-quickstart.md:124:Add `--print-parsed-parameters` to see each config file applied in sequence:`
- L817: `pkg/doc/tutorials/config-files-quickstart.md:127:go run ./cmd/examples/config-overlay overlay --print-parsed-parameters`
- L818: `pkg/doc/tutorials/config-files-quickstart.md:162:To layer `<base>.override.yaml` automatically on top of `--config-file`:`
- L819: `pkg/doc/tutorials/config-files-quickstart.md:192:Map arbitrary config structures to parameters without custom Go by using the pattern-based config mapper. Works with YAML or JSON files.`
- L820: `pkg/doc/tutorials/config-files-quickstart.md:195:// Define a layer`
- L821: `pkg/doc/tutorials/config-files-quickstart.md:196:demoLayer, _ := schema.NewSection("demo", "Demo",`
- L822: `pkg/doc/tutorials/config-files-quickstart.md:203:paramLayers := schema.NewSchema(layers.WithLayers(demoLayer))`
- L823: `pkg/doc/tutorials/config-files-quickstart.md:206:mapper, _ := patternmapper.NewConfigMapper(paramLayers,`
- L824: `pkg/doc/tutorials/config-files-quickstart.md:209:        TargetLayer: "demo",`
- L825: `pkg/doc/tutorials/config-files-quickstart.md:211:            {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L826: `pkg/doc/tutorials/config-files-quickstart.md:220:_ = sources.Execute(paramLayers, values.New(), mw)`
- L827: `pkg/doc/tutorials/config-files-quickstart.md:226:b := patternmapper.NewConfigMapperBuilder(paramLayers).`
- L828: `pkg/doc/tutorials/config-files-quickstart.md:238:err := sources.Execute(layers_, parsed,`
- L829: `pkg/doc/tutorials/config-files-quickstart.md:253:      TargetLayer:     "demo",`
- L830: `pkg/doc/tutorials/config-files-quickstart.md:254:      TargetParameter: "api-key",`
- L831: `pkg/doc/tutorials/config-files-quickstart.md:259:- Ambiguity: wildcard patterns that match multiple different values or rules that resolve to the same target parameter cause errors. Prefer named captures (e.g., `app.{env}.api_key`) when collecting multiple values.`
- L832: `pkg/doc/tutorials/config-files-quickstart.md:261:- Missing parameters: mapping to a non-existent parameter errors (prefix-aware), helping catch typos early.`
- L833: `pkg/doc/tutorials/config-files-quickstart.md:268:err := sources.Execute(layers_, parsed,`
- L834: `cmd/examples/parameter-types/sample-text.txt:4:Perfect for testing string-from-file parameters.`
- L835: `cmd/glaze/main.go:26:	err := logging.AddLoggingLayerToRootCommand(rootCmd, "glaze")`
- L836: `pkg/cmds/json-schema.go:29:// parameterTypeToJsonSchema converts a parameter definition to a JSON schema property`
- L837: `pkg/cmds/json-schema.go:30:func parameterTypeToJsonSchema(param *fields.Definition) (*JsonSchemaProperty, error) {`
- L838: `pkg/cmds/json-schema.go:110:	// File-based parameter types`
- L839: `pkg/cmds/json-schema.go:145:		return nil, fmt.Errorf("unsupported parameter type: %s", param.Type)`
- L840: `pkg/cmds/json-schema.go:162:		prop, err := parameterTypeToJsonSchema(flag)`
- L841: `pkg/cmds/json-schema.go:178:		prop, err := parameterTypeToJsonSchema(arg)`
- L842: `cmd/examples/parameter-types/README.md:1:# Parameter Types Example`
- L843: `cmd/examples/parameter-types/README.md:3:This example demonstrates all parameter types available in the glazed framework.`
- L844: `cmd/examples/parameter-types/README.md:9:go build -o parameter-types .`
- L845: `cmd/examples/parameter-types/README.md:11:# Show help to see all available parameters`
- L846: `cmd/examples/parameter-types/README.md:12:./parameter-types --help`
- L847: `cmd/examples/parameter-types/README.md:15:./parameter-types`
- L848: `cmd/examples/parameter-types/README.md:18:./parameter-types \`
- L849: `cmd/examples/parameter-types/README.md:28:./parameter-types \`
- L850: `cmd/examples/parameter-types/README.md:35:./parameter-types \`
- L851: `cmd/examples/parameter-types/README.md:44:./parameter-types \`
- L852: `cmd/examples/parameter-types/README.md:48:./parameter-types \`
- L853: `cmd/examples/parameter-types/README.md:52:## Parameter Types Demonstrated`
- L854: `cmd/examples/parameter-types/README.md:85:- `sample.json` - JSON object for testing object parameters`
- L855: `cmd/examples/parameter-types/README.md:87:- `sample-list.json` - JSON array for testing list parameters`
- L856: `cmd/examples/parameter-types/README.md:88:- `sample-text.txt` - Multi-line text for string parameters`
- L857: `cmd/examples/parameter-types/README.md:89:- `sample-lines.txt` - Line-by-line text for list parameters`
- L858: `cmd/examples/parameter-types/README.md:90:- `config.yaml` - Configuration file for key-value parameters`
- L859: `cmd/examples/parameter-types/README.md:94:The program displays all parsed parameter values in a structured format, demonstrating how each type is processed and what the final values look like.`
- L860: `cmd/examples/parameter-types/README.md:96:Note that secret parameters will show as `***` in the output to protect sensitive data.`
- L861: `cmd/examples/parameter-types/main.go:25:type ParameterTypesSettings struct {`
- L862: `cmd/examples/parameter-types/main.go:56:type ParameterTypesCommand struct {`
- L863: `cmd/examples/parameter-types/main.go:60:var _ cmds.GlazeCommand = (*ParameterTypesCommand)(nil)`
- L864: `cmd/examples/parameter-types/main.go:62:func NewParameterTypesCommand() (*ParameterTypesCommand, error) {`
- L865: `cmd/examples/parameter-types/main.go:65:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L866: `cmd/examples/parameter-types/main.go:68:	return &ParameterTypesCommand{`
- L867: `cmd/examples/parameter-types/main.go:70:			"parameter-types",`
- L868: `cmd/examples/parameter-types/main.go:71:			cmds.WithShort("Showcase all parameter types available in glazed"),`
- L869: `cmd/examples/parameter-types/main.go:72:			cmds.WithLong(`This command demonstrates all the different parameter types available in the glazed framework.`
- L870: `cmd/examples/parameter-types/main.go:75:Parameter types demonstrated:`
- L871: `cmd/examples/parameter-types/main.go:81:Use --help to see all available parameters and their descriptions.`),`
- L872: `cmd/examples/parameter-types/main.go:87:					fields.WithHelp("A simple string parameter"),`
- L873: `cmd/examples/parameter-types/main.go:93:					fields.WithHelp("A secret parameter (will be masked when displayed)"),`
- L874: `cmd/examples/parameter-types/main.go:99:					fields.WithHelp("An integer parameter"),`
- L875: `cmd/examples/parameter-types/main.go:105:					fields.WithHelp("A floating point parameter"),`
- L876: `cmd/examples/parameter-types/main.go:111:					fields.WithHelp("A boolean parameter"),`
- L877: `cmd/examples/parameter-types/main.go:117:					fields.WithHelp("A date parameter (RFC3339 format or natural language)"),`
- L878: `cmd/examples/parameter-types/main.go:123:					fields.WithHelp("A choice parameter with predefined options"),`
- L879: `cmd/examples/parameter-types/main.go:159:					fields.WithHelp("A file parameter that loads file metadata"),`
- L880: `cmd/examples/parameter-types/main.go:210:			cmds.WithLayersList(`
- L881: `cmd/examples/parameter-types/main.go:217:func (c *ParameterTypesCommand) RunIntoGlazeProcessor(`
- L882: `cmd/examples/parameter-types/main.go:222:	s := &ParameterTypesSettings{}`
- L883: `cmd/examples/parameter-types/main.go:225:		return errors.Wrap(err, "Failed to initialize settings from parameters")`
- L884: `cmd/examples/parameter-types/main.go:228:	// We'll use hardcoded metadata since layer access is complex`
- L885: `cmd/examples/parameter-types/main.go:230:	// Create a result row for each parameter`
- L886: `cmd/examples/parameter-types/main.go:231:	parameterData := []struct {`
- L887: `cmd/examples/parameter-types/main.go:240:		{"string-param", fields.TypeString, s.StringParam, "A simple string parameter", false, nil, "default-string"},`
- L888: `cmd/examples/parameter-types/main.go:241:		{"secret-param", fields.TypeSecret, s.SecretParam, "A secret parameter (will be masked when displayed)", false, nil, "secret-value"},`
- L889: `cmd/examples/parameter-types/main.go:242:		{"integer-param", fields.TypeInteger, s.IntegerParam, "An integer parameter", false, nil, 42},`
- L890: `cmd/examples/parameter-types/main.go:243:		{"float-param", fields.TypeFloat, s.FloatParam, "A floating point parameter", false, nil, 3.14},`
- L891: `cmd/examples/parameter-types/main.go:244:		{"bool-param", fields.TypeBool, s.BoolParam, "A boolean parameter", false, nil, true},`
- L892: `cmd/examples/parameter-types/main.go:245:		{"date-param", fields.TypeDate, s.DateParam, "A date parameter (RFC3339 format or natural language)", false, nil, "2024-01-01T00:00:00Z"},`
- L893: `cmd/examples/parameter-types/main.go:246:		{"choice-param", fields.TypeChoice, s.ChoiceParam, "A choice parameter with predefined options", false, []string{"option1", "option2", "option3"}, "option1"},`
- L894: `cmd/examples/parameter-types/main.go:251:		{"file-param", fields.TypeFile, s.FileParam, "A file parameter that loads file metadata", false, nil, nil},`
- L895: `cmd/examples/parameter-types/main.go:263:	for _, param := range parameterData {`
- L896: `cmd/examples/parameter-types/main.go:302:			types.MRP("parameter_name", param.name),`
- L897: `cmd/examples/parameter-types/main.go:303:			types.MRP("parameter_type", string(param.paramType)),`
- L898: `cmd/examples/parameter-types/main.go:324:	cmd, err := NewParameterTypesCommand()`
- L899: `cmd/examples/parameter-types/main.go:331:		Use:   "parameter-types",`
- L900: `cmd/examples/parameter-types/main.go:332:		Short: "Showcase all glazed parameter types",`
- L901: `pkg/doc/topics/07-load-parameters-from-json.md:2:Title: Loading Parameters from JSON`
- L902: `pkg/doc/topics/07-load-parameters-from-json.md:3:Slug: load-parameters-json`
- L903: `pkg/doc/topics/07-load-parameters-from-json.md:4:Short: Explains how to load parameters from a JSON file.`
- L904: `pkg/doc/topics/07-load-parameters-from-json.md:7:- Parameters`
- L905: `pkg/doc/topics/07-load-parameters-from-json.md:9:- load-parameters-from-json`
- L906: `pkg/doc/topics/07-load-parameters-from-json.md:16:In addition to specifying parameters via command line flags, you can also load parameters from a JSON file.`
- L907: `pkg/doc/topics/07-load-parameters-from-json.md:19:This allows you to store common parameter configurations and reuse them across commands.`
- L908: `pkg/doc/topics/07-load-parameters-from-json.md:21:To load parameters from JSON, use the `--load-parameters-from-json` flag followed by the path to your JSON file:`
- L909: `pkg/doc/topics/07-load-parameters-from-json.md:24:command --load-parameters-from-json parameters.json [other arguments]`
- L910: `pkg/doc/topics/07-load-parameters-from-json.md:27:The JSON file should contain a JSON object where the keys are parameter names and the values are the parameter values you want to set.`
- L911: `pkg/doc/topics/07-load-parameters-from-json.md:39:This will set the `fields` and `output` parameters as if they had been passed via the command line.`
- L912: `pkg/doc/topics/07-load-parameters-from-json.md:60:‚ùØ glaze json --load-parameters-from-json /tmp/test-json.json misc/test-data/[123].json `
- L913: `pkg/doc/topics/07-load-parameters-from-json.md:79:The `ParseCommandFromMap` function in `cmds/map.go` is used to parse command parameters from a map structure, such as when loading parameters from JSON.`
- L914: `pkg/doc/topics/07-load-parameters-from-json.md:81:It takes a `CommandDescription`, a `map[string]interface{}` of parameters, and returns:`
- L915: `pkg/doc/topics/07-load-parameters-from-json.md:83:- A map of `ParsedParameterLayer` structs for each layer`
- L916: `pkg/doc/topics/07-load-parameters-from-json.md:84:- A combined map of all parameter values`
- L917: `pkg/doc/topics/07-load-parameters-from-json.md:89:1. It iterates through each layer in the `CommandDescription``
- L918: `pkg/doc/topics/07-load-parameters-from-json.md:90:2. For layers that implement the `JSONParameterLayer` interface, it calls `ParseFlagsFromJSON` to parse values from the map into a `ParsedParameterLayer``
- L919: `pkg/doc/topics/07-load-parameters-from-json.md:91:3. It adds the parsed layer to the output map`
- L920: `pkg/doc/topics/07-load-parameters-from-json.md:92:4. It also copies layer parameters into the combined parameter map`
- L921: `pkg/doc/topics/07-load-parameters-from-json.md:93:5. After parsing layers, it parses any remaining flags and arguments using the `CommandDescription` directly`
- L922: `pkg/doc/topics/07-load-parameters-from-json.md:108:layers, allParams, err := cmds.ParseCommandFromMap(cmd, params)`
- L923: `pkg/doc/topics/07-load-parameters-from-json.md:111:The returned `layers` map contains the parsed layers, while `allParams` contains all parameters combined.`
- L924: `cmd/glaze/cmds/example.go:31:	glazedLayer, err := settings.NewGlazedSchema()`
- L925: `cmd/glaze/cmds/example.go:33:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L926: `cmd/glaze/cmds/example.go:56:			cmds.WithLayersList(`
- L927: `cmd/glaze/cmds/example.go:57:				glazedLayer,`
- L928: `cmd/glaze/cmds/example.go:65:// parsedLayers contains the result of parsing each layer that has been`
- L929: `cmd/glaze/cmds/example.go:66:// registered with the command description. These layers can be glazed structured data`
- L930: `cmd/glaze/cmds/example.go:67:// flags, database connection parameters, application specification fields.`
- L931: `cmd/glaze/cmds/example.go:76:		return errors.Wrap(err, "failed to initialize example settings from parameters")`
- L932: `pkg/doc/topics/23-pattern-based-config-mapping.md:4:Short: Declarative mapping of config files to parameter layers using pattern matching rules`
- L933: `pkg/doc/topics/23-pattern-based-config-mapping.md:18:The pattern-based config mapping system provides a declarative way to map arbitrary config file structures to Glazed's layer-based parameter system without writing custom Go functions. Instead of implementing `ConfigFileMapper` functions with manual config traversal, you define mapping rules that specify patterns to match in config files and how to map matched values to parameters. This keeps configuration logic concise, testable, and consistent across commands.`
- L934: `pkg/doc/topics/23-pattern-based-config-mapping.md:26:- Using the Mapper: Wire into `LoadParametersFromFile``
- L935: `pkg/doc/topics/23-pattern-based-config-mapping.md:39:- Verify target layers exist and static target parameters are valid (prefix-aware)`
- L936: `pkg/doc/topics/23-pattern-based-config-mapping.md:40:- Check that any `{name}` referenced in `TargetParameter` is captured in `Source``
- L937: `pkg/doc/topics/23-pattern-based-config-mapping.md:44:- For each pattern, collect matches; resolve `{captures}` into parameter names`
- L938: `pkg/doc/topics/23-pattern-based-config-mapping.md:45:- Write values to the target layer/parameter; error on ambiguity or collisions`
- L939: `pkg/doc/topics/23-pattern-based-config-mapping.md:56:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L940: `pkg/doc/topics/23-pattern-based-config-mapping.md:62:mapper, err := pm.NewConfigMapper(layers_,`
- L941: `pkg/doc/topics/23-pattern-based-config-mapping.md:65:        TargetLayer:     "demo",`
- L942: `pkg/doc/topics/23-pattern-based-config-mapping.md:66:        TargetParameter: "api-key",`
- L943: `pkg/doc/topics/23-pattern-based-config-mapping.md:70:// Use with LoadParametersFromFile`
- L944: `pkg/doc/topics/23-pattern-based-config-mapping.md:85:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L945: `pkg/doc/topics/23-pattern-based-config-mapping.md:90:b := pm.NewConfigMapperBuilder(layers_).`
- L946: `pkg/doc/topics/23-pattern-based-config-mapping.md:98:// Use with LoadParametersFromFile`
- L947: `pkg/doc/topics/23-pattern-based-config-mapping.md:116:    target_layer: "demo"`
- L948: `pkg/doc/topics/23-pattern-based-config-mapping.md:117:    target_parameter: "api-key"`
- L949: `pkg/doc/topics/23-pattern-based-config-mapping.md:119:    target_layer: "demo"`
- L950: `pkg/doc/topics/23-pattern-based-config-mapping.md:120:    target_parameter: "{env}-api-key"`
- L951: `pkg/doc/topics/23-pattern-based-config-mapping.md:127:  target_layer: "demo"`
- L952: `pkg/doc/topics/23-pattern-based-config-mapping.md:128:  target_parameter: "threshold"`
- L953: `pkg/doc/topics/23-pattern-based-config-mapping.md:137:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L954: `pkg/doc/topics/23-pattern-based-config-mapping.md:146:mapper, err := pm.NewConfigMapper(layers_, rules...)`
- L955: `pkg/doc/topics/23-pattern-based-config-mapping.md:150:mapper2, err := pm.LoadMapperFromFile(layers_, "mappings.yaml")`
- L956: `pkg/doc/topics/23-pattern-based-config-mapping.md:165:Exact match patterns map specific config paths to parameters with no variation:`
- L957: `pkg/doc/topics/23-pattern-based-config-mapping.md:170:    TargetLayer:     "demo",`
- L958: `pkg/doc/topics/23-pattern-based-config-mapping.md:171:    TargetParameter: "api-key",`
- L959: `pkg/doc/topics/23-pattern-based-config-mapping.md:186:Named captures extract segments from config paths and use them in parameter names, enabling environment-specific or multi-tenant configurations:`
- L960: `pkg/doc/topics/23-pattern-based-config-mapping.md:191:    TargetLayer:     "demo",`
- L961: `pkg/doc/topics/23-pattern-based-config-mapping.md:192:    TargetParameter: "{env}-api-key",`
- L962: `pkg/doc/topics/23-pattern-based-config-mapping.md:209:The `{env}` capture extracts whatever value appears at that position in the config (here, "dev" or "prod") and makes it available for use in the target parameter name.`
- L963: `pkg/doc/topics/23-pattern-based-config-mapping.md:218:    TargetLayer:     "demo",`
- L964: `pkg/doc/topics/23-pattern-based-config-mapping.md:219:    TargetParameter: "api-key",`
- L965: `pkg/doc/topics/23-pattern-based-config-mapping.md:234:Important: When a wildcard pattern matches multiple keys with different values, the mapper treats this as an ambiguity and returns an error by default. Use named captures (e.g., `app.{env}.api_key`) if you need to collect multiple values, or ensure matched values are identical if a single target parameter is intended. This prevents accidental aggregation of unrelated values.`
- L966: `pkg/doc/topics/23-pattern-based-config-mapping.md:243:    TargetLayer: "demo",`
- L967: `pkg/doc/topics/23-pattern-based-config-mapping.md:245:        {Source: "api_key", TargetParameter: "api-key"},`
- L968: `pkg/doc/topics/23-pattern-based-config-mapping.md:246:        {Source: "threshold", TargetParameter: "threshold"},`
- L969: `pkg/doc/topics/23-pattern-based-config-mapping.md:247:        {Source: "timeout", TargetParameter: "timeout"},`
- L970: `pkg/doc/topics/23-pattern-based-config-mapping.md:255:b := patternmapper.NewConfigMapperBuilder(layers).`
- L971: `pkg/doc/topics/23-pattern-based-config-mapping.md:287:    TargetLayer: "demo",`
- L972: `pkg/doc/topics/23-pattern-based-config-mapping.md:289:        {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L973: `pkg/doc/topics/23-pattern-based-config-mapping.md:290:        {Source: "threshold", TargetParameter: "threshold"},`
- L974: `pkg/doc/topics/23-pattern-based-config-mapping.md:314:The `{env}` capture from the parent pattern is available in all child rules, allowing them to construct environment-specific parameter names.`
- L975: `pkg/doc/topics/23-pattern-based-config-mapping.md:326:    // Target layer slug (required for leaf rules)`
- L976: `pkg/doc/topics/23-pattern-based-config-mapping.md:328:    TargetLayer string`
- L977: `pkg/doc/topics/23-pattern-based-config-mapping.md:330:    // Target parameter name (required for leaf rules)`
- L978: `pkg/doc/topics/23-pattern-based-config-mapping.md:332:    TargetParameter string`
- L979: `pkg/doc/topics/23-pattern-based-config-mapping.md:347:b := patternmapper.NewConfigMapperBuilder(layers).`
- L980: `pkg/doc/topics/23-pattern-based-config-mapping.md:359:- Prefix-aware parameter resolution and compile-time validation of static targets apply at Build().`
- L981: `pkg/doc/topics/23-pattern-based-config-mapping.md:370:3. **Target layer**: Must exist in parameter layers`
- L982: `pkg/doc/topics/23-pattern-based-config-mapping.md:371:4. **Target parameter**: Must exist in target layer *(validated at runtime per match)*`
- L983: `pkg/doc/topics/23-pattern-based-config-mapping.md:379:    TargetParameter: "{env}-api-key",  // {env} not captured in source`
- L984: `pkg/doc/topics/23-pattern-based-config-mapping.md:381:// Error: "capture reference {env} in target parameter not found in source pattern"`
- L985: `pkg/doc/topics/23-pattern-based-config-mapping.md:383:// Error: target layer doesn't exist`
- L986: `pkg/doc/topics/23-pattern-based-config-mapping.md:386:    TargetLayer: "nonexistent",`
- L987: `pkg/doc/topics/23-pattern-based-config-mapping.md:387:    TargetParameter: "api-key",`
- L988: `pkg/doc/topics/23-pattern-based-config-mapping.md:389:// Error: "target layer \"nonexistent\" does not exist"`
- L989: `pkg/doc/topics/23-pattern-based-config-mapping.md:399:    TargetLayer:     "demo",`
- L990: `pkg/doc/topics/23-pattern-based-config-mapping.md:400:    TargetParameter: "api-key",`
- L991: `pkg/doc/topics/23-pattern-based-config-mapping.md:411:- Multi-match: If a single pattern matches multiple paths that would resolve to the same target parameter with different values (e.g., `app.*.api_key` for `dev` and `prod`), an error is returned.`
- L992: `pkg/doc/topics/23-pattern-based-config-mapping.md:412:- Collisions: If different patterns resolve to the same target parameter (e.g., `app.settings.api_key` and `config.api_key` both mapping to `demo.api-key`), an error is returned.`
- L993: `pkg/doc/topics/23-pattern-based-config-mapping.md:416:Runtime errors occur when config files don't match expectations or reference nonexistent parameters. The system provides detailed error messages to aid debugging. Error messages include both the user-provided target name and the canonical (prefix-aware) parameter name where relevant.`
- L994: `pkg/doc/topics/23-pattern-based-config-mapping.md:420:- Target parameter doesn't exist in layer`
- L995: `pkg/doc/topics/23-pattern-based-config-mapping.md:429:**Example error for missing parameter**:`
- L996: `pkg/doc/topics/23-pattern-based-config-mapping.md:431:target parameter "api-key" does not exist in layer "demo" (pattern: "app.settings.api_key")`
- L997: `pkg/doc/topics/23-pattern-based-config-mapping.md:434:**Example error for missing parameter with prefix**:`
- L998: `pkg/doc/topics/23-pattern-based-config-mapping.md:436:target parameter "api-key" (checked as "demo-api-key") does not exist in layer "demo" (pattern: "app.settings.api_key")`
- L999: `pkg/doc/topics/23-pattern-based-config-mapping.md:439:When a layer has a prefix and the target parameter name doesn't include it, the error message shows both the provided name and the resolved canonical name (with prefix). This helps debug parameter name mismatches.`
- L1000: `pkg/doc/topics/23-pattern-based-config-mapping.md:445:- Overwrites: Overwrites across different rules to the same parameter are considered collisions and will error.`
- L1001: `pkg/doc/topics/23-pattern-based-config-mapping.md:455:- Grouped parameters (nested rules)`
- L1002: `pkg/doc/topics/23-pattern-based-config-mapping.md:470:A real-world example showing pattern mapper integration. This example highlights capture inheritance, prefix-aware parameters, and minimal application wiring.`
- L1003: `pkg/doc/topics/23-pattern-based-config-mapping.md:476:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1004: `pkg/doc/topics/23-pattern-based-config-mapping.md:479:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1005: `pkg/doc/topics/23-pattern-based-config-mapping.md:483:    // Define parameter layers`
- L1006: `pkg/doc/topics/23-pattern-based-config-mapping.md:484:    layer, _ := schema.NewSection("demo", "Demo",`
- L1007: `pkg/doc/topics/23-pattern-based-config-mapping.md:491:    paramLayers := schema.NewSchema(layers.WithLayers(layer))`
- L1008: `pkg/doc/topics/23-pattern-based-config-mapping.md:494:    mapper, err := patternmapper.NewConfigMapper(paramLayers,`
- L1009: `pkg/doc/topics/23-pattern-based-config-mapping.md:497:            TargetLayer: "demo",`
- L1010: `pkg/doc/topics/23-pattern-based-config-mapping.md:499:                {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L1011: `pkg/doc/topics/23-pattern-based-config-mapping.md:514:    parsedLayers := values.New()`
- L1012: `pkg/doc/topics/23-pattern-based-config-mapping.md:515:    err = sources.Execute(paramLayers, parsedLayers, middleware)`
- L1013: `pkg/doc/topics/23-pattern-based-config-mapping.md:536:patternMapper, _ := patternmapper.NewConfigMapper(layers, rules...)`
- L1014: `pkg/doc/topics/23-pattern-based-config-mapping.md:561:glaze help parameter-layers-and-parsed-layers`
- L1015: `cmd/glaze/cmds/yaml.go:30:	glazedLayer, err := settings.NewGlazedSchema()`
- L1016: `cmd/glaze/cmds/yaml.go:32:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L1017: `cmd/glaze/cmds/yaml.go:66:			cmds.WithLayersList(`
- L1018: `cmd/glaze/cmds/yaml.go:67:				glazedLayer,`
- L1019: `cmd/glaze/cmds/yaml.go:84:		return errors.Wrap(err, "Failed to initialize yaml settings from parameters")`
- L1020: `pkg/doc/topics/18-lua.md:37:Executes a GlazeCommand with parameters from a Lua table.`
- L1021: `pkg/doc/topics/18-lua.md:43:Executes a BareCommand with parameters from a Lua table.`
- L1022: `pkg/doc/topics/18-lua.md:49:Executes a WriterCommand with parameters from a Lua table.`
- L1023: `pkg/doc/topics/18-lua.md:65:Middleware to parse nested Lua tables into ParsedLayers.`
- L1024: `pkg/doc/topics/18-lua.md:91:1. **ParseLuaTableToLayer**`
- L1025: `pkg/doc/topics/18-lua.md:93:func ParseLuaTableToLayer(L *lua.LState, luaTable *lua.LTable, layer schema.Section) (*values.SectionValues, error)`
- L1026: `pkg/doc/topics/18-lua.md:95:Parses a Lua table into a ParsedLayer.`
- L1027: `pkg/doc/topics/18-lua.md:97:2. **ParseNestedLuaTableToParsedLayers**`
- L1028: `pkg/doc/topics/18-lua.md:99:func ParseNestedLuaTableToParsedLayers(L *lua.LState, luaTable *lua.LTable, parameterLayers *schema.Schema) (*values.Values, error)`
- L1029: `pkg/doc/topics/18-lua.md:101:Parses a nested Lua table into ParsedLayers.`
- L1030: `pkg/doc/topics/18-lua.md:103:3. **ParseParameterFromLua**`
- L1031: `pkg/doc/topics/18-lua.md:105:func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error)`
- L1032: `pkg/doc/topics/18-lua.md:107:Parses a Lua value into a Go value based on the parameter definition.`
- L1033: `pkg/doc/topics/18-lua.md:129:2. A global table containing parameter information (`command_name_params`)`
- L1034: `pkg/doc/topics/18-lua.md:146:### Accessing Command Parameters`
- L1035: `pkg/doc/topics/18-lua.md:148:The registration process creates a global Lua table with parameter information:`
- L1036: `pkg/doc/topics/18-lua.md:150:for layer_name, layer_params in pairs(animal_list_params) do`
- L1037: `pkg/doc/topics/18-lua.md:151:    print("Layer: " .. layer_name)`
- L1038: `pkg/doc/topics/18-lua.md:152:    for param_name, param_info in pairs(layer_params) do`
- L1039: `pkg/doc/topics/18-lua.md:162:The wrapper supports nested Lua tables for complex parameter structures:`
- L1040: `pkg/doc/topics/18-lua.md:205:4. Structure your parameter tables to match the expected layer organization`
- L1041: `pkg/doc/topics/18-lua.md:207:5. Leverage the parameter information tables for runtime validation and documentation`
- L1042: `cmd/glaze/cmds/markdown.go:428:	glazedLayer, err := settings.NewGlazedSchema()`
- L1043: `cmd/glaze/cmds/markdown.go:432:	cobraLayer, ok := glazedLayer.(schema.CobraSection)`
- L1044: `cmd/glaze/cmds/markdown.go:434:		panic("glazed layer is not a CobraSection")`
- L1045: `cmd/glaze/cmds/markdown.go:437:	err = cobraLayer.AddLayerToCobraCommand(parseCmd)`
- L1046: `cmd/glaze/cmds/markdown.go:447:	err = cobraLayer.AddLayerToCobraCommand(splitByHeadingCmd)`
- L1047: `pkg/doc/topics/08-file-parameter-type.md:3:Slug: file-parameters`
- L1048: `pkg/doc/topics/08-file-parameter-type.md:4:Short: Describes how to work with file inputs in command parameters.`
- L1049: `pkg/doc/topics/08-file-parameter-type.md:7:- Parameters`
- L1050: `pkg/doc/topics/08-file-parameter-type.md:14:Glazed provides two new parameter types `file` and `fileList` that allow passing file paths which will be automatically loaded and parsed.`
- L1051: `pkg/doc/topics/08-file-parameter-type.md:18:File parameters are parsed into a single or a list of `FileData` structures which can then be accessed from within a template.`
- L1052: `pkg/doc/topics/08-file-parameter-type.md:21:package parameters`
- L1053: `pkg/doc/topics/08-file-parameter-type.md:55:The `FileData` structure returned by the `file` and `fileList` parameters can be easily used inside templates.`
- L1054: `pkg/doc/topics/08-file-parameter-type.md:86:## The `file` ParameterType`
- L1055: `pkg/doc/topics/08-file-parameter-type.md:88:The `file` parameter type allows passing a single file path, which will be read and parsed into a `FileData` structure.`
- L1056: `pkg/doc/topics/08-file-parameter-type.md:113:## The `fileList` Parameter`
- L1057: `cmd/glaze/cmds/csv.go:25:	glazedLayer, err := settings.NewGlazedSchema()`
- L1058: `cmd/glaze/cmds/csv.go:73:			cmds.WithLayersList(`
- L1059: `cmd/glaze/cmds/csv.go:74:				glazedLayer,`
- L1060: `cmd/glaze/cmds/csv.go:93:		return errors.Wrap(err, "failed to initialize csv settings from parameters")`
- L1061: `pkg/doc/topics/16-adding-parameter-types.md:2:Title: Adding New Parameter Types to Glazed`
- L1062: `pkg/doc/topics/16-adding-parameter-types.md:3:Slug: adding-parameter-types`
- L1063: `pkg/doc/topics/16-adding-parameter-types.md:4:Short: Comprehensive guide on implementing new parameter types in the Glazed framework.`
- L1064: `pkg/doc/topics/16-adding-parameter-types.md:6:- parameters`
- L1065: `pkg/doc/topics/16-adding-parameter-types.md:18:# Adding New Parameter Types to Glazed`
- L1066: `pkg/doc/topics/16-adding-parameter-types.md:22:Parameter types in glazed are defined in the [`glazed/pkg/cmds/parameters`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters) package. Each parameter type requires modifications to several files to handle:`
- L1067: `pkg/doc/topics/16-adding-parameter-types.md:32:This guide explains how to add a new parameter type to the glazed command line framework. We'll use the example of adding a `credentials` parameter type to demonstrate the process.`
- L1068: `pkg/doc/topics/16-adding-parameter-types.md:36:When adding a new parameter type, you need to modify these files:`
- L1069: `pkg/doc/topics/16-adding-parameter-types.md:38:### Core Parameter Files`
- L1070: `pkg/doc/topics/16-adding-parameter-types.md:39:1. [`parameter-type.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameter-type.go) - Define the type constant and metadata methods`
- L1071: `pkg/doc/topics/16-adding-parameter-types.md:40:2. [`parse.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parse.go) - Add parsing logic`
- L1072: `pkg/doc/topics/16-adding-parameter-types.md:41:3. [`parameters.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameters.go) - Add validation and value assignment`
- L1073: `pkg/doc/topics/16-adding-parameter-types.md:42:4. [`cobra.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/cobra.go) - Add CLI flag support`
- L1074: `pkg/doc/topics/16-adding-parameter-types.md:43:5. [`viper.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/viper.go) - Add configuration file support`
- L1075: `pkg/doc/topics/16-adding-parameter-types.md:44:6. [`render.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/render.go) - Add display formatting`
- L1076: `pkg/doc/topics/16-adding-parameter-types.md:53:## Step 1: Define the Parameter Type`
- L1077: `pkg/doc/topics/16-adding-parameter-types.md:55:In [`parameter-type.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameter-type.go), add your new type constant:`
- L1078: `pkg/doc/topics/16-adding-parameter-types.md:60:    ParameterTypeCredentials ParameterType = "credentials"`
- L1079: `pkg/doc/topics/16-adding-parameter-types.md:67:func (p ParameterType) IsList() bool {`
- L1080: `pkg/doc/topics/16-adding-parameter-types.md:69:    case ParameterTypeCredentials:`
- L1081: `pkg/doc/topics/16-adding-parameter-types.md:85:In [`parse.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parse.go), add a case to the `ParseParameter` method:`
- L1082: `pkg/doc/topics/16-adding-parameter-types.md:88:func (p *ParameterDefinition) ParseParameter(v []string, options ...ParseStepOption) (*ParsedParameter, error) {`
- L1083: `pkg/doc/topics/16-adding-parameter-types.md:94:    case ParameterTypeCredentials:`
- L1084: `pkg/doc/topics/16-adding-parameter-types.md:136:func (p *ParameterDefinition) ParseFromReader(f io.Reader, filename string, options ...ParseStepOption) (*ParsedParameter, error) {`
- L1085: `pkg/doc/topics/16-adding-parameter-types.md:142:    case ParameterTypeCredentials:`
- L1086: `pkg/doc/topics/16-adding-parameter-types.md:160:In [`parameters.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/parameters.go), add validation to `CheckValueValidity`:`
- L1087: `pkg/doc/topics/16-adding-parameter-types.md:163:func (p *ParameterDefinition) CheckValueValidity(v interface{}) (interface{}, error) {`
- L1088: `pkg/doc/topics/16-adding-parameter-types.md:169:    case ParameterTypeCredentials:`
- L1089: `pkg/doc/topics/16-adding-parameter-types.md:175:                return nil, errors.Errorf("Value for parameter %s is not credentials (expected map[string]string): %v", p.Name, v)`
- L1090: `pkg/doc/topics/16-adding-parameter-types.md:203:func (p *ParameterDefinition) InitializeValueToEmptyValue(value reflect.Value) error {`
- L1091: `pkg/doc/topics/16-adding-parameter-types.md:207:    case ParameterTypeCredentials:`
- L1092: `pkg/doc/topics/16-adding-parameter-types.md:216:func (p *ParameterDefinition) SetValueFromInterface(value reflect.Value, v interface{}) error {`
- L1093: `pkg/doc/topics/16-adding-parameter-types.md:222:    case ParameterTypeCredentials:`
- L1094: `pkg/doc/topics/16-adding-parameter-types.md:225:            return errors.Errorf("expected credentials for parameter %s, got %T", p.Name, v)`
- L1095: `pkg/doc/topics/16-adding-parameter-types.md:234:In [`cobra.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/cobra.go), add flag creation logic:`
- L1096: `pkg/doc/topics/16-adding-parameter-types.md:237:func (ps *ParameterDefinitions) AddToCobraCommand(cmd *cobra.Command) error {`
- L1097: `pkg/doc/topics/16-adding-parameter-types.md:240:    switch parameter.Type {`
- L1098: `pkg/doc/topics/16-adding-parameter-types.md:243:    case ParameterTypeCredentials:`
- L1099: `pkg/doc/topics/16-adding-parameter-types.md:245:        if parameter.Default != nil {`
- L1100: `pkg/doc/topics/16-adding-parameter-types.md:246:            if creds, ok := (*parameter.Default).(map[string]string); ok {`
- L1101: `pkg/doc/topics/16-adding-parameter-types.md:252:        cmd.Flags().StringSliceVarP(&ps.cobraParameterValues[parameter.Name], `
- L1102: `pkg/doc/topics/16-adding-parameter-types.md:253:            parameter.Name, parameter.ShortFlag, defaultValue, parameter.Help)`
- L1103: `pkg/doc/topics/16-adding-parameter-types.md:261:func (ps *ParameterDefinitions) SetupCobraCompletions(cmd *cobra.Command) error {`
- L1104: `pkg/doc/topics/16-adding-parameter-types.md:264:    switch parameter.Type {`
- L1105: `pkg/doc/topics/16-adding-parameter-types.md:265:    case ParameterTypeCredentials:`
- L1106: `pkg/doc/topics/16-adding-parameter-types.md:266:        err = cmd.RegisterFlagCompletionFunc(parameter.Name, func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {`
- L1107: `pkg/doc/topics/16-adding-parameter-types.md:275:In [`render.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/pkg/cmds/parameters/render.go), add display formatting:`
- L1108: `pkg/doc/topics/16-adding-parameter-types.md:278:func RenderValue(parameterType ParameterType, value interface{}) (string, error) {`
- L1109: `pkg/doc/topics/16-adding-parameter-types.md:279:    switch parameterType {`
- L1110: `pkg/doc/topics/16-adding-parameter-types.md:282:    case ParameterTypeCredentials:`
- L1111: `pkg/doc/topics/16-adding-parameter-types.md:304:After implementing the core parameter functionality, you may need to update additional files that have exhaustive switch statements on parameter types:`
- L1112: `pkg/doc/topics/16-adding-parameter-types.md:321:func FlagTypeToGoType(s *jen.Statement, parameterType fields.Type) *jen.Statement {`
- L1113: `pkg/doc/topics/16-adding-parameter-types.md:322:    switch parameterType {`
- L1114: `pkg/doc/topics/16-adding-parameter-types.md:332:func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error) {`
- L1115: `pkg/doc/topics/16-adding-parameter-types.md:347:        return nil, fmt.Errorf("invalid type for credentials parameter '%s': expected table, got %s", paramDef.Name, value.Type())`
- L1116: `pkg/doc/topics/16-adding-parameter-types.md:352:**Pro Tip**: Run `make lint` or `golangci-lint run` after adding your parameter type to discover any additional files with exhaustive switches that need updating.`
- L1117: `pkg/doc/topics/16-adding-parameter-types.md:354:## Step 8: Update Parameter Types Example`
- L1118: `pkg/doc/topics/16-adding-parameter-types.md:356:Update the parameter types example command in [`cmd/examples/parameter-types/main.go`](file:///home/manuel/workspaces/2025-06-09/add-geppetto-js/glazed/cmd/examples/parameter-types/main.go) to showcase your new parameter type.`
- L1119: `pkg/doc/topics/16-adding-parameter-types.md:358:### Add to Parameter Definitions`
- L1120: `pkg/doc/topics/16-adding-parameter-types.md:359:Add your parameter to the `cmds.WithFlags()` section:`
- L1121: `pkg/doc/topics/16-adding-parameter-types.md:365:    fields.WithHelp("A credentials parameter for username/password pairs"),`
- L1122: `pkg/doc/topics/16-adding-parameter-types.md:371:Add a field to the `ParameterTypesSettings` struct:`
- L1123: `pkg/doc/topics/16-adding-parameter-types.md:374:type ParameterTypesSettings struct {`
- L1124: `pkg/doc/topics/16-adding-parameter-types.md:380:### Add to Parameter Data Array`
- L1125: `pkg/doc/topics/16-adding-parameter-types.md:381:Add an entry to the `parameterData` slice in `RunIntoGlazeProcessor`:`
- L1126: `pkg/doc/topics/16-adding-parameter-types.md:384:{"credentials-param", fields.TypeCredentials, s.CredentialsParam, "A credentials parameter for username/password pairs", false, nil, map[string]string{"username": "admin", "password": "secret"}},`
- L1127: `pkg/doc/topics/16-adding-parameter-types.md:387:This ensures that developers and users can easily test and understand how your new parameter type works in practice.`
- L1128: `pkg/doc/topics/16-adding-parameter-types.md:391:After updating the example, test it to ensure your new parameter type works correctly:`
- L1129: `pkg/doc/topics/16-adding-parameter-types.md:394:cd cmd/examples/parameter-types`
- L1130: `pkg/doc/topics/16-adding-parameter-types.md:395:go build -o parameter-types .`
- L1131: `pkg/doc/topics/16-adding-parameter-types.md:398:./parameter-types parameter-types`
- L1132: `pkg/doc/topics/16-adding-parameter-types.md:401:./parameter-types parameter-types --credentials-param username:admin,password:secret`
- L1133: `pkg/doc/topics/16-adding-parameter-types.md:403:# Test parameter parsing (useful for debugging)`
- L1134: `pkg/doc/topics/16-adding-parameter-types.md:404:./parameter-types parameter-types --credentials-param username:test,password:demo --print-parsed-parameters`
- L1135: `pkg/doc/topics/16-adding-parameter-types.md:408:- Your parameter appears in the help output (`--help`)`
- L1136: `pkg/doc/topics/16-adding-parameter-types.md:416:Create comprehensive tests for your new parameter type:`
- L1137: `pkg/doc/topics/16-adding-parameter-types.md:419:func TestCredentialsParameter(t *testing.T) {`
- L1138: `pkg/doc/topics/16-adding-parameter-types.md:445:            pd := &ParameterDefinition{`
- L1139: `pkg/doc/topics/16-adding-parameter-types.md:447:                Type: ParameterTypeCredentials,`
- L1140: `pkg/doc/topics/16-adding-parameter-types.md:450:            result, err := pd.ParseParameter(tt.input)`
- L1141: `pkg/doc/topics/16-adding-parameter-types.md:463:## Example: Complete Credentials Parameter Type`
- L1142: `pkg/doc/topics/16-adding-parameter-types.md:465:Here's what the complete implementation would look like for a credentials parameter type:`
- L1143: `pkg/doc/topics/16-adding-parameter-types.md:467:### In parameter-type.go`
- L1144: `pkg/doc/topics/16-adding-parameter-types.md:471:    ParameterTypeCredentials ParameterType = "credentials"`
- L1145: `pkg/doc/topics/16-adding-parameter-types.md:474:func (p ParameterType) IsKeyValue() bool {`
- L1146: `pkg/doc/topics/16-adding-parameter-types.md:476:    case ParameterTypeKeyValue, ParameterTypeCredentials:`
- L1147: `pkg/doc/topics/16-adding-parameter-types.md:493:When adding a new parameter type to glazed, you need to modify these core files and follow these steps:`
- L1148: `pkg/doc/topics/16-adding-parameter-types.md:495:1. **Define the type constant** in `parameter-type.go``
- L1149: `pkg/doc/topics/16-adding-parameter-types.md:497:3. **Add validation and value assignment** in `parameters.go``
- L1150: `pkg/doc/topics/16-adding-parameter-types.md:502:8. **Update the parameter types example** in `cmd/examples/parameter-types/main.go``
- L1151: `pkg/doc/topics/16-adding-parameter-types.md:508:1. **Consistent naming**: Use the pattern `ParameterType<Name>` for constants`
- L1152: `pkg/doc/topics/16-adding-parameter-types.md:514:7. **Documentation**: Update parameter type documentation and help text`
- L1153: `pkg/doc/topics/16-adding-parameter-types.md:516:9. **Update examples**: Always update the parameter types example to showcase new types`
- L1154: `pkg/doc/topics/16-adding-parameter-types.md:527:Follow these patterns when implementing your custom parameter type to ensure consistency with the rest of the glazed framework.`
- L1155: `pkg/doc/topics/16-adding-parameter-types.md:529:**Important**: The parameter types example in `cmd/examples/parameter-types/` serves as both documentation and a testing tool. Always update it when adding new parameter types so users and developers can easily understand and test the new functionality.`
- L1156: `pkg/doc/tutorials/custom-layer.md:2:Title: Creating Custom Parameter Layers`
- L1157: `pkg/doc/tutorials/custom-layer.md:3:Slug: custom-layer-tutorial`
- L1158: `pkg/doc/tutorials/custom-layer.md:4:Short: Step-by-step tutorial for creating reusable custom parameter layers in Glazed`
- L1159: `pkg/doc/tutorials/custom-layer.md:7:- layers`
- L1160: `pkg/doc/tutorials/custom-layer.md:8:- parameters`
- L1161: `pkg/doc/tutorials/custom-layer.md:17:# Creating Custom Parameter Layers: Tutorial`
- L1162: `pkg/doc/tutorials/custom-layer.md:21:Custom parameter layers address the common challenge of duplicating parameter definitions across multiple CLI commands. Instead of copying the same flags for logging, database connections, or API configurations across commands, parameter layers provide reusable components that encapsulate related parameters and their validation logic.`
- L1163: `pkg/doc/tutorials/custom-layer.md:23:This tutorial demonstrates building a production-ready logging layer that can be reused across any Glazed command, providing consistent configuration interfaces and behavior throughout an application.`
- L1164: `pkg/doc/tutorials/custom-layer.md:29:- **Reusable logging layer implementation** with comprehensive parameter definitions`
- L1165: `pkg/doc/tutorials/custom-layer.md:30:- **Type-safe configuration structures** using struct tags for parameter binding`
- L1166: `pkg/doc/tutorials/custom-layer.md:32:- **Command composition patterns** demonstrating layer reuse across multiple commands`
- L1167: `pkg/doc/tutorials/custom-layer.md:43:Comprehensive logging configuration for production applications requires multiple parameter categories:`
- L1168: `pkg/doc/tutorials/custom-layer.md:56:Parameter layers eliminate the need to duplicate these 7+ flags across every command by defining the configuration once and reusing it throughout the application.`
- L1169: `pkg/doc/tutorials/custom-layer.md:58:## Step 1: Parameter Design`
- L1170: `pkg/doc/tutorials/custom-layer.md:60:Production logging layers require parameters that address both developer and operational requirements:`
- L1171: `pkg/doc/tutorials/custom-layer.md:62:**Core Parameters:**`
- L1172: `pkg/doc/tutorials/custom-layer.md:69:**Production Parameters:**`
- L1173: `pkg/doc/tutorials/custom-layer.md:73:- **Input validation**: Clear error messages for invalid parameter combinations`
- L1174: `pkg/doc/tutorials/custom-layer.md:78:mkdir glazed-logging-layer`
- L1175: `pkg/doc/tutorials/custom-layer.md:79:cd glazed-logging-layer`
- L1176: `pkg/doc/tutorials/custom-layer.md:80:go mod init glazed-logging-layer`
- L1177: `pkg/doc/tutorials/custom-layer.md:86:The project structure separates parameter definitions from business logic for maintainability:`
- L1178: `pkg/doc/tutorials/custom-layer.md:89:glazed-logging-layer/`
- L1179: `pkg/doc/tutorials/custom-layer.md:90:‚îú‚îÄ‚îÄ main.go           # Demo commands showing layer usage`
- L1180: `pkg/doc/tutorials/custom-layer.md:92:‚îÇ   ‚îú‚îÄ‚îÄ layer.go      # Parameter definitions and layer creation`
- L1181: `pkg/doc/tutorials/custom-layer.md:98:This separation enables independent testing of parameter validation and provides clear initialization patterns for applications using the layer.`
- L1182: `pkg/doc/tutorials/custom-layer.md:104:The settings struct defines the layer's configuration interface, using struct tags to map CLI parameters to Go fields. This struct serves as both the parameter binding target and the configuration container for logger initialization.`
- L1183: `pkg/doc/tutorials/custom-layer.md:121:// This struct serves as both the parameter binding target and the`
- L1184: `pkg/doc/tutorials/custom-layer.md:261:## Step 4: Define the Parameter Interface`
- L1185: `pkg/doc/tutorials/custom-layer.md:263:Create `logging/layer.go`:`
- L1186: `pkg/doc/tutorials/custom-layer.md:265:The layer definition specifies the CLI parameters and their configuration options. Each parameter includes type, default values, validation rules, and help text.`
- L1187: `pkg/doc/tutorials/custom-layer.md:271:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1188: `pkg/doc/tutorials/custom-layer.md:272:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1189: `pkg/doc/tutorials/custom-layer.md:276:    // LoggingSlug is the unique identifier for this layer.`
- L1190: `pkg/doc/tutorials/custom-layer.md:280:// NewLoggingLayer creates a new parameter layer for logging configuration.`
- L1191: `pkg/doc/tutorials/custom-layer.md:281:func NewLoggingLayer() (schema.Section, error) {`
- L1192: `pkg/doc/tutorials/custom-layer.md:286:            // Core logging parameters - the ones everyone needs`
- L1193: `pkg/doc/tutorials/custom-layer.md:309:            // Developer convenience parameters`
- L1194: `pkg/doc/tutorials/custom-layer.md:341:// NewLoggingLayerWithOptions creates a logging layer with customization options`
- L1195: `pkg/doc/tutorials/custom-layer.md:342:func NewLoggingLayerWithOptions(opts ...LoggingLayerOption) (schema.Section, error) {`
- L1196: `pkg/doc/tutorials/custom-layer.md:343:    config := &loggingLayerConfig{`
- L1197: `pkg/doc/tutorials/custom-layer.md:354:    layer, err := NewLoggingLayer()`
- L1198: `pkg/doc/tutorials/custom-layer.md:360:    params := layer.GetParameterDefinitions()`
- L1199: `pkg/doc/tutorials/custom-layer.md:373:    // To implement conditional parameters, you would need to create separate layers`
- L1200: `pkg/doc/tutorials/custom-layer.md:374:    // or build the layer conditionally rather than removing parameters after creation.`
- L1201: `pkg/doc/tutorials/custom-layer.md:375:    // For production code, use the basic NewLoggingLayer() without RemoveFlag calls.`
- L1202: `pkg/doc/tutorials/custom-layer.md:377:    return layer, nil`
- L1203: `pkg/doc/tutorials/custom-layer.md:380:// Configuration options for the logging layer`
- L1204: `pkg/doc/tutorials/custom-layer.md:381:type loggingLayerConfig struct {`
- L1205: `pkg/doc/tutorials/custom-layer.md:387:type LoggingLayerOption func(*loggingLayerConfig)`
- L1206: `pkg/doc/tutorials/custom-layer.md:389:// WithLogstash includes Logstash configuration parameters`
- L1207: `pkg/doc/tutorials/custom-layer.md:390:func WithLogstash() LoggingLayerOption {`
- L1208: `pkg/doc/tutorials/custom-layer.md:391:    return func(c *loggingLayerConfig) {`
- L1209: `pkg/doc/tutorials/custom-layer.md:397:func WithDefaultLevel(level string) LoggingLayerOption {`
- L1210: `pkg/doc/tutorials/custom-layer.md:398:    return func(c *loggingLayerConfig) {`
- L1211: `pkg/doc/tutorials/custom-layer.md:404:func WithDefaultFormat(format string) LoggingLayerOption {`
- L1212: `pkg/doc/tutorials/custom-layer.md:405:    return func(c *loggingLayerConfig) {`
- L1213: `pkg/doc/tutorials/custom-layer.md:421:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1214: `pkg/doc/tutorials/custom-layer.md:425:// GetLoggingSettings extracts logging settings from parsed layers`
- L1215: `pkg/doc/tutorials/custom-layer.md:426:func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {`
- L1216: `pkg/doc/tutorials/custom-layer.md:428:    if err := parsedLayers.InitializeStruct(LoggingSlug, settings); err != nil {`
- L1217: `pkg/doc/tutorials/custom-layer.md:434:// InitializeLogging sets up logging from parsed layers`
- L1218: `pkg/doc/tutorials/custom-layer.md:435:func InitializeLogging(parsedLayers *values.Values) error {`
- L1219: `pkg/doc/tutorials/custom-layer.md:436:    settings, err := GetLoggingSettings(parsedLayers)`
- L1220: `pkg/doc/tutorials/custom-layer.md:457:func MustInitializeLogging(parsedLayers *values.Values) {`
- L1221: `pkg/doc/tutorials/custom-layer.md:458:    if err := InitializeLogging(parsedLayers); err != nil {`
- L1222: `pkg/doc/tutorials/custom-layer.md:476:## Step 6: Create a Command Using the Layer`
- L1223: `pkg/doc/tutorials/custom-layer.md:489:    "glazed-logging-layer/logging"`
- L1224: `pkg/doc/tutorials/custom-layer.md:493:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1225: `pkg/doc/tutorials/custom-layer.md:494:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1226: `pkg/doc/tutorials/custom-layer.md:502:// ProcessDataCommand demonstrates using the logging layer`
- L1227: `pkg/doc/tutorials/custom-layer.md:516:    parsedLayers *values.Values,`
- L1228: `pkg/doc/tutorials/custom-layer.md:520:    if err := logging.InitializeLogging(parsedLayers); err != nil {`
- L1229: `pkg/doc/tutorials/custom-layer.md:528:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, settings); err != nil {`
- L1230: `pkg/doc/tutorials/custom-layer.md:575:    // Create logging layer with custom options`
- L1231: `pkg/doc/tutorials/custom-layer.md:576:    loggingLayer, err := logging.NewLoggingLayerWithOptions(`
- L1232: `pkg/doc/tutorials/custom-layer.md:585:    // Create glazed layer for output formatting`
- L1233: `pkg/doc/tutorials/custom-layer.md:586:    glazedLayer, err := settings.NewGlazedParameterLayers()`
- L1234: `pkg/doc/tutorials/custom-layer.md:596:This command demonstrates how to use the custom logging layer.`
- L1235: `pkg/doc/tutorials/custom-layer.md:635:        // Add both logging and glazed layers`
- L1236: `pkg/doc/tutorials/custom-layer.md:636:        cmds.WithLayersList(loggingLayer, glazedLayer),`
- L1237: `pkg/doc/tutorials/custom-layer.md:646:// Second command to demonstrate layer reuse`
- L1238: `pkg/doc/tutorials/custom-layer.md:659:    parsedLayers *values.Values,`
- L1239: `pkg/doc/tutorials/custom-layer.md:662:    // Initialize logging (same layer, reused!)`
- L1240: `pkg/doc/tutorials/custom-layer.md:663:    if err := logging.InitializeLogging(parsedLayers); err != nil {`
- L1241: `pkg/doc/tutorials/custom-layer.md:670:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, settings); err != nil {`
- L1242: `pkg/doc/tutorials/custom-layer.md:704:    // Reuse the same logging layer - this is the power of layers!`
- L1243: `pkg/doc/tutorials/custom-layer.md:705:    loggingLayer, err := logging.NewLoggingLayer()`
- L1244: `pkg/doc/tutorials/custom-layer.md:710:    glazedLayer, err := settings.NewGlazedParameterLayers()`
- L1245: `pkg/doc/tutorials/custom-layer.md:742:        cmds.WithLayersList(loggingLayer, glazedLayer),`
- L1246: `pkg/doc/tutorials/custom-layer.md:755:        Short: "Data processing application with custom logging layer",`
- L1247: `pkg/doc/tutorials/custom-layer.md:756:        Long:  "Demonstrates how to create and reuse custom parameter layers in Glazed",`
- L1248: `pkg/doc/tutorials/custom-layer.md:793:## Step 7: Test Your Custom Layer`
- L1249: `pkg/doc/tutorials/custom-layer.md:857:### Layer Composition`
- L1250: `pkg/doc/tutorials/custom-layer.md:859:Create specialized layers by combining the logging layer with others:`
- L1251: `pkg/doc/tutorials/custom-layer.md:862:func NewDatabaseLayerWithLogging() ([]schema.Section, error) {`
- L1252: `pkg/doc/tutorials/custom-layer.md:863:    loggingLayer, err := logging.NewLoggingLayer()`
- L1253: `pkg/doc/tutorials/custom-layer.md:868:    dbLayer, err := database.NewDatabaseLayer()`
- L1254: `pkg/doc/tutorials/custom-layer.md:873:    return []schema.Section{loggingLayer, dbLayer}, nil`
- L1255: `pkg/doc/tutorials/custom-layer.md:883:**Before layers**: Adding logging to commands required copying flag definitions, validation logic, and initialization code across multiple files, leading to inconsistent behavior and maintenance overhead.`
- L1256: `pkg/doc/tutorials/custom-layer.md:885:**With layers**: Adding logging to any command requires a single line: `cmds.WithLayersList(loggingLayer)`. All commands share the same interface, validation, and behavior patterns.`
- L1257: `pkg/doc/tutorials/custom-layer.md:889:**Separation of Concerns**: The logging layer handles configuration independently from business logic, enabling isolated testing and reuse across different commands.`
- L1258: `pkg/doc/tutorials/custom-layer.md:893:**Sensible Defaults**: The layer provides working defaults for common use cases while supporting advanced configurations for enterprise requirements.`
- L1259: `pkg/doc/tutorials/custom-layer.md:895:**Convention Over Configuration**: Consistent patterns for parameter naming, struct tags, and validation provide familiar interfaces for Go developers.`
- L1260: `pkg/doc/tutorials/custom-layer.md:899:The implemented layer includes production-ready capabilities:`
- L1261: `pkg/doc/tutorials/custom-layer.md:909:Layer composition enables modular architecture patterns for complex applications:`
- L1262: `pkg/doc/tutorials/custom-layer.md:913:‚îÇ   API Layer     ‚îÇ  ‚îÇ Database Layer  ‚îÇ  ‚îÇ Logging Layer   ‚îÇ`
- L1263: `pkg/doc/tutorials/custom-layer.md:925:                    ‚îÇ   parameters      ‚îÇ`
- L1264: `pkg/doc/tutorials/custom-layer.md:929:Each layer handles a specific concern. Commands compose required layers to build applications that scale from simple scripts to complex enterprise systems.`
- L1265: `pkg/doc/tutorials/custom-layer.md:933:### Layer Library Development`
- L1266: `pkg/doc/tutorials/custom-layer.md:935:Common layer implementations for production applications:`
- L1267: `pkg/doc/tutorials/custom-layer.md:937:**Database Layer**: Connection pooling, transaction management, migration flags`
- L1268: `pkg/doc/tutorials/custom-layer.md:938:**HTTP Client Layer**: Authentication, retries, circuit breakers, rate limiting  `
- L1269: `pkg/doc/tutorials/custom-layer.md:939:**File Processing Layer**: Input/output directories, file patterns, validation`
- L1270: `pkg/doc/tutorials/custom-layer.md:940:**Cache Layer**: Redis configuration, TTL settings, eviction policies`
- L1271: `pkg/doc/tutorials/custom-layer.md:948:baseLayer := NewBaseLayer(`
- L1272: `pkg/doc/tutorials/custom-layer.md:954:apiLayer := NewAPILayer(`
- L1273: `pkg/doc/tutorials/custom-layer.md:962:Enterprise layer implementations must address:`
- L1274: `pkg/doc/tutorials/custom-layer.md:966:- **Validation relationships**: Cross-parameter validation and dependency checking`
- L1275: `pkg/doc/tutorials/custom-layer.md:967:- **Backward compatibility**: Evolution strategies for layer APIs`
- L1276: `pkg/doc/tutorials/custom-layer.md:969:## Layer Patterns That Work in Production`
- L1277: `pkg/doc/tutorials/custom-layer.md:971:### Database Layer`
- L1278: `pkg/doc/tutorials/custom-layer.md:985:### HTTP Client Layer`
- L1279: `pkg/doc/tutorials/custom-layer.md:998:### File Processing Layer`
- L1280: `pkg/doc/tutorials/custom-layer.md:1014:This tutorial demonstrates implementing reusable parameter layers for CLI applications. The key principle is **configuration through composition**.`
- L1281: `pkg/doc/tutorials/custom-layer.md:1016:Rather than defining flags individually per command, standardized layers encapsulate interface and behavior patterns. This approach creates application consistency, reduces maintenance overhead, and provides predictable user interfaces.`
- L1282: `pkg/doc/tutorials/custom-layer.md:1018:The layer pattern enables scalable CLI architecture that grows from simple commands to comprehensive enterprise applications.`
- L1283: `pkg/doc/topics/10-template-command.md:17:A TemplateCommand allows you to define commands that render Go template text using command-line parameters as template variables. This enables rapid prototyping of text generation tools without writing Go code‚Äîsimply define parameters in YAML and write a template that uses those parameters.`
- L1284: `pkg/doc/topics/10-template-command.md:21:Template commands are defined in YAML files with a `template` field containing Go template syntax. The template receives all parsed parameters as variables accessible through the standard `{{.variable}}` syntax.`
- L1285: `pkg/doc/topics/10-template-command.md:97:		// Provide parameter values for the "default" layer`
- L1286: `pkg/doc/topics/10-template-command.md:114:Template commands use Go's `text/template` package syntax. All parsed parameters are available as variables in the template context.`
- L1287: `pkg/doc/topics/10-template-command.md:135:  # Using defaults for optional parameters`
- L1288: `pkg/doc/topics/10-template-command.md:139:## Parameter Types`
- L1289: `pkg/doc/topics/10-template-command.md:141:Template commands can leverage the full range of Glazed parameter types, allowing for rich and validated inputs. This means you can create templates that accept everything from simple strings and booleans to lists, choices, and even content from files.`
- L1290: `pkg/doc/topics/10-template-command.md:143:Template commands support all standard Glazed parameter types:`
- L1291: `pkg/doc/topics/10-template-command.md:151:For more details on parameter types, see:`
- L1292: `pkg/doc/topics/10-template-command.md:153:glaze help parameter-types`
- L1293: `cmd/glaze/cmds/docs.go:52:	// This is an example of selective use of glazed parameter schema.`
- L1294: `cmd/glaze/cmds/docs.go:56:	glazedLayer, err := settings.NewGlazedSchema(`
- L1295: `cmd/glaze/cmds/docs.go:57:		settings.WithFieldsFiltersParameterLayerOptions(`
- L1296: `cmd/glaze/cmds/docs.go:79:	cobraLayer, ok := glazedLayer.(schema.CobraSection)`
- L1297: `cmd/glaze/cmds/docs.go:81:		panic("glazed layer is not a CobraSection")`
- L1298: `cmd/glaze/cmds/docs.go:84:	err = cobraLayer.AddLayerToCobraCommand(DocsCmd)`
- L1299: `pkg/doc/topics/13-layers-and-parsed-layers.md:2:Title: Parameter Layers and Parsed Layers`
- L1300: `pkg/doc/topics/13-layers-and-parsed-layers.md:3:Slug: parameter-layers-and-parsed-layers`
- L1301: `pkg/doc/topics/13-layers-and-parsed-layers.md:5:    Learn how to use parameter layers and parsed layers in Glazed to organize and manage parameter definitions.`
- L1302: `pkg/doc/topics/13-layers-and-parsed-layers.md:7:  - layers`
- L1303: `pkg/doc/topics/13-layers-and-parsed-layers.md:17:## Parameter Layers`
- L1304: `pkg/doc/topics/13-layers-and-parsed-layers.md:19:Layers in the glazed package provide a way to group and organize parameter definitions. They allow for better structure and modularity in command-line interfaces and other parameter-driven systems.`
- L1305: `pkg/doc/topics/13-layers-and-parsed-layers.md:21:A layer is a logical grouping of related parameter definitions. It consists of several components:`
- L1306: `pkg/doc/topics/13-layers-and-parsed-layers.md:22:1. **Name**: A human-readable name for the layer.`
- L1307: `pkg/doc/topics/13-layers-and-parsed-layers.md:23:2. **Slug**: A unique identifier for the layer, used in code.`
- L1308: `pkg/doc/topics/13-layers-and-parsed-layers.md:24:3. **Description**: A brief explanation of the layer's purpose.`
- L1309: `pkg/doc/topics/13-layers-and-parsed-layers.md:25:4. **Prefix**: An optional prefix for parameter names within the layer.`
- L1310: `pkg/doc/topics/13-layers-and-parsed-layers.md:26:5. **Parameter Definitions**: A collection of parameter definitions that belong to this layer.`
- L1311: `pkg/doc/topics/13-layers-and-parsed-layers.md:28:### Parameter Definitions`
- L1312: `pkg/doc/topics/13-layers-and-parsed-layers.md:30:A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.`
- L1313: `pkg/doc/topics/13-layers-and-parsed-layers.md:32:1. **ParameterLayer**: An interface that groups parameter definitions and provides metadata.`
- L1314: `pkg/doc/topics/13-layers-and-parsed-layers.md:33:2. **ParameterLayers**: A collection of ParameterLayer objects.`
- L1315: `pkg/doc/topics/13-layers-and-parsed-layers.md:35:## Creating and Working with Parameter Layers`
- L1316: `pkg/doc/topics/13-layers-and-parsed-layers.md:37:The `ParameterLayerImpl` struct provides a straightforward implementation of the`
- L1317: `pkg/doc/topics/13-layers-and-parsed-layers.md:38:`ParameterLayer` interface.`
- L1318: `pkg/doc/topics/13-layers-and-parsed-layers.md:40:### Creating a Parameter Layer`
- L1319: `pkg/doc/topics/13-layers-and-parsed-layers.md:42:You can create a new parameter layer using the `NewParameterLayer` function:`
- L1320: `pkg/doc/topics/13-layers-and-parsed-layers.md:45:layer, err := NewParameterLayer("config", "Configuration",`
- L1321: `pkg/doc/topics/13-layers-and-parsed-layers.md:48:    WithParameterDefinitions(`
- L1322: `pkg/doc/topics/13-layers-and-parsed-layers.md:58:### Adding Parameters to a Layer`
- L1323: `pkg/doc/topics/13-layers-and-parsed-layers.md:60:You can add parameters to an existing layer using the `AddFlags` method:`
- L1324: `pkg/doc/topics/13-layers-and-parsed-layers.md:63:layer.AddFlags(`
- L1325: `pkg/doc/topics/13-layers-and-parsed-layers.md:69:### Initializing Parameter Defaults from a Struct`
- L1326: `pkg/doc/topics/13-layers-and-parsed-layers.md:71:You can initialize the default values of parameters in a layer using a struct:`
- L1327: `pkg/doc/topics/13-layers-and-parsed-layers.md:88:err := layer.InitializeParameterDefaultsFromStruct(&defaultConfig)`
- L1328: `pkg/doc/topics/13-layers-and-parsed-layers.md:94:### Initializing Parameter Defaults from a Map`
- L1329: `pkg/doc/topics/13-layers-and-parsed-layers.md:106:err := layer.InitializeParameterDefaultsFromParameters(defaultValues)`
- L1330: `pkg/doc/topics/13-layers-and-parsed-layers.md:112:### Initializing a Struct from Parameter Defaults`
- L1331: `pkg/doc/topics/13-layers-and-parsed-layers.md:114:You can also populate a struct with the default values from the parameter layer:`
- L1332: `pkg/doc/topics/13-layers-and-parsed-layers.md:118:err := layer.InitializeStructFromParameterDefaults(&config)`
- L1333: `pkg/doc/topics/13-layers-and-parsed-layers.md:124:### Loading a Parameter Layer from YAML`
- L1334: `pkg/doc/topics/13-layers-and-parsed-layers.md:126:You can create a parameter layer from a YAML definition:`
- L1335: `pkg/doc/topics/13-layers-and-parsed-layers.md:142:layer, err := NewParameterLayerFromYAML(yamlContent)`
- L1336: `pkg/doc/topics/13-layers-and-parsed-layers.md:148:### Cloning a Parameter Layer`
- L1337: `pkg/doc/topics/13-layers-and-parsed-layers.md:150:To create a deep copy of a parameter layer:`
- L1338: `pkg/doc/topics/13-layers-and-parsed-layers.md:153:clonedLayer := layer.Clone()`
- L1339: `pkg/doc/topics/13-layers-and-parsed-layers.md:156:### Creating ParameterLayers`
- L1340: `pkg/doc/topics/13-layers-and-parsed-layers.md:159:layers := NewParameterLayers(`
- L1341: `pkg/doc/topics/13-layers-and-parsed-layers.md:160:    WithLayers(configLayer, outputLayer),`
- L1342: `pkg/doc/topics/13-layers-and-parsed-layers.md:164:### Registering Layers Under Explicit Slugs on Commands`
- L1343: `pkg/doc/topics/13-layers-and-parsed-layers.md:166:When creating a `cmds.CommandDescription`, you can register layers under explicit slugs using `cmds.WithLayersMap`.`
- L1344: `pkg/doc/topics/13-layers-and-parsed-layers.md:169:// Create layers with internal slugs`
- L1345: `pkg/doc/topics/13-layers-and-parsed-layers.md:170:cfgLayer, _ := schema.NewSection("config", "Configuration")`
- L1346: `pkg/doc/topics/13-layers-and-parsed-layers.md:171:outLayer, _ := schema.NewSection("output", "Output")`
- L1347: `pkg/doc/topics/13-layers-and-parsed-layers.md:176:    cmds.WithLayersMap(map[string]schema.Section{`
- L1348: `pkg/doc/topics/13-layers-and-parsed-layers.md:177:        "cfg": cfgLayer,   // registered as "cfg"`
- L1349: `pkg/doc/topics/13-layers-and-parsed-layers.md:178:        "out": outLayer,   // registered as "out"`
- L1350: `pkg/doc/topics/13-layers-and-parsed-layers.md:182:// Later, parsed layers will be accessed by these slugs`
- L1351: `pkg/doc/topics/13-layers-and-parsed-layers.md:183:// parsedLayers.InitializeStruct("cfg", &myCfg)`
- L1352: `pkg/doc/topics/13-layers-and-parsed-layers.md:186:Note: If the layer is a `*schema.SectionImpl` and the key differs from the layer's internal slug, the layer is cloned and aligned to the registration key to maintain consistency at runtime.`
- L1353: `pkg/doc/topics/13-layers-and-parsed-layers.md:188:### Accessing Layer Information`
- L1354: `pkg/doc/topics/13-layers-and-parsed-layers.md:191:name := layer.GetName()`
- L1355: `pkg/doc/topics/13-layers-and-parsed-layers.md:192:slug := layer.GetSlug()`
- L1356: `pkg/doc/topics/13-layers-and-parsed-layers.md:193:description := layer.GetDescription()`
- L1357: `pkg/doc/topics/13-layers-and-parsed-layers.md:198:Iterate over all parameter layers:`
- L1358: `pkg/doc/topics/13-layers-and-parsed-layers.md:201:parameterLayers.ForEach(func(key string, p ParameterLayer) {`
- L1359: `pkg/doc/topics/13-layers-and-parsed-layers.md:202:    // Process each layer`
- L1360: `pkg/doc/topics/13-layers-and-parsed-layers.md:205:err := parameterLayers.ForEachE(func(key string, p ParameterLayer) error {`
- L1361: `pkg/doc/topics/13-layers-and-parsed-layers.md:206:    // Process each layer, return error to stop iteration`
- L1362: `pkg/doc/topics/13-layers-and-parsed-layers.md:213:Create a new ParameterLayers containing only the specified layers:`
- L1363: `pkg/doc/topics/13-layers-and-parsed-layers.md:216:subset := parameterLayers.Subset("config", "output")`
- L1364: `pkg/doc/topics/13-layers-and-parsed-layers.md:219:### AppendLayers and PrependLayers`
- L1365: `pkg/doc/topics/13-layers-and-parsed-layers.md:221:Add layers to the end or beginning of the collection:`
- L1366: `pkg/doc/topics/13-layers-and-parsed-layers.md:224:parameterLayers.AppendLayers(newLayer1, newLayer2)`
- L1367: `pkg/doc/topics/13-layers-and-parsed-layers.md:225:parameterLayers.PrependLayers(newLayer3, newLayer4)`
- L1368: `pkg/doc/topics/13-layers-and-parsed-layers.md:230:Merge two ParameterLayers collections:`
- L1369: `pkg/doc/topics/13-layers-and-parsed-layers.md:233:mergedLayers := parameterLayers.Merge(otherParameterLayers)`
- L1370: `pkg/doc/topics/13-layers-and-parsed-layers.md:238:Create a deep copy of ParameterLayers:`
- L1371: `pkg/doc/topics/13-layers-and-parsed-layers.md:241:clonedParameterLayers := parameterLayers.Clone()`
- L1372: `pkg/doc/topics/13-layers-and-parsed-layers.md:244:### GetAllParameterDefinitions`
- L1373: `pkg/doc/topics/13-layers-and-parsed-layers.md:246:Get all parameter definitions across all layers:`
- L1374: `pkg/doc/topics/13-layers-and-parsed-layers.md:249:allDefinitions := parameterLayers.GetAllParameterDefinitions()`
- L1375: `pkg/doc/topics/13-layers-and-parsed-layers.md:252:## Parsed Layers`
- L1376: `pkg/doc/topics/13-layers-and-parsed-layers.md:254:A ParsedLayer is the result of parsing input data (such as command-line`
- L1377: `pkg/doc/topics/13-layers-and-parsed-layers.md:255:arguments, configuration files, or environment variables) using a ParameterLayer`
- L1378: `pkg/doc/topics/13-layers-and-parsed-layers.md:258:1. **Layer**: A reference to the original ParameterLayer used for parsing.`
- L1379: `pkg/doc/topics/13-layers-and-parsed-layers.md:259:2. **Parameters**: A collection of ParsedParameter objects, each containing:`
- L1380: `pkg/doc/topics/13-layers-and-parsed-layers.md:260:    - The original ParameterDefinition`
- L1381: `pkg/doc/topics/13-layers-and-parsed-layers.md:264:ParsedLayers is a collection of ParsedLayer objects, typically representing all the layers used in a command or application.`
- L1382: `pkg/doc/topics/13-layers-and-parsed-layers.md:266:### Usage of ParsedLayers`
- L1383: `pkg/doc/topics/13-layers-and-parsed-layers.md:268:ParsedLayers are primarily used to:`
- L1384: `pkg/doc/topics/13-layers-and-parsed-layers.md:270:1. Store and organize parsed parameter values`
- L1385: `pkg/doc/topics/13-layers-and-parsed-layers.md:271:2. Access parsed values across different layers`
- L1386: `pkg/doc/topics/13-layers-and-parsed-layers.md:274:5. Provide a unified interface for accessing all parsed parameters in an application`
- L1387: `pkg/doc/topics/13-layers-and-parsed-layers.md:277:### Creating a ParsedLayer`
- L1388: `pkg/doc/topics/13-layers-and-parsed-layers.md:280:parsedLayer, err := NewParsedLayer(layer,`
- L1389: `pkg/doc/topics/13-layers-and-parsed-layers.md:281:    WithParsedParameterValue("verbose", true),`
- L1390: `pkg/doc/topics/13-layers-and-parsed-layers.md:288:### Creating ParsedLayers`
- L1391: `pkg/doc/topics/13-layers-and-parsed-layers.md:291:parsedLayers := NewParsedLayers(`
- L1392: `pkg/doc/topics/13-layers-and-parsed-layers.md:292:    WithParsedLayer("config", parsedConfigLayer),`
- L1393: `pkg/doc/topics/13-layers-and-parsed-layers.md:293:    WithParsedLayer("output", parsedOutputLayer),`
- L1394: `pkg/doc/topics/13-layers-and-parsed-layers.md:300:value, ok := parsedLayer.GetParameter("verbose")`
- L1395: `pkg/doc/topics/13-layers-and-parsed-layers.md:302:    // Parameter not found`
- L1396: `pkg/doc/topics/13-layers-and-parsed-layers.md:306:### Initializing Structs from ParsedLayers`
- L1397: `pkg/doc/topics/13-layers-and-parsed-layers.md:315:err := parsedLayers.InitializeStruct("config", &config)`
- L1398: `pkg/doc/topics/13-layers-and-parsed-layers.md:321:### Merging ParsedLayers`
- L1399: `pkg/doc/topics/13-layers-and-parsed-layers.md:324:parsedLayers.GetDefaultParameterLayer().MergeParameters(otherParsedLayer)`
- L1400: `pkg/doc/topics/13-layers-and-parsed-layers.md:327:### Getting All Parsed Parameters`
- L1401: `pkg/doc/topics/13-layers-and-parsed-layers.md:330:allParams := parsedLayers.GetAllParsedParameters()`
- L1402: `pkg/doc/topics/13-layers-and-parsed-layers.md:336:Iterate over all parsed layers:`
- L1403: `pkg/doc/topics/13-layers-and-parsed-layers.md:339:parsedLayers.ForEach(func(k string, v *ParsedLayer) {`
- L1404: `pkg/doc/topics/13-layers-and-parsed-layers.md:340:    // Process each layer`
- L1405: `pkg/doc/topics/13-layers-and-parsed-layers.md:343:err := parsedLayers.ForEachE(func(k string, v *ParsedLayer) error {`
- L1406: `pkg/doc/topics/13-layers-and-parsed-layers.md:344:    // Process each layer, return error to stop iteration`
- L1407: `pkg/doc/topics/13-layers-and-parsed-layers.md:351:Get a map of all parameter values across all layers:`
- L1408: `pkg/doc/topics/13-layers-and-parsed-layers.md:354:dataMap := parsedLayers.GetDataMap()`
- L1409: `pkg/doc/topics/13-layers-and-parsed-layers.md:359:Get an existing ParsedLayer or create a new one if it doesn't exist:`
- L1410: `pkg/doc/topics/13-layers-and-parsed-layers.md:362:parsedLayer := parsedLayers.GetOrCreate(someParameterLayer)`
- L1411: `pkg/doc/topics/13-layers-and-parsed-layers.md:367:Create a deep copy of ParsedLayers:`
- L1412: `pkg/doc/topics/13-layers-and-parsed-layers.md:370:clonedParsedLayers := parsedLayers.Clone()`
- L1413: `pkg/doc/topics/13-layers-and-parsed-layers.md:376:Middlewares in the Glazed framework provide a powerful mechanism to manage parameter values from various sources such as environment variables, configuration files, and command-line arguments. They allow for flexible and modular parameter handling in your applications.`
- L1414: `pkg/doc/topics/13-layers-and-parsed-layers.md:380:- **Middleware Structure**: Each middleware processes parameters before and/or after calling the next handler in the chain. They work with `ParameterLayers` and `ParsedLayers` to manage parameter definitions and values.`
- L1415: `pkg/doc/topics/13-layers-and-parsed-layers.md:386:1. **SetFromDefaults**: Populates parameters with their default values if no value exists.`
- L1416: `pkg/doc/topics/13-layers-and-parsed-layers.md:400:3. **LoadParametersFromFile / LoadParametersFromFiles**: Load parameters from JSON or YAML files.`
- L1417: `pkg/doc/topics/13-layers-and-parsed-layers.md:411:4. **ParseFromCobraCommand**: Parses parameter values from a Cobra command, typically used for CLI applications.`
- L1418: `pkg/doc/topics/13-layers-and-parsed-layers.md:420:To use middlewares, chain them together and execute them with your parameter layers and parsed layers:`
- L1419: `pkg/doc/topics/13-layers-and-parsed-layers.md:424:sources.Execute(layers, parsedLayers,`
- L1420: `pkg/doc/topics/13-layers-and-parsed-layers.md:435:- **Layer Filtering**: Apply middlewares to specific layers using whitelisting or blacklisting.`
- L1421: `pkg/doc/topics/13-layers-and-parsed-layers.md:436:- **Source Tracking**: Use `WithParseStepSource` to track where parameter values originate.`
- L1422: `pkg/help/cmd/cobra.go:150:	// if we are showing the short help and shortHelpLayers annotation was set,`
- L1423: `pkg/help/cmd/cobra.go:153:		shortHelpLayers_, ok := c.Annotations["shortHelpLayers"]`
- L1424: `pkg/help/cmd/cobra.go:155:			shortHelpLayers := map[string]interface{}{}`
- L1425: `pkg/help/cmd/cobra.go:156:			for _, v := range strings.Split(shortHelpLayers_, ",") {`
- L1426: `pkg/help/cmd/cobra.go:157:				shortHelpLayers[v] = true`
- L1427: `pkg/help/cmd/cobra.go:163:				if _, ok = shortHelpLayers[f.Slug]; ok {`
- L1428: `pkg/help/cmd/cobra.go:168:				if _, ok = shortHelpLayers[f.Slug]; ok {`
- L1429: `pkg/doc/tutorials/04-lua.md:70:2. Creates a global table containing parameter information (`animal_list_params`)`
- L1430: `pkg/doc/tutorials/04-lua.md:75:- Set up parameters for the command`
- L1431: `pkg/doc/tutorials/04-lua.md:78:- Display parameter information`
- L1432: `pkg/doc/tutorials/04-lua.md:98:-- Print parameter information`
- L1433: `pkg/doc/tutorials/04-lua.md:99:print("\nParameters for animal_list command:")`
- L1434: `pkg/doc/tutorials/04-lua.md:100:for layer_name, layer_params in pairs(animal_list_params) do`
- L1435: `pkg/doc/tutorials/04-lua.md:101:    print("Layer: " .. layer_name)`
- L1436: `pkg/doc/tutorials/04-lua.md:102:    for param_name, param_info in pairs(layer_params) do`
- L1437: `pkg/doc/tutorials/04-lua.md:127:For more complex commands, you might need to work with nested parameter structures. Here's how to use nested tables:`
- L1438: `pkg/doc/tutorials/04-lua.md:154:err := sources.Execute(cmd.Description().Layers, `
- L1439: `pkg/doc/tutorials/04-lua.md:155:    parsedLayers, `
- L1440: `pkg/doc/tutorials/04-lua.md:166:- Work with parameters and nested tables`
- L1441: `pkg/doc/topics/16-parsing-parameters.md:2:Title: Parsing Parameters`
- L1442: `pkg/doc/topics/16-parsing-parameters.md:3:Slug: parsing-parameters`
- L1443: `pkg/doc/topics/16-parsing-parameters.md:4:Short: Learn how to define and parse parameters in Go applications using the Parameter API.`
- L1444: `pkg/doc/topics/16-parsing-parameters.md:6:  - Parameter API`
- L1445: `pkg/doc/topics/16-parsing-parameters.md:17:The **Parameter API** facilitates parsing and managing parameters in Go applications. It's ideal for applications requiring flexible parameter handling.`
- L1446: `pkg/doc/topics/16-parsing-parameters.md:21:### ParameterDefinition`
- L1447: `pkg/doc/topics/16-parsing-parameters.md:23:A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status.`
- L1448: `pkg/doc/topics/16-parsing-parameters.md:26:type ParameterDefinition struct {`
- L1449: `pkg/doc/topics/16-parsing-parameters.md:29:    Type       ParameterType `yaml:"type"``
- L1450: `pkg/doc/topics/16-parsing-parameters.md:38:### ParameterDefinitions`
- L1451: `pkg/doc/topics/16-parsing-parameters.md:40:`ParameterDefinitions` is an ordered map of `ParameterDefinition` instances, indexed by name.`
- L1452: `pkg/doc/topics/16-parsing-parameters.md:43:type ParameterDefinitions struct {`
- L1453: `pkg/doc/topics/16-parsing-parameters.md:44:    *orderedmap.OrderedMap[string, *ParameterDefinition]`
- L1454: `pkg/doc/topics/16-parsing-parameters.md:48:### ParsedParameter`
- L1455: `pkg/doc/topics/16-parsing-parameters.md:50:A `ParsedParameter` contains the parsed value, its `ParameterDefinition`, and a log of parsing steps.`
- L1456: `pkg/doc/topics/16-parsing-parameters.md:53:type ParsedParameter struct {`
- L1457: `pkg/doc/topics/16-parsing-parameters.md:55:    ParameterDefinition *ParameterDefinition`
- L1458: `pkg/doc/topics/16-parsing-parameters.md:60:### ParsedParameters`
- L1459: `pkg/doc/topics/16-parsing-parameters.md:62:`ParsedParameters` is an ordered map of `ParsedParameter` instances, indexed by parameter names.`
- L1460: `pkg/doc/topics/16-parsing-parameters.md:65:type ParsedParameters struct {`
- L1461: `pkg/doc/topics/16-parsing-parameters.md:66:    *orderedmap.OrderedMap[string, *ParsedParameter]`
- L1462: `pkg/doc/topics/16-parsing-parameters.md:84:Follow these steps to use the Parameter API: define parameters and parse them from user input or configuration files.`
- L1463: `pkg/doc/topics/16-parsing-parameters.md:86:### Defining Parameters`
- L1464: `pkg/doc/topics/16-parsing-parameters.md:88:Define parameters using `ParameterDefinition`, specifying name, type, and options like default values or choices.`
- L1465: `pkg/doc/topics/16-parsing-parameters.md:91:import "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1466: `pkg/doc/topics/16-parsing-parameters.md:93:// Define a string parameter with a default value`
- L1467: `pkg/doc/topics/16-parsing-parameters.md:103:### Parsing Parameters`
- L1468: `pkg/doc/topics/16-parsing-parameters.md:105:Parse input values (e.g., from command-line arguments) to obtain `ParsedParameter` instances.`
- L1469: `pkg/doc/topics/16-parsing-parameters.md:111:parsedParam, err := paramName.ParseParameter(inputs)`
- L1470: `pkg/doc/topics/16-parsing-parameters.md:121:Access parsed parameter values via `ParsedParameters`.`
- L1471: `pkg/doc/topics/16-parsing-parameters.md:124:// Create a collection of parameter definitions`
- L1472: `pkg/doc/topics/16-parsing-parameters.md:126:    parameters.WithParameterDefinitionList([]*fields.Definition{paramName}),`
- L1473: `pkg/doc/topics/16-parsing-parameters.md:129:// Parse a parameter value`
- L1474: `pkg/doc/topics/16-parsing-parameters.md:130:parsedParams, err := paramDefs.ParseParameters(userInputs)`
- L1475: `pkg/doc/topics/16-parsing-parameters.md:140:## Managing Parsed Parameters`
- L1476: `pkg/doc/topics/16-parsing-parameters.md:142:Manage parsed parameters using these methods: updating values, merging parameter sets, and cloning parsed data.`
- L1477: `pkg/doc/topics/16-parsing-parameters.md:146:Update a parsed parameter's value, optionally appending a new parsing step.`
- L1478: `pkg/doc/topics/16-parsing-parameters.md:152:### Merging Parameters`
- L1479: `pkg/doc/topics/16-parsing-parameters.md:154:Merge another `ParsedParameters` instance, combining values and logs.`
- L1480: `pkg/doc/topics/16-parsing-parameters.md:160:### Cloning Parameters`
- L1481: `pkg/doc/topics/16-parsing-parameters.md:162:Create a deep copy of `ParsedParameters` to avoid unintended mutations.`
- L1482: `pkg/doc/topics/16-parsing-parameters.md:168:## Handling Defaults and Required Parameters`
- L1483: `pkg/doc/topics/16-parsing-parameters.md:170:Specify default values and enforce required parameters.`
- L1484: `pkg/doc/topics/16-parsing-parameters.md:173:// Define a required integer parameter without a default`
- L1485: `pkg/doc/topics/16-parsing-parameters.md:182:During parsing, an error is returned if a required parameter is missing. If an optional parameter is missing, its default value is used.`
- L1486: `pkg/doc/topics/16-parsing-parameters.md:185:parsedParam, err := ageParam.ParseParameter([]string{})`
- L1487: `pkg/doc/topics/16-parsing-parameters.md:197:Each `ParsedParameter` logs parsing steps, showing how the final value was derived.`
- L1488: `pkg/doc/topics/16-parsing-parameters.md:207:Define parameters to accept values from files (e.g., JSON, YAML, CSV).`
- L1489: `pkg/doc/topics/16-parsing-parameters.md:210:// Define a parameter that expects a JSON file`
- L1490: `pkg/doc/topics/16-parsing-parameters.md:218:// Parse the parameter from file input`
- L1491: `pkg/doc/topics/16-parsing-parameters.md:219:parsedFileParam, err := fileParam.ParseParameter([]string{"config.json"})`
- L1492: `pkg/cmds/fields/parameters.go:16:// Definition is a declarative way of describing a command line parameter.`
- L1493: `pkg/cmds/fields/parameters.go:71:	parameterType Type,`
- L1494: `pkg/cmds/fields/parameters.go:76:		Type: parameterType,`
- L1495: `pkg/cmds/fields/parameters.go:87:	return fmt.Sprintf("{Parameter: %s - %s}", p.Name, p.Type)`
- L1496: `pkg/cmds/fields/parameters.go:124:		return errors.Errorf("invalid value for parameter %s: %v", p.Name, value.Interface())`
- L1497: `pkg/cmds/fields/parameters.go:151:// InitializeValueToEmptyValue initializes the given value to the empty value of the type of the parameter.`
- L1498: `pkg/cmds/fields/parameters.go:182:		return errors.Errorf("unknown parameter type %s", p.Type)`
- L1499: `pkg/cmds/fields/parameters.go:189:// various supported parameter types.`
- L1500: `pkg/cmds/fields/parameters.go:200:			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, v)`
- L1501: `pkg/cmds/fields/parameters.go:207:			return errors.Errorf("expected bool value for parameter %s, got %T", p.Name, v)`
- L1502: `pkg/cmds/fields/parameters.go:220:			return errors.Errorf("expected string list for parameter %s, got %T", p.Name, v)`
- L1503: `pkg/cmds/fields/parameters.go:227:			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, v)`
- L1504: `pkg/cmds/fields/parameters.go:231:			return errors.Wrapf(err, "error parsing value for parameter %s", p.Name)`
- L1505: `pkg/cmds/fields/parameters.go:244:			return errors.Errorf("expected list of files for parameter %s, got %T", p.Name, v)`
- L1506: `pkg/cmds/fields/parameters.go:251:			return errors.Errorf("expected list of maps for parameter %s, got %T", p.Name, v)`
- L1507: `pkg/cmds/fields/parameters.go:258:			return errors.Errorf("expected map for parameter %s, got %T", p.Name, v)`
- L1508: `pkg/cmds/fields/parameters.go:265:			return errors.Errorf("expected map for parameter %s, got %T", p.Name, v)`
- L1509: `pkg/cmds/fields/parameters.go:269:			return errors.Errorf("expected map of strings for parameter %s, got %T", p.Name, v)`
- L1510: `pkg/cmds/fields/parameters.go:274:		return errors.Errorf("unknown parameter type %s", p.Type)`
- L1511: `pkg/cmds/fields/parameters.go:279:// ParsedParametersFromDefaults uses the parameter definitions default values to create a ParsedParameters`
- L1512: `pkg/cmds/fields/parameters.go:281:func (pds *Definitions) ParsedParametersFromDefaults() (*ParsedParameters, error) {`
- L1513: `pkg/cmds/fields/parameters.go:282:	ret := NewParsedParameters()`
- L1514: `pkg/cmds/fields/parameters.go:302:// InitializeStructFromDefaults initializes a struct from a map of parameter definitions.`
- L1515: `pkg/cmds/fields/parameters.go:308:	parsedParameters, err := pds.ParsedParametersFromDefaults()`
- L1516: `pkg/cmds/fields/parameters.go:312:	return parsedParameters.InitializeStruct(s)`
- L1517: `pkg/cmds/fields/parameters.go:315:// InitializeDefaultsFromStruct initializes the parameters definitions from a struct.`
- L1518: `pkg/cmds/fields/parameters.go:317:// the default value of the corresponding definition in `parameterDefinitions`.`
- L1519: `pkg/cmds/fields/parameters.go:355:						return errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)`
- L1520: `pkg/cmds/fields/parameters.go:358:						return errors.Errorf("wildcard parameters require a map of strings, field %s is not a map of strings", field.Name)`
- L1521: `pkg/cmds/fields/parameters.go:378:		parameter, ok := pds.Get(tagOptions.Name)`
- L1522: `pkg/cmds/fields/parameters.go:380:			return errors.Errorf("unknown parameter %s when initializing defaults from struct", tag)`
- L1523: `pkg/cmds/fields/parameters.go:384:		err = parameter.SetDefaultFromValue(value)`
- L1524: `pkg/cmds/fields/parameters.go:397:		parameter, ok := pds.Get(k)`
- L1525: `pkg/cmds/fields/parameters.go:399:			return errors.Errorf("unknown parameter when initializing defaults from map: %s", k)`
- L1526: `pkg/cmds/fields/parameters.go:401:		err := parameter.SetDefaultFromValue(reflect.ValueOf(v))`
- L1527: `pkg/cmds/fields/parameters.go:410:// CheckParameterDefaultValueValidity checks if the Definition's Default is valid.`
- L1528: `pkg/cmds/fields/parameters.go:412:func (p *Definition) CheckParameterDefaultValueValidity() (interface{}, error) {`
- L1529: `pkg/cmds/fields/parameters.go:421:		return nil, errors.Wrapf(err, "invalid default value for parameter %s", p.Name)`
- L1530: `pkg/cmds/fields/parameters.go:444:			return nil, errors.Errorf("Value for parameter %s is not a string: %v", p.Name, v)`
- L1531: `pkg/cmds/fields/parameters.go:453:			return nil, errors.Errorf("Value for parameter %s (type %T) is not a list of objects: %v", p.Name, v, v)`
- L1532: `pkg/cmds/fields/parameters.go:460:			return nil, errors.Errorf("Value for parameter %s is not an object: %v", p.Name, v)`
- L1533: `pkg/cmds/fields/parameters.go:467:			return nil, errors.Errorf("Value for parameter %s is not an integer: %v", p.Name, v)`
- L1534: `pkg/cmds/fields/parameters.go:474:			return nil, errors.Errorf("Value for parameter %s is not a float: %v", p.Name, v)`
- L1535: `pkg/cmds/fields/parameters.go:481:			return nil, errors.Errorf("Value for parameter %s is not a bool: %v", p.Name, v)`
- L1536: `pkg/cmds/fields/parameters.go:490:				return nil, errors.Wrapf(err, "Value for parameter %s is not a valid date: %v", p.Name, v)`
- L1537: `pkg/cmds/fields/parameters.go:496:			return nil, errors.Errorf("Value for parameter %s is not a valid date: %v", p.Name, v)`
- L1538: `pkg/cmds/fields/parameters.go:502:			return nil, errors.Errorf("Value for parameter %s is not a file (got type %T): %v", p.Name, v, v)`
- L1539: `pkg/cmds/fields/parameters.go:509:			return nil, errors.Errorf("Value for parameter %s is not a file list: %v", p.Name, v)`
- L1540: `pkg/cmds/fields/parameters.go:522:				return nil, errors.Errorf("Value for parameter %s is not a string list: %v", p.Name, v)`
- L1541: `pkg/cmds/fields/parameters.go:528:				return nil, errors.Errorf("Value for parameter %s is not a string list: %v", p.Name, v)`
- L1542: `pkg/cmds/fields/parameters.go:537:			return nil, errors.Errorf("Default value for parameter %s is not an integer list: %v", p.Name, v)`
- L1543: `pkg/cmds/fields/parameters.go:544:			return nil, errors.Errorf("Value for parameter %s is not a float list: %v", p.Name, v)`
- L1544: `pkg/cmds/fields/parameters.go:550:			return nil, errors.Errorf("Definition %s is a choice parameter but has no choices", p.Name)`
- L1545: `pkg/cmds/fields/parameters.go:555:			return nil, errors.Errorf("Value for parameter %s is not a string: %v", p.Name, v)`
- L1546: `pkg/cmds/fields/parameters.go:566:			return nil, errors.Errorf("Definition %s is a choice parameter but has no choices", p.Name)`
- L1547: `pkg/cmds/fields/parameters.go:571:			return nil, errors.Errorf("Value for parameter %s is not a choice list: %v", p.Name, v)`
- L1548: `pkg/cmds/fields/parameters.go:590:			return nil, errors.Errorf("Value for parameter %s is not a key value map: %v", p.Name, v)`
- L1549: `pkg/cmds/fields/parameters.go:595:			return nil, errors.Errorf("Value for parameter %s is not a key value map: %v", p.Name, v)`
- L1550: `pkg/cmds/fields/parameters.go:600:		return nil, errors.Errorf("unknown parameter type %s", p.Type)`
- L1551: `pkg/cmds/fields/parameters.go:610:	return errors.Errorf("Value %s is not a valid choice for parameter %s. Valid choices are: %v", choice, p.Name, p.Choices)`
- L1552: `pkg/cmds/fields/parameters.go:617:	parameters_ := NewDefinitions()`
- L1553: `pkg/cmds/fields/parameters.go:620:	var parameters []*Definition`
- L1554: `pkg/cmds/fields/parameters.go:622:	err = yaml.Unmarshal(yamlContent, &parameters)`
- L1555: `pkg/cmds/fields/parameters.go:627:	for _, p := range parameters {`
- L1556: `pkg/cmds/fields/parameters.go:628:		_, err := p.CheckParameterDefaultValueValidity()`
- L1557: `pkg/cmds/fields/parameters.go:630:			panic(errors.Wrap(err, "Failed to check parameter default value validity"))`
- L1558: `pkg/cmds/fields/parameters.go:632:		parameters_.Set(p.Name, p)`
- L1559: `pkg/cmds/fields/parameters.go:635:	return parameters_`
- L1560: `pkg/cmds/fields/parameters.go:645:func WithDefinitions(parameterDefinitions *Definitions) DefinitionsOption {`
- L1561: `pkg/cmds/fields/parameters.go:647:		p.Merge(parameterDefinitions)`
- L1562: `pkg/cmds/fields/parameters.go:651:func WithDefinitionList(parameterDefinitions []*Definition) DefinitionsOption {`
- L1563: `pkg/cmds/fields/parameters.go:653:		for _, pd := range parameterDefinitions {`
- L1564: `pkg/cmds/fields/parameters.go:672:// The parameter definitions are cloned as well.`
- L1565: `pkg/cmds/fields/parameters.go:677:// Merge merges the parameter definitions from m into p.`
- L1566: `pkg/cmds/fields/parameters.go:678:// It clones each parameter definition before adding it to p`
- L1567: `pkg/cmds/fields/parameters.go:688:// fields. The parameter definitions are not cloned.`
- L1568: `pkg/cmds/fields/parameters.go:718:// fields. The parameter definitions are not cloned.`
- L1569: `pkg/cmds/fields/parameters.go:731:// ForEachE calls the given function f on each parameter definition in p.`
- L1570: `pkg/cmds/fields/parameters.go:744:// ForEach calls the given function f on each parameter definition in p.`
- L1571: `pkg/cmds/fields/parameters.go:760:	var parameterDefinitions []*Definition`
- L1572: `pkg/cmds/fields/parameters.go:761:	err := value.Decode(&parameterDefinitions)`
- L1573: `pkg/cmds/fields/parameters.go:766:	for _, pd_ := range parameterDefinitions {`
- L1574: `pkg/cmds/fields/parameters.go:782:			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, value)`
- L1575: `pkg/cmds/fields/parameters.go:789:			return errors.Errorf("expected bool value for parameter %s, got %T", p.Name, value)`
- L1576: `pkg/cmds/fields/parameters.go:802:			return errors.Errorf("expected string list for parameter %s, got %T", p.Name, value)`
- L1577: `pkg/cmds/fields/parameters.go:809:			return errors.Errorf("expected time.Time value for parameter %s, got %T", p.Name, value)`
- L1578: `pkg/cmds/fields/parameters.go:822:			return errors.Errorf("expected list of files for parameter %s, got %T", p.Name, value)`
- L1579: `pkg/cmds/fields/parameters.go:829:			return errors.Errorf("expected list of maps for parameter %s, got %T", p.Name, value)`
- L1580: `pkg/cmds/fields/parameters.go:836:			return errors.Errorf("expected map for parameter %s, got %T", p.Name, value)`
- L1581: `pkg/cmds/fields/parameters.go:843:			return errors.Errorf("expected map of strings for parameter %s, got %T", p.Name, value)`
- L1582: `pkg/cmds/fields/parameters.go:848:		return errors.Errorf("unknown parameter type %s", p.Type)`
- L1583: `pkg/doc/topics/commands-reference.md:10:- layers`
- L1584: `pkg/doc/topics/commands-reference.md:22:The Glazed command system provides a structured approach to building CLI applications that handle multiple output formats, complex parameter validation, and reusable components. This reference covers the complete command system architecture, interfaces, and implementation patterns.`
- L1585: `pkg/doc/topics/commands-reference.md:24:Building CLI tools typically involves handling parameter parsing, validation, output formatting, and configuration management. Glazed addresses these concerns through a layered architecture that separates command logic from presentation and parameter management.`
- L1586: `pkg/doc/topics/commands-reference.md:26:The core principle is separation of concerns: commands focus on business logic while Glazed handles parameter parsing, validation, and output formatting. This approach enables automatic support for multiple output formats, consistent parameter handling across commands, and reusable parameter groups.`
- L1587: `pkg/doc/topics/commands-reference.md:41:‚îÇ  (name, flags, arguments, layers, etc.)     ‚îÇ`
- L1588: `pkg/doc/topics/commands-reference.md:46:‚îÇ               Parameter Layers               ‚îÇ`
- L1589: `pkg/doc/topics/commands-reference.md:56:‚îÇ  Parameters  ‚îÇ          ‚îÇ ParsedLayers    ‚îÇ`
- L1590: `pkg/doc/topics/commands-reference.md:84:2. **CommandDescription**: Contains metadata about a command (name, description, parameters, etc.)`
- L1591: `pkg/doc/topics/commands-reference.md:85:3. **Parameter Layers**: Organize parameters into logical groups (database, logging, output, etc.)`
- L1592: `pkg/doc/topics/commands-reference.md:86:4. **Parameters**: Define command inputs with type information, validation, and help text`
- L1593: `pkg/doc/topics/commands-reference.md:87:5. **ParsedLayers**: Runtime values after collecting from CLI flags, environment, config files, and defaults`
- L1594: `pkg/doc/topics/commands-reference.md:92:The Glazed framework is organized into distinct packages to separate concerns like command definition, parameter handling, and output processing. This modular design makes the system extensible and easier to maintain. Key packages handle command interfaces (`cmds`), parameter definitions (`parameters`), and integration with CLI libraries like Cobra (`cli`).`
- L1595: `pkg/doc/topics/commands-reference.md:95:- `github.com/go-go-golems/glazed/pkg/cmds/parameters`: Parameter types and definitions`
- L1596: `pkg/doc/topics/commands-reference.md:96:- `github.com/go-go-golems/glazed/pkg/cmds/layers`: Parameter layering system`
- L1597: `pkg/doc/topics/commands-reference.md:101:- `github.com/go-go-golems/glazed/pkg/settings`: Standard Glazed parameter layers`
- L1598: `pkg/doc/topics/commands-reference.md:123:    Run(ctx context.Context, parsedLayers *values.Values) error`
- L1599: `pkg/doc/topics/commands-reference.md:139:func (c *CleanupCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L1600: `pkg/doc/topics/commands-reference.md:141:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1601: `pkg/doc/topics/commands-reference.md:187:    RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error`
- L1602: `pkg/doc/topics/commands-reference.md:205:func (c *HealthReportCommand) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {`
- L1603: `pkg/doc/topics/commands-reference.md:207:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1604: `pkg/doc/topics/commands-reference.md:248:    RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error`
- L1605: `pkg/doc/topics/commands-reference.md:268:    parsedLayers *values.Values,`
- L1606: `pkg/doc/topics/commands-reference.md:272:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1607: `pkg/doc/topics/commands-reference.md:332:func (c *StatusCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L1608: `pkg/doc/topics/commands-reference.md:334:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1609: `pkg/doc/topics/commands-reference.md:348:    parsedLayers *values.Values, `
- L1610: `pkg/doc/topics/commands-reference.md:352:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1611: `pkg/doc/topics/commands-reference.md:372:A well-structured Glazed command separates its identity and logic. The recommended pattern involves a `Command` struct embedding a `CommandDescription` for metadata, a separate `Settings` struct for type-safe parameter access via `glazed` tags, and a `Run` method containing the business logic. This separation is bridged at runtime by `InitializeStruct`, which populates the `Settings` struct from parsed command-line values.`
- L1612: `pkg/doc/topics/commands-reference.md:380:**Settings Struct**: Provides type safety by defining a struct that mirrors command inputs. Glazed automatically maps parameters to struct fields through `glazed` tags.`
- L1613: `pkg/doc/topics/commands-reference.md:384:**Constructor Function**: Creates the command description with its parameters and layers.`
- L1614: `pkg/doc/topics/commands-reference.md:388:Settings structs provide type-safe access to parsed command parameters. Each field uses a `glazed` tag that must match the parameter name defined in the command description:`
- L1615: `pkg/doc/topics/commands-reference.md:393:    Count   int    `glazed:"count"`     // Maps to "count" parameter`
- L1616: `pkg/doc/topics/commands-reference.md:394:    Format  string `glazed:"format"`   // Maps to "format" parameter  `
- L1617: `pkg/doc/topics/commands-reference.md:395:    Verbose bool   `glazed:"verbose"`  // Maps to "verbose" parameter`
- L1618: `pkg/doc/topics/commands-reference.md:396:    DryRun  bool   `glazed:"dry-run"`  // Maps to "dry-run" parameter`
- L1619: `pkg/doc/topics/commands-reference.md:400:The `InitializeStruct` method populates the settings struct from parsed layers. Always specify the correct layer slug (use `schema.DefaultSlug` for command-specific parameters):`
- L1620: `pkg/doc/topics/commands-reference.md:405:    parsedLayers *values.Values,`
- L1621: `pkg/doc/topics/commands-reference.md:411:    // Extract values from the "default" layer into the struct`
- L1622: `pkg/doc/topics/commands-reference.md:412:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1623: `pkg/doc/topics/commands-reference.md:440:### Working with Multiple Layers`
- L1624: `pkg/doc/topics/commands-reference.md:442:Commands often use multiple parameter layers. Extract settings from each layer separately:`
- L1625: `pkg/doc/topics/commands-reference.md:458:    parsedLayers *values.Values,`
- L1626: `pkg/doc/topics/commands-reference.md:463:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, cmdSettings); err != nil {`
- L1627: `pkg/doc/topics/commands-reference.md:467:    // Extract database layer settings`
- L1628: `pkg/doc/topics/commands-reference.md:469:    if err := parsedLayers.InitializeStruct("database", dbSettings); err != nil {`
- L1629: `pkg/doc/topics/commands-reference.md:473:    // Extract logging layer settings`
- L1630: `pkg/doc/topics/commands-reference.md:475:    if err := parsedLayers.InitializeStruct("logging", logSettings); err != nil {`
- L1631: `pkg/doc/topics/commands-reference.md:492:func (c *ExampleCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L1632: `pkg/doc/topics/commands-reference.md:498:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, &s); err != nil {`
- L1633: `pkg/doc/topics/commands-reference.md:514:func (c *ExampleCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L1634: `pkg/doc/topics/commands-reference.md:516:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1635: `pkg/doc/topics/commands-reference.md:527:func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {`
- L1636: `pkg/doc/topics/commands-reference.md:529:    err := parsedLayers.InitializeStruct("database", settings)`
- L1637: `pkg/doc/topics/commands-reference.md:534:    dbSettings, err := GetDatabaseSettings(parsedLayers)`
- L1638: `pkg/doc/topics/commands-reference.md:545:While Glazed excels at building standard CLI tools, its architecture also supports more advanced use cases. Commands can be executed programmatically for testing or integration into other Go applications, and the parameter system can load values from multiple sources like environment variables and config files, not just CLI flags. These patterns allow you to build commands that are not just standalone tools, but reusable components in a larger software ecosystem.`
- L1639: `pkg/doc/topics/commands-reference.md:561:// Define parameter values`
- L1640: `pkg/doc/topics/commands-reference.md:563:    runner.WithValuesForLayers(map[string]map[string]interface{}{`
- L1641: `pkg/doc/topics/commands-reference.md:584:### Parameter Loading Sources`
- L1642: `pkg/doc/topics/commands-reference.md:586:Parameters can be loaded from multiple sources (in priority order):`
- L1643: `pkg/doc/topics/commands-reference.md:602:    runner.WithValuesForLayers(map[string]map[string]interface{}{`
- L1644: `pkg/doc/topics/commands-reference.md:656:    parsedLayers *values.Values,`
- L1645: `pkg/doc/topics/commands-reference.md:682:    parsedLayers *values.Values,`
- L1646: `pkg/doc/topics/commands-reference.md:686:    if err := parsedLayers.InitializeStruct(schema.DefaultSlug, s); err != nil {`
- L1647: `pkg/doc/topics/commands-reference.md:727:func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L1648: `pkg/doc/topics/commands-reference.md:782:## Parameters`
- L1649: `pkg/doc/topics/commands-reference.md:784:Glazed treats command-line parameters as more than just strings. They are typed objects with built-in validation, default values, and help text. This approach shifts the burden of parsing and validation from the command's business logic to the framework itself. By defining a parameter's type (e.g., `ParameterTypeInteger`, `ParameterTypeDate`, `ParameterTypeFile`), you get automatic error handling and a more robust and user-friendly CLI.`
- L1650: `pkg/doc/topics/commands-reference.md:786:Glazed parameters are typed objects with validation rules and behavior, unlike traditional CLI libraries that treat parameters as simple strings requiring manual parsing and validation. This enables automatic validation, help generation, and multi-source value loading.`
- L1651: `pkg/doc/topics/commands-reference.md:788:### Parameter Type System`
- L1652: `pkg/doc/topics/commands-reference.md:790:Parameter types define data structure, parsing behavior, and validation rules. Each type handles string parsing, validation, and help text generation.`
- L1653: `pkg/doc/topics/commands-reference.md:793:**`ParameterTypeString`**: The workhorse for text inputs - names, descriptions, URLs`
- L1654: `pkg/doc/topics/commands-reference.md:794:**`ParameterTypeSecret`**: Like strings, but values are masked in help and logs (perfect for passwords, API keys)`
- L1655: `pkg/doc/topics/commands-reference.md:795:**`ParameterTypeInteger`**: Whole numbers with automatic range validation`
- L1656: `pkg/doc/topics/commands-reference.md:796:**`ParameterTypeFloat`**: Decimal numbers for measurements, percentages, ratios`
- L1657: `pkg/doc/topics/commands-reference.md:797:**`ParameterTypeBool`**: True/false flags that work with `--flag` and `--no-flag` patterns`
- L1658: `pkg/doc/topics/commands-reference.md:798:**`ParameterTypeDate`**: Intelligent date parsing that handles multiple formats`
- L1659: `pkg/doc/topics/commands-reference.md:801:**`ParameterTypeStringList`**: Multiple values like `--tag web --tag api --tag production``
- L1660: `pkg/doc/topics/commands-reference.md:802:**`ParameterTypeIntegerList`**: Lists of numbers for ports, IDs, quantities`
- L1661: `pkg/doc/topics/commands-reference.md:803:**`ParameterTypeFloatList`**: Multiple decimal values for coordinates, measurements`
- L1662: `pkg/doc/topics/commands-reference.md:806:**`ParameterTypeChoice`**: Single selection from predefined options (with tab completion!)`
- L1663: `pkg/doc/topics/commands-reference.md:807:**`ParameterTypeChoiceList`**: Multiple selections from predefined options`
- L1664: `pkg/doc/topics/commands-reference.md:810:**`ParameterTypeFile`**: File paths with existence validation and tab completion`
- L1665: `pkg/doc/topics/commands-reference.md:811:**`ParameterTypeFileList`**: Multiple file paths`
- L1666: `pkg/doc/topics/commands-reference.md:812:**`ParameterTypeStringFromFile`**: Read text content from a file (useful for large inputs)`
- L1667: `pkg/doc/topics/commands-reference.md:813:**`ParameterTypeStringListFromFile`**: Read line-separated lists from files`
- L1668: `pkg/doc/topics/commands-reference.md:816:**`ParameterTypeKeyValue`**: Map-like inputs: `--env DATABASE_URL=postgres://... --env DEBUG=true``
- L1669: `pkg/doc/topics/commands-reference.md:818:### Parameter Definition Options`
- L1670: `pkg/doc/topics/commands-reference.md:822:    "parameter-name",                    // Required: parameter name`
- L1671: `pkg/doc/topics/commands-reference.md:823:    fields.TypeString,      // Required: parameter type`
- L1672: `pkg/doc/topics/commands-reference.md:835:    parameters.WithFileExtensions(".txt", ".md"),`
- L1673: `pkg/doc/topics/commands-reference.md:841:Arguments are positional parameters that don't use flags:`
- L1674: `pkg/doc/topics/commands-reference.md:942:// Avoid: Manual parameter extraction`
- L1675: `pkg/doc/topics/commands-reference.md:943:source, _ := parsedLayers.GetString("source")`
- L1676: `pkg/doc/topics/commands-reference.md:944:maxAge, _ := parsedLayers.GetString("max-age") // Bug waiting to happen!`
- L1677: `pkg/doc/topics/commands-reference.md:951:Write clear help text with examples for complex parameters:`
- L1678: `pkg/doc/topics/commands-reference.md:977:Validate parameters before expensive operations. Always check context cancellation in loops and long operations.`
- L1679: `pkg/doc/topics/commands-reference.md:1017:2. Study the layer guide to understand parameter organization:`
- L1680: `pkg/doc/topics/commands-reference.md:1019:   glaze help layers-guide`
- L1681: `cmd/glaze/cmds/html/cmds.go:55:	glazedLayer, err := settings.NewGlazedSchema()`
- L1682: `cmd/glaze/cmds/html/cmds.go:59:	cobraLayer, ok := glazedLayer.(schema.CobraSection)`
- L1683: `cmd/glaze/cmds/html/cmds.go:61:		return nil, fmt.Errorf("glazed layer is not a CobraSection")`
- L1684: `cmd/glaze/cmds/html/cmds.go:64:	err = cobraLayer.AddLayerToCobraCommand(parseCmd)`
- L1685: `cmd/glaze/cmds/html/cmds.go:119:	err = cobraLayer.AddLayerToCobraCommand(extractCmd)`
- L1686: `pkg/doc/topics/03-templates.md:230:- `toUrlParameter(v interface{}) string` - Convert value to URL parameter format`
- L1687: `pkg/cmds/fields/gather-parameters_test.go:14:	ParameterDefs []*Definition `yaml:"parameterDefs"``
- L1688: `pkg/cmds/fields/gather-parameters_test.go:15:	// The actual map fromwhich the parameters are gathered`
- L1689: `pkg/cmds/fields/gather-parameters_test.go:17:	// Only gather parameters that are provided in the map`
- L1690: `pkg/cmds/fields/gather-parameters_test.go:25:var gatherParametersYAML string`
- L1691: `pkg/cmds/fields/gather-parameters_test.go:27:func TestGatherParametersFromMap(t *testing.T) {`
- L1692: `pkg/cmds/fields/gather-parameters_test.go:28:	tests, err := yaml.LoadTestFromYAML[[]TestCase](gatherParametersYAML)`
- L1693: `pkg/cmds/fields/gather-parameters_test.go:33:			pds := NewDefinitions(WithDefinitionList(tt.ParameterDefs))`
- L1694: `pkg/cmds/fields/gather-parameters_test.go:35:			parsedParameters, err := pds.GatherParametersFromMap(tt.Data, tt.OnlyProvided)`
- L1695: `pkg/cmds/fields/gather-parameters_test.go:41:				require.Equal(t, tt.ExpectedResult, parsedParameters.ToMap())`
- L1696: `pkg/doc/topics/06-usage-string.md:19:In contrast to parameter flags, which are preceded by `--` for `-`, arguments are `
- L1697: `pkg/doc/topics/06-usage-string.md:32:- Parameters accepting list inputs should not directly follow each other.`
- L1698: `pkg/doc/topics/06-usage-string.md:34:### Required Parameters`
- L1699: `pkg/doc/topics/06-usage-string.md:45:### Optional Parameters`
- L1700: `pkg/doc/topics/06-usage-string.md:57:### List Parameters`
- L1701: `pkg/doc/topics/06-usage-string.md:69:Parameters may come with default values. These can be identified by text following the format `default: value`. This means that if you do not provide a value for this argument, the system will use the default value.`
- L1702: `cmd/glaze/cmds/json.go:38:	glazedLayer, err := settings.NewGlazedSchema()`
- L1703: `cmd/glaze/cmds/json.go:40:		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L1704: `cmd/glaze/cmds/json.go:79:			cmds.WithLayersList(`
- L1705: `cmd/glaze/cmds/json.go:80:				glazedLayer,`
- L1706: `cmd/glaze/cmds/json.go:90:		return errors.Wrap(err, "Failed to initialize json settings from parameters")`
- L1707: `pkg/doc/topics/how-to-write-good-documentation-pages.md:335:- **Options/Config:** When documenting flags, parameters, or settings`
- L1708: `pkg/doc/tutorials/01-a-simple-table-cli.md:20:- `ParameterDefinition`: This struct is used to define the parameters (flags or arguments) that the command takes. It`
- L1709: `pkg/doc/tutorials/01-a-simple-table-cli.md:21:  includes the name of the parameter, the type, and any default value.`
- L1710: `pkg/doc/tutorials/01-a-simple-table-cli.md:72:	parsedLayers map[string]*layers.ParsedParameterLayer,`
- L1711: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:21:The new system replaces Viper's automatic config discovery and merging with explicit file loading middlewares that record each parse step. This makes it clear where each parameter value originated and enables better debugging with `--print-parsed-parameters`.`
- L1712: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:27:1. **Config File Loading**: Replace `GatherFlagsFromViper()` and `GatherFlagsFromCustomViper()` with `LoadParametersFromFile()` or `LoadParametersFromFiles()``
- L1713: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:28:2. **Logging Initialization**: Move from `InitLoggerFromViper()` to `InitLoggerFromCobra()` or `SetupLoggingFromParsedLayers()``
- L1714: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:59:### 2. Config File Format Must Match Layer Structure`
- L1715: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:69:**After:** Config must match layer names and parameters:`
- L1716: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:71:# Layer names as top-level keys`
- L1717: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:82:- Group parameters under layer names`
- L1718: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:83:- Update parameter names to match definitions`
- L1719: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:87:mapper, _ := patternmapper.NewConfigMapper(layers,`
- L1720: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:90:        TargetLayer:     "demo",`
- L1721: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:91:        TargetParameter: "api-key",`
- L1722: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:101:    // Transform your config to layer format`
- L1723: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:121:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1724: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:141:### After: Using LoadParametersFromFile`
- L1725: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:146:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1726: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:171:For applications with a single config file, use `LoadParametersFromFile`:`
- L1727: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:181:The config file must match the default structure (layer names as top-level keys):`
- L1728: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:191:For applications that compose configuration from multiple files, use `LoadParametersFromFiles`:`
- L1729: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:243:### After: Using LoadParametersFromFiles`
- L1730: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:248:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1731: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:306:    // Add logging layer`
- L1732: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:307:    err := logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L1733: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:340:    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L1734: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:353:### Alternative: Initialize from Parsed Layers`
- L1735: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:355:If you're using Glazed's middleware system and want logging to respect config file values, initialize from parsed layers instead:`
- L1736: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:360:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1737: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:364:    // ... setup layers and parse ...`
- L1738: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:366:    err := sources.Execute(layers_, parsed,`
- L1739: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:375:    // Initialize logging from parsed layers (includes config file values)`
- L1740: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:376:    err = logging.SetupLoggingFromParsedLayers(parsed)`
- L1741: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:420:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1742: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:455:- `--config-file` flag is automatically available via `command-settings` layer`
- L1743: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:473:If your config files don't match the default layer structure, you have two options: pattern-based mapping (declarative) or custom mapper functions (programmatic).`
- L1744: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:485:mapper, err := pm.NewConfigMapper(layers_,`
- L1745: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:488:        TargetLayer:     "demo",`
- L1746: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:489:        TargetParameter: "api-key",`
- L1747: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:493:        TargetLayer:     "demo",`
- L1748: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:494:        TargetParameter: "{env}-api-key",`
- L1749: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:498:// Use with LoadParametersFromFile`
- L1750: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:521:    // Transform config structure to layer format`
- L1751: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:551:sources.Execute(layers_, parsed,`
- L1752: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:602:   logging.SetupLoggingFromParsedLayers(parsed)`
- L1753: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:658:Environment variable names follow the pattern: `{PREFIX}_{LAYER}_{PARAMETER}` (e.g., `APP_DEMO_API_KEY` for `demo.api-key`).`
- L1754: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:693:Use `--print-parsed-parameters` to see exactly where each parameter value came from:`
- L1755: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:696:myapp command --print-parsed-parameters`
- L1756: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:699:This shows the full parse history for each parameter, including which config file set each value.`
- L1757: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:703:Before applying config files, validate them against your layer definitions:`
- L1758: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:711:func validateConfigFile(layers_ *schema.Schema, path string) error {`
- L1759: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:722:    // Check each layer and parameter`
- L1760: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:723:    for layerSlug, v := range raw {`
- L1761: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:724:        layer, ok := layers_.Get(layerSlug)`
- L1762: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:726:            return fmt.Errorf("unknown layer: %s", layerSlug)`
- L1763: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:731:            return fmt.Errorf("layer %s must be an object", layerSlug)`
- L1764: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:734:        pds := layer.GetParameterDefinitions()`
- L1765: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:738:                return fmt.Errorf("unknown parameter %s.%s", layerSlug, key)`
- L1766: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:742:                return fmt.Errorf("invalid value for %s.%s: %v", layerSlug, key, err)`
- L1767: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:764:2. Variable names follow `{PREFIX}_{LAYER}_{PARAMETER}` format`
- L1768: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:771:2. Check config file order in `LoadParametersFromFiles` (low ‚Üí high)`
- L1769: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:772:3. Use `--print-parsed-parameters` to see actual precedence`
- L1770: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:776:If you have legacy config files that don't match the layer structure:`
- L1771: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:807:    err := logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L1772: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:853:    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "myapp")`
- L1773: `pkg/doc/tutorials/migrating-from-viper-to-config-files.md:889:2. **Use `--print-parsed-parameters`**: Confirm precedence is as expected`
- L1774: `pkg/cmds/fields/gather-arguments.go:13:// Only the last parameter definitions can be a list parameter type.`
- L1775: `pkg/cmds/fields/gather-arguments.go:28:) (*ParsedParameters, error) {`
- L1776: `pkg/cmds/fields/gather-arguments.go:30:	result := NewParsedParameters()`
- L1777: `pkg/cmds/fields/gather-arguments.go:38:		p := &ParsedParameter{`
- L1778: `pkg/cmds/fields/gather-arguments.go:70:		i2, err := argument.ParseParameter(v, parseOptions...)`
- L1779: `pkg/doc/topics/24-config-files.md:19:- Traceability: Each config file write is logged with `source: config` and `{ config_file, index }` metadata and can be inspected with `--print-parsed-parameters`.`
- L1780: `pkg/doc/topics/24-config-files.md:31:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1781: `pkg/doc/topics/24-config-files.md:33:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1782: `pkg/doc/topics/24-config-files.md:38:    // Define layers`
- L1783: `pkg/doc/topics/24-config-files.md:46:    pls := schema.NewSchema(layers.WithLayers(demo))`
- L1784: `pkg/doc/topics/24-config-files.md:63:If you‚Äôre building a CLI, the Cobra integration wires configuration, environment variables, positional arguments, and flags into a predictable pipeline with minimal boilerplate. `CobraParserConfig` lets you enable app-wide env prefixes, resolve config files, or inject your own resolver logic. This keeps your command code focused on business logic while Glazed handles the parsing pipeline and debug flags (like `--print-parsed-parameters`).`
- L1785: `pkg/doc/topics/24-config-files.md:73:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1786: `pkg/doc/topics/24-config-files.md:74:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1787: `pkg/doc/topics/24-config-files.md:85:    desc := cmds.NewCommandDescription("demo", cmds.WithLayersList(demo))`
- L1788: `pkg/doc/topics/24-config-files.md:104:Load a single YAML/JSON file when your application‚Äôs configuration is centralized. The file is parsed into your parameter layers, and each value update is recorded as a `config` parse step, making it clear where settings came from when debugging.`
- L1789: `pkg/doc/topics/24-config-files.md:110:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1790: `pkg/doc/topics/24-config-files.md:114:layers_ := schema.NewSchema(/* ... */)`
- L1791: `pkg/doc/topics/24-config-files.md:116:_ = sources.Execute(layers_, parsed,`
- L1792: `pkg/doc/topics/24-config-files.md:129:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1793: `pkg/doc/topics/24-config-files.md:134:_ = sources.Execute(layers_, parsed,`
- L1794: `pkg/doc/topics/24-config-files.md:141:Many CLIs have a conventional config location (XDG, home dotdir, or `/etc`). `ResolveAppConfigPath` encapsulates that search so your app can ‚Äújust find‚Äù a config without hardcoding paths. Pair it with a `--config-file` flag (already provided by the `command-settings` layer) so power users can override discovery. For overlays, a resolver can add optional files like `<base>.override.yaml` if they exist, keeping configuration flexible without hidden magic.`
- L1795: `pkg/doc/topics/24-config-files.md:171:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1796: `pkg/doc/topics/24-config-files.md:191:Glazed supports both ‚Äúdefault-shaped‚Äù configs (where the file mirrors your layers and parameters) and mappers (which translate arbitrary structures to parameter updates). Use the default structure for greenfield projects and simple cases‚Äîit‚Äôs the most transparent. Reach for mappers when you must consume legacy formats, have nested structures that don‚Äôt match your parameter layout, or need to derive multiple parameters from one subtree.`
- L1797: `pkg/doc/topics/24-config-files.md:193:Glazed supports two ways to map config file data into parameter layers:`
- L1798: `pkg/doc/topics/24-config-files.md:195:1) Default structure (no mapper): your config matches the layer/parameter shapes directly`
- L1799: `pkg/doc/topics/24-config-files.md:204:2) Mappers: use a mapper to transform arbitrary config shapes to layer/parameter assignments.`
- L1800: `pkg/doc/topics/24-config-files.md:208:Pattern mappers describe how to traverse a config tree and map matched values into parameters. Patterns support exact segments, wildcards, and named captures (for environment-like keys such as `{env}`). Validation happens both at construction time (syntax, capture references, static targets) and at runtime (required matches, ambiguity, collisions). Prefer named captures over wildcards when you expect multiple values to be collected.`
- L1801: `pkg/doc/topics/24-config-files.md:210:Use `github.com/go-go-golems/glazed/pkg/cmds/middlewares/patternmapper` to declare mapping rules and pass the mapper to `LoadParametersFromFile`.`
- L1802: `pkg/doc/topics/24-config-files.md:216:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1803: `pkg/doc/topics/24-config-files.md:219:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1804: `pkg/doc/topics/24-config-files.md:229:pls := schema.NewSchema(layers.WithLayers(demo))`
- L1805: `pkg/doc/topics/24-config-files.md:234:        TargetLayer: "demo",`
- L1806: `pkg/doc/topics/24-config-files.md:236:            {Source: "api_key", TargetParameter: "{env}-api-key"},`
- L1807: `pkg/doc/topics/24-config-files.md:248:Use a custom function when you need full control: conditional logic, array handling, value transformations, or cross-field validation that‚Äôs not practical to express with patterns. The function receives the unmarshaled config as `interface{}` and returns a standard `map[layerSlug]map[paramName]any` for Glazed to apply.`
- L1808: `pkg/doc/topics/24-config-files.md:250:Provide a `ConfigFileMapper` function to `WithConfigFileMapper` to transform raw config into a `map[layerSlug]map[paramName]any`:`
- L1809: `pkg/doc/topics/24-config-files.md:260:    // inspect raw (unmarshaled YAML/JSON) and build the layer map`
- L1810: `pkg/doc/topics/24-config-files.md:271:## Inspecting parse steps (`--print-parsed-parameters`)`
- L1811: `pkg/doc/topics/24-config-files.md:273:Parsing is not a black box‚Äîevery write records its source and any relevant metadata. Enable `--print-parsed-parameters` to see the exact sequence of updates for each parameter. This is invaluable when debugging precedence issues (for example, ‚Äúwhy didn‚Äôt my local override win?‚Äù) or auditing where a value originated.`
- L1812: `pkg/doc/topics/24-config-files.md:275:Add the `command-settings` layer (done automatically by the Cobra parser unless disabled) and run with `--print-parsed-parameters` to see where a value came from:`
- L1813: `pkg/doc/topics/24-config-files.md:292:Validate configs early to catch mistakes before runtime. For default-shaped files, check for unknown layers/parameters and type errors. For pattern-based configs, instantiate a mapper and call `Map` in a validate-only pass; the mapper will fail fast on missing required matches, ambiguous patterns, or invalid targets. These validators are small enough to run in CI and provide crisp error messages for contributors.`
- L1814: `pkg/doc/topics/24-config-files.md:298:Apply this validator to YAML/JSON files that mirror your layers. It‚Äôs conservative by design: any unexpected layer or parameter is flagged, and values are type-checked against your parameter definitions. This keeps configs tidy and prevents silent drift as parameters evolve.`
- L1815: `pkg/doc/topics/24-config-files.md:308:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1816: `pkg/doc/topics/24-config-files.md:309:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1817: `pkg/doc/topics/24-config-files.md:313:func validateConfigFile(layers_ *schema.Schema, path string) error {`
- L1818: `pkg/doc/topics/24-config-files.md:320:    for layerSlug, v := range raw {`
- L1819: `pkg/doc/topics/24-config-files.md:321:        layer, ok := layers_.Get(layerSlug)`
- L1820: `pkg/doc/topics/24-config-files.md:322:        if !ok { issues = append(issues, fmt.Sprintf("unknown layer %s", layerSlug)); continue }`
- L1821: `pkg/doc/topics/24-config-files.md:324:        if !ok { issues = append(issues, fmt.Sprintf("layer %s must be an object", layerSlug)); continue }`
- L1822: `pkg/doc/topics/24-config-files.md:325:        pds := layer.GetParameterDefinitions()`
- L1823: `pkg/doc/topics/24-config-files.md:329:            if !known[key] { issues = append(issues, fmt.Sprintf("unknown parameter %s.%s", layerSlug, key)); continue }`
- L1824: `pkg/doc/topics/24-config-files.md:332:                issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))`
- L1825: `pkg/doc/topics/24-config-files.md:345:For declarative mappings, the mapper is your validator. Build it once per app (construction validates static aspects) and call `Map` on the raw config (runtime semantics validate dynamic aspects). Error messages include path hints and prefix-aware parameter names to accelerate debugging.`
- L1826: `pkg/doc/topics/24-config-files.md:352:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1827: `pkg/doc/topics/24-config-files.md:390:Legacy Viper-based middlewares like `GatherFlagsFromViper` and per-command `--load-parameters-from-file` are deprecated. Prefer config middlewares (`LoadParametersFromFiles`) with resolvers and `--config-file`.`
- L1828: `pkg/cmds/fields/strings.go:8:// GatherFlagsFromStringList parses command line arguments into a ParsedParameters`
- L1829: `pkg/cmds/fields/strings.go:12:// It returns the parsed parameters map, any non-flag arguments, and any error`
- L1830: `pkg/cmds/fields/strings.go:32:) (*ParsedParameters, []string, error) {`
- L1831: `pkg/cmds/fields/strings.go:37:	// build a map of flag names to parameter definitions, including through shortflags`
- L1832: `pkg/cmds/fields/strings.go:119:	result := NewParsedParameters()`
- L1833: `pkg/cmds/fields/strings.go:125:		parsedValue, err := param.ParseParameter(values, parseOptions...)`
- L1834: `pkg/cmds/fields/strings.go:140:				p := &ParsedParameter{`
- L1835: `pkg/doc/topics/21-cmds-middlewares.md:4:Short: Learn how to use Glazed's middleware system to load parameter values from various sources`
- L1836: `pkg/doc/topics/21-cmds-middlewares.md:7:- parameters`
- L1837: `pkg/doc/topics/21-cmds-middlewares.md:13:- LoadParametersFromFile`
- L1838: `pkg/doc/topics/21-cmds-middlewares.md:23:# Glazed Middlewares Guide: Loading Parameter Values`
- L1839: `pkg/doc/topics/21-cmds-middlewares.md:27:Glazed provides a flexible middleware system for loading parameter values from various sources. This guide explains how to use these middlewares effectively to populate your command parameters from different locations like environment variables, config files, and command line arguments.`
- L1840: `pkg/doc/topics/21-cmds-middlewares.md:36:type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error`
- L1841: `pkg/doc/topics/21-cmds-middlewares.md:40:### Relationship between ParameterLayers and ParsedLayers`
- L1842: `pkg/doc/topics/21-cmds-middlewares.md:42:- **ParameterLayers**: These are collections of parameter definitions. They define the structure and metadata of parameters, such as their names, types, and default values.`
- L1843: `pkg/doc/topics/21-cmds-middlewares.md:44:- **ParsedLayers**: These are collections of parsed parameter values. They store the actual values obtained from various sources like command-line arguments, environment variables, or configuration files.`
- L1844: `pkg/doc/topics/21-cmds-middlewares.md:46:Middlewares operate on these two structures to manage and transform parameter values.`
- L1845: `pkg/doc/topics/21-cmds-middlewares.md:52:1. **Modular Parameter Handling**: They allow for modular and reusable parameter processing logic. Each middleware can focus on a specific source or transformation of parameter values.`
- L1846: `pkg/doc/topics/21-cmds-middlewares.md:54:2. **Logging and Tracking**: Each middleware can log its actions, providing a trace of how parameter values were derived.`
- L1847: `pkg/doc/topics/21-cmds-middlewares.md:56:### Adding Information to Parsed Parameters`
- L1848: `pkg/doc/topics/21-cmds-middlewares.md:58:Each middleware can add information to the parsed parameters by:`
- L1849: `pkg/doc/topics/21-cmds-middlewares.md:62:- Logging the source and transformation steps for each parameter value.`
- L1850: `pkg/doc/topics/21-cmds-middlewares.md:68:- It can process parameters before and/or after calling `next``
- L1851: `pkg/doc/topics/21-cmds-middlewares.md:70:    - `ParameterLayers`: Contains parameter definitions`
- L1852: `pkg/doc/topics/21-cmds-middlewares.md:71:    - `ParsedLayers`: Stores the actual parameter values`
- L1853: `pkg/doc/topics/21-cmds-middlewares.md:78:ExecuteMiddlewares(layers, parsedLayers,`
- L1854: `pkg/doc/topics/21-cmds-middlewares.md:81:    LoadParametersFromFile("config.yaml"),`
- L1855: `pkg/doc/topics/21-cmds-middlewares.md:86:1. LoadParametersFromFile`
- L1856: `pkg/doc/topics/21-cmds-middlewares.md:94:Use `SetFromDefaults` to populate parameters with their default values:`
- L1857: `pkg/doc/topics/21-cmds-middlewares.md:102:This middleware reads the default values specified in parameter definitions and sets them if no value exists.`
- L1858: `pkg/doc/topics/21-cmds-middlewares.md:115:- Parameter `port` becomes `APP_PORT``
- L1859: `pkg/doc/topics/21-cmds-middlewares.md:116:- Parameter `db_host` becomes `APP_DB_HOST``
- L1860: `pkg/doc/topics/21-cmds-middlewares.md:120:Load parameters from JSON or YAML files using `LoadParametersFromFile`:`
- L1861: `pkg/doc/topics/21-cmds-middlewares.md:130:By default, `LoadParametersFromFile` expects the config file to have this structure:`
- L1862: `pkg/doc/topics/21-cmds-middlewares.md:132:layerName:`
- L1863: `pkg/doc/topics/21-cmds-middlewares.md:133:  parameterName: value`
- L1864: `pkg/doc/topics/21-cmds-middlewares.md:134:  anotherParameter: value`
- L1865: `pkg/doc/topics/21-cmds-middlewares.md:149:    // Map flat keys to layer parameters`
- L1866: `pkg/doc/topics/21-cmds-middlewares.md:191:The mapper handles both structures and maps them to the standard layer format. This allows you to:`
- L1867: `pkg/doc/topics/21-cmds-middlewares.md:194:- Transform nested JSON/YAML hierarchies into layer parameters`
- L1868: `pkg/doc/topics/21-cmds-middlewares.md:236:Load parameters from specific config files using built-in file middlewares:`
- L1869: `pkg/doc/topics/21-cmds-middlewares.md:257:    // Transform your custom config structure to layer map format`
- L1870: `pkg/doc/topics/21-cmds-middlewares.md:285:### 8. Layer Manipulation`
- L1871: `pkg/doc/topics/21-cmds-middlewares.md:287:Glazed provides several middlewares for manipulating parsed layers directly:`
- L1872: `pkg/doc/topics/21-cmds-middlewares.md:289:#### Replacing Layers`
- L1873: `pkg/doc/topics/21-cmds-middlewares.md:291:Replace a single layer:`
- L1874: `pkg/doc/topics/21-cmds-middlewares.md:293:// Replace the "config" layer with a new one`
- L1875: `pkg/doc/topics/21-cmds-middlewares.md:294:middleware := middlewares.ReplaceParsedLayer("config", newLayer)`
- L1876: `pkg/doc/topics/21-cmds-middlewares.md:297:Replace multiple layers at once:`
- L1877: `pkg/doc/topics/21-cmds-middlewares.md:299:// Replace multiple layers with new ones`
- L1878: `pkg/doc/topics/21-cmds-middlewares.md:300:middleware := middlewares.ReplaceParsedLayers(newLayers)`
- L1879: `pkg/doc/topics/21-cmds-middlewares.md:303:#### Merging Layers`
- L1880: `pkg/doc/topics/21-cmds-middlewares.md:305:Merge a single layer:`
- L1881: `pkg/doc/topics/21-cmds-middlewares.md:307:// Merge a layer into the "config" layer`
- L1882: `pkg/doc/topics/21-cmds-middlewares.md:308:middleware := middlewares.MergeParsedLayer("config", layerToMerge)`
- L1883: `pkg/doc/topics/21-cmds-middlewares.md:311:Merge multiple layers:`
- L1884: `pkg/doc/topics/21-cmds-middlewares.md:313:// Merge multiple layers into existing ones`
- L1885: `pkg/doc/topics/21-cmds-middlewares.md:314:middleware := middlewares.MergeParsedLayers(layersToMerge)`
- L1886: `pkg/doc/topics/21-cmds-middlewares.md:317:#### Selective Layer Operations`
- L1887: `pkg/doc/topics/21-cmds-middlewares.md:319:For more fine-grained control, you can use selective middlewares that only operate on specific layers:`
- L1888: `pkg/doc/topics/21-cmds-middlewares.md:322:// Replace only specific layers`
- L1889: `pkg/doc/topics/21-cmds-middlewares.md:323:middleware := middlewares.ReplaceParsedLayersSelective(newLayers, []string{"config", "env"})`
- L1890: `pkg/doc/topics/21-cmds-middlewares.md:325:// Merge only specific layers`
- L1891: `pkg/doc/topics/21-cmds-middlewares.md:326:middleware := middlewares.MergeParsedLayersSelective(layersToMerge, []string{"user", "profile"})`
- L1892: `pkg/doc/topics/21-cmds-middlewares.md:330:- Update only certain configuration layers while preserving others`
- L1893: `pkg/doc/topics/21-cmds-middlewares.md:337:sources.Execute(layers, parsedLayers,`
- L1894: `pkg/doc/topics/21-cmds-middlewares.md:338:    // Replace only the base configuration layers`
- L1895: `pkg/doc/topics/21-cmds-middlewares.md:339:    middlewares.ReplaceParsedLayersSelective(baseConfig, []string{"system", "defaults"}),`
- L1896: `pkg/doc/topics/21-cmds-middlewares.md:342:    middlewares.MergeParsedLayersSelective(userConfig, []string{"preferences", "history"}),`
- L1897: `pkg/doc/topics/21-cmds-middlewares.md:345:    middlewares.ReplaceParsedLayers(envConfig),`
- L1898: `pkg/doc/topics/21-cmds-middlewares.md:349:These layer manipulation middlewares are useful when you need to:`
- L1899: `pkg/doc/topics/21-cmds-middlewares.md:352:- Apply temporary parameter changes`
- L1900: `pkg/doc/topics/21-cmds-middlewares.md:357:sources.Execute(layers, parsedLayers,`
- L1901: `pkg/doc/topics/21-cmds-middlewares.md:359:    middlewares.ReplaceParsedLayer("base", baseConfig),`
- L1902: `pkg/doc/topics/21-cmds-middlewares.md:361:    middlewares.MergeParsedLayer("env", envSettings),`
- L1903: `pkg/doc/topics/21-cmds-middlewares.md:363:    middlewares.MergeParsedLayer("user", userPrefs),`
- L1904: `pkg/doc/topics/21-cmds-middlewares.md:402:### 2. Layer Filtering`
- L1905: `pkg/doc/topics/21-cmds-middlewares.md:404:Restrict middleware operation to specific layers:`
- L1906: `pkg/doc/topics/21-cmds-middlewares.md:407:// Only apply to specified layers`
- L1907: `pkg/doc/topics/21-cmds-middlewares.md:408:middleware := middlewares.WrapWithWhitelistedLayers(`
- L1908: `pkg/doc/topics/21-cmds-middlewares.md:413:// Exclude specific layers`
- L1909: `pkg/doc/topics/21-cmds-middlewares.md:414:middleware := middlewares.WrapWithBlacklistedLayers(`
- L1910: `pkg/doc/topics/21-cmds-middlewares.md:426:    "layer1": {`
- L1911: `pkg/doc/topics/21-cmds-middlewares.md:443:   ExecuteMiddlewares(layers, parsedLayers,`
- L1912: `pkg/doc/topics/21-cmds-middlewares.md:446:       LoadParametersFromFile(),    // More specific`
- L1913: `pkg/doc/topics/21-cmds-middlewares.md:453:   err := sources.Execute(layers, parsedLayers, `
- L1914: `pkg/doc/topics/21-cmds-middlewares.md:461:4. **Layer Organization**: Group related parameters into logical layers for easier management and filtering.`
- L1915: `pkg/doc/topics/21-cmds-middlewares.md:470:sources.Execute(layers, parsedLayers,`
- L1916: `pkg/doc/topics/21-cmds-middlewares.md:492:sources.Execute(layers, parsedLayers,`
- L1917: `pkg/doc/topics/21-cmds-middlewares.md:548:    layers := createTestLayers()`
- L1918: `pkg/doc/topics/21-cmds-middlewares.md:549:    parsedLayers := values.New()`
- L1919: `pkg/doc/topics/21-cmds-middlewares.md:553:    err := sources.Execute(layers, parsedLayers, middleware)`
- L1920: `pkg/doc/topics/21-cmds-middlewares.md:557:    value, exists := parsedLayers.GetParameter("default", "param1")`
- L1921: `pkg/doc/topics/21-cmds-middlewares.md:567:    layers := createTestLayers()`
- L1922: `pkg/doc/topics/21-cmds-middlewares.md:568:    parsedLayers := values.New()`
- L1923: `pkg/doc/topics/21-cmds-middlewares.md:579:    err := sources.Execute(layers, parsedLayers, mws...)`
- L1924: `pkg/doc/topics/21-cmds-middlewares.md:583:    value, _ := parsedLayers.GetParameter("default", "param1")`
- L1925: `pkg/doc/topics/21-cmds-middlewares.md:592:    layers := createTestLayers()`
- L1926: `pkg/doc/topics/21-cmds-middlewares.md:593:    parsedLayers := values.New()`
- L1927: `pkg/doc/topics/21-cmds-middlewares.md:596:    parsedLayers.SetParameter("default", "email", "invalid-email")`
- L1928: `pkg/doc/topics/21-cmds-middlewares.md:600:    err := sources.Execute(layers, parsedLayers, middleware)`
- L1929: `pkg/doc/topics/21-cmds-middlewares.md:608:1. Use logging middleware to track parameter changes:`
- L1930: `pkg/doc/topics/21-cmds-middlewares.md:622:parsedLayers.ForEach(func(layer string, params *parameters.ParsedParameters) {`
- L1931: `pkg/doc/topics/21-cmds-middlewares.md:624:        fmt.Printf("%s.%s = %v\n", layer, name, value)`
- L1932: `pkg/doc/topics/21-cmds-middlewares.md:629:Remember that middlewares are a powerful tool for managing parameter values, but with that power comes the need for careful organization and consideration of precedence rules.`
- L1933: `pkg/doc/topics/21-cmds-middlewares.md:670:            ShortHelpLayers: []string{"default", "helpers"},`
- L1934: `pkg/doc/topics/21-cmds-middlewares.md:688:    if commandSettings.LoadParametersFromFile != "" {`
- L1935: `pkg/doc/topics/21-cmds-middlewares.md:690:            sources.FromFile(commandSettings.LoadParametersFromFile))`
- L1936: `pkg/doc/topics/21-cmds-middlewares.md:709:    // Env config for specific layers (if needed)`
- L1937: `pkg/doc/topics/21-cmds-middlewares.md:710:    middlewares.WrapWithWhitelistedLayers(`
- L1938: `pkg/doc/topics/21-cmds-middlewares.md:733:## Layer-Specific Configuration`
- L1939: `pkg/doc/topics/21-cmds-middlewares.md:735:Restrict middleware to specific layers:`
- L1940: `pkg/doc/topics/21-cmds-middlewares.md:738:middlewares.WrapWithWhitelistedLayers(`
- L1941: `pkg/doc/topics/21-cmds-middlewares.md:750:The foundation of Glazed's parameter system is the `ParameterLayer`. Before we can use middlewares, we need to define our parameter structure. This example shows how to create a layer that matches the architectural concepts discussed earlier:`
- L1942: `pkg/doc/topics/21-cmds-middlewares.md:756:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L1943: `pkg/doc/topics/21-cmds-middlewares.md:757:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L1944: `pkg/doc/topics/21-cmds-middlewares.md:762:    // Create a new parameter layer`
- L1945: `pkg/doc/topics/21-cmds-middlewares.md:763:    layer, err := schema.NewSection(`
- L1946: `pkg/doc/topics/21-cmds-middlewares.md:785:    // Create parameter layers container`
- L1947: `pkg/doc/topics/21-cmds-middlewares.md:786:    parameterLayers := schema.NewSchema(`
- L1948: `pkg/doc/topics/21-cmds-middlewares.md:787:        layers.WithLayers(layer),`
- L1949: `pkg/doc/topics/21-cmds-middlewares.md:793:- Parameter definitions with types, defaults, and help text`
- L1950: `pkg/doc/topics/21-cmds-middlewares.md:794:- Layer organization with meaningful names and descriptions`
- L1951: `pkg/doc/topics/21-cmds-middlewares.md:795:- Error handling for layer creation`
- L1952: `pkg/doc/topics/21-cmds-middlewares.md:796:- Container structure for managing multiple layers`
- L1953: `pkg/doc/topics/21-cmds-middlewares.md:800:Now that we understand the middleware signature and execution order, let's see how to implement specific middlewares. These examples show how the middleware chain processes parameters in practice.`
- L1954: `pkg/doc/topics/21-cmds-middlewares.md:804:The `SetFromDefaults` middleware demonstrates the basic middleware pattern of processing parameters after the next handler:`
- L1955: `pkg/doc/topics/21-cmds-middlewares.md:808:    // Create empty parsed layers`
- L1956: `pkg/doc/topics/21-cmds-middlewares.md:809:    parsedLayers := values.New()`
- L1957: `pkg/doc/topics/21-cmds-middlewares.md:817:        parameterLayers,`
- L1958: `pkg/doc/topics/21-cmds-middlewares.md:818:        parsedLayers,`
- L1959: `pkg/doc/topics/21-cmds-middlewares.md:826:    configLayer, _ := parsedLayers.Get("config")`
- L1960: `pkg/doc/topics/21-cmds-middlewares.md:827:    hostValue, _ := configLayer.GetParameter("host")`
- L1961: `pkg/doc/topics/21-cmds-middlewares.md:833:- Creation of empty ParsedLayers to store results`
- L1962: `pkg/doc/topics/21-cmds-middlewares.md:845:    parsedLayers := values.New()`
- L1963: `pkg/doc/topics/21-cmds-middlewares.md:856:        parameterLayers,`
- L1964: `pkg/doc/topics/21-cmds-middlewares.md:857:        parsedLayers,`
- L1965: `pkg/doc/topics/21-cmds-middlewares.md:868:- Layer-specific updates`
- L1966: `pkg/doc/topics/21-cmds-middlewares.md:874:After middlewares process the parameters, there are several ways to access the results. These patterns align with different use cases in the architecture:`
- L1967: `pkg/doc/topics/21-cmds-middlewares.md:877:func accessParsedValues(parsedLayers *values.Values) {`
- L1968: `pkg/doc/topics/21-cmds-middlewares.md:878:    // 1. Direct access through layer`
- L1969: `pkg/doc/topics/21-cmds-middlewares.md:879:    configLayer, _ := parsedLayers.Get("config")`
- L1970: `pkg/doc/topics/21-cmds-middlewares.md:880:    hostValue, _ := configLayer.GetParameter("host")`
- L1971: `pkg/doc/topics/21-cmds-middlewares.md:882:    // 2. Get all parameters as a map`
- L1972: `pkg/doc/topics/21-cmds-middlewares.md:883:    dataMap := parsedLayers.GetDataMap()`
- L1973: `pkg/doc/topics/21-cmds-middlewares.md:893:    err := parsedLayers.InitializeStruct("config", &config)`
- L1974: `pkg/doc/topics/21-cmds-middlewares.md:901:- Direct layer access for fine-grained control`
- L1975: `pkg/doc/topics/21-cmds-middlewares.md:902:- Map-based access for dynamic parameter handling`
- L1976: `pkg/doc/topics/21-cmds-middlewares.md:903:- Struct initialization for type-safe parameter usage`
- L1977: `pkg/doc/topics/21-cmds-middlewares.md:906:### 4. Tracking Parameter History`
- L1978: `pkg/doc/topics/21-cmds-middlewares.md:908:One of the key features of Glazed's middleware system is its ability to track parameter changes. This helps debug parameter processing and understand value origins:`
- L1979: `pkg/doc/topics/21-cmds-middlewares.md:911:func checkParameterHistory(parsedLayers *values.Values) {`
- L1980: `pkg/doc/topics/21-cmds-middlewares.md:912:    configLayer, _ := parsedLayers.Get("config")`
- L1981: `pkg/doc/topics/21-cmds-middlewares.md:913:    hostParam, _ := configLayer.Parameters.Get("host")`
- L1982: `pkg/doc/topics/21-cmds-middlewares.md:926:- Debugging support for parameter processing`
- L1983: `pkg/doc/topics/21-cmds-middlewares.md:934:    parsedLayers := values.New()`
- L1984: `pkg/doc/topics/21-cmds-middlewares.md:936:    // Define different parameter sources`
- L1985: `pkg/doc/topics/21-cmds-middlewares.md:953:        parameterLayers,`
- L1986: `pkg/doc/topics/21-cmds-middlewares.md:954:        parsedLayers,`
- L1987: `pkg/doc/topics/21-cmds-middlewares.md:974:### 6. Working with Restricted Layers`
- L1988: `pkg/doc/topics/21-cmds-middlewares.md:976:Layer restriction is a powerful feature that implements the modular parameter handling concept discussed in the architecture:`
- L1989: `pkg/doc/topics/21-cmds-middlewares.md:979:func useRestrictedLayers() {`
- L1990: `pkg/doc/topics/21-cmds-middlewares.md:980:    parsedLayers := values.New()`
- L1991: `pkg/doc/topics/21-cmds-middlewares.md:988:    // Only apply to whitelisted layers`
- L1992: `pkg/doc/topics/21-cmds-middlewares.md:989:    whitelistedMiddleware := middlewares.WrapWithWhitelistedLayers(`
- L1993: `pkg/doc/topics/21-cmds-middlewares.md:994:    // Or blacklist specific layers`
- L1994: `pkg/doc/topics/21-cmds-middlewares.md:995:    blacklistedMiddleware := middlewares.WrapWithBlacklistedLayers(`
- L1995: `pkg/doc/topics/21-cmds-middlewares.md:996:        []string{"other-layer"},`
- L1996: `pkg/doc/topics/21-cmds-middlewares.md:1001:        parameterLayers,`
- L1997: `pkg/doc/topics/21-cmds-middlewares.md:1002:        parsedLayers,`
- L1998: `pkg/doc/topics/21-cmds-middlewares.md:1014:- Layer isolation`
- L1999: `pkg/doc/topics/21-cmds-middlewares.md:1015:- Parameter scope control`
- L2000: `pkg/doc/topics/21-cmds-middlewares.md:1021:These examples can be combined to create sophisticated parameter handling systems. For instance, a typical application might:`
- L2001: `pkg/doc/topics/21-cmds-middlewares.md:1023:1. Define multiple parameter layers for different concerns`
- L2002: `pkg/doc/topics/21-cmds-middlewares.md:1025:3. Use layer restrictions to manage parameter scope`
- L2003: `pkg/doc/topics/21-cmds-middlewares.md:1026:4. Track parameter history for debugging`
- L2004: `pkg/cmds/fields/parameters_test.go:15://go:embed "test-data/parameters_test.yaml"`
- L2005: `pkg/cmds/fields/parameters_test.go:18:var testParameterDefinitions *Definitions`
- L2006: `pkg/cmds/fields/parameters_test.go:26:	parameterDefinition *Definition`
- L2007: `pkg/cmds/fields/parameters_test.go:32://go:embed "test-data/parameters_validity_test.yaml"`
- L2008: `pkg/cmds/fields/parameters_test.go:35:var testParameterValidList []*ValidityTest`
- L2009: `pkg/cmds/fields/parameters_test.go:45:		test.parameterDefinition = &Definition{`
- L2010: `pkg/cmds/fields/parameters_test.go:58:var testParametersTypesYaml []byte`
- L2011: `pkg/cmds/fields/parameters_test.go:67:func loadParameterTypeTests(yamlData []byte) ([]TypeTest, error) {`
- L2012: `pkg/cmds/fields/parameters_test.go:76:var testParameterTypeTests []TypeTest`
- L2013: `pkg/cmds/fields/parameters_test.go:78:func initialParameterTests() {`
- L2014: `pkg/cmds/fields/parameters_test.go:79:	testParameterDefinitions = LoadDefinitionsFromYAML(testFlagsYaml)`
- L2015: `pkg/cmds/fields/parameters_test.go:81:	testParameterValidList, err = loadValidityTestDataFromYAML(validityTestYaml)`
- L2016: `pkg/cmds/fields/parameters_test.go:86:	testParameterTypeTests, err = loadParameterTypeTests(testParametersTypesYaml)`
- L2017: `pkg/cmds/fields/parameters_test.go:92:func TestParameterTypes(t *testing.T) {`
- L2018: `pkg/cmds/fields/parameters_test.go:93:	initialParameterTests()`
- L2019: `pkg/cmds/fields/parameters_test.go:94:	for _, test := range testParameterTypeTests {`
- L2020: `pkg/cmds/fields/parameters_test.go:103:func TestParameterValidity(t *testing.T) {`
- L2021: `pkg/cmds/fields/parameters_test.go:104:	initialParameterTests()`
- L2022: `pkg/cmds/fields/parameters_test.go:105:	for _, validityTest := range testParameterValidList {`
- L2023: `pkg/cmds/fields/parameters_test.go:107:			_, err := validityTest.parameterDefinition.CheckValueValidity(validityTest.Value)`
- L2024: `pkg/cmds/fields/parameters_test.go:118:	initialParameterTests()`
- L2025: `pkg/cmds/fields/parameters_test.go:119:	intFlag, _ := testParameterDefinitions.Get("int-flag")`
- L2026: `pkg/cmds/fields/parameters_test.go:130:	intFlag, _ = testParameterDefinitions.Get("int-flag-without-default")`
- L2027: `pkg/cmds/fields/parameters_test.go:137:	intFlag, _ = testParameterDefinitions.Get("int-flag-with-empty-default")`
- L2028: `pkg/cmds/fields/parameters_test.go:144:	initialParameterTests()`
- L2029: `pkg/cmds/fields/parameters_test.go:145:	intFlag, _ := testParameterDefinitions.Get("int-flag")`
- L2030: `pkg/cmds/fields/parameters_test.go:156:	intFlag, _ = testParameterDefinitions.Get("int-flag-without-default")`
- L2031: `pkg/cmds/fields/parameters_test.go:163:	intFlag, _ = testParameterDefinitions.Get("int-flag-with-empty-default")`
- L2032: `pkg/cmds/fields/parameters_test.go:171:	initialParameterTests()`
- L2033: `pkg/cmds/fields/parameters_test.go:172:	floatFlag, _ := testParameterDefinitions.Get("float-flag")`
- L2034: `pkg/cmds/fields/parameters_test.go:183:	floatFlag, _ = testParameterDefinitions.Get("float-flag-without-default")`
- L2035: `pkg/cmds/fields/parameters_test.go:190:	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-empty-default")`
- L2036: `pkg/cmds/fields/parameters_test.go:195:	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-int-default")`
- L2037: `pkg/cmds/fields/parameters_test.go:202:	initialParameterTests()`
- L2038: `pkg/cmds/fields/parameters_test.go:203:	floatFlag, _ := testParameterDefinitions.Get("float-flag")`
- L2039: `pkg/cmds/fields/parameters_test.go:214:	floatFlag, _ = testParameterDefinitions.Get("float-flag-without-default")`
- L2040: `pkg/cmds/fields/parameters_test.go:221:	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-empty-default")`
- L2041: `pkg/cmds/fields/parameters_test.go:228:	initialParameterTests()`
- L2042: `pkg/cmds/fields/parameters_test.go:229:	dateFlag, _ := testParameterDefinitions.Get("date-flag")`
- L2043: `pkg/cmds/fields/parameters_test.go:244:	dateFlag, _ = testParameterDefinitions.Get("date-flag-without-default")`
- L2044: `pkg/cmds/fields/parameters_test.go:251:	initialParameterTests()`
- L2045: `pkg/cmds/fields/parameters_test.go:252:	stringFlag, _ := testParameterDefinitions.Get("string-flag")`
- L2046: `pkg/cmds/fields/parameters_test.go:263:	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")`
- L2047: `pkg/cmds/fields/parameters_test.go:270:	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")`
- L2048: `pkg/cmds/fields/parameters_test.go:277:	initialParameterTests()`
- L2049: `pkg/cmds/fields/parameters_test.go:278:	stringFlag, _ := testParameterDefinitions.Get("string-flag")`
- L2050: `pkg/cmds/fields/parameters_test.go:289:	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")`
- L2051: `pkg/cmds/fields/parameters_test.go:296:	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")`
- L2052: `pkg/cmds/fields/parameters_test.go:303:	initialParameterTests()`
- L2053: `pkg/cmds/fields/parameters_test.go:304:	stringFlag, _ := testParameterDefinitions.Get("string-flag")`
- L2054: `pkg/cmds/fields/parameters_test.go:315:	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")`
- L2055: `pkg/cmds/fields/parameters_test.go:322:	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")`
- L2056: `pkg/cmds/fields/parameters_test.go:328:	boolFlag, _ := testParameterDefinitions.Get("bool-flag")`
- L2057: `pkg/cmds/fields/parameters_test.go:339:	boolFlag, _ = testParameterDefinitions.Get("bool-flag-without-default")`
- L2058: `pkg/cmds/fields/parameters_test.go:346:	boolFlag, _ = testParameterDefinitions.Get("bool-flag-with-empty-default")`
- L2059: `pkg/cmds/fields/parameters_test.go:353:	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")`
- L2060: `pkg/cmds/fields/parameters_test.go:364:	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")`
- L2061: `pkg/cmds/fields/parameters_test.go:380:	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")`
- L2062: `pkg/cmds/fields/parameters_test.go:391:	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")`
- L2063: `pkg/cmds/fields/parameters_test.go:407:	initialParameterTests()`
- L2064: `pkg/cmds/fields/parameters_test.go:408:	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")`
- L2065: `pkg/cmds/fields/parameters_test.go:419:	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")`
- L2066: `pkg/cmds/fields/parameters_test.go:435:	initialParameterTests()`
- L2067: `pkg/cmds/fields/parameters_test.go:436:	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")`
- L2068: `pkg/cmds/fields/parameters_test.go:447:	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")`
- L2069: `pkg/cmds/fields/parameters_test.go:463:	initialParameterTests()`
- L2070: `pkg/cmds/fields/parameters_test.go:464:	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")`
- L2071: `pkg/cmds/fields/parameters_test.go:475:	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")`
- L2072: `pkg/cmds/fields/parameters_test.go:491:	initialParameterTests()`
- L2073: `pkg/cmds/fields/parameters_test.go:492:	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")`
- L2074: `pkg/cmds/fields/parameters_test.go:503:	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")`
- L2075: `pkg/cmds/fields/parameters_test.go:519:	intListFlag, _ := testParameterDefinitions.Get("int-list-flag")`
- L2076: `pkg/cmds/fields/parameters_test.go:530:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-without-default")`
- L2077: `pkg/cmds/fields/parameters_test.go:537:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-with-empty-default")`
- L2078: `pkg/cmds/fields/parameters_test.go:544:	intListFlag, _ := testParameterDefinitions.Get("int-list-flag")`
- L2079: `pkg/cmds/fields/parameters_test.go:556:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-without-default")`
- L2080: `pkg/cmds/fields/parameters_test.go:564:	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-with-empty-default")`
- L2081: `pkg/cmds/fields/parameters_test.go:572:	floatListFlag, _ := testParameterDefinitions.Get("float-list-flag")`
- L2082: `pkg/cmds/fields/parameters_test.go:583:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-without-default")`
- L2083: `pkg/cmds/fields/parameters_test.go:590:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-with-empty-default")`
- L2084: `pkg/cmds/fields/parameters_test.go:597:	floatListFlag, _ := testParameterDefinitions.Get("float-list-flag")`
- L2085: `pkg/cmds/fields/parameters_test.go:609:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-without-default")`
- L2086: `pkg/cmds/fields/parameters_test.go:617:	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-with-empty-default")`
- L2087: `pkg/cmds/fields/parameters_test.go:625:	objectFromFileFlag, _ := testParameterDefinitions.Get("object-from-file-flag")`
- L2088: `pkg/cmds/fields/parameters_test.go:634:	objectFromFileFlag, _ = testParameterDefinitions.Get("object-from-file-flag-without-default")`
- L2089: `pkg/cmds/fields/parameters_test.go:641:	objectFromFileFlag, _ = testParameterDefinitions.Get("object-from-file-flag-with-empty-default")`
- L2090: `pkg/cmds/fields/parameters_test.go:648:	objectListFromFileFlag, _ := testParameterDefinitions.Get("object-list-from-file-flag")`
- L2091: `pkg/cmds/fields/parameters_test.go:660:	objectListFromFileFlag, _ = testParameterDefinitions.Get("object-list-from-file-flag-without-default")`
- L2092: `pkg/cmds/fields/parameters_test.go:667:	objectListFromFileFlag, _ = testParameterDefinitions.Get("object-list-from-file-flag-with-empty-default")`
- L2093: `pkg/cmds/fields/parameters_test.go:674:	stringFromFileFlag, _ := testParameterDefinitions.Get("string-from-file-flag")`
- L2094: `pkg/cmds/fields/parameters_test.go:683:	stringFromFileFlag, _ = testParameterDefinitions.Get("string-from-file-flag-without-default")`
- L2095: `pkg/cmds/fields/parameters_test.go:690:	stringFromFileFlag, _ = testParameterDefinitions.Get("string-from-file-flag-with-empty-default")`
- L2096: `pkg/cmds/fields/parameters_test.go:697:	stringListFromFileFlag, _ := testParameterDefinitions.Get("string-list-from-file-flag")`
- L2097: `pkg/cmds/fields/parameters_test.go:706:	stringListFromFileFlag, _ = testParameterDefinitions.Get("string-list-from-file-flag-without-default")`
- L2098: `pkg/cmds/fields/parameters_test.go:713:	stringListFromFileFlag, _ = testParameterDefinitions.Get("string-list-from-file-flag-with-empty-default")`
- L2099: `pkg/cmds/fields/parameters_test.go:720:	initialParameterTests()`
- L2100: `pkg/cmds/fields/parameters_test.go:721:	stringListFlag, _ := testParameterDefinitions.Get("string-list-flag")`
- L2101: `pkg/cmds/fields/parameters_test.go:732:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-without-default")`
- L2102: `pkg/cmds/fields/parameters_test.go:739:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-with-empty-default")`
- L2103: `pkg/cmds/fields/parameters_test.go:746:	initialParameterTests()`
- L2104: `pkg/cmds/fields/parameters_test.go:747:	stringListFlag, _ := testParameterDefinitions.Get("string-list-flag")`
- L2105: `pkg/cmds/fields/parameters_test.go:758:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-without-default")`
- L2106: `pkg/cmds/fields/parameters_test.go:765:	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-with-empty-default")`
- L2107: `pkg/cmds/fields/parameters_test.go:772:	keyValueFlag, _ := testParameterDefinitions.Get("key-value-flag")`
- L2108: `pkg/cmds/fields/parameters_test.go:781:	keyValueFlag, _ = testParameterDefinitions.Get("key-value-flag-without-default")`
- L2109: `pkg/cmds/fields/parameters_test.go:788:	keyValueFlag, _ = testParameterDefinitions.Get("key-value-flag-with-empty-default")`
- L2110: `pkg/doc/topics/01-help-system.md:349://   Parameters: [1 database]`
- L2111: `pkg/cmds/fields/strings_test.go:10:// TestGatherFlagsFromStringList_ValidArgumentsAndParameters tests the function with valid arguments and fields.`
- L2112: `pkg/cmds/fields/strings_test.go:11:func TestGatherFlagsFromStringList_ValidArgumentsAndParameters(t *testing.T) {`
- L2113: `pkg/cmds/fields/strings_test.go:366:		// "--flag value" (empty parameters)`
- L2114: `pkg/cmds/fields/strings_test.go:368:			name:    "EmptyParameters",`
- L2115: `pkg/cmds/fields/strings_test.go:373:		// "--flag value" (parameters with empty ShortFlag)`
- L2116: `pkg/cmds/fields/strings_test.go:375:			name: "ParametersWithEmptyShortFlag",`
- L2117: `pkg/cmds/fields/strings_test.go:385:		// "--flag value -f value" (parameters with the same Name and ShortFlag)`
- L2118: `pkg/cmds/fields/strings_test.go:386:		// "--flag1 value1 -f value2" (parameters with different Name but the same ShortFlag)`
- L2119: `pkg/cmds/fields/strings_test.go:388:			name: "ParametersWithDifferentNameSameShortFlag",`
- L2120: `pkg/cmds/fields/strings_test.go:396:		// "--flag1 value1 --flag2 value2" (mix of valid and invalid parameters)`
- L2121: `pkg/cmds/fields/strings_test.go:398:			name: "MixOfValidAndInvalidParameters",`
- L2122: `pkg/cmds/fields/strings_test.go:402:				// Assuming invalid parameter doesn't have a type`
- L2123: `pkg/cmds/fields/strings_test.go:500:			got_.ForEach(func(key string, p *ParsedParameter) {`
- L2124: `pkg/cmds/fields/viper.go:17:) (*ParsedParameters, error) {`
- L2125: `pkg/cmds/fields/viper.go:19:		log.Warn().Msg("fields.GatherFlagsFromViper is deprecated; use LoadParametersFromFiles + UpdateFromEnv")`
- L2126: `pkg/cmds/fields/viper.go:21:	ret := NewParsedParameters()`
- L2127: `pkg/cmds/fields/viper.go:26:		parsed := &ParsedParameter{`
- L2128: `pkg/cmds/fields/viper.go:118:			return nil, errors.Errorf("Unknown parameter type %s for flag %s", p.Type, p.Name)`
- L2129: `pkg/cmds/fields/cobra.go:13:// GenerateUseString creates a string representation of the 'Use' field for a given cobra command and a list of parameter definitions. The first word of the existing 'Use' field is treated as the verb for the command.`
- L2130: `pkg/cmds/fields/cobra.go:15://   - Required parameters are enclosed in '<>'.`
- L2131: `pkg/cmds/fields/cobra.go:16://   - Optional parameters are enclosed in '[]'.`
- L2132: `pkg/cmds/fields/cobra.go:17://   - Optional parameters that accept multiple input (TypeStringList or TypeIntegerList) are followed by '...'.`
- L2133: `pkg/cmds/fields/cobra.go:18://   - If a parameter has a default value, it is specified after parameter name like 'parameter (default: value)'.`
- L2134: `pkg/cmds/fields/cobra.go:21://   - If there is a required parameter 'name', and an optional parameter 'age' with a default value of '30', the resulting string will be: 'verb <name> [age (default: 30)]'.`
- L2135: `pkg/cmds/fields/cobra.go:22://   - If there is a required parameter 'name', and an optional parameter 'colors' of type TypeStringList, the resulting Use string will be: 'verb <name> [colors...]'`
- L2136: `pkg/cmds/fields/cobra.go:85:		_, err := argument.CheckParameterDefaultValueValidity()`
- L2137: `pkg/cmds/fields/cobra.go:120:// AddParametersToCobraCommand takes the parameters from a CommandDescription and converts them`
- L2138: `pkg/cmds/fields/cobra.go:121:// to cobra flags, before adding them to the Parameters() of a the passed cobra command.`
- L2139: `pkg/cmds/fields/cobra.go:122:func (pds *Definitions) AddParametersToCobraCommand(`
- L2140: `pkg/cmds/fields/cobra.go:133:	err = pds.GetFlags().ForEachE(func(parameter *Definition) error {`
- L2141: `pkg/cmds/fields/cobra.go:134:		_, err := parameter.CheckParameterDefaultValueValidity()`
- L2142: `pkg/cmds/fields/cobra.go:136:			return errors.Wrapf(err, "Invalid default value for argument %s", parameter.Name)`
- L2143: `pkg/cmds/fields/cobra.go:139:		flagName := prefix + parameter.Name`
- L2144: `pkg/cmds/fields/cobra.go:142:		shortFlag := parameter.ShortFlag`
- L2145: `pkg/cmds/fields/cobra.go:154:		helpText := parameter.Help`
- L2146: `pkg/cmds/fields/cobra.go:155:		helpText = fmt.Sprintf("%s - <%s>", helpText, parameter.Type)`
- L2147: `pkg/cmds/fields/cobra.go:157:		switch parameter.Type {`
- L2148: `pkg/cmds/fields/cobra.go:165:			if parameter.ShortFlag != "" {`
- L2149: `pkg/cmds/fields/cobra.go:177:			if parameter.ShortFlag != "" {`
- L2150: `pkg/cmds/fields/cobra.go:186:			if parameter.Default != nil {`
- L2151: `pkg/cmds/fields/cobra.go:187:				defaultValue, err = cast.ToString(*parameter.Default)`
- L2152: `pkg/cmds/fields/cobra.go:189:					return errors.Errorf("Default value for parameter %s is not a string: %v", parameter.Name, *parameter.Default)`
- L2153: `pkg/cmds/fields/cobra.go:193:			if parameter.ShortFlag != "" {`
- L2154: `pkg/cmds/fields/cobra.go:201:			if parameter.Default != nil {`
- L2155: `pkg/cmds/fields/cobra.go:202:				defaultValue, ok = cast.CastNumberInterfaceToInt[int](*parameter.Default)`
- L2156: `pkg/cmds/fields/cobra.go:204:					return errors.Errorf("Default value for parameter %s is not an integer: %v", parameter.Name, *parameter.Default)`
- L2157: `pkg/cmds/fields/cobra.go:208:			if parameter.ShortFlag != "" {`
- L2158: `pkg/cmds/fields/cobra.go:217:			if parameter.Default != nil {`
- L2159: `pkg/cmds/fields/cobra.go:218:				defaultValue, ok = cast.CastFloatInterfaceToFloat[float64](*parameter.Default)`
- L2160: `pkg/cmds/fields/cobra.go:220:					return errors.Errorf("Default value for parameter %s is not a float: %v", parameter.Name, *parameter.Default)`
- L2161: `pkg/cmds/fields/cobra.go:224:			if parameter.ShortFlag != "" {`
- L2162: `pkg/cmds/fields/cobra.go:233:			if parameter.Default != nil {`
- L2163: `pkg/cmds/fields/cobra.go:234:				defaultValue, ok = (*parameter.Default).(bool)`
- L2164: `pkg/cmds/fields/cobra.go:236:					return errors.Errorf("Default value for parameter %s is not a bool: %v", parameter.Name, *parameter.Default)`
- L2165: `pkg/cmds/fields/cobra.go:240:			if parameter.ShortFlag != "" {`
- L2166: `pkg/cmds/fields/cobra.go:249:			if parameter.Default != nil {`
- L2167: `pkg/cmds/fields/cobra.go:250:				switch v_ := (*parameter.Default).(type) {`
- L2168: `pkg/cmds/fields/cobra.go:261:					return errors.Errorf("Default value for parameter %s is not a valid date: %v", parameter.Name, *parameter.Default)`
- L2169: `pkg/cmds/fields/cobra.go:265:			if parameter.ShortFlag != "" {`
- L2170: `pkg/cmds/fields/cobra.go:274:			if parameter.Default != nil {`
- L2171: `pkg/cmds/fields/cobra.go:275:				stringList, ok := (*parameter.Default).([]string)`
- L2172: `pkg/cmds/fields/cobra.go:277:					defaultValue, ok := (*parameter.Default).([]interface{})`
- L2173: `pkg/cmds/fields/cobra.go:279:						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)`
- L2174: `pkg/cmds/fields/cobra.go:285:						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)`
- L2175: `pkg/cmds/fields/cobra.go:292:			if parameter.ShortFlag != "" {`
- L2176: `pkg/cmds/fields/cobra.go:301:			if parameter.Default != nil {`
- L2177: `pkg/cmds/fields/cobra.go:302:				stringMap, ok := (*parameter.Default).(map[string]string)`
- L2178: `pkg/cmds/fields/cobra.go:304:					defaultValue, ok := (*parameter.Default).(map[string]interface{})`
- L2179: `pkg/cmds/fields/cobra.go:306:						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)`
- L2180: `pkg/cmds/fields/cobra.go:325:				return errors.Wrapf(err, "Could not convert default value for parameter %s to string list: %v", parameter.Name, *parameter.Default)`
- L2181: `pkg/cmds/fields/cobra.go:328:			if parameter.ShortFlag != "" {`
- L2182: `pkg/cmds/fields/cobra.go:336:			if parameter.Default != nil {`
- L2183: `pkg/cmds/fields/cobra.go:337:				defaultValue, ok = cast.CastInterfaceToIntList[int](*parameter.Default)`
- L2184: `pkg/cmds/fields/cobra.go:339:					return errors.Errorf("Default value for parameter %s is not an integer list: %v", parameter.Name, *parameter.Default)`
- L2185: `pkg/cmds/fields/cobra.go:343:			if parameter.ShortFlag != "" {`
- L2186: `pkg/cmds/fields/cobra.go:351:			if parameter.Default != nil {`
- L2187: `pkg/cmds/fields/cobra.go:352:				defaultValue, ok = cast.CastInterfaceToFloatList[float64](*parameter.Default)`
- L2188: `pkg/cmds/fields/cobra.go:354:					return errors.Errorf("Default value for parameter %s is not a float list: %v", parameter.Name, *parameter.Default)`
- L2189: `pkg/cmds/fields/cobra.go:357:			if parameter.ShortFlag != "" {`
- L2190: `pkg/cmds/fields/cobra.go:366:			if parameter.Default != nil {`
- L2191: `pkg/cmds/fields/cobra.go:367:				defaultValue, err = cast.ToString(*parameter.Default)`
- L2192: `pkg/cmds/fields/cobra.go:369:					return errors.Errorf("Default value for parameter %s is not a string: %v", parameter.Name, *parameter.Default)`
- L2193: `pkg/cmds/fields/cobra.go:373:			choiceString := strings.Join(parameter.Choices, ",")`
- L2194: `pkg/cmds/fields/cobra.go:375:			if parameter.ShortFlag != "" {`
- L2195: `pkg/cmds/fields/cobra.go:382:			return errors.Errorf("Unknown parameter type for parameter %s: %s", parameter.Name, parameter.Type)`
- L2196: `pkg/cmds/fields/cobra.go:395:// to the parameter description passed in params. The result is a map of parameter`
- L2197: `pkg/cmds/fields/cobra.go:398:// If onlyProvided is true, only parameters that are provided`
- L2198: `pkg/cmds/fields/cobra.go:401:// If a parameter cannot be parsed correctly, or is missing even though it is not optional,`
- L2199: `pkg/cmds/fields/cobra.go:404:// The required argument checks that all the required parameter definitions are present.`
- L2200: `pkg/cmds/fields/cobra.go:413:) (*ParsedParameters, error) {`
- L2201: `pkg/cmds/fields/cobra.go:414:	ps := NewParsedParameters()`
- L2202: `pkg/cmds/fields/cobra.go:417:		p := &ParsedParameter{`
- L2203: `pkg/cmds/fields/cobra.go:435:				return errors.Errorf("Parameter %s is required", pd.Name)`
- L2204: `pkg/cmds/fields/cobra.go:468:			v2, err := pd.ParseParameter([]string{v}, options...)`
- L2205: `pkg/cmds/fields/cobra.go:515:			v2, err := pd.ParseParameter(v, options...)`
- L2206: `pkg/cmds/fields/cobra.go:552:				v2, err := pd.ParseParameter(v, options...)`
- L2207: `pkg/cmds/test-data/cobra/02-key-value.yaml:13:    flagParameters:`
- L2208: `pkg/cmds/test-data/cobra/01-test-simple.yaml:18:    argumentParameters:`
- L2209: `pkg/cmds/test-data/cobra/01-test-simple.yaml:23:    flagParameters:`
- L2210: `pkg/cmds/test-data/cobra/01-test-simple.yaml:28:    argumentParameters:`
- L2211: `pkg/cmds/test-data/cobra/01-test-simple.yaml:32:    flagParameters:`
- L2212: `pkg/cmds/fields/parse.go:29:// ParseParameter parses command line arguments according to the given Definition.`
- L2213: `pkg/cmds/fields/parse.go:30:// It returns the parsed parameter value and a non-nil error if parsing failed.`
- L2214: `pkg/cmds/fields/parse.go:36:// If the parameter is required and not provided, an error is returned.`
- L2215: `pkg/cmds/fields/parse.go:37:// If the parameter is optional and not provided, the default value is returned.`
- L2216: `pkg/cmds/fields/parse.go:81:func (p *Definition) ParseParameter(v []string, options ...ParseOption) (*ParsedParameter, error) {`
- L2217: `pkg/cmds/fields/parse.go:82:	ret := &ParsedParameter{`
- L2218: `pkg/cmds/fields/parse.go:316:				// TODO(2023-02-11): The separator could be stored in the parameter itself?`
- L2219: `pkg/cmds/fields/parse.go:342:		return nil, errors.Errorf("Unknown parameter type %s", p.Type)`
- L2220: `pkg/cmds/fields/parse.go:355:func parseFromFileName(fileName string, p *Definition, options ...ParseOption) (*ParsedParameter, error) {`
- L2221: `pkg/cmds/fields/parse.go:356:	ret := &ParsedParameter{`
- L2222: `pkg/cmds/fields/parse.go:440:// In the case of parameters taking multiple files, this needs to be called for each file`
- L2223: `pkg/cmds/fields/parse.go:445:) (*ParsedParameter, error) {`
- L2224: `pkg/cmds/fields/parse.go:446:	ret := &ParsedParameter{`
- L2225: `pkg/cmds/fields/parse.go:607:		return nil, errors.New("Cannot parse from file for this parameter type")`
- L2226: `pkg/cmds/fields/parse.go:615:) (*ParsedParameter, error) {`
- L2227: `pkg/cmds/fields/parse.go:616:	ret := &ParsedParameter{`
- L2228: `pkg/help/store/compat.go:11:// HelpSystem provides a compatibility layer with the existing help system interface`
- L2229: `pkg/cmds/test-data/cobra/03-string-from-file.yaml:11:    flagParameters:`
- L2230: `pkg/cmds/test-data/cobra/03-string-from-file.yaml:16:    flagParameters:`
- L2231: `pkg/cmds/fields/initialize-struct_test.go:17:// TestInitializeStructWithValidStruct tests initializing a struct with valid parameters`
- L2232: `pkg/cmds/fields/initialize-struct_test.go:19:	parsedParams := fields.NewParsedParameters(`
- L2233: `pkg/cmds/fields/initialize-struct_test.go:20:		fields.WithParsedParameter(`
- L2234: `pkg/cmds/fields/initialize-struct_test.go:26:		fields.WithParsedParameter(`
- L2235: `pkg/cmds/fields/initialize-struct_test.go:44:	parsedParams := &fields.ParsedParameters{}`
- L2236: `pkg/cmds/fields/initialize-struct_test.go:54:	parsedParams := &fields.ParsedParameters{}`
- L2237: `pkg/cmds/fields/initialize-struct_test.go:65:	parsedParams := &fields.ParsedParameters{}`
- L2238: `pkg/cmds/fields/initialize-struct_test.go:74:// TestInitializeStructWithMissingParameters tests initializing a struct with missing parameters`
- L2239: `pkg/cmds/fields/initialize-struct_test.go:75:func TestInitializeStructWithMissingParameters(t *testing.T) {`
- L2240: `pkg/cmds/fields/initialize-struct_test.go:76:	parsedParams := fields.NewParsedParameters(`
- L2241: `pkg/cmds/fields/initialize-struct_test.go:77:		fields.WithParsedParameter(`
- L2242: `pkg/cmds/fields/initialize-struct_test.go:100:	parsedParams := fields.NewParsedParameters(`
- L2243: `pkg/cmds/fields/initialize-struct_test.go:101:		fields.WithParsedParameter(`
- L2244: `pkg/cmds/fields/initialize-struct_test.go:123:	parsedParams := fields.NewParsedParameters(`
- L2245: `pkg/cmds/fields/initialize-struct_test.go:124:		fields.WithParsedParameter(`
- L2246: `pkg/cmds/fields/initialize-struct_test.go:146:	parsedParams := fields.NewParsedParameters(`
- L2247: `pkg/cmds/fields/initialize-struct_test.go:147:		fields.WithParsedParameter(`
- L2248: `pkg/cmds/fields/initialize-struct_test.go:169:	parsedParams := fields.NewParsedParameters(`
- L2249: `pkg/cmds/fields/initialize-struct_test.go:170:		fields.WithParsedParameter(`
- L2250: `pkg/cmds/fields/initialize-struct_test.go:199:	parsedParams := fields.NewParsedParameters(`
- L2251: `pkg/cmds/fields/initialize-struct_test.go:200:		fields.WithParsedParameter(`
- L2252: `pkg/cmds/fields/initialize-struct_test.go:222:	parsedParams := fields.NewParsedParameters(`
- L2253: `pkg/cmds/fields/initialize-struct_test.go:223:		fields.WithParsedParameter(`
- L2254: `pkg/cmds/fields/initialize-struct_test.go:244:// TestInitializeStructWithWildcardMultipleMatches tests wildcard pattern matching multiple parameters`
- L2255: `pkg/cmds/fields/initialize-struct_test.go:246:	parsedParams := fields.NewParsedParameters(`
- L2256: `pkg/cmds/fields/initialize-struct_test.go:247:		fields.WithParsedParameter(`
- L2257: `pkg/cmds/fields/initialize-struct_test.go:253:		fields.WithParsedParameter(`
- L2258: `pkg/cmds/fields/initialize-struct_test.go:271:// TestInitializeStructWithWildcardNoMatches tests wildcard pattern matching no parameters`
- L2259: `pkg/cmds/fields/initialize-struct_test.go:273:	parsedParams := fields.NewParsedParameters()`
- L2260: `pkg/cmds/fields/initialize-struct_test.go:288:	parsedParams := fields.NewParsedParameters(`
- L2261: `pkg/cmds/fields/initialize-struct_test.go:289:		fields.WithParsedParameter(`
- L2262: `pkg/cmds/fields/initialize-struct_test.go:301:	assert.Contains(t, err.Error(), "wildcard parameters require a map field")`
- L2263: `pkg/cmds/fields/initialize-struct_test.go:310:	parsedParams := fields.NewParsedParameters(`
- L2264: `pkg/cmds/fields/initialize-struct_test.go:311:		fields.WithParsedParameter(`
- L2265: `pkg/cmds/fields/initialize-struct_test.go:317:		fields.WithParsedParameter(`
- L2266: `pkg/cmds/fields/initialize-struct_test.go:334:	parsedParams := fields.NewParsedParameters(`
- L2267: `pkg/cmds/fields/initialize-struct_test.go:335:		fields.WithParsedParameter(`
- L2268: `pkg/cmds/fields/initialize-struct_test.go:358:	parsedParams := fields.NewParsedParameters(`
- L2269: `pkg/cmds/fields/initialize-struct_test.go:359:		fields.WithParsedParameter(`
- L2270: `pkg/cmds/fields/initialize-struct_test.go:365:		fields.WithParsedParameter(`
- L2271: `pkg/cmds/fields/initialize-struct_test.go:371:		fields.WithParsedParameter(`
- L2272: `pkg/cmds/fields/initialize-struct_test.go:395:	parsedParams := fields.NewParsedParameters(`
- L2273: `pkg/cmds/fields/initialize-struct_test.go:396:		fields.WithParsedParameter(`
- L2274: `pkg/cmds/fields/initialize-struct_test.go:451:	assert.Contains(t, err.Error(), "wildcard parameters require a map field")`
- L2275: `pkg/cmds/fields/initialize-struct_test.go:528:	parsedParams := fields.NewParsedParameters(`
- L2276: `pkg/cmds/fields/initialize-struct_test.go:529:		fields.WithParsedParameter(`
- L2277: `pkg/cmds/fields/initialize-struct_test.go:563:	parsedParams := fields.NewParsedParameters(`
- L2278: `pkg/cmds/fields/initialize-struct_test.go:564:		fields.WithParsedParameter(`
- L2279: `pkg/cmds/fields/initialize-struct_test.go:591:	parsedParams := fields.NewParsedParameters(`
- L2280: `pkg/cmds/fields/initialize-struct_test.go:592:		fields.WithParsedParameter(`
- L2281: `pkg/cmds/fields/initialize-struct_test.go:617:	parsedParams := fields.NewParsedParameters(`
- L2282: `pkg/cmds/fields/initialize-struct_test.go:618:		fields.WithParsedParameter(`
- L2283: `pkg/cmds/fields/initialize-struct_test.go:643:	parsedParams := fields.NewParsedParameters(`
- L2284: `pkg/cmds/fields/initialize-struct_test.go:644:		fields.WithParsedParameter(`
- L2285: `pkg/cmds/fields/initialize-struct_test.go:679:	parsedParams := fields.NewParsedParameters(`
- L2286: `pkg/cmds/fields/initialize-struct_test.go:680:		fields.WithParsedParameter(`
- L2287: `pkg/cmds/fields/initialize-struct_test.go:706:	parsedParams := fields.NewParsedParameters(`
- L2288: `pkg/cmds/fields/initialize-struct_test.go:707:		fields.WithParsedParameter(`
- L2289: `pkg/cmds/fields/initialize-struct_test.go:746:	parsedParams := fields.NewParsedParameters(`
- L2290: `pkg/cmds/fields/initialize-struct_test.go:747:		fields.WithParsedParameter(`
- L2291: `pkg/help/store/README.md:23:- **Compat**: Compatibility layer for existing help system interface`
- L2292: `pkg/help/store/README.md:197:## Compatibility Layer`
- L2293: `pkg/help/store/README.md:241:The predicate system is more powerful than the existing `SectionQuery`, but the compatibility layer ensures existing code continues to work.`
- L2294: `pkg/cmds/fields/initialize-struct.go:55:// InitializeStruct initializes a struct from a ParsedParameters map.`
- L2295: `pkg/cmds/fields/initialize-struct.go:59:// parameter value in the ParsedParameters map and set the field's value.`
- L2296: `pkg/cmds/fields/initialize-struct.go:61:// If the tag open `from_json` is appended to `glazed` and the parameter`
- L2297: `pkg/cmds/fields/initialize-struct.go:64:// If the tag contains a wildcard, the function will match parameter names against the`
- L2298: `pkg/cmds/fields/initialize-struct.go:76:// ps is the ParsedParameters map to lookup parameter values from.`
- L2299: `pkg/cmds/fields/initialize-struct.go:130:// - A tagged field does not have a matching parameter value in ps`
- L2300: `pkg/cmds/fields/initialize-struct.go:132:func (p *ParsedParameters) InitializeStruct(s interface{}) error {`
- L2301: `pkg/cmds/fields/initialize-struct.go:160:				return errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)`
- L2302: `pkg/cmds/fields/initialize-struct.go:166:			parameter, ok := p.Get(options.Name)`
- L2303: `pkg/cmds/fields/initialize-struct.go:171:			if err := p.setTargetValue(dst, parameter.Value, options.FromJson); err != nil {`
- L2304: `pkg/cmds/fields/initialize-struct.go:179:// setWildcardValues matches parameter names from ParsedParameters against a supplied pattern using the`
- L2305: `pkg/cmds/fields/initialize-struct.go:187:// using the parameter name as the key and the parameter value as the map value.`
- L2306: `pkg/cmds/fields/initialize-struct.go:191:// Parameters:`
- L2307: `pkg/cmds/fields/initialize-struct.go:192://   - dst: A reflect.Value acting as the container for storing the matched keys and their parameter values.`
- L2308: `pkg/cmds/fields/initialize-struct.go:193://   - pattern: String pattern used for matching parameter names. It can include literal characters,`
- L2309: `pkg/cmds/fields/initialize-struct.go:195:func (p *ParsedParameters) setWildcardValues(dst reflect.Value, pattern string, fromJson bool) error {`
- L2310: `pkg/cmds/fields/initialize-struct.go:208:	err := p.ForEachE(func(paramName string, parameter *ParsedParameter) error {`
- L2311: `pkg/cmds/fields/initialize-struct.go:210:			// Check if the type of parameter.Value is compatible with the map's value type`
- L2312: `pkg/cmds/fields/initialize-struct.go:211:			if reflect.TypeOf(parameter.Value) != elemType {`
- L2313: `pkg/cmds/fields/initialize-struct.go:212:				return errors.Errorf("type mismatch: expected type %s, got %s", elemType, reflect.TypeOf(parameter.Value))`
- L2314: `pkg/cmds/fields/initialize-struct.go:215:			paramValue := reflect.ValueOf(parameter.Value)`
- L2315: `pkg/cmds/fields/initialize-struct.go:217:			// Check if the type of parameter.Value is directly assignable to the map's value type`
- L2316: `pkg/cmds/fields/initialize-struct.go:219:				// Check if the type of parameter.Value can be converted to the map's value type`
- L2317: `pkg/cmds/fields/initialize-struct.go:281:func (p *ParsedParameters) handleFromJSON(dst reflect.Value, value interface{}) error {`
- L2318: `pkg/cmds/fields/initialize-struct.go:307:func (p *ParsedParameters) handleFileData(dst reflect.Value, value interface{}) (bool, error) {`
- L2319: `pkg/cmds/fields/initialize-struct.go:389:func (p *ParsedParameters) setTargetValue(dst reflect.Value, value interface{}, fromJson bool) error {`
- L2320: `pkg/cmds/fields/initialize-struct.go:482:				return nil, errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)`
- L2321: `pkg/cmds/fields/parse_test.go:20:type ParameterTestCase struct {`
- L2322: `pkg/cmds/fields/parse_test.go:66:type ParameterTest struct {`
- L2323: `pkg/cmds/fields/parse_test.go:71:	Cases        []ParameterTestCase`
- L2324: `pkg/cmds/fields/parse_test.go:74:func TestParameterDate(t *testing.T) {`
- L2325: `pkg/cmds/fields/parse_test.go:75:	cases := []ParameterTestCase{`
- L2326: `pkg/cmds/fields/parse_test.go:203:	parameter := New(`
- L2327: `pkg/cmds/fields/parse_test.go:211:			got, err := parameter.ParseParameter(tc.Input)`
- L2328: `pkg/cmds/fields/parse_test.go:225:func TestParseParameter(t *testing.T) {`
- L2329: `pkg/cmds/fields/parse_test.go:226:	tests := []ParameterTest{`
- L2330: `pkg/cmds/fields/parse_test.go:228:			Name:         "ParameterString",`
- L2331: `pkg/cmds/fields/parse_test.go:231:			Cases: []ParameterTestCase{`
- L2332: `pkg/cmds/fields/parse_test.go:238:			Name:         "ParameterStringList",`
- L2333: `pkg/cmds/fields/parse_test.go:241:			Cases: []ParameterTestCase{`
- L2334: `pkg/cmds/fields/parse_test.go:248:			Name:         "ParameterInt",`
- L2335: `pkg/cmds/fields/parse_test.go:251:			Cases: []ParameterTestCase{`
- L2336: `pkg/cmds/fields/parse_test.go:259:			Name:         "ParameterIntegerList",`
- L2337: `pkg/cmds/fields/parse_test.go:262:			Cases: []ParameterTestCase{`
- L2338: `pkg/cmds/fields/parse_test.go:271:			Name:         "ParameterBool",`
- L2339: `pkg/cmds/fields/parse_test.go:274:			Cases: []ParameterTestCase{`
- L2340: `pkg/cmds/fields/parse_test.go:283:			Name:         "ParameterFloat",`
- L2341: `pkg/cmds/fields/parse_test.go:286:			Cases: []ParameterTestCase{`
- L2342: `pkg/cmds/fields/parse_test.go:294:			Name:         "ParameterFloatList",`
- L2343: `pkg/cmds/fields/parse_test.go:297:			Cases: []ParameterTestCase{`
- L2344: `pkg/cmds/fields/parse_test.go:305:			Name:         "ParameterChoice",`
- L2345: `pkg/cmds/fields/parse_test.go:309:			Cases: []ParameterTestCase{`
- L2346: `pkg/cmds/fields/parse_test.go:317:			Name:         "ParameterChoiceList",`
- L2347: `pkg/cmds/fields/parse_test.go:321:			Cases: []ParameterTestCase{`
- L2348: `pkg/cmds/fields/parse_test.go:333:			Cases: []ParameterTestCase{`
- L2349: `pkg/cmds/fields/parse_test.go:343:		parameter := New(`
- L2350: `pkg/cmds/fields/parse_test.go:351:				got, err := parameter.ParseParameter(tc.Input)`
- L2351: `pkg/cmds/fields/parse_test.go:364:	parameter := New("test", TypeStringListFromFile,`
- L2352: `pkg/cmds/fields/parse_test.go:369:	i, err := parameter.ParseFromReader(reader, "test.txt")`
- L2353: `pkg/cmds/fields/parse_test.go:374:	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L2354: `pkg/cmds/fields/parse_test.go:379:	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L2355: `pkg/cmds/fields/parse_test.go:385:	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L2356: `pkg/cmds/fields/parse_test.go:391:	i, err = parameter.ParseFromReader(reader, "test.json")`
- L2357: `pkg/cmds/fields/parse_test.go:397:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2358: `pkg/cmds/fields/parse_test.go:402:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2359: `pkg/cmds/fields/parse_test.go:407:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2360: `pkg/cmds/fields/parse_test.go:412:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2361: `pkg/cmds/fields/parse_test.go:417:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2362: `pkg/cmds/fields/parse_test.go:422:	i, err = parameter.ParseFromReader(reader, "test.json")`
- L2363: `pkg/cmds/fields/parse_test.go:429:	i, err = parameter.ParseFromReader(reader, "test.yaml")`
- L2364: `pkg/cmds/fields/parse_test.go:435:	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L2365: `pkg/cmds/fields/parse_test.go:442:	parameter := New("test", TypeObjectFromFile,`
- L2366: `pkg/cmds/fields/parse_test.go:447:	i, err := parameter.ParseFromReader(reader, "test.json")`
- L2367: `pkg/cmds/fields/parse_test.go:452:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2368: `pkg/cmds/fields/parse_test.go:456:	i, err = parameter.ParseFromReader(reader, "test.json")`
- L2369: `pkg/cmds/fields/parse_test.go:461:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2370: `pkg/cmds/fields/parse_test.go:466:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2371: `pkg/cmds/fields/parse_test.go:471:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2372: `pkg/cmds/fields/parse_test.go:476:	_, err = parameter.ParseFromReader(reader, "test.json")`
- L2373: `pkg/cmds/fields/parse_test.go:481:	i, err = parameter.ParseFromReader(reader, "test.yaml")`
- L2374: `pkg/cmds/fields/parse_test.go:486:	i, err = parameter.ParseFromReader(reader, "test.yml")`
- L2375: `pkg/cmds/fields/parse_test.go:492:	i, err = parameter.ParseFromReader(reader, "test.yaml")`
- L2376: `pkg/cmds/fields/parse_test.go:498:	_, err = parameter.ParseFromReader(reader, "test.yaml")`
- L2377: `pkg/cmds/fields/parse_test.go:503:	_, err = parameter.ParseFromReader(reader, "test.yaml")`
- L2378: `pkg/cmds/fields/parse_test.go:509:	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L2379: `pkg/cmds/fields/parse_test.go:517:	_, err = parameter.ParseFromReader(reader, "test.csv")`
- L2380: `pkg/cmds/fields/parse_test.go:522:	_, err = parameter.ParseFromReader(reader, "test.csv")`
- L2381: `pkg/cmds/fields/parse_test.go:527:	_, err = parameter.ParseFromReader(reader, "test.csv")`
- L2382: `pkg/cmds/fields/parse_test.go:533:	i, err = parameter.ParseFromReader(reader, "test.tsv")`
- L2383: `pkg/cmds/fields/parse_test.go:540:	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L2384: `pkg/cmds/fields/parse_test.go:547:	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L2385: `pkg/cmds/fields/parse_test.go:553:	parameter := New("test", TypeObjectListFromFile,`
- L2386: `pkg/cmds/fields/parse_test.go:557:	v, err := parseObjectListFromString(parameter, `[{"test":"test"}]`, "test.json")`
- L2387: `pkg/cmds/fields/parse_test.go:562:	v, err = parseObjectListFromString(parameter, `[{"test":"test"},{"test2":"test2"}]`, "test.json")`
- L2388: `pkg/cmds/fields/parse_test.go:566:	_, err = parseObjectListFromString(parameter, `{"test":"test"`, "test.json")`
- L2389: `pkg/cmds/fields/parse_test.go:569:	v, err = parseObjectListFromString(parameter, `[{"test":{"test":"test"}}]`, "test.json")`
- L2390: `pkg/cmds/fields/parse_test.go:574:	v, err = parseObjectListFromString(parameter, `[]`, "test.json")`
- L2391: `pkg/cmds/fields/parse_test.go:579:	_, err = parseObjectListFromString(parameter, ``, "test.json")`
- L2392: `pkg/cmds/fields/parse_test.go:583:	_, err = parseObjectListFromString(parameter, `["test"]`, "test.json")`
- L2393: `pkg/cmds/fields/parse_test.go:587:	v, err = parseObjectListFromString(parameter, `{"test":"test"}`
- L2394: `pkg/cmds/fields/parse_test.go:593:	_, err = parseObjectListFromString(parameter, `{"test":"test"}{"test2":"test2"}`, "test.ndjson")`
- L2395: `pkg/cmds/fields/parse_test.go:597:	v, err = parseObjectListFromString(parameter, `{"test":"test"}`, "test.ndjson")`
- L2396: `pkg/cmds/fields/parse_test.go:602:	_, err = parseObjectListFromString(parameter, `{"test":"test"}`
- L2397: `pkg/cmds/fields/parse_test.go:607:	v, err = parseObjectListFromString(parameter, `- test: test`, "test.yaml")`
- L2398: `pkg/cmds/fields/parse_test.go:611:	v, err = parseObjectListFromString(parameter, `- test: test`, "test.yml")`
- L2399: `pkg/cmds/fields/parse_test.go:616:	v, err = parseObjectListFromString(parameter, `- test: test`
- L2400: `pkg/cmds/fields/parse_test.go:622:	v, err = parseObjectListFromString(parameter, `- test: {test: test}`, "test.yaml")`
- L2401: `pkg/cmds/fields/parse_test.go:627:	_, err = parseObjectListFromString(parameter, `- test`
- L2402: `pkg/cmds/fields/parse_test.go:632:	v, err = parseObjectListFromString(parameter, `test: test`, "test.yaml")`
- L2403: `pkg/cmds/fields/parse_test.go:637:	v, err = parseObjectListFromString(parameter, `[]`, "test.yaml")`
- L2404: `pkg/cmds/fields/parse_test.go:642:	_, err = parseObjectListFromString(parameter, ``, "test.yaml")`
- L2405: `pkg/cmds/fields/parse_test.go:646:	v, err = parseObjectListFromString(parameter, `test,test2`
- L2406: `pkg/cmds/fields/parse_test.go:652:	v, err = parseObjectListFromString(parameter, `test,test2`
- L2407: `pkg/cmds/fields/parse_test.go:659:	_, err = parseObjectListFromString(parameter, `test,test2`, "test.csv")`
- L2408: `pkg/cmds/fields/parse_test.go:663:	v, err = parseObjectListFromString(parameter, ``, "test.csv")`
- L2409: `pkg/cmds/fields/parse_test.go:668:	v, err = parseObjectListFromString(parameter, `test,test2`
- L2410: `pkg/cmds/fields/parse_test.go:675:func parseObjectListFromString(parameter *Definition, input string, fileName string) ([]map[string]interface{}, error) {`
- L2411: `pkg/cmds/fields/parse_test.go:677:	i, err := parameter.ParseFromReader(reader, fileName)`
- L2412: `pkg/cmds/fields/parse_test.go:689:	parameter := New("test", TypeStringFromFile,`
- L2413: `pkg/cmds/fields/parse_test.go:694:	i, err := parameter.ParseFromReader(reader, "test.txt")`
- L2414: `pkg/cmds/fields/parse_test.go:700:	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L2415: `pkg/cmds/fields/parse_test.go:705:	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L2416: `pkg/cmds/fields/parse_test.go:711:	parameter := New("test", TypeStringFromFile,`
- L2417: `pkg/cmds/fields/parse_test.go:715:	v, err := parameter.ParseParameter([]string{"test-data/string.txt"})`
- L2418: `pkg/cmds/fields/parse_test.go:719:	parameter = New("test", TypeStringFromFiles,`
- L2419: `pkg/cmds/fields/parse_test.go:722:	v, err = parameter.ParseParameter([]string{"test-data/string.txt"})`
- L2420: `pkg/cmds/fields/parse_test.go:726:	v, err = parameter.ParseParameter([]string{"test-data/string.txt", "test-data/string2.txt"})`
- L2421: `pkg/cmds/fields/parse_test.go:732:	parameter := New("test", TypeStringListFromFile,`
- L2422: `pkg/cmds/fields/parse_test.go:736:	v, err := parameter.ParseParameter([]string{"test-data/string.txt"})`
- L2423: `pkg/cmds/fields/parse_test.go:740:	v, err = parameter.ParseParameter([]string{"test-data/stringList.csv"})`
- L2424: `pkg/cmds/fields/parse_test.go:744:	v, err = parameter.ParseParameter([]string{"test-data/stringList.csv", "test-data/stringList2.csv"})`
- L2425: `pkg/cmds/fields/parse_test.go:748:	parameter = New("test", TypeStringListFromFiles,`
- L2426: `pkg/cmds/fields/parse_test.go:751:	v, err = parameter.ParseParameter([]string{"test-data/string.txt"})`
- L2427: `pkg/cmds/fields/parse_test.go:755:	v, err = parameter.ParseParameter([]string{"test-data/string.txt", "test-data/string2.txt"})`
- L2428: `pkg/cmds/fields/parse_test.go:761:	parameter := New("test", TypeObjectListFromFile,`
- L2429: `pkg/cmds/fields/parse_test.go:765:	v, err := parameter.ParseParameter([]string{"test-data/object.json"})`
- L2430: `pkg/cmds/fields/parse_test.go:769:	v, err = parameter.ParseParameter([]string{"test-data/objectList.json"})`
- L2431: `pkg/cmds/fields/parse_test.go:783:	v, err = parameter.ParseParameter([]string{"test-data/objectList3.csv"})`
- L2432: `pkg/cmds/fields/parse_test.go:797:	parameter = New("test", TypeObjectListFromFiles,`
- L2433: `pkg/cmds/fields/parse_test.go:801:	v, err = parameter.ParseParameter([]string{"test-data/object.json"})`
- L2434: `pkg/cmds/fields/parse_test.go:805:	v, err = parameter.ParseParameter([]string{"test-data/object.json", "test-data/object2.json"})`
- L2435: `pkg/cmds/fields/parse_test.go:820:	v, err = parameter.ParseParameter([]string{`
- L2436: `pkg/cmds/fields/parse_test.go:931:			_, err := param.CheckParameterDefaultValueValidity()`
- L2437: `pkg/cmds/fields/parse_test.go:944:	_, err := param.CheckParameterDefaultValueValidity()`
- L2438: `pkg/cmds/fields/parse_test.go:961:		_, err := param.CheckParameterDefaultValueValidity()`
- L2439: `pkg/doc/tutorials/05-build-first-command.md:24:- Understand command configuration and parameter handling`
- L2440: `pkg/doc/tutorials/05-build-first-command.md:79:Every Glazed command follows a consistent pattern: a command struct embeds `*cmds.CommandDescription` for metadata, and a settings struct maps command-line flags to Go fields using struct tags for type-safe parameter access.`
- L2441: `pkg/doc/tutorials/05-build-first-command.md:87:// Step 2.2: Define settings for type-safe parameter access`
- L2442: `pkg/doc/tutorials/05-build-first-command.md:97:1. **Command Struct**: `ListUsersCommand` embeds `*cmds.CommandDescription`, which contains command metadata (name, help text, parameters)`
- L2443: `pkg/doc/tutorials/05-build-first-command.md:153:### Command Configuration and Parameters`
- L2444: `pkg/doc/tutorials/05-build-first-command.md:155:Command configuration combines your custom fields with Glazed's built-in output formatting capabilities. The `settings.NewGlazedSchema()` helper (a wrapper around `settings.NewGlazedParameterLayers()`) adds standard flags like `--output`, `--fields`, and `--sort-columns`, while your custom field definitions specify the command's business logic inputs.`
- L2445: `pkg/doc/tutorials/05-build-first-command.md:162:    glazedLayer, err := settings.NewGlazedSchema()`
- L2446: `pkg/doc/tutorials/05-build-first-command.md:167:    // Create command settings layer for debugging features`
- L2447: `pkg/doc/tutorials/05-build-first-command.md:168:    commandSettingsLayer, err := cli.NewCommandSettingsLayer()`
- L2448: `pkg/doc/tutorials/05-build-first-command.md:173:    // Define command with parameters`
- L2449: `pkg/doc/tutorials/05-build-first-command.md:215:        // Add glazed and command settings layers`
- L2450: `pkg/doc/tutorials/05-build-first-command.md:216:        cmds.WithLayersList(glazedLayer, commandSettingsLayer),`
- L2451: `pkg/doc/tutorials/05-build-first-command.md:227:1. **Glazed Schema Section**: `settings.NewGlazedSchema()` adds built-in parameters like `--output`, `--fields`, `--sort-columns` (and `cli.BuildCobraCommand` will auto-add it for `GlazeCommand` implementations if you don't)`
- L2452: `pkg/doc/tutorials/05-build-first-command.md:228:2. **Command Settings Layer**: `cli.NewCommandSettingsLayer()` adds debugging and configuration parameters:`
- L2453: `pkg/doc/tutorials/05-build-first-command.md:229:   - `--print-parsed-parameters`: Debug parameter parsing`
- L2454: `pkg/doc/tutorials/05-build-first-command.md:231:   - `--load-parameters-from-file`: Load settings from JSON file`
- L2455: `pkg/doc/tutorials/05-build-first-command.md:233:4. **Parameter Definitions**: Each flag specifies:`
- L2456: `pkg/doc/tutorials/05-build-first-command.md:238:5. **Layer Composition**: Combines custom parameters with Glazed's built-in layers`
- L2457: `pkg/doc/tutorials/05-build-first-command.md:328:3. **Filtering Logic**: Demonstrates how command parameters control data processing`
- L2458: `pkg/doc/tutorials/05-build-first-command.md:332:Glazed commands integrate with standard Cobra applications through the `cli.BuildCobraCommand()` builder function. This function handles the conversion between Glazed's parameter layer system and Cobra's flag parsing, automatically configuring output processing and help text generation. You can pass parser and mode options via `CobraParserConfig` and `CobraOption` helpers.`
- L2459: `pkg/doc/tutorials/05-build-first-command.md:354:            ShortHelpLayers: []string{schema.DefaultSlug},`
- L2460: `pkg/doc/tutorials/05-build-first-command.md:379:Glazed provides a logging layer you can attach to your root command. This exposes logging-related flags and initializes logging based on configuration. Initialize the logger in `PersistentPreRunE` using Cobra-parsed flags so logging is active before your command logic runs.`
- L2461: `pkg/doc/tutorials/05-build-first-command.md:399:    _ = logging.AddLoggingLayerToRootCommand(rootCmd, "glazed-quickstart")`
- L2462: `pkg/doc/tutorials/05-build-first-command.md:408:- Add logging flags with `logging.AddLoggingLayerToRootCommand(rootCmd, "<use-name>")`.`
- L2463: `pkg/doc/tutorials/05-build-first-command.md:410:- Alternatively, you can call `logging.SetupLoggingFromParsedLayers(parsedLayers)` after parsing for per-command logging settings.`
- L2464: `pkg/doc/tutorials/05-build-first-command.md:416:3. **Enhanced Cobra Bridge**: Use `cli.WithParserConfig` to pass a `CobraParserConfig` that customizes parser behavior (e.g., `ShortHelpLayers`, `MiddlewaresFunc`).`
- L2465: `pkg/doc/tutorials/05-build-first-command.md:425:- `--print-parsed-parameters`: Shows how parameters were parsed from different sources`
- L2466: `pkg/doc/tutorials/05-build-first-command.md:427:- `--print-schema`: Displays the command's parameter schema`
- L2467: `pkg/doc/tutorials/05-build-first-command.md:434:- **Contextual Help**: Provides detailed help based on command context and available layers`
- L2468: `pkg/doc/tutorials/05-build-first-command.md:435:- **Parameter Documentation**: Automatically generates help text from parameter definitions`
- L2469: `pkg/doc/tutorials/05-build-first-command.md:436:- **Layer-Aware Help**: Shows relevant parameters based on active layers`
- L2470: `pkg/doc/tutorials/05-build-first-command.md:441:Testing validates that your command properly parses parameters, processes data according to the business logic, and integrates correctly with Glazed's output system.`
- L2471: `pkg/doc/tutorials/05-build-first-command.md:450:# Try different parameter combinations`
- L2472: `pkg/doc/tutorials/05-build-first-command.md:457:./glazed-quickstart list-users --print-parsed-parameters`
- L2473: `pkg/doc/tutorials/05-build-first-command.md:468:1. **Help Text**: `--help` displays auto-generated parameter descriptions and examples with enhanced formatting`
- L2474: `pkg/doc/tutorials/05-build-first-command.md:469:2. **Parameter Validation**: Invalid values trigger automatic validation errors`
- L2475: `pkg/doc/tutorials/05-build-first-command.md:472:5. **Help Command**: `help` command provides contextual documentation and parameter guidance`
- L2476: `pkg/doc/tutorials/05-build-first-command.md:572:    // Add command settings layer for debugging features`
- L2477: `pkg/doc/tutorials/05-build-first-command.md:573:    commandSettingsLayer, err := cli.NewCommandSettingsLayer()`
- L2478: `pkg/doc/tutorials/05-build-first-command.md:591:        cmds.WithLayersList(commandSettingsLayer),`
- L2479: `pkg/doc/tutorials/05-build-first-command.md:633:        ShortHelpLayers: []string{schema.DefaultSlug},`
- L2480: `pkg/doc/tutorials/05-build-first-command.md:668:./glazed-quickstart status --print-parsed-parameters`
- L2481: `pkg/doc/tutorials/05-build-first-command.md:700:**Type Safety**: Use settings structs with `glazed` tags for automatic parameter parsing and validation.`
- L2482: `pkg/doc/tutorials/05-build-first-command.md:704:**Input Validation**: Validate business rules in your command implementation, not just parameter types:`
- L2483: `pkg/doc/tutorials/05-build-first-command.md:707:// Validate business rules after parameter parsing`
- L2484: `pkg/doc/tutorials/05-build-first-command.md:718:### Advanced Parameter Types`
- L2485: `pkg/doc/tutorials/05-build-first-command.md:720:Glazed supports various parameter types beyond basic strings, integers, and booleans:`
- L2486: `pkg/doc/tutorials/05-build-first-command.md:724:    // File parameter validates file exists`
- L2487: `pkg/doc/tutorials/05-build-first-command.md:731:    // Choice parameter limits valid options`
- L2488: `pkg/doc/tutorials/05-build-first-command.md:778:glaze help layers-guide`
- L2489: `pkg/doc/tutorials/05-build-first-command.md:781:Learn about parameter layers for organizing reusable configuration sets across commands.`
- L2490: `pkg/doc/tutorials/05-build-first-command.md:798:glaze help custom-layer`
- L2491: `pkg/doc/tutorials/05-build-first-command.md:801:Create domain-specific parameter layers for your application's needs.`
- L2492: `pkg/cmds/sources/update.go:12:// FromDefaults is a middleware that sets default values from parameter definitions.`
- L2493: `pkg/cmds/sources/update.go:13:// It calls the next handler, and then iterates through each layer and parameter definition.`
- L2494: `pkg/cmds/sources/update.go:14:// If a default is defined, it sets that as the parameter value in the parsed layer.`
- L2495: `pkg/cmds/sources/update.go:17:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2496: `pkg/cmds/sources/update.go:18:			err := next(layers_, parsedLayers)`
- L2497: `pkg/cmds/sources/update.go:22:			err = layers_.UpdateWithDefaults(parsedLayers, options...)`
- L2498: `pkg/cmds/sources/update.go:31:// FromMap takes a map where the keys are layer slugs and the values are`
- L2499: `pkg/cmds/sources/update.go:32:// maps of parameter name -> value. It calls next, and then merges the provided`
- L2500: `pkg/cmds/sources/update.go:33:// values into the parsed layers, skipping any layers not present in layers_.`
- L2501: `pkg/cmds/sources/update.go:36:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2502: `pkg/cmds/sources/update.go:37:			err := next(layers_, parsedLayers)`
- L2503: `pkg/cmds/sources/update.go:42:			return updateFromMap(layers_, parsedLayers, m, options...)`
- L2504: `pkg/cmds/sources/update.go:47:// FromMapFirst takes a map where the keys are layer slugs and the values are`
- L2505: `pkg/cmds/sources/update.go:48:// maps of parameter name -> value. It calls next, and then merges the provided`
- L2506: `pkg/cmds/sources/update.go:49:// values into the parsed layers, skipping any layers not present in layers_.`
- L2507: `pkg/cmds/sources/update.go:52:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2508: `pkg/cmds/sources/update.go:53:			err := updateFromMap(layers_, parsedLayers, m, options...)`
- L2509: `pkg/cmds/sources/update.go:58:			return next(layers_, parsedLayers)`
- L2510: `pkg/cmds/sources/update.go:63:// FromMapAsDefault takes a map where the keys are layer slugs and the values are`
- L2511: `pkg/cmds/sources/update.go:64:// maps of parameter name -> value. It calls next, and then merges the provided`
- L2512: `pkg/cmds/sources/update.go:65:// values into the parsed layers if the parameter hasn't already been set, skipping any layers not present in layers_.`
- L2513: `pkg/cmds/sources/update.go:68:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2514: `pkg/cmds/sources/update.go:69:			err := next(layers_, parsedLayers)`
- L2515: `pkg/cmds/sources/update.go:74:			return updateFromMapAsDefault(layers_, parsedLayers, m, options...)`
- L2516: `pkg/cmds/sources/update.go:79:// FromMapAsDefaultFirst takes a map where the keys are layer slugs and the values are`
- L2517: `pkg/cmds/sources/update.go:80:// maps of parameter name -> value. It calls next, and then merges the provided`
- L2518: `pkg/cmds/sources/update.go:81:// values into the parsed layers if the parameter hasn't already been set, skipping any layers not present in layers_.`
- L2519: `pkg/cmds/sources/update.go:84:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2520: `pkg/cmds/sources/update.go:85:			err := updateFromMapAsDefault(layers_, parsedLayers, m, options...)`
- L2521: `pkg/cmds/sources/update.go:90:			return next(layers_, parsedLayers)`
- L2522: `pkg/cmds/sources/update.go:96:	layers_ *schema.Schema,`
- L2523: `pkg/cmds/sources/update.go:97:	parsedLayers *values.Values,`
- L2524: `pkg/cmds/sources/update.go:101:		layer, ok := layers_.Get(k)`
- L2525: `pkg/cmds/sources/update.go:106:		parsedLayer := parsedLayers.GetOrCreate(layer)`
- L2526: `pkg/cmds/sources/update.go:107:		ps, err := layer.GetDefinitions().GatherParametersFromMap(v, true, options...)`
- L2527: `pkg/cmds/sources/update.go:111:		_, err = parsedLayer.Parameters.Merge(ps)`
- L2528: `pkg/cmds/sources/update.go:120:	layers_ *schema.Schema,`
- L2529: `pkg/cmds/sources/update.go:121:	parsedLayers *values.Values,`
- L2530: `pkg/cmds/sources/update.go:125:		layer, ok := layers_.Get(k)`
- L2531: `pkg/cmds/sources/update.go:130:		parsedLayer := parsedLayers.GetOrCreate(layer)`
- L2532: `pkg/cmds/sources/update.go:131:		ps, err := layer.GetDefinitions().GatherParametersFromMap(v, true, options...)`
- L2533: `pkg/cmds/sources/update.go:135:		_, err = parsedLayer.Parameters.MergeAsDefault(ps)`
- L2534: `pkg/cmds/sources/update.go:144:	layers_ *schema.Schema,`
- L2535: `pkg/cmds/sources/update.go:145:	parsedLayers *values.Values,`
- L2536: `pkg/cmds/sources/update.go:149:	err := layers_.ForEachE(func(key string, l schema.Section) error {`
- L2537: `pkg/cmds/sources/update.go:150:		parsedLayer := parsedLayers.GetOrCreate(l)`
- L2538: `pkg/cmds/sources/update.go:152:		layerPrefix := l.GetPrefix()`
- L2539: `pkg/cmds/sources/update.go:154:			// Compute env key based on layer prefix + param name, hyphen->underscore, uppercase,`
- L2540: `pkg/cmds/sources/update.go:156:			base := layerPrefix + p.Name`
- L2541: `pkg/cmds/sources/update.go:170:				// Parse env string into the appropriate typed value using the parameter's parser.`
- L2542: `pkg/cmds/sources/update.go:193:				pp, err := p.ParseParameter(inputs, opts...)`
- L2543: `pkg/cmds/sources/update.go:198:				if err := parsedLayer.Parameters.UpdateWithLog(p.Name, p, pp.Value, pp.Log...); err != nil {`
- L2544: `pkg/cmds/sources/update.go:215:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2545: `pkg/cmds/sources/update.go:216:			err := next(layers_, parsedLayers)`
- L2546: `pkg/cmds/sources/update.go:221:			return updateFromEnv(layers_, parsedLayers, prefix, options...)`
- L2547: `pkg/cmds/sources/update.go:226:func updateFromStringList(layers_ *schema.Schema, parsedLayers *values.Values, prefix string, args []string, options ...fields.ParseOption) error {`
- L2548: `pkg/cmds/sources/update.go:227:	err := layers_.ForEachE(func(key string, l schema.Section) error {`
- L2549: `pkg/cmds/sources/update.go:228:		parsedLayer := parsedLayers.GetOrCreate(l)`
- L2550: `pkg/cmds/sources/update.go:235:		_, err = parsedLayer.Parameters.Merge(ps)`
- L2551: `pkg/cmds/sources/update.go:245:		_, err = parsedLayer.Parameters.Merge(ps)`
- L2552: `pkg/cmds/sources/update.go:262:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2553: `pkg/cmds/sources/update.go:263:			err := next(layers_, parsedLayers)`
- L2554: `pkg/cmds/sources/update.go:268:			return updateFromStringList(layers_, parsedLayers, prefix, args, options...)`
- L2555: `pkg/cmds/fields/errors.go:12:	return fmt.Sprintf("invalid value %v for parameter %s of type %s", e.Value, e.Name, e.Type)`
- L2556: `pkg/cmds/fields/serialize.go:9:// SerializableParsedParameter represents a parsed parameter in a format suitable for`
- L2557: `pkg/cmds/fields/serialize.go:11:type SerializableParsedParameter struct {`
- L2558: `pkg/cmds/fields/serialize.go:16:// ToSerializableParsedParameter converts a ParsedParameter to its serializable representation`
- L2559: `pkg/cmds/fields/serialize.go:17:func ToSerializableParsedParameter(pp *ParsedParameter) *SerializableParsedParameter {`
- L2560: `pkg/cmds/fields/serialize.go:18:	return &SerializableParsedParameter{`
- L2561: `pkg/cmds/fields/serialize.go:24:// SerializableParsedParameters represents a collection of parsed parameters in a format suitable`
- L2562: `pkg/cmds/fields/serialize.go:25:// for YAML/JSON serialization, maintaining the order of parameters`
- L2563: `pkg/cmds/fields/serialize.go:26:type SerializableParsedParameters struct {`
- L2564: `pkg/cmds/fields/serialize.go:27:	// Using orderedmap to maintain parameter order while having name-based access`
- L2565: `pkg/cmds/fields/serialize.go:28:	Parameters *orderedmap.OrderedMap[string, *SerializableParsedParameter] `yaml:"parameters" json:"parameters"``
- L2566: `pkg/cmds/fields/serialize.go:31:// ToSerializableParsedParameters converts a ParsedParameters collection to its serializable representation`
- L2567: `pkg/cmds/fields/serialize.go:32:func ToSerializableParsedParameters(pp *ParsedParameters) *SerializableParsedParameters {`
- L2568: `pkg/cmds/fields/serialize.go:33:	ret := &SerializableParsedParameters{`
- L2569: `pkg/cmds/fields/serialize.go:34:		Parameters: orderedmap.New[string, *SerializableParsedParameter](),`
- L2570: `pkg/cmds/fields/serialize.go:37:	pp.ForEach(func(key string, value *ParsedParameter) {`
- L2571: `pkg/cmds/fields/serialize.go:38:		serialized := ToSerializableParsedParameter(value)`
- L2572: `pkg/cmds/fields/serialize.go:39:		ret.Parameters.Set(key, serialized)`
- L2573: `pkg/cmds/fields/serialize.go:45:// MarshalYAML implements yaml.Marshaler for SerializableParsedParameters`
- L2574: `pkg/cmds/fields/serialize.go:46:func (spp *SerializableParsedParameters) MarshalYAML() (interface{}, error) {`
- L2575: `pkg/cmds/fields/serialize.go:48:	m := make(map[string]*SerializableParsedParameter)`
- L2576: `pkg/cmds/fields/serialize.go:49:	for pair := spp.Parameters.Oldest(); pair != nil; pair = pair.Next() {`
- L2577: `pkg/cmds/fields/serialize.go:55:// MarshalJSON implements json.Marshaler for SerializableParsedParameters`
- L2578: `pkg/cmds/fields/serialize.go:56:func (spp *SerializableParsedParameters) MarshalJSON() ([]byte, error) {`
- L2579: `pkg/cmds/fields/serialize.go:58:	m := make(map[string]*SerializableParsedParameter)`
- L2580: `pkg/cmds/fields/serialize.go:59:	for pair := spp.Parameters.Oldest(); pair != nil; pair = pair.Next() {`
- L2581: `pkg/cmds/fields/parameter-type.go:49:// NeedsFileContent returns true if the parameter type is one that loads one or more files, when provided with the given`
- L2582: `pkg/cmds/fields/parameter-type.go:71:// NeedsMultipleFileContent returns true if the parameter type is one that loads multiple files.`
- L2583: `pkg/cmds/fields/parameter-type.go:98:// IsList returns true if the parameter has to be parsed from a list of strings,`
- L2584: `pkg/cmds/sources/middlewares_test.go:21:	ParameterLayers []helpers.TestParameterLayer `yaml:"parameterLayers"``
- L2585: `pkg/cmds/sources/middlewares_test.go:22:	Values          []helpers.TestSectionValues  `yaml:"parsedLayers"``
- L2586: `pkg/cmds/sources/middlewares_test.go:23:	ExpectedLayers  []helpers.TestExpectedLayer  `yaml:"expectedLayers"``
- L2587: `pkg/cmds/sources/middlewares_test.go:40:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L2588: `pkg/cmds/sources/middlewares_test.go:41:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L2589: `pkg/cmds/sources/middlewares_test.go:44:			err := middleware(func(layers *schema.Schema, parsedLayers *values.Values) error {`
- L2590: `pkg/cmds/sources/middlewares_test.go:46:			})(layers_, parsedLayers)`
- L2591: `pkg/cmds/sources/middlewares_test.go:53:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L2592: `pkg/cmds/sources/middlewares_test.go:73:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L2593: `pkg/cmds/sources/middlewares_test.go:74:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L2594: `pkg/cmds/sources/middlewares_test.go:77:				layers_, parsedLayers,`
- L2595: `pkg/cmds/sources/middlewares_test.go:85:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L2596: `pkg/cmds/sources/middlewares_test.go:100:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L2597: `pkg/cmds/sources/middlewares_test.go:101:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L2598: `pkg/cmds/sources/middlewares_test.go:104:				layers_, parsedLayers,`
- L2599: `pkg/cmds/sources/middlewares_test.go:112:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L2600: `pkg/cmds/sources/middlewares_test.go:132:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L2601: `pkg/cmds/sources/middlewares_test.go:133:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L2602: `pkg/cmds/sources/middlewares_test.go:142:				layers_, parsedLayers,`
- L2603: `pkg/cmds/sources/middlewares_test.go:155:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L2604: `pkg/cmds/sources/middlewares_test.go:161://go:embed tests/wrap-with-restricted-layers.yaml`
- L2605: `pkg/cmds/sources/middlewares_test.go:162:var wrapWithRestrictedLayersTestsYAML string`
- L2606: `pkg/cmds/sources/middlewares_test.go:164:type wrapWithRestrictedLayersTest struct {`
- L2607: `pkg/cmds/sources/middlewares_test.go:174:func TestWrapWithRestrictedLayers(t *testing.T) {`
- L2608: `pkg/cmds/sources/middlewares_test.go:175:	tests, err := yaml.LoadTestFromYAML[[]wrapWithRestrictedLayersTest](wrapWithRestrictedLayersTestsYAML)`
- L2609: `pkg/cmds/sources/middlewares_test.go:180:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L2610: `pkg/cmds/sources/middlewares_test.go:181:			parsedLayers := values.New()`
- L2611: `pkg/cmds/sources/middlewares_test.go:189:				ms_ = append(ms_, sources.WrapWithBlacklistedLayers(tt.BlacklistedSlugs,`
- L2612: `pkg/cmds/sources/middlewares_test.go:193:				ms_ = append(ms_, sources.WrapWithWhitelistedLayers(tt.WhitelistedSlugs,`
- L2613: `pkg/cmds/sources/middlewares_test.go:201:				layers_, parsedLayers,`
- L2614: `pkg/cmds/sources/middlewares_test.go:210:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L2615: `pkg/cmds/sources/middlewares_test.go:230:			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L2616: `pkg/cmds/sources/middlewares_test.go:231:			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L2617: `pkg/cmds/sources/middlewares_test.go:236:			err = sources.Execute(layers_, parsedLayers, middlewares_...)`
- L2618: `pkg/cmds/sources/middlewares_test.go:244:				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L2619: `pkg/help/help.go:474:		fmt.Printf("Parameters: %v\n", args)`
- L2620: `pkg/cmds/fields/parsed-parameter.go:11:type ParsedParameter struct {`
- L2621: `pkg/cmds/fields/parsed-parameter.go:54:// Update sets the value of the parsedParameter, and appends a new parseStep.`
- L2622: `pkg/cmds/fields/parsed-parameter.go:55:func (p *ParsedParameter) Update(value interface{}, options ...ParseOption) error {`
- L2623: `pkg/cmds/fields/parsed-parameter.go:73:func (p *ParsedParameter) RenderValue() (string, error) {`
- L2624: `pkg/cmds/fields/parsed-parameter.go:77:// UpdateWithLog sets the value of the parsedParameter, and appends the given log.`
- L2625: `pkg/cmds/fields/parsed-parameter.go:78:func (p *ParsedParameter) UpdateWithLog(value interface{}, log ...ParseStep) error {`
- L2626: `pkg/cmds/fields/parsed-parameter.go:89:// Set sets the value of the parsedParameter, and manually updates the log`
- L2627: `pkg/cmds/fields/parsed-parameter.go:90:func (p *ParsedParameter) Set(value interface{}, log ...ParseStep) {`
- L2628: `pkg/cmds/fields/parsed-parameter.go:100:func (p *ParsedParameter) Merge(v *ParsedParameter, options ...ParseOption) {`
- L2629: `pkg/cmds/fields/parsed-parameter.go:107:func (p *ParsedParameter) Clone() *ParsedParameter {`
- L2630: `pkg/cmds/fields/parsed-parameter.go:108:	ret := &ParsedParameter{`
- L2631: `pkg/cmds/fields/parsed-parameter.go:117:// GetInterfaceValue returns the value as an interface{}. If the type of the parameter is a list,`
- L2632: `pkg/cmds/fields/parsed-parameter.go:120:func (p *ParsedParameter) GetInterfaceValue() (interface{}, error) {`
- L2633: `pkg/cmds/fields/parsed-parameter.go:121:	parameterType := p.Definition.Type`
- L2634: `pkg/cmds/fields/parsed-parameter.go:123:	case parameterType.IsList():`
- L2635: `pkg/cmds/fields/parsed-parameter.go:130:	case parameterType.IsObject(),`
- L2636: `pkg/cmds/fields/parsed-parameter.go:131:		parameterType.IsKeyValue():`
- L2637: `pkg/cmds/fields/parsed-parameter.go:134:	case parameterType.IsObjectList():`
- L2638: `pkg/cmds/fields/parsed-parameter.go:155:type ParsedParameters struct {`
- L2639: `pkg/cmds/fields/parsed-parameter.go:156:	*orderedmap.OrderedMap[string, *ParsedParameter]`
- L2640: `pkg/cmds/fields/parsed-parameter.go:159:type ParsedParametersOption func(*ParsedParameters)`
- L2641: `pkg/cmds/fields/parsed-parameter.go:161:func WithParsedParameter(pd *Definition, key string, value interface{}) ParsedParametersOption {`
- L2642: `pkg/cmds/fields/parsed-parameter.go:162:	return func(p *ParsedParameters) {`
- L2643: `pkg/cmds/fields/parsed-parameter.go:163:		p.Set(key, &ParsedParameter{`
- L2644: `pkg/cmds/fields/parsed-parameter.go:170:func NewParsedParameters(options ...ParsedParametersOption) *ParsedParameters {`
- L2645: `pkg/cmds/fields/parsed-parameter.go:171:	ret := &ParsedParameters{`
- L2646: `pkg/cmds/fields/parsed-parameter.go:172:		OrderedMap: orderedmap.New[string, *ParsedParameter](),`
- L2647: `pkg/cmds/fields/parsed-parameter.go:180:func (p *ParsedParameters) GetValue(key string) interface{} {`
- L2648: `pkg/cmds/fields/parsed-parameter.go:188:func (p *ParsedParameters) Clone() *ParsedParameters {`
- L2649: `pkg/cmds/fields/parsed-parameter.go:189:	ret := NewParsedParameters()`
- L2650: `pkg/cmds/fields/parsed-parameter.go:190:	p.ForEach(func(k string, v *ParsedParameter) {`
- L2651: `pkg/cmds/fields/parsed-parameter.go:196:// UpdateExistingValue updates the value of an existing parameter, and returns true if the parameter existed.`
- L2652: `pkg/cmds/fields/parsed-parameter.go:197:// If the parameter did not exist, it returns false.`
- L2653: `pkg/cmds/fields/parsed-parameter.go:198:func (p *ParsedParameters) UpdateExistingValue(`
- L2654: `pkg/cmds/fields/parsed-parameter.go:213:func (p *ParsedParameters) Update(`
- L2655: `pkg/cmds/fields/parsed-parameter.go:214:	key string, pp *ParsedParameter,`
- L2656: `pkg/cmds/fields/parsed-parameter.go:225:func (p *ParsedParameters) UpdateValue(`
- L2657: `pkg/cmds/fields/parsed-parameter.go:233:		v_ = &ParsedParameter{`
- L2658: `pkg/cmds/fields/parsed-parameter.go:245:func (p *ParsedParameters) MustUpdateValue(`
- L2659: `pkg/cmds/fields/parsed-parameter.go:252:		return errors.Errorf("parameter %s not found", key)`
- L2660: `pkg/cmds/fields/parsed-parameter.go:261:func (p *ParsedParameters) UpdateWithLog(`
- L2661: `pkg/cmds/fields/parsed-parameter.go:268:		v_ = &ParsedParameter{`
- L2662: `pkg/cmds/fields/parsed-parameter.go:280:// SetAsDefault sets the current value of the parameter if no value has yet been set.`
- L2663: `pkg/cmds/fields/parsed-parameter.go:281:func (p *ParsedParameters) SetAsDefault(`
- L2664: `pkg/cmds/fields/parsed-parameter.go:295:// in ParsedParameters.`
- L2665: `pkg/cmds/fields/parsed-parameter.go:296:func (p *ParsedParameters) ForEach(f func(key string, value *ParsedParameter)) {`
- L2666: `pkg/cmds/fields/parsed-parameter.go:303:// ParsedParameters. It stops at, and returns, the first error encountered.`
- L2667: `pkg/cmds/fields/parsed-parameter.go:304:func (p *ParsedParameters) ForEachE(f func(key string, value *ParsedParameter) error) error {`
- L2668: `pkg/cmds/fields/parsed-parameter.go:316:// we actually merge the ParsedParameter themselves, by appending the entire history of the other parameter to the`
- L2669: `pkg/cmds/fields/parsed-parameter.go:318:func (p *ParsedParameters) Merge(other *ParsedParameters) (*ParsedParameters, error) {`
- L2670: `pkg/cmds/fields/parsed-parameter.go:319:	err := other.ForEachE(func(k string, v *ParsedParameter) error {`
- L2671: `pkg/cmds/fields/parsed-parameter.go:333:func (p *ParsedParameters) MergeAsDefault(other *ParsedParameters, options ...ParseOption) (*ParsedParameters, error) {`
- L2672: `pkg/cmds/fields/parsed-parameter.go:334:	err := other.ForEachE(func(k string, v *ParsedParameter) error {`
- L2673: `pkg/cmds/fields/parsed-parameter.go:347:// ToMap converts ParsedParameters to map[string]interface{} by assigning each ParsedParameter's value to its key.`
- L2674: `pkg/cmds/fields/parsed-parameter.go:348:func (p *ParsedParameters) ToMap() map[string]interface{} {`
- L2675: `pkg/cmds/fields/parsed-parameter.go:350:	p.ForEach(func(k string, v *ParsedParameter) {`
- L2676: `pkg/cmds/fields/parsed-parameter.go:356:// ToInterfaceMap converts ParsedParameters to map[string]interface{} by converting each ParsedParameter's value to interface{}.`
- L2677: `pkg/cmds/fields/parsed-parameter.go:357:// It returns an error if it fails to convert any ParsedParameter's value.`
- L2678: `pkg/cmds/fields/parsed-parameter.go:358:func (p *ParsedParameters) ToInterfaceMap() (map[string]interface{}, error) {`
- L2679: `pkg/cmds/fields/parsed-parameter.go:360:	err := p.ForEachE(func(k string, v *ParsedParameter) error {`
- L2680: `pkg/cmds/fields/parsed-parameter.go:374:// MarshalYAML implements yaml.Marshaler for ParsedParameters`
- L2681: `pkg/cmds/fields/parsed-parameter.go:375:func (p *ParsedParameters) MarshalYAML() (interface{}, error) {`
- L2682: `pkg/cmds/fields/parsed-parameter.go:376:	return ToSerializableParsedParameters(p), nil`
- L2683: `pkg/cmds/fields/parsed-parameter.go:379:// MarshalJSON implements json.Marshaler for ParsedParameters`
- L2684: `pkg/cmds/fields/parsed-parameter.go:380:func (p *ParsedParameters) MarshalJSON() ([]byte, error) {`
- L2685: `pkg/cmds/fields/parsed-parameter.go:381:	return json.Marshal(ToSerializableParsedParameters(p))`
- L2686: `pkg/cmds/fields/gather-parameters.go:9:// GatherParametersFromMap gathers parameter values from a map.`
- L2687: `pkg/cmds/fields/gather-parameters.go:13:// - If the parameter is missing and required, an error is returned.`
- L2688: `pkg/cmds/fields/gather-parameters.go:14:// - If the parameter is missing and optional, the default value is used.`
- L2689: `pkg/cmds/fields/gather-parameters.go:17:// Values are looked up by parameter name, as well as short flag if provided.`
- L2690: `pkg/cmds/fields/gather-parameters.go:19:// The returned map contains the gathered parameter values, with defaults filled in`
- L2691: `pkg/cmds/fields/gather-parameters.go:21:func (pds *Definitions) GatherParametersFromMap(`
- L2692: `pkg/cmds/fields/gather-parameters.go:25:) (*ParsedParameters, error) {`
- L2693: `pkg/cmds/fields/gather-parameters.go:26:	ret := NewParsedParameters()`
- L2694: `pkg/cmds/fields/gather-parameters.go:29:		parsed := &ParsedParameter{`
- L2695: `pkg/cmds/fields/gather-parameters.go:52:					return errors.Errorf("Missing required parameter %s", p.Name)`
- L2696: `pkg/cmds/fields/gather-parameters.go:62:			v__, err := p.ParseParameter([]string{s})`
- L2697: `pkg/cmds/fields/gather-parameters.go:64:				return errors.Wrapf(err, "Invalid value for parameter %s", p.Name)`
- L2698: `pkg/cmds/fields/gather-parameters.go:72:			return errors.Wrapf(err, "Invalid value for parameter %s", p.Name)`
- L2699: `pkg/cmds/helpers/test-helpers.go:17:// Package parameters provides structures and helper functions required for`
- L2700: `pkg/cmds/helpers/test-helpers.go:32:// 3. Use the New* functions to convert the data loaded from YAML into appropriate form for the glazed library (typically, Values, ParsedDefinitions, ParameterLayers)`
- L2701: `pkg/cmds/helpers/test-helpers.go:42:// - name: "Empty layers and parsedLayers"`
- L2702: `pkg/cmds/helpers/test-helpers.go:43://  parameterLayers: []`
- L2703: `pkg/cmds/helpers/test-helpers.go:44://  parsedLayers: []`
- L2704: `pkg/cmds/helpers/test-helpers.go:45://  expectedLayers: []`
- L2705: `pkg/cmds/helpers/test-helpers.go:48://- name: "Single layer with default"`
- L2706: `pkg/cmds/helpers/test-helpers.go:49://  parameterLayers:`
- L2707: `pkg/cmds/helpers/test-helpers.go:50://    - name: "layer1"`
- L2708: `pkg/cmds/helpers/test-helpers.go:55://  parsedLayers:`
- L2709: `pkg/cmds/helpers/test-helpers.go:56://    - name: "layer1"`
- L2710: `pkg/cmds/helpers/test-helpers.go:57://  expectedLayers:`
- L2711: `pkg/cmds/helpers/test-helpers.go:58://    - name: "layer1"`
- L2712: `pkg/cmds/helpers/test-helpers.go:63://- name: "Multiple layers with defaults"`
- L2713: `pkg/cmds/helpers/test-helpers.go:64://  parameterLayers:`
- L2714: `pkg/cmds/helpers/test-helpers.go:65://    - name: "layer1"`
- L2715: `pkg/cmds/helpers/test-helpers.go:73://    - name: "layer2"`
- L2716: `pkg/cmds/helpers/test-helpers.go:78://  parsedLayers:`
- L2717: `pkg/cmds/helpers/test-helpers.go:79://    - name: "layer1"`
- L2718: `pkg/cmds/helpers/test-helpers.go:80://		parameters:`
- L2719: `pkg/cmds/helpers/test-helpers.go:83://    - name: "layer2"`
- L2720: `pkg/cmds/helpers/test-helpers.go:84://  expectedLayers:`
- L2721: `pkg/cmds/helpers/test-helpers.go:85://    - name: "layer1"`
- L2722: `pkg/cmds/helpers/test-helpers.go:89://    - name: "layer2"`
- L2723: `pkg/cmds/helpers/test-helpers.go:99:// 	parameterLayers []fields.TestParameterLayer`
- L2724: `pkg/cmds/helpers/test-helpers.go:100:// 	parsedLayers    []fields.TestSectionValues`
- L2725: `pkg/cmds/helpers/test-helpers.go:101:// 	expectedLayers  []fields.TestExpectedLayer`
- L2726: `pkg/cmds/helpers/test-helpers.go:110:// 			layers_ := fields.NewTestParameterLayers(tt.parameterLayers)`
- L2727: `pkg/cmds/helpers/test-helpers.go:111:// 			parsedLayers := fields.NewTestValues(layers_, tt.parsedLayers)`
- L2728: `pkg/cmds/helpers/test-helpers.go:120:// 			for _, l_ := range tt.expectedLayers {`
- L2729: `pkg/cmds/helpers/test-helpers.go:121:// 				l, ok := parsedLayers.Get(l_.Name)`
- L2730: `pkg/cmds/helpers/test-helpers.go:124:// 				actual := l.Parameters.ToMap()`
- L2731: `pkg/cmds/helpers/test-helpers.go:131:type TestParameterLayer struct {`
- L2732: `pkg/cmds/helpers/test-helpers.go:137:type TestParsedParameter struct {`
- L2733: `pkg/cmds/helpers/test-helpers.go:144:	Parameters []TestParsedParameter `yaml:"parameters"``
- L2734: `pkg/cmds/helpers/test-helpers.go:147:type TestExpectedLayer struct {`
- L2735: `pkg/cmds/helpers/test-helpers.go:159:const TestWhitelistLayers = "whitelistLayers"`
- L2736: `pkg/cmds/helpers/test-helpers.go:160:const TestWhitelistLayersFirst = "whitelistLayersFirst"`
- L2737: `pkg/cmds/helpers/test-helpers.go:161:const TestWhitelistLayerParameters = "whitelistLayerParameters"`
- L2738: `pkg/cmds/helpers/test-helpers.go:162:const TestWhitelistLayerParametersFirst = "whitelistLayerParametersFirst"`
- L2739: `pkg/cmds/helpers/test-helpers.go:163:const TestBlacklistLayers = "blacklistLayers"`
- L2740: `pkg/cmds/helpers/test-helpers.go:164:const TestBlacklistLayersFirst = "blacklistLayersFirst"`
- L2741: `pkg/cmds/helpers/test-helpers.go:165:const TestBlacklistLayerParameters = "blacklistLayerParameters"`
- L2742: `pkg/cmds/helpers/test-helpers.go:166:const TestBlacklistLayerParametersFirst = "blacklistLayerParametersFirst"`
- L2743: `pkg/cmds/helpers/test-helpers.go:184:	Layers     *[]string                          `yaml:"layers"``
- L2744: `pkg/cmds/helpers/test-helpers.go:185:	Parameters *map[string][]string               `yaml:"parameters"``
- L2745: `pkg/cmds/helpers/test-helpers.go:216:		case TestWhitelistLayers:`
- L2746: `pkg/cmds/helpers/test-helpers.go:217:			ret = append(ret, sources.WhitelistLayers(*m.Layers))`
- L2747: `pkg/cmds/helpers/test-helpers.go:218:		case TestWhitelistLayersFirst:`
- L2748: `pkg/cmds/helpers/test-helpers.go:219:			ret = append(ret, sources.WhitelistLayersFirst(*m.Layers))`
- L2749: `pkg/cmds/helpers/test-helpers.go:220:		case TestWhitelistLayerParameters:`
- L2750: `pkg/cmds/helpers/test-helpers.go:221:			ret = append(ret, sources.WhitelistLayerParameters(*m.Parameters))`
- L2751: `pkg/cmds/helpers/test-helpers.go:222:		case TestWhitelistLayerParametersFirst:`
- L2752: `pkg/cmds/helpers/test-helpers.go:223:			ret = append(ret, sources.WhitelistLayerParametersFirst(*m.Parameters))`
- L2753: `pkg/cmds/helpers/test-helpers.go:224:		case TestBlacklistLayers:`
- L2754: `pkg/cmds/helpers/test-helpers.go:225:			ret = append(ret, sources.BlacklistLayers(*m.Layers))`
- L2755: `pkg/cmds/helpers/test-helpers.go:226:		case TestBlacklistLayersFirst:`
- L2756: `pkg/cmds/helpers/test-helpers.go:227:			ret = append(ret, sources.BlacklistLayersFirst(*m.Layers))`
- L2757: `pkg/cmds/helpers/test-helpers.go:228:		case TestBlacklistLayerParameters:`
- L2758: `pkg/cmds/helpers/test-helpers.go:229:			ret = append(ret, sources.BlacklistLayerParameters(*m.Parameters))`
- L2759: `pkg/cmds/helpers/test-helpers.go:230:		case TestBlacklistLayerParametersFirst:`
- L2760: `pkg/cmds/helpers/test-helpers.go:231:			ret = append(ret, sources.BlacklistLayerParametersFirst(*m.Parameters))`
- L2761: `pkg/cmds/helpers/test-helpers.go:240:// NewTestParameterLayer is a helper function to create a ParameterLayer from parameterDefinition`
- L2762: `pkg/cmds/helpers/test-helpers.go:241:func NewTestParameterLayer(l TestParameterLayer) schema.Section {`
- L2763: `pkg/cmds/helpers/test-helpers.go:253:func NewTestParameterLayers(ls []TestParameterLayer) *schema.Schema {`
- L2764: `pkg/cmds/helpers/test-helpers.go:256:		ret.Set(l.Name, NewTestParameterLayer(l))`
- L2765: `pkg/cmds/helpers/test-helpers.go:261:// NewTestSectionValues helper function to create a Values from TestParsedParameter`
- L2766: `pkg/cmds/helpers/test-helpers.go:263:	params_ := fields.NewParsedParameters()`
- L2767: `pkg/cmds/helpers/test-helpers.go:265:	for _, p := range l.Parameters {`
- L2768: `pkg/cmds/helpers/test-helpers.go:268:			panic("parameter definition not found")`
- L2769: `pkg/cmds/helpers/test-helpers.go:276:	ret, err := values.NewSectionValues(pl, values.WithParameters(params_))`
- L2770: `pkg/cmds/helpers/test-helpers.go:289:			panic("parameter layer not found")`
- L2771: `pkg/cmds/helpers/test-helpers.go:307:func TestExpectedOutputs(t *testing.T, expectedLayers []TestExpectedLayer, parsedLayers *values.Values) {`
- L2772: `pkg/cmds/helpers/test-helpers.go:308:	expectedLayers_ := map[string]TestExpectedLayer{}`
- L2773: `pkg/cmds/helpers/test-helpers.go:309:	for _, l_ := range expectedLayers {`
- L2774: `pkg/cmds/helpers/test-helpers.go:310:		expectedLayers_[l_.Name] = l_`
- L2775: `pkg/cmds/helpers/test-helpers.go:311:		l, ok := parsedLayers.Get(l_.Name)`
- L2776: `pkg/cmds/helpers/test-helpers.go:314:		actual, err := l.Parameters.ToInterfaceMap()`
- L2777: `pkg/cmds/helpers/test-helpers.go:323:			actual, ok := l.Parameters.Get(k)`
- L2778: `pkg/cmds/helpers/test-helpers.go:336:	parsedLayers.ForEach(func(key string, l *values.SectionValues) {`
- L2779: `pkg/cmds/helpers/test-helpers.go:337:		if _, ok := expectedLayers_[key]; !ok {`
- L2780: `pkg/cmds/helpers/test-helpers.go:338:			t.Errorf("did not expect layer %s to be present", key)`
- L2781: `pkg/doc/topics/12-profiles-use-code.md:30:Profile middleware in Pinocchio is responsible for loading and applying configuration parameters from a specified`
- L2782: `pkg/doc/topics/12-profiles-use-code.md:46:	parsedCommandLayers *values.Values,`
- L2783: `pkg/doc/topics/12-profiles-use-code.md:71:For advanced use cases, combine profile middleware with additional config files using `LoadParametersFromFile` or `LoadParametersFromFiles`:`
- L2784: `pkg/doc/topics/12-profiles-use-code.md:122:The middleware will then load the configuration parameters from the `development` profile and apply them to the command.`
- L2785: `pkg/cmds/sources/load-parameters-from-json.go:15:// into the standard layer map format: map[layerSlug]map[parameterName]value.`
- L2786: `pkg/cmds/sources/load-parameters-from-json.go:17:// The output should map layer slugs to parameter name/value pairs.`
- L2787: `pkg/cmds/sources/load-parameters-from-json.go:23:// FromFile loads parameter definitions from a JSON or YAML file and applies them to the parameter layers.`
- L2788: `pkg/cmds/sources/load-parameters-from-json.go:26://	layer-slug:`
- L2789: `pkg/cmds/sources/load-parameters-from-json.go:27://	  parameter-name: value`
- L2790: `pkg/cmds/sources/load-parameters-from-json.go:32:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2791: `pkg/cmds/sources/load-parameters-from-json.go:33:			err := next(layers_, parsedLayers)`
- L2792: `pkg/cmds/sources/load-parameters-from-json.go:43:			m, err := readConfigFileToLayerMap(filename, opts.Mapper)`
- L2793: `pkg/cmds/sources/load-parameters-from-json.go:47:			return updateFromMap(layers_, parsedLayers, m, opts.ParseOptions...)`
- L2794: `pkg/cmds/sources/load-parameters-from-json.go:57:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2795: `pkg/cmds/sources/load-parameters-from-json.go:58:			if err := next(layers_, parsedLayers); err != nil {`
- L2796: `pkg/cmds/sources/load-parameters-from-json.go:66:				m, err := readConfigFileToLayerMap(f, opts.Mapper)`
- L2797: `pkg/cmds/sources/load-parameters-from-json.go:77:				if err := updateFromMap(layers_, parsedLayers, m, parseOpts...); err != nil {`
- L2798: `pkg/cmds/sources/load-parameters-from-json.go:95:// into the standard layer map format. If not provided, the default behavior expects:`
- L2799: `pkg/cmds/sources/load-parameters-from-json.go:97://	layer-slug:`
- L2800: `pkg/cmds/sources/load-parameters-from-json.go:98://	  parameter-name: value`
- L2801: `pkg/cmds/sources/load-parameters-from-json.go:108:// config file structures into the standard layer map format.`
- L2802: `pkg/cmds/sources/load-parameters-from-json.go:116:// WithParseOptions adds parse step options that will be applied when loading parameters from the config file.`
- L2803: `pkg/cmds/sources/load-parameters-from-json.go:123:func readConfigFileToLayerMap(filename string, mapper ConfigMapper) (map[string]map[string]interface{}, error) {`
- L2804: `pkg/cmds/sources/load-parameters-from-json.go:151:	// Default behavior: expect the standard layer map structure`
- L2805: `pkg/cmds/sources/load-parameters-from-json.go:154:		for layerSlug, layerData := range m {`
- L2806: `pkg/cmds/sources/load-parameters-from-json.go:155:			if layerMap, ok := layerData.(map[string]interface{}); ok {`
- L2807: `pkg/cmds/sources/load-parameters-from-json.go:156:				result[layerSlug] = layerMap`
- L2808: `pkg/cmds/sources/load-parameters-from-json.go:158:				return nil, errors.Errorf("expected map[string]interface{} for layer %s, got %T", layerSlug, layerData)`
- L2809: `pkg/doc/topics/09-gather-flags-from-string-list.md:25:	params []*ParameterDefinition,`
- L2810: `pkg/doc/topics/09-gather-flags-from-string-list.md:32:## Parameters`
- L2811: `pkg/doc/topics/09-gather-flags-from-string-list.md:35:- `params`: a slice of `*ParameterDefinition` representing the parameter definitions.`
- L2812: `pkg/doc/topics/09-gather-flags-from-string-list.md:42:The function returns a map where the keys are the parameter names and the values are the parsed values. If a flag is not recognized or its value cannot be parsed, an error is returned.`
- L2813: `pkg/doc/topics/09-gather-flags-from-string-list.md:49:params := []*ParameterDefinition{`
- L2814: `pkg/doc/topics/09-gather-flags-from-string-list.md:50:   {Name: "verbose", ShortFlag: "v", Type: ParameterTypeBool},`
- L2815: `pkg/doc/topics/09-gather-flags-from-string-list.md:51:   {Name: "output", ShortFlag: "o", Type: ParameterTypeString},`
- L2816: `pkg/doc/topics/09-gather-flags-from-string-list.md:64:In this example, the function parses the `--verbose` and `-o` flags according to the provided parameter definitions. The `--verbose` flag is a boolean flag and is set to "true". The `-o` flag is a string flag and its value is "file.txt".`
- L2817: `pkg/doc/topics/logging-layer.md:2:Title: Logging Layer API Reference`
- L2818: `pkg/doc/topics/logging-layer.md:3:Slug: logging-layer-reference`
- L2819: `pkg/doc/topics/logging-layer.md:16:# Logging Layer API Reference`
- L2820: `pkg/doc/topics/logging-layer.md:20:The Glazed logging layer provides comprehensive logging configuration for CLI applications through command-line parameters, environment variables, and configuration files. The layer handles setup for console output, file logging, and centralized log aggregation while supporting multiple output formats and verbosity levels.`
- L2821: `pkg/doc/topics/logging-layer.md:33:    A[CLI Parameters] --> B[Logging Layer]`
- L2822: `pkg/doc/topics/logging-layer.md:43:The logging layer transforms command-line parameters into configured log outputs, supporting development, testing, and production deployment scenarios.`
- L2823: `pkg/doc/topics/logging-layer.md:49:Add the logging layer to any Glazed command:`
- L2824: `pkg/doc/topics/logging-layer.md:58:    loggingLayer, err := logging.NewLoggingLayer()`
- L2825: `pkg/doc/topics/logging-layer.md:60:        return nil, fmt.Errorf("failed to create logging layer: %w", err)`
- L2826: `pkg/doc/topics/logging-layer.md:66:        cmds.WithLayersList(loggingLayer),`
- L2827: `pkg/doc/topics/logging-layer.md:74:    parsedLayers *values.Values,`
- L2828: `pkg/doc/topics/logging-layer.md:77:    // Initialize logging settings from parsed layers`
- L2829: `pkg/doc/topics/logging-layer.md:79:    if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {`
- L2830: `pkg/doc/topics/logging-layer.md:149:## Configuration Parameters`
- L2831: `pkg/doc/topics/logging-layer.md:153:| Parameter | Type | Default | Description |`
- L2832: `pkg/doc/topics/logging-layer.md:262:To initialize logging from parsed layers, use the standard pattern:`
- L2833: `pkg/doc/topics/logging-layer.md:265:// Extract logging settings from parsed layers`
- L2834: `pkg/doc/topics/logging-layer.md:267:if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {`
- L2835: `pkg/doc/topics/logging-layer.md:298:if err := parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings); err != nil {`
- L2836: `pkg/doc/topics/logging-layer.md:310:#### NewLoggingLayer`
- L2837: `pkg/doc/topics/logging-layer.md:313:func NewLoggingLayer() (schema.Section, error)`
- L2838: `pkg/doc/topics/logging-layer.md:316:Creates parameter layer for command definitions.`
- L2839: `pkg/doc/topics/logging-layer.md:320:loggingLayer, err := logging.NewLoggingLayer()`
- L2840: `pkg/doc/topics/logging-layer.md:327:    cmds.WithLayersList(loggingLayer),`
- L2841: `pkg/doc/topics/logging-layer.md:389:   parsedLayers.InitializeStruct(logging.LoggingLayerSlug, &settings)`
- L2842: `pkg/doc/topics/logging-layer.md:416:- [Custom Layer Tutorial](../tutorials/custom-layer.md): Creating custom parameter layers`
- L2843: `pkg/doc/topics/logging-layer.md:417:- [Layers Guide](../topics/layers-guide.md): Parameter layer system overview`
- L2844: `pkg/doc/topics/22-command-loaders.md:146:	"github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L2845: `pkg/doc/topics/22-command-loaders.md:244:	// Add other options like WithLong, WithArguments, WithLayers etc. as needed`
- L2846: `pkg/doc/topics/22-command-loaders.md:259:func (msc *MySpecificCommand) Run(ctx context.Context, parsedLayers *values.Values) error { /* ... */}`
- L2847: `pkg/doc/topics/22-command-loaders.md:274:-   **`SqlCommandLoader` (`github.com/go-go-golems/sqleton/pkg/cmds`)**: Loads SQL execution commands for the `sqleton` tool from YAML files containing SQL queries and parameter definitions. Uses `loaders.CheckYamlFileType(f, fileName, "sqleton")` in `IsFileSupported`.`
- L2848: `pkg/doc/topics/using-the-query-api.md:37:The query system consists of several layered components:`
- L2849: `pkg/doc/topics/using-the-query-api.md:57:‚îú‚îÄ‚îÄ dsl_bridge.go          # Integration layer`
- L2850: `pkg/doc/topics/using-the-query-api.md:206:fmt.Printf("Parameters: %v\n", debugInfo.Parameters)`
- L2851: `pkg/doc/topics/using-the-query-api.md:569:            http.Error(w, "Missing query parameter", http.StatusBadRequest)`
- L2852: `pkg/cmds/fields/parameters_from_defaults_test.go:12:func TestParsedParametersFromDefaults_BasicTypes(t *testing.T) {`
- L2853: `pkg/cmds/fields/parameters_from_defaults_test.go:15:		parameterDefinitions *Definitions`
- L2854: `pkg/cmds/fields/parameters_from_defaults_test.go:21:			parameterDefinitions: NewDefinitions(`
- L2855: `pkg/cmds/fields/parameters_from_defaults_test.go:61:			parameterDefinitions: NewDefinitions(`
- L2856: `pkg/cmds/fields/parameters_from_defaults_test.go:83:			result, err := tt.parameterDefinitions.ParsedParametersFromDefaults()`
- L2857: `pkg/cmds/fields/parameters_from_defaults_test.go:94:				assert.True(t, ok, "parameter %s should exist", paramName)`
- L2858: `pkg/cmds/fields/parameters_from_defaults_test.go:95:				assert.Equal(t, expectedValue, param.Value, "parameter %s should have correct value", paramName)`
- L2859: `pkg/cmds/fields/parameters_from_defaults_test.go:98:			// Special check for date parameter in the first test case`
- L2860: `pkg/cmds/fields/parameters_from_defaults_test.go:101:				assert.True(t, ok, "date parameter should exist")`
- L2861: `pkg/cmds/fields/parameters_from_defaults_test.go:103:				assert.True(t, ok, "date parameter should be time.Time")`
- L2862: `pkg/cmds/fields/parameters_from_defaults_test.go:111:func TestParsedParametersFromDefaults_EdgeCases(t *testing.T) {`
- L2863: `pkg/cmds/fields/parameters_from_defaults_test.go:114:		parameterDefinitions *Definitions`
- L2864: `pkg/cmds/fields/parameters_from_defaults_test.go:119:			name:                 "empty parameter definitions",`
- L2865: `pkg/cmds/fields/parameters_from_defaults_test.go:120:			parameterDefinitions: NewDefinitions(),`
- L2866: `pkg/cmds/fields/parameters_from_defaults_test.go:125:			parameterDefinitions: NewDefinitions(`
- L2867: `pkg/cmds/fields/parameters_from_defaults_test.go:143:			parameterDefinitions: NewDefinitions(`
- L2868: `pkg/cmds/fields/parameters_from_defaults_test.go:172:			result, err := tt.parameterDefinitions.ParsedParametersFromDefaults()`
- L2869: `pkg/cmds/fields/parameters_from_defaults_test.go:180:			// Check that we have exactly the expected number of parameters`
- L2870: `pkg/cmds/fields/parameters_from_defaults_test.go:182:				"number of parameters should match expected")`
- L2871: `pkg/cmds/fields/parameters_from_defaults_test.go:187:				assert.True(t, ok, "parameter %s should exist", paramName)`
- L2872: `pkg/cmds/fields/parameters_from_defaults_test.go:188:				assert.Equal(t, expectedValue, param.Value, "parameter %s should have correct value", paramName)`
- L2873: `pkg/cmds/fields/parameters_from_defaults_test.go:194:func TestParsedParametersFromDefaults_ListTypes(t *testing.T) {`
- L2874: `pkg/cmds/fields/parameters_from_defaults_test.go:221:	result, err := pd.ParsedParametersFromDefaults()`
- L2875: `pkg/cmds/fields/parameters_from_defaults_test.go:227:	assert.True(t, ok, "string-list parameter should exist")`
- L2876: `pkg/cmds/fields/parameters_from_defaults_test.go:232:	assert.True(t, ok, "integer-list parameter should exist")`
- L2877: `pkg/cmds/fields/parameters_from_defaults_test.go:237:	assert.True(t, ok, "choice-list parameter should exist")`
- L2878: `pkg/cmds/fields/parameters_from_defaults_test.go:242:	assert.True(t, ok, "float-list parameter should exist")`
- L2879: `pkg/cmds/fields/parameters_from_defaults_test.go:246:func TestParsedParametersFromDefaults_MapTypes(t *testing.T) {`
- L2880: `pkg/cmds/fields/parameters_from_defaults_test.go:262:	result, err := pd.ParsedParametersFromDefaults()`
- L2881: `pkg/cmds/fields/parameters_from_defaults_test.go:268:	assert.True(t, ok, "key-value parameter should exist")`
- L2882: `pkg/cmds/fields/parameters_from_defaults_test.go:273:	assert.True(t, ok, "object-from-file parameter should exist")`
- L2883: `pkg/cmds/fields/parameters_from_defaults_test.go:277:func TestParsedParametersFromDefaults_FileLoadingTypes(t *testing.T) {`
- L2884: `pkg/cmds/fields/parameters_from_defaults_test.go:296:	result, err := pd.ParsedParametersFromDefaults()`
- L2885: `pkg/cmds/fields/parameters_from_defaults_test.go:302:	assert.True(t, ok, "string-list-from-file parameter should exist")`
- L2886: `pkg/cmds/fields/parameters_from_defaults_test.go:307:	assert.True(t, ok, "object-list-from-file parameter should exist")`
- L2887: `pkg/cmds/fields/parameters_from_defaults_test.go:314:func TestParsedParametersFromDefaults_EmptyCollections(t *testing.T) {`
- L2888: `pkg/cmds/fields/parameters_from_defaults_test.go:335:	result, err := pd.ParsedParametersFromDefaults()`
- L2889: `pkg/cmds/fields/parameters_from_defaults_test.go:341:	assert.True(t, ok, "empty-string-list parameter should exist")`
- L2890: `pkg/cmds/fields/parameters_from_defaults_test.go:346:	assert.True(t, ok, "empty-key-value parameter should exist")`
- L2891: `pkg/cmds/fields/parameters_from_defaults_test.go:351:	assert.True(t, ok, "empty-object parameter should exist")`
- L2892: `pkg/cmds/fields/parameters_from_defaults_test.go:355:func TestParsedParametersFromDefaults_NilComplexTypes(t *testing.T) {`
- L2893: `pkg/cmds/fields/parameters_from_defaults_test.go:417:	result, err := pd.ParsedParametersFromDefaults()`
- L2894: `pkg/cmds/fields/parameters_from_defaults_test.go:421:	// All parameters should be excluded since they have nil defaults`
- L2895: `pkg/cmds/fields/parameters_from_defaults_test.go:422:	assert.Equal(t, 0, result.Len(), "no parameters should be included")`
- L2896: `pkg/cmds/fields/parameters_from_defaults_test.go:424:	// Verify each parameter is not present`
- L2897: `pkg/cmds/fields/parameters_from_defaults_test.go:434:		assert.False(t, ok, "parameter %s should not exist", name)`
- L2898: `pkg/cmds/cmds.go:26:	Layers         *schema.Schema         `yaml:"layers,omitempty"``
- L2899: `pkg/cmds/cmds.go:77:func WithLayersList(ls ...schema.Section) CommandDescriptionOption {`
- L2900: `pkg/cmds/cmds.go:80:			c.Layers.Set(l.GetSlug(), l)`
- L2901: `pkg/cmds/cmds.go:85:func WithLayers(ls *schema.Schema) CommandDescriptionOption {`
- L2902: `pkg/cmds/cmds.go:87:		c.Layers.Merge(ls)`
- L2903: `pkg/cmds/cmds.go:91:// WithSchema is an alias for WithLayers that accepts a schema.Schema.`
- L2904: `pkg/cmds/cmds.go:94:	return WithLayers((*schema.Schema)(s))`
- L2905: `pkg/cmds/cmds.go:97:// WithLayersMap registers layers using explicit slugs from the provided map.`
- L2906: `pkg/cmds/cmds.go:98:// The map key is used as the registration slug. If a layer's internal slug`
- L2907: `pkg/cmds/cmds.go:102://   - Prefer cloning the layer and overriding the slug on the clone when the`
- L2908: `pkg/cmds/cmds.go:105://   - Otherwise, the layer is registered under the provided key as-is.`
- L2909: `pkg/cmds/cmds.go:108:// from its internal slug, middlewares that derive parsed layer slugs from the`
- L2910: `pkg/cmds/cmds.go:109:// layer's GetSlug() may use the internal slug instead of the registration key.`
- L2911: `pkg/cmds/cmds.go:112:func WithLayersMap(m map[string]schema.Section) CommandDescriptionOption {`
- L2912: `pkg/cmds/cmds.go:116:				// Try a generic clone: many wrapper types embed ParameterLayerImpl,`
- L2913: `pkg/cmds/cmds.go:117:				// whose Clone returns *ParameterLayerImpl. If so, set the slug.`
- L2914: `pkg/cmds/cmds.go:121:					c.Layers.Set(slug, impl)`
- L2915: `pkg/cmds/cmds.go:122:					log.Debug().Str("slug", slug).Str("internalSlug", l.GetSlug()).Msg("WithLayersMap: cloned layer and set overridden slug")`
- L2916: `pkg/cmds/cmds.go:125:				// Fallback: keep original layer but register under provided key.`
- L2917: `pkg/cmds/cmds.go:126:				// Parsed layers may still use the internal slug when indexing.`
- L2918: `pkg/cmds/cmds.go:127:				log.Warn().Str("slug", slug).Str("internalSlug", l.GetSlug()).Msg("WithLayersMap: registering layer with mismatched internal slug; parsed layers may use internal slug")`
- L2919: `pkg/cmds/cmds.go:129:			c.Layers.Set(slug, l)`
- L2920: `pkg/cmds/cmds.go:134:// WithFlags is a convenience function to add arguments to the default layer, useful`
- L2921: `pkg/cmds/cmds.go:135:// to make the transition from explicit flags and arguments to a default layer a bit easier.`
- L2922: `pkg/cmds/cmds.go:140:		layer, ok := c.GetDefaultLayer()`
- L2923: `pkg/cmds/cmds.go:143:			layer, err = schema.NewSection(schema.DefaultSlug, "Flags")`
- L2924: `pkg/cmds/cmds.go:147:			c.Layers.Set(layer.GetSlug(), layer)`
- L2925: `pkg/cmds/cmds.go:148:			err = c.Layers.MoveToFront(layer.GetSlug())`
- L2926: `pkg/cmds/cmds.go:153:		layer.AddFields(flags...)`
- L2927: `pkg/cmds/cmds.go:157:// WithArguments is a convenience function to add arguments to the default layer, useful`
- L2928: `pkg/cmds/cmds.go:158:// to make the transition from explicit flags and arguments to a default layer a bit easier.`
- L2929: `pkg/cmds/cmds.go:163:		layer, ok := c.GetDefaultLayer()`
- L2930: `pkg/cmds/cmds.go:166:			layer, err = schema.NewSection(schema.DefaultSlug, "Arguments")`
- L2931: `pkg/cmds/cmds.go:170:			c.Layers.Set(layer.GetSlug(), layer)`
- L2932: `pkg/cmds/cmds.go:171:			err = c.Layers.MoveToFront(layer.GetSlug())`
- L2933: `pkg/cmds/cmds.go:180:		layer.AddFields(arguments...)`
- L2934: `pkg/cmds/cmds.go:190:func WithReplaceLayers(layers_ ...schema.Section) CommandDescriptionOption {`
- L2935: `pkg/cmds/cmds.go:192:		for _, l := range layers_ {`
- L2936: `pkg/cmds/cmds.go:193:			c.Layers.Set(l.GetSlug(), l)`
- L2937: `pkg/cmds/cmds.go:231:		Layers: schema.NewSchema(),`
- L2938: `pkg/cmds/cmds.go:254:func (cd *CommandDescription) GetDefaultLayer() (schema.Section, bool) {`
- L2939: `pkg/cmds/cmds.go:255:	return cd.GetLayer(schema.DefaultSlug)`
- L2940: `pkg/cmds/cmds.go:259:	l, ok := cd.GetDefaultLayer()`
- L2941: `pkg/cmds/cmds.go:267:	l, ok := cd.GetDefaultLayer()`
- L2942: `pkg/cmds/cmds.go:275:// GetDefaultsMap returns a map of parameter names to their default values`
- L2943: `pkg/cmds/cmds.go:281:	params, err := flags.ParsedParametersFromDefaults()`
- L2944: `pkg/cmds/cmds.go:286:	argsParams, err := arguments.ParsedParametersFromDefaults()`
- L2945: `pkg/cmds/cmds.go:299:func (cd *CommandDescription) GetLayer(name string) (schema.Section, bool) {`
- L2946: `pkg/cmds/cmds.go:300:	return cd.Layers.Get(name)`
- L2947: `pkg/cmds/cmds.go:303:func (cd *CommandDescription) Clone(cloneLayers bool, options ...CommandDescriptionOption) *CommandDescription {`
- L2948: `pkg/cmds/cmds.go:305:	layers_ := schema.NewSchema()`
- L2949: `pkg/cmds/cmds.go:306:	if cloneLayers {`
- L2950: `pkg/cmds/cmds.go:307:		layers_ = cd.Layers.Clone()`
- L2951: `pkg/cmds/cmds.go:318:		Layers:  layers_,`
- L2952: `pkg/cmds/cmds.go:343:func (cd *CommandDescription) SetLayers(layers ...schema.Section) {`
- L2953: `pkg/cmds/cmds.go:344:	for _, l := range layers {`
- L2954: `pkg/cmds/cmds.go:345:		cd.Layers.Set(l.GetSlug(), l)`
- L2955: `pkg/cmds/cmds.go:356:	Metadata(ctx context.Context, parsedLayers *values.Values) (map[string]interface{}, error)`
- L2956: `pkg/cmds/cmds.go:368:	Run(ctx context.Context, parsedLayers *values.Values) error`
- L2957: `pkg/cmds/cmds.go:373:	RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error`
- L2958: `pkg/cmds/cmds.go:380:	// NOTE(manuel, 2023-02-27) We can probably simplify this to only take parsed layers`
- L2959: `pkg/cmds/cmds.go:382:	// The ps and GlazeProcessor calls could be replaced by a GlazeCommand specific layer,`
- L2960: `pkg/cmds/cmds.go:384:	// is just something created by the passed in GlazeLayer anyway.`
- L2961: `pkg/cmds/cmds.go:392:	RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error`
- L2962: `pkg/cmds/sources/layers.go:9:// ReplaceSectionValues is a middleware that replaces a parsed layer with a new one.`
- L2963: `pkg/cmds/sources/layers.go:10:// It first calls next, then replaces the specified layer with a clone of the provided one.`
- L2964: `pkg/cmds/sources/layers.go:11:// If the layer doesn't exist in the original parsedLayers, it will be added.`
- L2965: `pkg/cmds/sources/layers.go:12:func ReplaceSectionValues(layerSlug string, newLayer *values.SectionValues) Middleware {`
- L2966: `pkg/cmds/sources/layers.go:14:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2967: `pkg/cmds/sources/layers.go:15:			err := next(layers_, parsedLayers)`
- L2968: `pkg/cmds/sources/layers.go:20:			if newLayer == nil {`
- L2969: `pkg/cmds/sources/layers.go:21:				return errors.New("cannot replace with nil layer")`
- L2970: `pkg/cmds/sources/layers.go:24:			parsedLayers.Set(layerSlug, newLayer.Clone())`
- L2971: `pkg/cmds/sources/layers.go:30:// ReplaceValues is a middleware that replaces multiple parsed layers at once.`
- L2972: `pkg/cmds/sources/layers.go:31:// It first calls next, then replaces all specified layers with clones of the provided ones.`
- L2973: `pkg/cmds/sources/layers.go:32:// If a layer doesn't exist in the original parsedLayers, it will be added.`
- L2974: `pkg/cmds/sources/layers.go:33:func ReplaceValues(newLayers *values.Values) Middleware {`
- L2975: `pkg/cmds/sources/layers.go:35:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2976: `pkg/cmds/sources/layers.go:36:			err := next(layers_, parsedLayers)`
- L2977: `pkg/cmds/sources/layers.go:41:			if newLayers == nil {`
- L2978: `pkg/cmds/sources/layers.go:42:				return errors.New("cannot replace with nil layers")`
- L2979: `pkg/cmds/sources/layers.go:45:			newLayers.ForEach(func(k string, v *values.SectionValues) {`
- L2980: `pkg/cmds/sources/layers.go:46:				parsedLayers.Set(k, v.Clone())`
- L2981: `pkg/cmds/sources/layers.go:53:// ReplaceValuesSelective is a middleware that replaces only the specified layers from the provided Values.`
- L2982: `pkg/cmds/sources/layers.go:54:// It first calls next, then replaces only the layers specified in slugs with clones from newLayers.`
- L2983: `pkg/cmds/sources/layers.go:55:// If a layer in slugs doesn't exist in newLayers, it is skipped.`
- L2984: `pkg/cmds/sources/layers.go:56:func ReplaceValuesSelective(newLayers *values.Values, slugs []string) Middleware {`
- L2985: `pkg/cmds/sources/layers.go:58:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2986: `pkg/cmds/sources/layers.go:59:			err := next(layers_, parsedLayers)`
- L2987: `pkg/cmds/sources/layers.go:64:			if newLayers == nil {`
- L2988: `pkg/cmds/sources/layers.go:65:				return errors.New("cannot replace with nil layers")`
- L2989: `pkg/cmds/sources/layers.go:69:				if layer, ok := newLayers.Get(slug); ok {`
- L2990: `pkg/cmds/sources/layers.go:70:					parsedLayers.Set(slug, layer.Clone())`
- L2991: `pkg/cmds/sources/layers.go:78:// MergeSectionValues is a middleware that merges a parsed layer into an existing one.`
- L2992: `pkg/cmds/sources/layers.go:79:// It first calls next, then merges the provided layer into the specified one.`
- L2993: `pkg/cmds/sources/layers.go:80:// If the target layer doesn't exist, it will be created.`
- L2994: `pkg/cmds/sources/layers.go:81:func MergeSectionValues(layerSlug string, layerToMerge *values.SectionValues) Middleware {`
- L2995: `pkg/cmds/sources/layers.go:83:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L2996: `pkg/cmds/sources/layers.go:84:			err := next(layers_, parsedLayers)`
- L2997: `pkg/cmds/sources/layers.go:89:			if layerToMerge == nil {`
- L2998: `pkg/cmds/sources/layers.go:90:				return errors.New("cannot merge nil layer")`
- L2999: `pkg/cmds/sources/layers.go:93:			targetLayer, ok := parsedLayers.Get(layerSlug)`
- L3000: `pkg/cmds/sources/layers.go:95:				parsedLayers.Set(layerSlug, layerToMerge.Clone())`
- L3001: `pkg/cmds/sources/layers.go:99:			err = targetLayer.MergeParameters(layerToMerge)`
- L3002: `pkg/cmds/sources/layers.go:108:// MergeValues is a middleware that merges multiple parsed layers at once.`
- L3003: `pkg/cmds/sources/layers.go:109:// It first calls next, then merges all provided layers into the existing ones.`
- L3004: `pkg/cmds/sources/layers.go:110:// If a target layer doesn't exist, it will be created.`
- L3005: `pkg/cmds/sources/layers.go:111:func MergeValues(layersToMerge *values.Values) Middleware {`
- L3006: `pkg/cmds/sources/layers.go:113:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3007: `pkg/cmds/sources/layers.go:114:			err := next(layers_, parsedLayers)`
- L3008: `pkg/cmds/sources/layers.go:119:			if layersToMerge == nil {`
- L3009: `pkg/cmds/sources/layers.go:120:				return errors.New("cannot merge nil layers")`
- L3010: `pkg/cmds/sources/layers.go:123:			err = parsedLayers.Merge(layersToMerge)`
- L3011: `pkg/cmds/sources/layers.go:132:// MergeValuesSelective is a middleware that merges only the specified layers from the provided Values.`
- L3012: `pkg/cmds/sources/layers.go:133:// It first calls next, then merges only the layers specified in slugs from layersToMerge into the existing layers.`
- L3013: `pkg/cmds/sources/layers.go:134:// If a layer in slugs doesn't exist in layersToMerge, it is skipped.`
- L3014: `pkg/cmds/sources/layers.go:135:// If a target layer doesn't exist in parsedLayers, it will be created.`
- L3015: `pkg/cmds/sources/layers.go:136:func MergeValuesSelective(layersToMerge *values.Values, slugs []string) Middleware {`
- L3016: `pkg/cmds/sources/layers.go:138:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3017: `pkg/cmds/sources/layers.go:139:			err := next(layers_, parsedLayers)`
- L3018: `pkg/cmds/sources/layers.go:144:			if layersToMerge == nil {`
- L3019: `pkg/cmds/sources/layers.go:145:				return errors.New("cannot merge nil layers")`
- L3020: `pkg/cmds/sources/layers.go:149:				if layer, ok := layersToMerge.Get(slug); ok {`
- L3021: `pkg/cmds/sources/layers.go:150:					targetLayer, exists := parsedLayers.Get(slug)`
- L3022: `pkg/cmds/sources/layers.go:152:						parsedLayers.Set(slug, layer.Clone())`
- L3023: `pkg/cmds/sources/layers.go:154:						err = targetLayer.MergeParameters(layer)`
- L3024: `pkg/doc/topics/layers-guide.md:2:Title: Glazed Command Layers Guide`
- L3025: `pkg/doc/topics/layers-guide.md:3:Slug: layers-guide  `
- L3026: `pkg/doc/topics/layers-guide.md:4:Short: Complete guide to understanding and working with command parameter layers in Glazed`
- L3027: `pkg/doc/topics/layers-guide.md:6:- layers`
- L3028: `pkg/doc/topics/layers-guide.md:7:- parameters`
- L3029: `pkg/doc/topics/layers-guide.md:16:# Glazed Command Layers: Complete Guide`
- L3030: `pkg/doc/topics/layers-guide.md:18:*Building maintainable CLI applications through modular parameter organization*`
- L3031: `pkg/doc/topics/layers-guide.md:22:2. [Parameter Organization Challenges](#parameter-organization-challenges)`
- L3032: `pkg/doc/topics/layers-guide.md:23:3. [Layer System Architecture](#layer-system-architecture)`
- L3033: `pkg/doc/topics/layers-guide.md:24:4. [Core Layer Concepts](#core-layer-concepts)`
- L3034: `pkg/doc/topics/layers-guide.md:25:5. [Layer Types & Components](#layer-types--components)`
- L3035: `pkg/doc/topics/layers-guide.md:26:6. [Creating and Working with Layers](#creating-and-working-with-layers)`
- L3036: `pkg/doc/topics/layers-guide.md:30:10. [Testing Layers](#testing-layers)`
- L3037: `pkg/doc/topics/layers-guide.md:34:Parameter layers organize related command parameters into reusable groups. This modular approach addresses common CLI development challenges including parameter proliferation, code duplication, naming conflicts, and maintenance complexity in growing applications.`
- L3038: `pkg/doc/topics/layers-guide.md:36:The layer system enables developers to:`
- L3039: `pkg/doc/topics/layers-guide.md:38:- **Organize parameters** logically by functionality (database, logging, output)`
- L3040: `pkg/doc/topics/layers-guide.md:39:- **Reuse parameter definitions** across multiple commands without duplication`
- L3041: `pkg/doc/topics/layers-guide.md:41:- **Maintain consistency** through centralized parameter definitions`
- L3042: `pkg/doc/topics/layers-guide.md:44:### Traditional Parameter Management Problems`
- L3043: `pkg/doc/topics/layers-guide.md:56:- **Parameter pollution**: Commands inherit irrelevant flags, cluttering help screens`
- L3044: `pkg/doc/topics/layers-guide.md:58:- **Code duplication**: Parameter definitions copy across commands, violating DRY principles`
- L3045: `pkg/doc/topics/layers-guide.md:59:- **Poor organization**: Parameters scatter without logical grouping`
- L3046: `pkg/doc/topics/layers-guide.md:90:### Glazed Layer Solution`
- L3047: `pkg/doc/topics/layers-guide.md:92:The layer system eliminates these problems by treating parameters as modular components that can be shared, composed, reused, maintained centrally, and extended without breaking existing commands.`
- L3048: `pkg/doc/topics/layers-guide.md:95:// Define reusable layers once`
- L3049: `pkg/doc/topics/layers-guide.md:97:    DatabaseLayer = CreateDatabaseLayer()  // --db-host, --db-port, --db-name`
- L3050: `pkg/doc/topics/layers-guide.md:98:    LoggingLayer  = CreateLoggingLayer()   // --log-level, --log-file, --verbose`
- L3051: `pkg/doc/topics/layers-guide.md:99:    ServerLayer   = CreateServerLayer()    // --host, --port, --timeout`
- L3052: `pkg/doc/topics/layers-guide.md:100:    GlazedLayer   = CreateGlazedLayer()    // --output, --fields, --format`
- L3053: `pkg/doc/topics/layers-guide.md:103:// Compose commands by combining relevant layers`
- L3054: `pkg/doc/topics/layers-guide.md:105:    cmds.WithLayers(ServerLayer, DatabaseLayer, LoggingLayer))`
- L3055: `pkg/doc/topics/layers-guide.md:108:    cmds.WithLayers(ServerLayer, LoggingLayer))  // No database needed`
- L3056: `pkg/doc/topics/layers-guide.md:111:    cmds.WithLayers(DatabaseLayer, LoggingLayer, GlazedLayer))  // No server needed`
- L3057: `pkg/doc/topics/layers-guide.md:114:## Parameter Organization Challenges`
- L3058: `pkg/doc/topics/layers-guide.md:116:Complex CLI applications face predictable parameter management challenges that layers directly address.`
- L3059: `pkg/doc/topics/layers-guide.md:118:### Parameter Explosion`
- L3060: `pkg/doc/topics/layers-guide.md:120:As applications add features, commands accumulate parameters that may not be relevant to their specific functionality. This creates cognitive overhead for users and increases implementation complexity.`
- L3061: `pkg/doc/topics/layers-guide.md:124:Multiple subsystems often require similar parameters (host, port, timeout). Without organization, developers resort to verbose prefixes that reduce usability and create inconsistent interfaces.`
- L3062: `pkg/doc/topics/layers-guide.md:128:Parameter definitions scattered across command implementations require manual synchronization. Adding SSL configuration to database connections means updating every command that uses databases.`
- L3063: `pkg/doc/topics/layers-guide.md:132:Without centralized parameter definitions, similar functionality develops different flag names across commands, creating inconsistent user experiences and requiring additional documentation.`
- L3064: `pkg/doc/topics/layers-guide.md:134:## Layer System Architecture`
- L3065: `pkg/doc/topics/layers-guide.md:136:The layer system separates parameter definition from runtime value resolution, enabling flexible composition while maintaining type safety.`
- L3066: `pkg/doc/topics/layers-guide.md:144:‚îÇ  ‚îÇ            Command Description           ‚îÇ ‚Üê Metadata + layer references`
- L3067: `pkg/doc/topics/layers-guide.md:147:‚îÇ  ‚îÇ  ‚îÇ          Parameter Layers           ‚îÇ ‚Üê Layer definitions (design time)`
- L3068: `pkg/doc/topics/layers-guide.md:150:‚îÇ  ‚îÇ  ‚îÇ  ‚îÇDefault Layer‚îÇ  Custom Layers  ‚îÇ   ‚îÇ ‚Üê Different types of layers`
- L3069: `pkg/doc/topics/layers-guide.md:160:‚îÇ              Runtime Parsing                 ‚îÇ ‚Üê Parameter resolution`
- L3070: `pkg/doc/topics/layers-guide.md:162:‚îÇ  Parameter Sources (in priority order):     ‚îÇ ‚Üê Multi-source configuration`
- L3071: `pkg/doc/topics/layers-guide.md:166:‚îÇ  4. Default values from layer definitions   ‚îÇ`
- L3072: `pkg/doc/topics/layers-guide.md:171:‚îÇ               Parsed Layers                  ‚îÇ ‚Üê Runtime values`
- L3073: `pkg/doc/topics/layers-guide.md:172:‚îÇ        (type-safe parameter values)         ‚îÇ`
- L3074: `pkg/doc/topics/layers-guide.md:178:1. **Layer Definitions** (design time): Parameter specifications and constraints`
- L3075: `pkg/doc/topics/layers-guide.md:180:3. **Parsed Layers** (application time): Type-safe access to resolved values`
- L3076: `pkg/doc/topics/layers-guide.md:182:### Layer Lifecycle`
- L3077: `pkg/doc/topics/layers-guide.md:184:Layers progress through distinct phases from definition to runtime use:`
- L3078: `pkg/doc/topics/layers-guide.md:186:1. **Definition Phase**: Parameters defined with types, defaults, and validation rules`
- L3079: `pkg/doc/topics/layers-guide.md:187:2. **Composition Phase**: Layers combined into command descriptions`
- L3080: `pkg/doc/topics/layers-guide.md:189:4. **Execution Phase**: Commands access type-safe parameter values`
- L3081: `pkg/doc/topics/layers-guide.md:191:## Core Layer Concepts`
- L3082: `pkg/doc/topics/layers-guide.md:193:### Layer Identity and Organization`
- L3083: `pkg/doc/topics/layers-guide.md:195:Every layer requires unique identification and logical organization within the application parameter namespace.`
- L3084: `pkg/doc/topics/layers-guide.md:197:#### Layer Hierarchy`
- L3085: `pkg/doc/topics/layers-guide.md:201:‚îú‚îÄ‚îÄ Default Layer (always present)`
- L3086: `pkg/doc/topics/layers-guide.md:204:‚îú‚îÄ‚îÄ Standard Layers (optional, commonly used)`
- L3087: `pkg/doc/topics/layers-guide.md:205:‚îÇ   ‚îú‚îÄ‚îÄ Glazed Layer (for structured output)  ‚Üê Output formatting`
- L3088: `pkg/doc/topics/layers-guide.md:206:‚îÇ   ‚îú‚îÄ‚îÄ Logging Layer (for logging configuration)  ‚Üê Debug & monitoring`
- L3089: `pkg/doc/topics/layers-guide.md:207:‚îÇ   ‚îî‚îÄ‚îÄ Database Layer (for database connections)  ‚Üê Data persistence`
- L3090: `pkg/doc/topics/layers-guide.md:208:‚îî‚îÄ‚îÄ Custom Layers (application-specific)`
- L3091: `pkg/doc/topics/layers-guide.md:209:    ‚îú‚îÄ‚îÄ Authentication Layer        ‚Üê Security & access control`
- L3092: `pkg/doc/topics/layers-guide.md:210:    ‚îú‚îÄ‚îÄ API Configuration Layer     ‚Üê External service integration`
- L3093: `pkg/doc/topics/layers-guide.md:211:    ‚îî‚îÄ‚îÄ Feature Toggle Layer        ‚Üê Experimental or optional features`
- L3094: `pkg/doc/topics/layers-guide.md:214:This hierarchy enables logical grouping, reusability across commands, extensibility without breaking changes, and automatic propagation of layer updates.`
- L3095: `pkg/doc/topics/layers-guide.md:216:### Parameter Definitions vs. Parsed Values`
- L3096: `pkg/doc/topics/layers-guide.md:218:The system distinguishes between parameter specifications (what's possible) and runtime values (what's actual).`
- L3097: `pkg/doc/topics/layers-guide.md:220:**Parameter Definitions** (specifications stored in layers):`
- L3098: `pkg/doc/topics/layers-guide.md:224:    "log-level",                    // Parameter name`
- L3099: `pkg/doc/topics/layers-guide.md:238:loggingLayer, ok := parsedLayers.Get("logging")`
- L3100: `pkg/doc/topics/layers-guide.md:240:    logLevel, ok := loggingLayer.GetParameter("log-level")`
- L3101: `pkg/doc/topics/layers-guide.md:251:### Layer Composition Patterns`
- L3102: `pkg/doc/topics/layers-guide.md:253:Layer composition determines command interfaces by selecting appropriate parameter groups.`
- L3103: `pkg/doc/topics/layers-guide.md:260:// Combine only needed layers`
- L3104: `pkg/doc/topics/layers-guide.md:262:    cmds.WithLayers(databaseLayer, loggingLayer))`
- L3105: `pkg/doc/topics/layers-guide.md:267:Dynamic layer assembly based on runtime conditions:`
- L3106: `pkg/doc/topics/layers-guide.md:270:// Build layer list based on features`
- L3107: `pkg/doc/topics/layers-guide.md:271:layers := []schema.Section{baseLayer}`
- L3108: `pkg/doc/topics/layers-guide.md:274:    layers = append(layers, databaseLayer)`
- L3109: `pkg/doc/topics/layers-guide.md:278:    layers = append(layers, glazedLayer)`
- L3110: `pkg/doc/topics/layers-guide.md:282:    cmds.WithLayersList(layers...))`
- L3111: `pkg/doc/topics/layers-guide.md:285:#### Layer Extension`
- L3112: `pkg/doc/topics/layers-guide.md:287:Building specialized variants from existing layers:`
- L3113: `pkg/doc/topics/layers-guide.md:290:// Extend existing layer without modification`
- L3114: `pkg/doc/topics/layers-guide.md:291:extendedDbLayer := databaseLayer.Clone()`
- L3115: `pkg/doc/topics/layers-guide.md:292:extendedDbLayer.AddFlags(`
- L3116: `pkg/doc/topics/layers-guide.md:298:## Layer Types & Components`
- L3117: `pkg/doc/topics/layers-guide.md:300:### Built-in Layer Types`
- L3118: `pkg/doc/topics/layers-guide.md:302:Glazed provides standard layer types for common CLI application requirements.`
- L3119: `pkg/doc/topics/layers-guide.md:304:#### Default Layer`
- L3120: `pkg/doc/topics/layers-guide.md:306:The Default Layer contains command-specific parameters unique to individual commands.`
- L3121: `pkg/doc/topics/layers-guide.md:311:- **Use Case**: Parameters fundamental to command operation, unlikely to be shared`
- L3122: `pkg/doc/topics/layers-guide.md:314:// Default layer created automatically`
- L3123: `pkg/doc/topics/layers-guide.md:324:// Parameters live in default layer, unique to "serve" command`
- L3124: `pkg/doc/topics/layers-guide.md:327:#### Glazed Layer`
- L3125: `pkg/doc/topics/layers-guide.md:329:The Glazed Layer provides comprehensive output formatting capabilities for commands producing structured data.`
- L3126: `pkg/doc/topics/layers-guide.md:333:- **Creation**: `settings.NewGlazedParameterLayers()``
- L3127: `pkg/doc/topics/layers-guide.md:337:glazedLayer, err := settings.NewGlazedParameterLayers()`
- L3128: `pkg/doc/topics/layers-guide.md:339:    return nil, fmt.Errorf("failed to create glazed layer: %w", err)`
- L3129: `pkg/doc/topics/layers-guide.md:345:### Custom Layer Components`
- L3130: `pkg/doc/topics/layers-guide.md:347:Application-specific layers address domain requirements through custom parameter definitions.`
- L3131: `pkg/doc/topics/layers-guide.md:349:#### Parameter Definitions`
- L3132: `pkg/doc/topics/layers-guide.md:351:Individual parameter specifications define acceptable input and behavior:`
- L3133: `pkg/doc/topics/layers-guide.md:355:    "connection-timeout",              // Parameter name`
- L3134: `pkg/doc/topics/layers-guide.md:365:- **Name**: Parameter identifier for CLI flags`
- L3135: `pkg/doc/topics/layers-guide.md:373:Parameter definitions include built-in validation for common patterns:`
- L3136: `pkg/doc/topics/layers-guide.md:376:// Choice parameters with automatic validation`
- L3137: `pkg/doc/topics/layers-guide.md:385:// Numeric parameters with defaults`
- L3138: `pkg/doc/topics/layers-guide.md:395:## Creating and Working with Layers`
- L3139: `pkg/doc/topics/layers-guide.md:397:### Method 1: Simple Layer Creation`
- L3140: `pkg/doc/topics/layers-guide.md:399:Direct layer creation for straightforward parameter grouping:`
- L3141: `pkg/doc/topics/layers-guide.md:402:func NewDatabaseLayer() (schema.Section, error) {`
- L3142: `pkg/doc/topics/layers-guide.md:404:        "database",                    // Layer identifier`
- L3143: `pkg/doc/topics/layers-guide.md:430:### Method 2: Type-Safe Layer with Settings Struct`
- L3144: `pkg/doc/topics/layers-guide.md:432:For complex layers requiring type safety and structured access:`
- L3145: `pkg/doc/topics/layers-guide.md:445:// 2. Create layer with parameter definitions`
- L3146: `pkg/doc/topics/layers-guide.md:446:func NewDatabaseLayer() (schema.Section, error) {`
- L3147: `pkg/doc/topics/layers-guide.md:491:func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {`
- L3148: `pkg/doc/topics/layers-guide.md:493:    err := parsedLayers.InitializeStruct("database", settings)`
- L3149: `pkg/doc/topics/layers-guide.md:500:    parsedLayers *values.Values,`
- L3150: `pkg/doc/topics/layers-guide.md:503:    // Extract database settings from the "database" layer`
- L3151: `pkg/doc/topics/layers-guide.md:504:    dbSettings, err := GetDatabaseSettings(parsedLayers)`
- L3152: `pkg/doc/topics/layers-guide.md:523:### Method 3: Layer Builder Pattern`
- L3153: `pkg/doc/topics/layers-guide.md:525:For complex scenarios requiring conditional parameters:`
- L3154: `pkg/doc/topics/layers-guide.md:528:type DatabaseLayerBuilder struct {`
- L3155: `pkg/doc/topics/layers-guide.md:529:    layer      schema.Section`
- L3156: `pkg/doc/topics/layers-guide.md:534:func NewDatabaseLayerBuilder() *DatabaseLayerBuilder {`
- L3157: `pkg/doc/topics/layers-guide.md:535:    layer, _ := schema.NewSection("database", "Database Configuration")`
- L3158: `pkg/doc/topics/layers-guide.md:536:    return &DatabaseLayerBuilder{layer: layer}`
- L3159: `pkg/doc/topics/layers-guide.md:539:func (b *DatabaseLayerBuilder) WithSSL() *DatabaseLayerBuilder {`
- L3160: `pkg/doc/topics/layers-guide.md:544:func (b *DatabaseLayerBuilder) WithConnectionPool() *DatabaseLayerBuilder {`
- L3161: `pkg/doc/topics/layers-guide.md:549:func (b *DatabaseLayerBuilder) Build() (schema.Section, error) {`
- L3162: `pkg/doc/topics/layers-guide.md:550:    // Add basic parameters`
- L3163: `pkg/doc/topics/layers-guide.md:551:    b.layer.AddFlags(`
- L3164: `pkg/doc/topics/layers-guide.md:558:    // Conditionally add SSL parameters`
- L3165: `pkg/doc/topics/layers-guide.md:560:        b.layer.AddFlags(`
- L3166: `pkg/doc/topics/layers-guide.md:567:    // Conditionally add connection pool parameters`
- L3167: `pkg/doc/topics/layers-guide.md:569:        b.layer.AddFlags(`
- L3168: `pkg/doc/topics/layers-guide.md:577:    return b.layer, nil`
- L3169: `pkg/doc/topics/layers-guide.md:581:dbLayer, _ := NewDatabaseLayerBuilder().`
- L3170: `pkg/doc/topics/layers-guide.md:587:### Method 4: Registering Layers with Explicit Slugs on Commands`
- L3171: `pkg/doc/topics/layers-guide.md:589:In some cases you may want to register layers on a command under explicit slugs that differ from the layer's internal slug. Use `cmds.WithLayersMap` to provide a map of slug-to-layer entries when creating a command description.`
- L3172: `pkg/doc/topics/layers-guide.md:592:dbLayer, _ := NewDatabaseLayer()        // internal slug: "database"`
- L3173: `pkg/doc/topics/layers-guide.md:593:loggingLayer, _ := NewLoggingLayer()    // internal slug: "logging"`
- L3174: `pkg/doc/topics/layers-guide.md:597:    cmds.WithLayersMap(map[string]schema.Section{`
- L3175: `pkg/doc/topics/layers-guide.md:598:        "db":  dbLayer,    // registered under explicit slug "db"`
- L3176: `pkg/doc/topics/layers-guide.md:599:        "log": loggingLayer,`
- L3177: `pkg/doc/topics/layers-guide.md:607:- If a layer's internal slug differs from the map key and the layer is a `*schema.SectionImpl`, Glazed will clone the layer and align its slug to the provided key for consistent runtime behavior.`
- L3178: `pkg/doc/topics/layers-guide.md:608:- For custom layer implementations, prefer using matching internal and registration slugs when possible.`
- L3179: `pkg/doc/topics/layers-guide.md:614:Complete layer implementation for a web server with database, logging, and server configuration:`
- L3180: `pkg/doc/topics/layers-guide.md:622:    "github.com/go-go-golems/glazed/pkg/cmds/layers"`
- L3181: `pkg/doc/topics/layers-guide.md:623:    "github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L3182: `pkg/doc/topics/layers-guide.md:648:// Layer creation functions`
- L3183: `pkg/doc/topics/layers-guide.md:649:func NewServerLayer() (schema.Section, error) {`
- L3184: `pkg/doc/topics/layers-guide.md:684:func NewLoggingLayer() (schema.Section, error) {`
- L3185: `pkg/doc/topics/layers-guide.md:712:func NewDatabaseLayer() (schema.Section, error) {`
- L3186: `pkg/doc/topics/layers-guide.md:749:// Command creation with layer composition`
- L3187: `pkg/doc/topics/layers-guide.md:751:    // Create layers`
- L3188: `pkg/doc/topics/layers-guide.md:752:    serverLayer, err := NewServerLayer()`
- L3189: `pkg/doc/topics/layers-guide.md:757:    loggingLayer, err := NewLoggingLayer()`
- L3190: `pkg/doc/topics/layers-guide.md:762:    databaseLayer, err := NewDatabaseLayer()`
- L3191: `pkg/doc/topics/layers-guide.md:767:    // Compose command with relevant layers`
- L3192: `pkg/doc/topics/layers-guide.md:772:        cmds.WithLayersList(serverLayer, databaseLayer, loggingLayer),`
- L3193: `pkg/doc/topics/layers-guide.md:778:    serverLayer, err := NewServerLayer()`
- L3194: `pkg/doc/topics/layers-guide.md:783:    loggingLayer, err := NewLoggingLayer()`
- L3195: `pkg/doc/topics/layers-guide.md:799:        cmds.WithLayersList(serverLayer, loggingLayer), // No database layer`
- L3196: `pkg/doc/topics/layers-guide.md:803:// Settings extraction helpers demonstrate how to use InitializeStruct with layer-specific settings`
- L3197: `pkg/doc/topics/layers-guide.md:804:func GetServerSettings(parsedLayers *values.Values) (*ServerSettings, error) {`
- L3198: `pkg/doc/topics/layers-guide.md:806:    err := parsedLayers.InitializeStruct("server", settings)`
- L3199: `pkg/doc/topics/layers-guide.md:810:func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {`
- L3200: `pkg/doc/topics/layers-guide.md:812:    err := parsedLayers.InitializeStruct("logging", settings)`
- L3201: `pkg/doc/topics/layers-guide.md:816:func GetDatabaseSettings(parsedLayers *values.Values) (*DatabaseSettings, error) {`
- L3202: `pkg/doc/topics/layers-guide.md:818:    err := parsedLayers.InitializeStruct("database", settings)`
- L3203: `pkg/doc/topics/layers-guide.md:822:// Example command implementation using multiple layer settings`
- L3204: `pkg/doc/topics/layers-guide.md:827:func (c *ServerCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L3205: `pkg/doc/topics/layers-guide.md:828:    // Extract settings from each layer`
- L3206: `pkg/doc/topics/layers-guide.md:829:    serverSettings, err := GetServerSettings(parsedLayers)`
- L3207: `pkg/doc/topics/layers-guide.md:834:    dbSettings, err := GetDatabaseSettings(parsedLayers)`
- L3208: `pkg/doc/topics/layers-guide.md:839:    logSettings, err := GetLoggingSettings(parsedLayers)`
- L3209: `pkg/doc/topics/layers-guide.md:844:    // Use settings from multiple layers`
- L3210: `pkg/doc/topics/layers-guide.md:870:Layer composition for applications with conditional functionality. This example shows how to extract settings from optional layers and use them together:`
- L3211: `pkg/doc/topics/layers-guide.md:873:// Feature layers for optional inclusion`
- L3212: `pkg/doc/topics/layers-guide.md:874:func NewCacheLayer() (schema.Section, error) {`
- L3213: `pkg/doc/topics/layers-guide.md:901:func NewMetricsLayer() (schema.Section, error) {`
- L3214: `pkg/doc/topics/layers-guide.md:930:    baseLayers    []schema.Section`
- L3215: `pkg/doc/topics/layers-guide.md:937:    loggingLayer, _ := NewLoggingLayer()`
- L3216: `pkg/doc/topics/layers-guide.md:940:        baseLayers: []schema.Section{loggingLayer},`
- L3217: `pkg/doc/topics/layers-guide.md:960:    commandLayers := append([]schema.Section{}, b.baseLayers...)`
- L3218: `pkg/doc/topics/layers-guide.md:962:    // Add optional layers based on enabled features`
- L3219: `pkg/doc/topics/layers-guide.md:964:        cacheLayer, err := NewCacheLayer()`
- L3220: `pkg/doc/topics/layers-guide.md:968:        commandLayers = append(commandLayers, cacheLayer)`
- L3221: `pkg/doc/topics/layers-guide.md:972:        metricsLayer, err := NewMetricsLayer()`
- L3222: `pkg/doc/topics/layers-guide.md:976:        commandLayers = append(commandLayers, metricsLayer)`
- L3223: `pkg/doc/topics/layers-guide.md:980:        authLayer, err := NewAuthLayer() // Assume this exists`
- L3224: `pkg/doc/topics/layers-guide.md:984:        commandLayers = append(commandLayers, authLayer)`
- L3225: `pkg/doc/topics/layers-guide.md:1003:        cmds.WithLayersList(commandLayers...),`
- L3226: `pkg/doc/topics/layers-guide.md:1020:// Helper functions for optional layer settings`
- L3227: `pkg/doc/topics/layers-guide.md:1021:func GetCacheSettings(parsedLayers *values.Values) (*CacheSettings, error) {`
- L3228: `pkg/doc/topics/layers-guide.md:1023:    err := parsedLayers.InitializeStruct("cache", settings)`
- L3229: `pkg/doc/topics/layers-guide.md:1027:func GetMetricsSettings(parsedLayers *values.Values) (*MetricsSettings, error) {`
- L3230: `pkg/doc/topics/layers-guide.md:1029:    err := parsedLayers.InitializeStruct("metrics", settings)`
- L3231: `pkg/doc/topics/layers-guide.md:1033:// Command implementation that handles optional layers`
- L3232: `pkg/doc/topics/layers-guide.md:1038:func (c *ProcessCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L3233: `pkg/doc/topics/layers-guide.md:1040:    logSettings, err := GetLoggingSettings(parsedLayers)`
- L3234: `pkg/doc/topics/layers-guide.md:1048:    if parsedLayers.Has("cache") {`
- L3235: `pkg/doc/topics/layers-guide.md:1049:        cacheSettings, err := GetCacheSettings(parsedLayers)`
- L3236: `pkg/doc/topics/layers-guide.md:1062:    if parsedLayers.Has("metrics") {`
- L3237: `pkg/doc/topics/layers-guide.md:1063:        metricsSettings, err := GetMetricsSettings(parsedLayers)`
- L3238: `pkg/doc/topics/layers-guide.md:1096:### 1. Layer Inheritance and Composition`
- L3239: `pkg/doc/topics/layers-guide.md:1098:Extending existing layers without modification:`
- L3240: `pkg/doc/topics/layers-guide.md:1101:// Base database layer`
- L3241: `pkg/doc/topics/layers-guide.md:1102:func NewBaseDatabaseLayer() (schema.Section, error) {`
- L3242: `pkg/doc/topics/layers-guide.md:1115:// Extended database layer with additional features`
- L3243: `pkg/doc/topics/layers-guide.md:1116:func NewAdvancedDatabaseLayer() (schema.Section, error) {`
- L3244: `pkg/doc/topics/layers-guide.md:1117:    // Start with base layer`
- L3245: `pkg/doc/topics/layers-guide.md:1118:    baseLayer, err := NewBaseDatabaseLayer()`
- L3246: `pkg/doc/topics/layers-guide.md:1124:    advancedLayer := baseLayer.Clone()`
- L3247: `pkg/doc/topics/layers-guide.md:1126:    // Add additional parameters`
- L3248: `pkg/doc/topics/layers-guide.md:1127:    advancedLayer.AddFlags(`
- L3249: `pkg/doc/topics/layers-guide.md:1136:    return advancedLayer, nil`
- L3250: `pkg/doc/topics/layers-guide.md:1140:### 2. Environment-Specific Layer Configuration`
- L3251: `pkg/doc/topics/layers-guide.md:1142:Adapting layers for different deployment environments:`
- L3252: `pkg/doc/topics/layers-guide.md:1150:func NewEnvironmentAwareDatabaseLayer(config EnvironmentConfig) (schema.Section, error) {`
- L3253: `pkg/doc/topics/layers-guide.md:1151:    layer, err := NewBaseDatabaseLayer()`
- L3254: `pkg/doc/topics/layers-guide.md:1156:    // Add environment-specific parameters`
- L3255: `pkg/doc/topics/layers-guide.md:1159:        layer.AddFlags(`
- L3256: `pkg/doc/topics/layers-guide.md:1166:        layer.AddFlags(`
- L3257: `pkg/doc/topics/layers-guide.md:1175:    // Add feature-specific parameters`
- L3258: `pkg/doc/topics/layers-guide.md:1179:            layer.AddFlags(`
- L3259: `pkg/doc/topics/layers-guide.md:1185:            layer.AddFlags(`
- L3260: `pkg/doc/topics/layers-guide.md:1192:    return layer, nil`
- L3261: `pkg/doc/topics/layers-guide.md:1196:### 3. Dynamic Layer Registration`
- L3262: `pkg/doc/topics/layers-guide.md:1198:Runtime layer registration for plugin systems:`
- L3263: `pkg/doc/topics/layers-guide.md:1201:type LayerRegistry struct {`
- L3264: `pkg/doc/topics/layers-guide.md:1202:    layers map[string]schema.Section`
- L3265: `pkg/doc/topics/layers-guide.md:1206:func NewLayerRegistry() *LayerRegistry {`
- L3266: `pkg/doc/topics/layers-guide.md:1207:    return &LayerRegistry{`
- L3267: `pkg/doc/topics/layers-guide.md:1208:        layers: make(map[string]schema.Section),`
- L3268: `pkg/doc/topics/layers-guide.md:1212:func (r *LayerRegistry) RegisterLayer(slug string, layer schema.Section) error {`
- L3269: `pkg/doc/topics/layers-guide.md:1216:    if _, exists := r.layers[slug]; exists {`
- L3270: `pkg/doc/topics/layers-guide.md:1217:        return fmt.Errorf("layer %s already registered", slug)`
- L3271: `pkg/doc/topics/layers-guide.md:1220:    r.layers[slug] = layer`
- L3272: `pkg/doc/topics/layers-guide.md:1224:func (r *LayerRegistry) GetLayer(slug string) (schema.Section, error) {`
- L3273: `pkg/doc/topics/layers-guide.md:1228:    layer, exists := r.layers[slug]`
- L3274: `pkg/doc/topics/layers-guide.md:1230:        return nil, fmt.Errorf("layer %s not found", slug)`
- L3275: `pkg/doc/topics/layers-guide.md:1233:    return layer, nil`
- L3276: `pkg/doc/topics/layers-guide.md:1236:func (r *LayerRegistry) BuildCommand(name string, layerSlugs []string) (*cmds.CommandDescription, error) {`
- L3277: `pkg/doc/topics/layers-guide.md:1237:    var commandLayers []schema.Section`
- L3278: `pkg/doc/topics/layers-guide.md:1239:    for _, slug := range layerSlugs {`
- L3279: `pkg/doc/topics/layers-guide.md:1240:        layer, err := r.GetLayer(slug)`
- L3280: `pkg/doc/topics/layers-guide.md:1244:        commandLayers = append(commandLayers, layer)`
- L3281: `pkg/doc/topics/layers-guide.md:1248:        cmds.WithLayersList(commandLayers...)), nil`
- L3282: `pkg/doc/topics/layers-guide.md:1252:func InitializePluginSystem() *LayerRegistry {`
- L3283: `pkg/doc/topics/layers-guide.md:1253:    registry := NewLayerRegistry()`
- L3284: `pkg/doc/topics/layers-guide.md:1255:    // Register core layers`
- L3285: `pkg/doc/topics/layers-guide.md:1256:    databaseLayer, _ := NewDatabaseLayer()`
- L3286: `pkg/doc/topics/layers-guide.md:1257:    registry.RegisterLayer("database", databaseLayer)`
- L3287: `pkg/doc/topics/layers-guide.md:1259:    loggingLayer, _ := NewLoggingLayer()`
- L3288: `pkg/doc/topics/layers-guide.md:1260:    registry.RegisterLayer("logging", loggingLayer)`
- L3289: `pkg/doc/topics/layers-guide.md:1262:    // Plugins can register additional layers`
- L3290: `pkg/doc/topics/layers-guide.md:1263:    // registry.RegisterLayer("custom-feature", customLayer)`
- L3291: `pkg/doc/topics/layers-guide.md:1269:### 4. Layer Validation and Constraints`
- L3292: `pkg/doc/topics/layers-guide.md:1271:Complex validation rules across layer parameters:`
- L3293: `pkg/doc/topics/layers-guide.md:1274:type LayerValidator struct {`
- L3294: `pkg/doc/topics/layers-guide.md:1280:func NewLayerValidator() *LayerValidator {`
- L3295: `pkg/doc/topics/layers-guide.md:1281:    return &LayerValidator{}`
- L3296: `pkg/doc/topics/layers-guide.md:1284:func (v *LayerValidator) AddRule(rule ValidationRule) {`
- L3297: `pkg/doc/topics/layers-guide.md:1288:func (v *LayerValidator) Validate(parsedLayers *values.Values) error {`
- L3298: `pkg/doc/topics/layers-guide.md:1290:        if err := rule(parsedLayers); err != nil {`
- L3299: `pkg/doc/topics/layers-guide.md:1297:// Cross-layer validation rules`
- L3300: `pkg/doc/topics/layers-guide.md:1298:func DatabaseConnectionRule(parsedLayers *values.Values) error {`
- L3301: `pkg/doc/topics/layers-guide.md:1299:    dbLayer, ok := parsedLayers.Get("database")`
- L3302: `pkg/doc/topics/layers-guide.md:1301:        return nil // Skip if database layer not present`
- L3303: `pkg/doc/topics/layers-guide.md:1304:    host, ok := dbLayer.GetParameter("db-host")`
- L3304: `pkg/doc/topics/layers-guide.md:1309:    port, ok := dbLayer.GetParameter("db-port")`
- L3305: `pkg/doc/topics/layers-guide.md:1314:    // Validate connection parameters make sense together`
- L3306: `pkg/doc/topics/layers-guide.md:1322:func SSLConfigurationRule(parsedLayers *values.Values) error {`
- L3307: `pkg/doc/topics/layers-guide.md:1323:    dbLayer, ok := parsedLayers.Get("database")`
- L3308: `pkg/doc/topics/layers-guide.md:1325:        return nil // Skip if database layer not present`
- L3309: `pkg/doc/topics/layers-guide.md:1328:    sslMode, ok := dbLayer.GetParameter("db-ssl-mode")`
- L3310: `pkg/doc/topics/layers-guide.md:1335:        cert, ok := dbLayer.GetParameter("db-ssl-cert")`
- L3311: `pkg/doc/topics/layers-guide.md:1345:func (c *MyCommand) Run(ctx context.Context, parsedLayers *values.Values) error {`
- L3312: `pkg/doc/topics/layers-guide.md:1346:    // Validate layer configuration`
- L3313: `pkg/doc/topics/layers-guide.md:1347:    validator := NewLayerValidator()`
- L3314: `pkg/doc/topics/layers-guide.md:1351:    if err := validator.Validate(parsedLayers); err != nil {`
- L3315: `pkg/doc/topics/layers-guide.md:1362:### Layer Design Principles`
- L3316: `pkg/doc/topics/layers-guide.md:1364:**Single Responsibility**: Each layer should handle one logical area of configuration. Database layers handle database parameters, logging layers handle logging configuration.`
- L3317: `pkg/doc/topics/layers-guide.md:1366:**Clear Naming**: Use descriptive layer slugs and parameter names. Prefer `database-connection-timeout` over `timeout`.`
- L3318: `pkg/doc/topics/layers-guide.md:1370:**Consistent Interfaces**: Use similar parameter names across layers. If one layer uses `host`, avoid `hostname` in another layer for the same concept.`
- L3319: `pkg/doc/topics/layers-guide.md:1372:### Parameter Organization`
- L3320: `pkg/doc/topics/layers-guide.md:1374:Group related parameters logically within layers. Database layers should include host, port, credentials, and connection options together.`
- L3321: `pkg/doc/topics/layers-guide.md:1378:Consider parameter relationships when designing layers. Parameters that are frequently used together belong in the same layer.`
- L3322: `pkg/doc/topics/layers-guide.md:1382:Only include layers that provide parameters relevant to the command's functionality. Avoid layer pollution by being selective.`
- L3323: `pkg/doc/topics/layers-guide.md:1386:Consider creating specialized layer variants for different command types. A read-only database layer might exclude authentication parameters.`
- L3324: `pkg/doc/topics/layers-guide.md:1390:Validate layer configuration early in command execution. Fail fast with clear error messages about parameter issues.`
- L3325: `pkg/doc/topics/layers-guide.md:1394:Use type-safe parameter extraction where possible. Struct-based settings reduce runtime errors and improve code clarity.`
- L3326: `pkg/doc/topics/layers-guide.md:1398:Write unit tests for layer definitions to ensure parameter validation works correctly. Test edge cases and error conditions.`
- L3327: `pkg/doc/topics/layers-guide.md:1400:Test layer composition to verify that combined layers work correctly together. Check for parameter conflicts and validation interactions.`
- L3328: `pkg/doc/topics/layers-guide.md:1402:Use integration tests to verify that commands work correctly with different layer combinations and parameter sources.`
- L3329: `pkg/doc/topics/layers-guide.md:1404:Document layer dependencies and relationships. Explain when layers should be used together and any constraints.`
- L3330: `pkg/doc/topics/layers-guide.md:1406:Keep layer definitions close to their usage when possible. This improves maintainability and reduces the chance of configuration drift.`
- L3331: `pkg/doc/topics/layers-guide.md:1408:Version layer definitions carefully in evolving applications. Consider backward compatibility when modifying existing layers.`
- L3332: `pkg/doc/topics/layers-guide.md:1410:## Testing Layers`
- L3333: `pkg/doc/topics/layers-guide.md:1412:### Unit Testing Layer Definitions`
- L3334: `pkg/doc/topics/layers-guide.md:1414:Test individual layer creation and parameter validation:`
- L3335: `pkg/doc/topics/layers-guide.md:1417:func TestDatabaseLayer(t *testing.T) {`
- L3336: `pkg/doc/topics/layers-guide.md:1418:    layer, err := NewDatabaseLayer()`
- L3337: `pkg/doc/topics/layers-guide.md:1420:    assert.Equal(t, "database", layer.GetSlug())`
- L3338: `pkg/doc/topics/layers-guide.md:1422:    // Test parameter definitions`
- L3339: `pkg/doc/topics/layers-guide.md:1423:    params := layer.GetParameterDefinitions()`
- L3340: `pkg/doc/topics/layers-guide.md:1436:func TestParameterValidation(t *testing.T) {`
- L3341: `pkg/doc/topics/layers-guide.md:1437:    layer, _ := NewDatabaseLayer()`
- L3342: `pkg/doc/topics/layers-guide.md:1440:    logLevelParam := layer.GetParameterDefinitions()["log-level"]`
- L3343: `pkg/doc/topics/layers-guide.md:1444:    // Test required parameters`
- L3344: `pkg/doc/topics/layers-guide.md:1445:    dbNameParam := layer.GetParameterDefinitions()["db-name"]`
- L3345: `pkg/doc/topics/layers-guide.md:1450:### Integration Testing Layer Composition`
- L3346: `pkg/doc/topics/layers-guide.md:1452:Test command creation with multiple layers:`
- L3347: `pkg/doc/topics/layers-guide.md:1456:    serverLayer, _ := NewServerLayer()`
- L3348: `pkg/doc/topics/layers-guide.md:1457:    databaseLayer, _ := NewDatabaseLayer()`
- L3349: `pkg/doc/topics/layers-guide.md:1458:    loggingLayer, _ := NewLoggingLayer()`
- L3350: `pkg/doc/topics/layers-guide.md:1461:        cmds.WithLayersList(serverLayer, databaseLayer, loggingLayer))`
- L3351: `pkg/doc/topics/layers-guide.md:1466:    // Verify all layers are present`
- L3352: `pkg/doc/topics/layers-guide.md:1467:    layers := command.GetLayers()`
- L3353: `pkg/doc/topics/layers-guide.md:1468:    assert.Len(t, layers, 3)`
- L3354: `pkg/doc/topics/layers-guide.md:1470:    // Verify no parameter conflicts`
- L3355: `pkg/doc/topics/layers-guide.md:1472:    for _, layer := range layers {`
- L3356: `pkg/doc/topics/layers-guide.md:1473:        for paramName := range layer.GetParameterDefinitions() {`
- L3357: `pkg/doc/topics/layers-guide.md:1475:                "Parameter %s defined in multiple layers", paramName)`
- L3358: `pkg/doc/topics/layers-guide.md:1482:### Testing Parameter Resolution`
- L3359: `pkg/doc/topics/layers-guide.md:1484:Test parameter value resolution from different sources:`
- L3360: `pkg/doc/topics/layers-guide.md:1487:func TestParameterResolution(t *testing.T) {`
- L3361: `pkg/doc/topics/layers-guide.md:1488:    // Create test command with layers`
- L3362: `pkg/doc/topics/layers-guide.md:1493:    parsedLayers, err := command.ParseLayers(args)`
- L3363: `pkg/doc/topics/layers-guide.md:1497:    dbLayer, ok := parsedLayers.Get("database")`
- L3364: `pkg/doc/topics/layers-guide.md:1500:    dbHost, ok := dbLayer.GetParameter("db-host")`
- L3365: `pkg/doc/topics/layers-guide.md:1504:    dbPort, ok := dbLayer.GetParameter("db-port")`
- L3366: `pkg/doc/topics/layers-guide.md:1510:    err = parsedLayers.InitializeStruct("database", dbSettings)`
- L3367: `pkg/doc/topics/layers-guide.md:1520:    parsedLayers, err := command.ParseLayers([]string{})`
- L3368: `pkg/doc/topics/layers-guide.md:1524:    dbLayer, _ := parsedLayers.Get("database")`
- L3369: `pkg/doc/topics/layers-guide.md:1525:    dbHost, _ := dbLayer.GetParameter("db-host")`
- L3370: `pkg/doc/topics/layers-guide.md:1528:    dbPort, _ := dbLayer.GetParameter("db-port")`
- L3371: `pkg/doc/topics/layers-guide.md:1531:    loggingLayer, _ := parsedLayers.Get("logging")`
- L3372: `pkg/doc/topics/layers-guide.md:1532:    logLevel, _ := loggingLayer.GetParameter("log-level")`
- L3373: `pkg/doc/topics/layers-guide.md:1537:### Testing Layer Builders and Dynamic Composition`
- L3374: `pkg/doc/topics/layers-guide.md:1539:Test builder patterns and conditional layer inclusion:`
- L3375: `pkg/doc/topics/layers-guide.md:1542:func TestDatabaseLayerBuilder(t *testing.T) {`
- L3376: `pkg/doc/topics/layers-guide.md:1543:    // Test basic layer`
- L3377: `pkg/doc/topics/layers-guide.md:1544:    basicLayer, err := NewDatabaseLayerBuilder().Build()`
- L3378: `pkg/doc/topics/layers-guide.md:1547:    basicParams := basicLayer.GetParameterDefinitions()`
- L3379: `pkg/doc/topics/layers-guide.md:1552:    // Test layer with SSL`
- L3380: `pkg/doc/topics/layers-guide.md:1553:    sslLayer, err := NewDatabaseLayerBuilder().WithSSL().Build()`
- L3381: `pkg/doc/topics/layers-guide.md:1556:    sslParams := sslLayer.GetParameterDefinitions()`
- L3382: `pkg/doc/topics/layers-guide.md:1561:    // Test layer with connection pool`
- L3383: `pkg/doc/topics/layers-guide.md:1562:    poolLayer, err := NewDatabaseLayerBuilder().WithConnectionPool().Build()`
- L3384: `pkg/doc/topics/layers-guide.md:1565:    poolParams := poolLayer.GetParameterDefinitions()`
- L3385: `pkg/doc/topics/layers-guide.md:1570:func TestConditionalLayerComposition(t *testing.T) {`
- L3386: `pkg/doc/topics/layers-guide.md:1576:    assert.Len(t, basicCmd.GetLayers(), 1) // Only logging layer`
- L3387: `pkg/doc/topics/layers-guide.md:1581:    assert.Len(t, cacheCmd.GetLayers(), 2) // Logging + cache layers`
- L3388: `pkg/doc/topics/layers-guide.md:1586:    assert.Len(t, fullCmd.GetLayers(), 4) // All layers`
- L3389: `pkg/doc/topics/layers-guide.md:1590:This comprehensive testing approach ensures layers work correctly individually and in composition, parameter resolution functions properly across different sources, and dynamic layer construction produces expected results.`
- L3390: `pkg/cmds/alias/alias.go:136:func (a *CommandAlias) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L3391: `pkg/cmds/alias/alias.go:144:	return glazeCommand.RunIntoGlazeProcessor(ctx, parsedLayers, gp)`
- L3392: `pkg/cmds/alias/alias.go:147:func (a *CommandAlias) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {`
- L3393: `pkg/cmds/alias/alias.go:155:	return writerCommand.RunIntoWriter(ctx, parsedLayers, w)`
- L3394: `pkg/cmds/alias/alias.go:177:	newLayers := s.Layers.Clone()`
- L3395: `pkg/cmds/alias/alias.go:184:		Layers:         newLayers,`
- L3396: `pkg/cmds/fields/test-data/parameters_test.yaml:1:#  ParameterTypeString         ParameterType = "string"`
- L3397: `pkg/cmds/fields/test-data/parameters_test.yaml:2:#  ParameterTypeStringFromFile ParameterType = "stringFromFile"`
- L3398: `pkg/cmds/fields/test-data/parameters_test.yaml:3:#  ParameterTypeObjectListFromFile ParameterType = "objectListFromFile"`
- L3399: `pkg/cmds/fields/test-data/parameters_test.yaml:4:#  ParameterTypeObjectFromFile     ParameterType = "objectFromFile"`
- L3400: `pkg/cmds/fields/test-data/parameters_test.yaml:5:#  // ParameterTypeKeyValue signals either a string with comma separate key-value options, or when beginning with @, a file with key-value options`
- L3401: `pkg/cmds/fields/test-data/parameters_test.yaml:6:#  ParameterTypeKeyValue    ParameterType = "keyValue"`
- L3402: `pkg/cmds/fields/test-data/parameters_test.yaml:7:#  ParameterTypeInteger     ParameterType = "int"`
- L3403: `pkg/cmds/fields/test-data/parameters_test.yaml:8:#  ParameterTypeFloat       ParameterType = "float"`
- L3404: `pkg/cmds/fields/test-data/parameters_test.yaml:9:#  ParameterTypeBool        ParameterType = "bool"`
- L3405: `pkg/cmds/fields/test-data/parameters_test.yaml:10:#  ParameterTypeDate        ParameterType = "date"`
- L3406: `pkg/cmds/fields/test-data/parameters_test.yaml:11:#  ParameterTypeStringList  ParameterType = "stringList"`
- L3407: `pkg/cmds/fields/test-data/parameters_test.yaml:12:#  ParameterTypeIntegerList ParameterType = "intList"`
- L3408: `pkg/cmds/fields/test-data/parameters_test.yaml:13:#  ParameterTypeFloatList   ParameterType = "floatList"`
- L3409: `pkg/cmds/fields/test-data/parameters_test.yaml:14:#  ParameterTypeChoice      ParameterType = "choice"`
- L3410: `pkg/cmds/fields/test-data/parameters_test.yaml:15:#  ParameterTypeChoiceList  ParameterType = "choiceList"`
- L3411: `pkg/cmds/layout/layout.go:24:	// These can be specified to override the values read from the flag / layer parameter definition`
- L3412: `pkg/cmds/sources/profiles.go:20:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3413: `pkg/cmds/sources/profiles.go:21:			err := next(layers_, parsedLayers)`
- L3414: `pkg/cmds/sources/profiles.go:57:			//   layer1:`
- L3415: `pkg/cmds/sources/profiles.go:58:			//     parameterName: parameterValue`
- L3416: `pkg/cmds/sources/profiles.go:59:			//   layer2:`
- L3417: `pkg/cmds/sources/profiles.go:60:			//     parameterName: parameterValue`
- L3418: `pkg/cmds/sources/profiles.go:70:				return updateFromMap(layers_, parsedLayers, profileMap, options...)`
- L3419: `pkg/cmds/sources/profiles.go:107:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3420: `pkg/cmds/sources/profiles.go:108:			err := next(layers_, parsedLayers)`
- L3421: `pkg/cmds/sources/profiles.go:148:			return updateFromMap(layers_, parsedLayers, profileMap, config.ParseOptions...)`
- L3422: `pkg/cmds/sources/profiles.go:223:	//   layer1:`
- L3423: `pkg/cmds/sources/profiles.go:224:	//     parameterName: parameterValue`
- L3424: `pkg/cmds/sources/profiles.go:225:	//   layer2:`
- L3425: `pkg/cmds/sources/profiles.go:226:	//     parameterName: parameterValue`
- L3426: `pkg/cmds/sources/update_test.go:15:	// Define a layer with a prefix so env keys are: PREFIX + "_" + UPPER(prefix+name)`
- L3427: `pkg/cmds/sources/update_test.go:16:	cfgLayer, err := schema.NewSection("cfg", "Config",`
- L3428: `pkg/cmds/sources/update_test.go:33:	pl := schema.NewSchema(schema.WithSections(cfgLayer))`
- L3429: `pkg/cmds/sources/update_test.go:75:	layer, ok := parsed.Get("cfg")`
- L3430: `pkg/cmds/sources/update_test.go:79:		v, ok := layer.Parameters.Get(name)`
- L3431: `pkg/cmds/sources/update_test.go:80:		require.True(t, ok, "parameter %s should be set", name)`
- L3432: `pkg/cmds/sources/update_test.go:101:	vp, ok := layer.Parameters.Get("verbose")`
- L3433: `pkg/cmds/sources/update_test.go:117:	cfgLayer, err := schema.NewSection("cfg", "Config",`
- L3434: `pkg/cmds/sources/update_test.go:125:	pl := schema.NewSchema(schema.WithSections(cfgLayer))`
- L3435: `pkg/cmds/sources/whitelist.go:8:// WhitelistLayersHandler only leaves the specified layers from the given ParameterLayers.`
- L3436: `pkg/cmds/sources/whitelist.go:9:// It takes a slice of layer slugs, and deletes any layers in the ParameterLayers`
- L3437: `pkg/cmds/sources/whitelist.go:11:func WhitelistLayersHandler(slugs []string) HandlerFunc {`
- L3438: `pkg/cmds/sources/whitelist.go:16:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3439: `pkg/cmds/sources/whitelist.go:18:		layers_.ForEach(func(key string, l schema.Section) {`
- L3440: `pkg/cmds/sources/whitelist.go:24:			layers_.Delete(key)`
- L3441: `pkg/cmds/sources/whitelist.go:30:func WhitelistLayerParametersHandler(parameters_ map[string][]string) HandlerFunc {`
- L3442: `pkg/cmds/sources/whitelist.go:31:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3443: `pkg/cmds/sources/whitelist.go:32:		layersToDelete := []string{}`
- L3444: `pkg/cmds/sources/whitelist.go:33:		layersToUpdate := map[string]schema.Section{}`
- L3445: `pkg/cmds/sources/whitelist.go:34:		layers_.ForEach(func(key string, l schema.Section) {`
- L3446: `pkg/cmds/sources/whitelist.go:35:			if _, ok := parameters_[key]; !ok {`
- L3447: `pkg/cmds/sources/whitelist.go:36:				layersToDelete = append(layersToDelete, key)`
- L3448: `pkg/cmds/sources/whitelist.go:40:			parametersToKeep := map[string]interface{}{}`
- L3449: `pkg/cmds/sources/whitelist.go:41:			for _, p := range parameters_[key] {`
- L3450: `pkg/cmds/sources/whitelist.go:42:				parametersToKeep[p] = nil`
- L3451: `pkg/cmds/sources/whitelist.go:44:			layersToUpdate[key] = schema.NewWhitelistParameterLayer(l, parametersToKeep)`
- L3452: `pkg/cmds/sources/whitelist.go:46:		for _, key := range layersToDelete {`
- L3453: `pkg/cmds/sources/whitelist.go:47:			layers_.Delete(key)`
- L3454: `pkg/cmds/sources/whitelist.go:49:		for key, l := range layersToUpdate {`
- L3455: `pkg/cmds/sources/whitelist.go:50:			layers_.Set(key, l)`
- L3456: `pkg/cmds/sources/whitelist.go:56:func WhitelistLayers(slugs []string) Middleware {`
- L3457: `pkg/cmds/sources/whitelist.go:58:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3458: `pkg/cmds/sources/whitelist.go:59:			err := next(layers_, parsedLayers)`
- L3459: `pkg/cmds/sources/whitelist.go:64:			return WhitelistLayersHandler(slugs)(layers_, parsedLayers)`
- L3460: `pkg/cmds/sources/whitelist.go:69:func WhitelistLayersFirst(slugs []string) Middleware {`
- L3461: `pkg/cmds/sources/whitelist.go:71:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3462: `pkg/cmds/sources/whitelist.go:72:			err := WhitelistLayersHandler(slugs)(layers_, parsedLayers)`
- L3463: `pkg/cmds/sources/whitelist.go:77:			return next(layers_, parsedLayers)`
- L3464: `pkg/cmds/sources/whitelist.go:82:func WhitelistLayerParameters(parameters_ map[string][]string) Middleware {`
- L3465: `pkg/cmds/sources/whitelist.go:84:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3466: `pkg/cmds/sources/whitelist.go:85:			err := next(layers_, parsedLayers)`
- L3467: `pkg/cmds/sources/whitelist.go:90:			return WhitelistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L3468: `pkg/cmds/sources/whitelist.go:95:func WhitelistLayerParametersFirst(parameters_ map[string][]string) Middleware {`
- L3469: `pkg/cmds/sources/whitelist.go:97:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3470: `pkg/cmds/sources/whitelist.go:98:			err := WhitelistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L3471: `pkg/cmds/sources/whitelist.go:103:			return next(layers_, parsedLayers)`
- L3472: `pkg/cmds/sources/whitelist.go:108:// BlacklistLayersHandler removes the specified layers from the given ParameterLayers.`
- L3473: `pkg/cmds/sources/whitelist.go:109:// It takes a slice of layer slugs, and deletes any layers in the ParameterLayers`
- L3474: `pkg/cmds/sources/whitelist.go:111:func BlacklistLayersHandler(slugs []string) HandlerFunc {`
- L3475: `pkg/cmds/sources/whitelist.go:116:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3476: `pkg/cmds/sources/whitelist.go:118:		layers_.ForEach(func(key string, l schema.Section) {`
- L3477: `pkg/cmds/sources/whitelist.go:124:			layers_.Delete(key)`
- L3478: `pkg/cmds/sources/whitelist.go:130:func BlacklistLayerParametersHandler(parameters_ map[string][]string) HandlerFunc {`
- L3479: `pkg/cmds/sources/whitelist.go:131:	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3480: `pkg/cmds/sources/whitelist.go:132:		layersToDelete := []string{}`
- L3481: `pkg/cmds/sources/whitelist.go:133:		layersToUpdate := map[string]schema.Section{}`
- L3482: `pkg/cmds/sources/whitelist.go:134:		layers_.ForEach(func(key string, l schema.Section) {`
- L3483: `pkg/cmds/sources/whitelist.go:135:			if _, ok := parameters_[key]; !ok {`
- L3484: `pkg/cmds/sources/whitelist.go:139:			parametersToKeep := map[string]interface{}{}`
- L3485: `pkg/cmds/sources/whitelist.go:140:			for _, p := range parameters_[key] {`
- L3486: `pkg/cmds/sources/whitelist.go:141:				parametersToKeep[p] = nil`
- L3487: `pkg/cmds/sources/whitelist.go:143:			layersToUpdate[key] = schema.NewBlacklistParameterLayer(l, parametersToKeep)`
- L3488: `pkg/cmds/sources/whitelist.go:145:		for _, key := range layersToDelete {`
- L3489: `pkg/cmds/sources/whitelist.go:146:			layers_.Delete(key)`
- L3490: `pkg/cmds/sources/whitelist.go:148:		for key, l := range layersToUpdate {`
- L3491: `pkg/cmds/sources/whitelist.go:149:			layers_.Set(key, l)`
- L3492: `pkg/cmds/sources/whitelist.go:155:// BlacklistLayers is a middleware that removes the given layers from ParameterLayers after running `next`.`
- L3493: `pkg/cmds/sources/whitelist.go:156:func BlacklistLayers(slugs []string) Middleware {`
- L3494: `pkg/cmds/sources/whitelist.go:158:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3495: `pkg/cmds/sources/whitelist.go:159:			err := next(layers_, parsedLayers)`
- L3496: `pkg/cmds/sources/whitelist.go:164:			return BlacklistLayersHandler(slugs)(layers_, parsedLayers)`
- L3497: `pkg/cmds/sources/whitelist.go:169:// BlacklistLayersFirst is a middleware that removes the given layers from ParameterLayers before running `next`.`
- L3498: `pkg/cmds/sources/whitelist.go:170:func BlacklistLayersFirst(slugs []string) Middleware {`
- L3499: `pkg/cmds/sources/whitelist.go:172:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3500: `pkg/cmds/sources/whitelist.go:173:			err := next(layers_, parsedLayers)`
- L3501: `pkg/cmds/sources/whitelist.go:178:			return BlacklistLayersHandler(slugs)(layers_, parsedLayers)`
- L3502: `pkg/cmds/sources/whitelist.go:183:// BlacklistLayerParameters is a middleware that removes the given parameters from ParameterLayers after running `next`.`
- L3503: `pkg/cmds/sources/whitelist.go:184:func BlacklistLayerParameters(parameters_ map[string][]string) Middleware {`
- L3504: `pkg/cmds/sources/whitelist.go:186:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3505: `pkg/cmds/sources/whitelist.go:187:			err := next(layers_, parsedLayers)`
- L3506: `pkg/cmds/sources/whitelist.go:192:			return BlacklistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L3507: `pkg/cmds/sources/whitelist.go:197:// BlacklistLayerParametersFirst is a middleware that removes the given parameters from ParameterLayers before running `next`.`
- L3508: `pkg/cmds/sources/whitelist.go:198:func BlacklistLayerParametersFirst(parameters_ map[string][]string) Middleware {`
- L3509: `pkg/cmds/sources/whitelist.go:200:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3510: `pkg/cmds/sources/whitelist.go:201:			err := BlacklistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L3511: `pkg/cmds/sources/whitelist.go:206:			return next(layers_, parsedLayers)`
- L3512: `pkg/cmds/sources/whitelist.go:211:// WrapWithLayerModifyingHandler wraps a middleware that modifies the layers`
- L3513: `pkg/cmds/sources/whitelist.go:212:// with additional middlewares. It clones the original layers, calls the`
- L3514: `pkg/cmds/sources/whitelist.go:213:// layer modifying middleware, chains any additional middlewares, calls`
- L3515: `pkg/cmds/sources/whitelist.go:214:// next with the original layers, and returns any errors.`
- L3516: `pkg/cmds/sources/whitelist.go:217:// restricted subset of layers. However, the normal set of middlewares is allowed`
- L3517: `pkg/cmds/sources/whitelist.go:219:func WrapWithLayerModifyingHandler(m HandlerFunc, nextMiddlewares ...Middleware) Middleware {`
- L3518: `pkg/cmds/sources/whitelist.go:221:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3519: `pkg/cmds/sources/whitelist.go:222:			err := next(layers_, parsedLayers)`
- L3520: `pkg/cmds/sources/whitelist.go:229:			clonedLayers := layers_.Clone()`
- L3521: `pkg/cmds/sources/whitelist.go:230:			err = m(clonedLayers, parsedLayers)`
- L3522: `pkg/cmds/sources/whitelist.go:235:			err = chain(Identity)(clonedLayers, parsedLayers)`
- L3523: `pkg/cmds/sources/whitelist.go:245:// WrapWithWhitelistedLayers wraps a middleware that restricts layers`
- L3524: `pkg/cmds/sources/whitelist.go:248:// certain restricted layers.`
- L3525: `pkg/cmds/sources/whitelist.go:249:func WrapWithWhitelistedLayers(slugs []string, nextMiddlewares ...Middleware) Middleware {`
- L3526: `pkg/cmds/sources/whitelist.go:250:	return WrapWithLayerModifyingHandler(WhitelistLayersHandler(slugs), nextMiddlewares...)`
- L3527: `pkg/cmds/sources/whitelist.go:253:func WrapWithWhitelistedParameterLayers(parameters_ map[string][]string, nextMiddlewares ...Middleware) Middleware {`
- L3528: `pkg/cmds/sources/whitelist.go:254:	return WrapWithLayerModifyingHandler(WhitelistLayerParametersHandler(parameters_), nextMiddlewares...)`
- L3529: `pkg/cmds/sources/whitelist.go:257:// WrapWithBlacklistedLayers wraps a middleware that restricts layers`
- L3530: `pkg/cmds/sources/whitelist.go:260:// certain restricted layers.`
- L3531: `pkg/cmds/sources/whitelist.go:261:func WrapWithBlacklistedLayers(slugs []string, nextMiddlewares ...Middleware) Middleware {`
- L3532: `pkg/cmds/sources/whitelist.go:262:	return WrapWithLayerModifyingHandler(BlacklistLayersHandler(slugs), nextMiddlewares...)`
- L3533: `pkg/cmds/sources/whitelist.go:265:func WrapWithBlacklistedParameterLayers(parameters_ map[string][]string, nextMiddlewares ...Middleware) Middleware {`
- L3534: `pkg/cmds/sources/whitelist.go:266:	return WrapWithLayerModifyingHandler(BlacklistLayerParametersHandler(parameters_), nextMiddlewares...)`
- L3535: `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:17:	// Create a simple layer`
- L3536: `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:18:	layer, err := schema.NewSection(`
- L3537: `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:20:		"Demo Layer",`
- L3538: `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:27:	pls := schema.NewSchema(schema.WithSections(layer))`
- L3539: `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:33:			TargetLayer:     "demo",`
- L3540: `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go:34:			TargetParameter: "api-key",`
- L3541: `pkg/helpers/markdown/markdown.go:100:// them based on the `withQuotes` parameter to decide on the inclusion of the enclosing ``` marks.`
- L3542: `pkg/cmds/sources/middlewares.go:8:type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error`
- L3543: `pkg/cmds/sources/middlewares.go:12:// layer middlewares:`
- L3544: `pkg/cmds/sources/middlewares.go:13:// - [x] whitelist (layers, parameters)`
- L3545: `pkg/cmds/sources/middlewares.go:14:// - [x] blacklist (layers, parameters)`
- L3546: `pkg/cmds/sources/middlewares.go:18:// - [x] from parameter definition defaults`
- L3547: `pkg/cmds/sources/middlewares.go:22:func Identity(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3548: `pkg/cmds/sources/middlewares.go:39:// Finally, it calls the resulting handler with the provided layers and parsedLayers.`
- L3549: `pkg/cmds/sources/middlewares.go:44:// [f1, f2, f3] will be executed as f1(f2(f3(handler)))(layers_, parsedLayers).`
- L3550: `pkg/cmds/sources/middlewares.go:49://   - if all you do is modify the parsedLayers, call `next` first.`
- L3551: `pkg/cmds/sources/middlewares.go:50://     This means that parsedLayers will be modified in the order of the middlewares.`
- L3552: `pkg/cmds/sources/middlewares.go:53://   - if you want to modify the layers before parsing, use the`
- L3553: `pkg/cmds/sources/middlewares.go:55://     get the newly updated ParameterLayers and thus potentially restrict which parameters they parse.`
- L3554: `pkg/cmds/sources/middlewares.go:56:func Execute(layers_ *schema.Schema, parsedLayers *values.Values, middlewares ...Middleware) error {`
- L3555: `pkg/cmds/sources/middlewares.go:66:	clonedLayers := layers_.Clone()`
- L3556: `pkg/cmds/sources/middlewares.go:67:	return handler(clonedLayers, parsedLayers)`
- L3557: `pkg/cmds/fields/test-data/gather-fields.yaml:3:  parameterDefs:`
- L3558: `pkg/cmds/fields/test-data/gather-fields.yaml:23:  parameterDefs:`
- L3559: `pkg/cmds/fields/test-data/gather-fields.yaml:40:  parameterDefs:`
- L3560: `pkg/cmds/fields/test-data/gather-fields.yaml:60:  parameterDefs:`
- L3561: `pkg/cmds/fields/test-data/gather-fields.yaml:79:  parameterDefs:`
- L3562: `pkg/cmds/fields/test-data/gather-fields.yaml:99:  parameterDefs:`
- L3563: `pkg/cmds/fields/test-data/gather-fields.yaml:117:  parameterDefs:`
- L3564: `pkg/cmds/fields/test-data/gather-fields.yaml:135:  parameterDefs:`
- L3565: `pkg/cmds/fields/test-data/gather-fields.yaml:151:  parameterDefs:`
- L3566: `pkg/cmds/fields/test-data/gather-fields.yaml:168:  parameterDefs:`
- L3567: `pkg/cmds/fields/test-data/gather-fields.yaml:184:  parameterDefs:`
- L3568: `pkg/cmds/fields/test-data/gather-fields.yaml:198:  parameterDefs:`
- L3569: `pkg/cmds/fields/test-data/gather-fields.yaml:217:  parameterDefs:`
- L3570: `pkg/cmds/fields/test-data/gather-fields.yaml:225:  expectedError: "unknown parameter type foobar"`
- L3571: `pkg/cmds/fields/test-data/gather-fields.yaml:229:  parameterDefs:`
- L3572: `pkg/cmds/fields/test-data/gather-fields.yaml:241:  parameterDefs:`
- L3573: `pkg/cmds/fields/test-data/gather-fields.yaml:253:  parameterDefs:`
- L3574: `pkg/cmds/fields/test-data/gather-fields.yaml:263:- title: "Test with choice parameters"`
- L3575: `pkg/cmds/fields/test-data/gather-fields.yaml:265:  parameterDefs:`
- L3576: `pkg/cmds/fields/test-data/gather-fields.yaml:279:- title: "Test with valid choice parameter"`
- L3577: `pkg/cmds/fields/test-data/gather-fields.yaml:281:  parameterDefs:`
- L3578: `pkg/cmds/fields/test-data/gather-fields.yaml:296:- title: "Test with empty choice parameter"`
- L3579: `pkg/cmds/fields/test-data/gather-fields.yaml:297:  description: "Ensure that providing an empty string for a choice parameter results in an error."`
- L3580: `pkg/cmds/fields/test-data/gather-fields.yaml:298:  parameterDefs:`
- L3581: `pkg/cmds/fields/test-data/gather-fields.yaml:313:# - title: "Test list-type parameter"`
- L3582: `pkg/cmds/fields/test-data/gather-fields.yaml:314:#   description: "Ensure that the list-type parameter is correctly parsed"`
- L3583: `pkg/cmds/fields/test-data/gather-fields.yaml:315:#   parameterDefs:`
- L3584: `pkg/cmds/fields/test-data/gather-fields.yaml:330:# - title: "Test with empty list-type parameter"`
- L3585: `pkg/cmds/fields/test-data/gather-fields.yaml:331:#   description: "Ensure that an empty list is handled correctly for list-type parameters."`
- L3586: `pkg/cmds/fields/test-data/gather-fields.yaml:332:#   parameterDefs:`
- L3587: `pkg/cmds/fields/test-data/gather-fields.yaml:342:- title: "Test with mixed types in list-type parameter"`
- L3588: `pkg/cmds/fields/test-data/gather-fields.yaml:344:  parameterDefs:`
- L3589: `pkg/cmds/fields/test-data/gather-fields.yaml:351:  expectedError: "List-type parameter 'scores' contains invalid types, expected float list."`
- L3590: `pkg/cmds/fields/test-data/gather-fields.yaml:353:- title: "Test with single value for list-type parameter"`
- L3591: `pkg/cmds/fields/test-data/gather-fields.yaml:354:  description: "Ensure that a single value is handled correctly for list-type parameters."`
- L3592: `pkg/cmds/fields/test-data/gather-fields.yaml:355:  parameterDefs:`
- L3593: `pkg/cmds/sources/custom-profiles_test.go:36:	// Create parameter definitions`
- L3594: `pkg/cmds/sources/custom-profiles_test.go:50:	// Create layers`
- L3595: `pkg/cmds/sources/custom-profiles_test.go:51:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L3596: `pkg/cmds/sources/custom-profiles_test.go:56:	parameterLayers := schema.NewSchema()`
- L3597: `pkg/cmds/sources/custom-profiles_test.go:57:	parameterLayers.Set("config", layer)`
- L3598: `pkg/cmds/sources/custom-profiles_test.go:59:	parsedLayers := values.New()`
- L3599: `pkg/cmds/sources/custom-profiles_test.go:69:	err = handler(parameterLayers, parsedLayers)`
- L3600: `pkg/cmds/sources/custom-profiles_test.go:73:	parsedLayer, ok := parsedLayers.Get("config")`
- L3601: `pkg/cmds/sources/custom-profiles_test.go:75:	require.NotNil(t, parsedLayer)`
- L3602: `pkg/cmds/sources/custom-profiles_test.go:77:	hostParamParsed, ok := parsedLayer.Parameters.Get("host")`
- L3603: `pkg/cmds/sources/custom-profiles_test.go:82:	portParamParsed, ok := parsedLayer.Parameters.Get("port")`
- L3604: `pkg/cmds/sources/custom-profiles_test.go:87:	debugParamParsed, ok := parsedLayer.Parameters.Get("debug")`
- L3605: `pkg/cmds/sources/custom-profiles_test.go:114:	// Create parameter definitions`
- L3606: `pkg/cmds/sources/custom-profiles_test.go:128:	// Create layers`
- L3607: `pkg/cmds/sources/custom-profiles_test.go:129:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L3608: `pkg/cmds/sources/custom-profiles_test.go:134:	parameterLayers := schema.NewSchema()`
- L3609: `pkg/cmds/sources/custom-profiles_test.go:135:	parameterLayers.Set("config", layer)`
- L3610: `pkg/cmds/sources/custom-profiles_test.go:137:	parsedLayers := values.New()`
- L3611: `pkg/cmds/sources/custom-profiles_test.go:147:	err = handler(parameterLayers, parsedLayers)`
- L3612: `pkg/cmds/sources/custom-profiles_test.go:151:	parsedLayer, ok := parsedLayers.Get("config")`
- L3613: `pkg/cmds/sources/custom-profiles_test.go:153:	require.NotNil(t, parsedLayer)`
- L3614: `pkg/cmds/sources/custom-profiles_test.go:155:	hostParamParsed, ok := parsedLayer.Parameters.Get("host")`
- L3615: `pkg/cmds/sources/custom-profiles_test.go:160:	portParamParsed, ok := parsedLayer.Parameters.Get("port")`
- L3616: `pkg/cmds/sources/custom-profiles_test.go:165:	debugParamParsed, ok := parsedLayer.Parameters.Get("debug")`
- L3617: `pkg/cmds/sources/custom-profiles_test.go:172:	// Create parameter definitions`
- L3618: `pkg/cmds/sources/custom-profiles_test.go:178:	// Create layers`
- L3619: `pkg/cmds/sources/custom-profiles_test.go:179:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L3620: `pkg/cmds/sources/custom-profiles_test.go:184:	parameterLayers := schema.NewSchema()`
- L3621: `pkg/cmds/sources/custom-profiles_test.go:185:	parameterLayers.Set("config", layer)`
- L3622: `pkg/cmds/sources/custom-profiles_test.go:187:	parsedLayers := values.New()`
- L3623: `pkg/cmds/sources/custom-profiles_test.go:197:	err = handler(parameterLayers, parsedLayers)`
- L3624: `pkg/cmds/sources/custom-profiles_test.go:216:	// Create parameter definitions`
- L3625: `pkg/cmds/sources/custom-profiles_test.go:222:	// Create layers`
- L3626: `pkg/cmds/sources/custom-profiles_test.go:223:	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L3627: `pkg/cmds/sources/custom-profiles_test.go:228:	parameterLayers := schema.NewSchema()`
- L3628: `pkg/cmds/sources/custom-profiles_test.go:229:	parameterLayers.Set("config", layer)`
- L3629: `pkg/cmds/sources/custom-profiles_test.go:231:	parsedLayers := values.New()`
- L3630: `pkg/cmds/sources/custom-profiles_test.go:242:	err = handler(parameterLayers, parsedLayers)`
- L3631: `pkg/helpers/maps/maps.go:74:// GlazedStructToMap converts a struct pointer to a map of parameter names to values.`
- L3632: `pkg/helpers/maps/maps.go:91:		parameterName, ok := field.Tag.Lookup("glazed")`
- L3633: `pkg/helpers/maps/maps.go:97:		ret[parameterName] = value`
- L3634: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:16:	// Create test layers`
- L3635: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:17:	layer, err := schema.NewSection(`
- L3636: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:19:		"Demo Layer",`
- L3637: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:25:	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3638: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:41:			TargetLayer:     "demo",`
- L3639: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:42:			TargetParameter: "api-key",`
- L3640: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:47:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3641: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:71:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3642: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:85:	// Create test layers`
- L3643: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:86:	layer, err := schema.NewSection(`
- L3644: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:88:		"Demo Layer",`
- L3645: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:94:	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3646: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:110:			TargetLayer:     "demo",`
- L3647: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:111:			TargetParameter: "api-key",`
- L3648: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:115:			TargetLayer:     "demo",`
- L3649: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:116:			TargetParameter: "api-key",`
- L3650: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:121:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3651: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:134:	t.Run("no collision - different parameters", func(t *testing.T) {`
- L3652: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:135:		layerMulti, err := schema.NewSection(`
- L3653: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:137:			"Demo Layer",`
- L3654: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:144:		testLayersMulti := schema.NewSchema(schema.WithSections(layerMulti))`
- L3655: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:149:				TargetLayer:     "demo",`
- L3656: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:150:				TargetParameter: "api-key",`
- L3657: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:154:				TargetLayer:     "demo",`
- L3658: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:155:				TargetParameter: "threshold",`
- L3659: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:170:		mapper, err := pm.NewConfigMapper(testLayersMulti, rulesMulti...)`
- L3660: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:175:		// Should not error because different parameters`
- L3661: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:186:		// Create a layer with a prefix`
- L3662: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:187:		layer, err := schema.NewSection(`
- L3663: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:189:			"Demo Layer",`
- L3664: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:196:		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3665: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:201:				TargetLayer:     "demo",`
- L3666: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:202:				TargetParameter: "api-key", // Without prefix`
- L3667: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:214:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3668: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:223:		// Create a layer with a prefix`
- L3669: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:224:		layer, err := schema.NewSection(`
- L3670: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:226:			"Demo Layer",`
- L3671: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:234:		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3672: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:239:				TargetLayer:     "demo",`
- L3673: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:240:				TargetParameter: "api-key", // This will resolve to demo-api-key which doesn't exist`
- L3674: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:246:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3675: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:255:	t.Run("error message for parameter with prefix already included (compile-time)", func(t *testing.T) {`
- L3676: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:256:		// Create a layer with a prefix`
- L3677: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:257:		layer, err := schema.NewSection(`
- L3678: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:259:			"Demo Layer",`
- L3679: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:266:		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3680: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:271:				TargetLayer:     "demo",`
- L3681: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:272:				TargetParameter: "demo-api-key", // With prefix already`
- L3682: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:276:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3683: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:289:		layer, err := schema.NewSection(`
- L3684: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:291:			"Demo Layer",`
- L3685: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:297:		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3686: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:303:				TargetLayer: "demo",`
- L3687: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:305:					{Source: "{env}.api_key", TargetParameter: "{env}-api-key"},`
- L3688: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:315:		_, _ = pm.NewConfigMapper(testLayers, rules...)`
- L3689: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:326:		layer, err := schema.NewSection(`
- L3690: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:328:			"Demo Layer",`
- L3691: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:334:		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3692: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:353:				TargetLayer:     "demo",`
- L3693: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:354:				TargetParameter: "api-key",`
- L3694: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:358:				TargetLayer:     "demo",`
- L3695: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:359:				TargetParameter: "api-key",`
- L3696: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:363:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3697: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:374:		layer, err := schema.NewSection(`
- L3698: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:376:			"Demo Layer",`
- L3699: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:383:		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3700: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:399:				TargetLayer:     "demo",`
- L3701: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:400:				TargetParameter: "api-key",`
- L3702: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:404:				TargetLayer:     "demo",`
- L3703: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:405:				TargetParameter: "api-key",`
- L3704: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:409:		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L3705: `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go:416:		// Error should mention the resolved parameter name (with prefix)`
- L3706: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:1:#  ParameterTypeString         ParameterType = "string"`
- L3707: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:2:#  ParameterTypeStringFromFile ParameterType = "stringFromFile"`
- L3708: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:3:#  ParameterTypeObjectListFromFile ParameterType = "objectListFromFile"`
- L3709: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:4:#  ParameterTypeObjectFromFile     ParameterType = "objectFromFile"`
- L3710: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:5:#  // ParameterTypeKeyValue signals either a string with comma separate key-value options, or when beginning with @, a file with key-value options`
- L3711: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:6:#  ParameterTypeKeyValue    ParameterType = "keyValue"`
- L3712: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:7:#  ParameterTypeInteger     ParameterType = "int"`
- L3713: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:8:#  ParameterTypeFloat       ParameterType = "float"`
- L3714: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:9:#  ParameterTypeBool        ParameterType = "bool"`
- L3715: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:10:#  ParameterTypeDate        ParameterType = "date"`
- L3716: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:11:#  ParameterTypeStringList  ParameterType = "stringList"`
- L3717: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:12:#  ParameterTypeIntegerList ParameterType = "intList"`
- L3718: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:13:#  ParameterTypeFloatList   ParameterType = "floatList"`
- L3719: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:14:#  ParameterTypeChoice      ParameterType = "choice"`
- L3720: `pkg/cmds/fields/test-data/parameters_validity_test.yaml:15:#  ParameterTypeChoiceList  ParameterType = "choiceList"`
- L3721: `pkg/cmds/sources/cobra.go:13:// FromCobra creates a middleware that parses parameter values from a Cobra command.`
- L3722: `pkg/cmds/sources/cobra.go:16:// It iterates through each layer, and if the layer implements the CobraSection interface,`
- L3723: `pkg/cmds/sources/cobra.go:17:// it parses the layer's parameters from the Cobra command.`
- L3724: `pkg/cmds/sources/cobra.go:24:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3725: `pkg/cmds/sources/cobra.go:25:			err := next(layers_, parsedLayers)`
- L3726: `pkg/cmds/sources/cobra.go:30:			err = layers_.ForEachE(func(key string, l schema.Section) error {`
- L3727: `pkg/cmds/sources/cobra.go:33:						"layer":          l.GetName(),`
- L3728: `pkg/cmds/sources/cobra.go:34:						"layer_slug":     l.GetSlug(),`
- L3729: `pkg/cmds/sources/cobra.go:35:						"layer_prefix":   l.GetPrefix(),`
- L3730: `pkg/cmds/sources/cobra.go:40:				parsedLayer := parsedLayers.GetOrCreate(l)`
- L3731: `pkg/cmds/sources/cobra.go:42:				if cobraLayer, ok := l.(schema.CobraSection); ok {`
- L3732: `pkg/cmds/sources/cobra.go:43:					cobraLayer, err := cobraLayer.ParseLayerFromCobraCommand(cmd, options_...)`
- L3733: `pkg/cmds/sources/cobra.go:48:					_, err = parsedLayer.Parameters.Merge(cobraLayer.Parameters)`
- L3734: `pkg/cmds/sources/cobra.go:65:// FromArgs creates a middleware that parses positional arguments for the default layer.`
- L3735: `pkg/cmds/sources/cobra.go:74:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3736: `pkg/cmds/sources/cobra.go:75:			err := next(layers_, parsedLayers)`
- L3737: `pkg/cmds/sources/cobra.go:80:			if defaultLayer, ok := layers_.Get(schema.DefaultSlug); ok {`
- L3738: `pkg/cmds/sources/cobra.go:81:				pds := defaultLayer.GetDefinitions()`
- L3739: `pkg/cmds/sources/cobra.go:87:				parsedLayer := parsedLayers.GetOrCreate(defaultLayer)`
- L3740: `pkg/cmds/sources/cobra.go:88:				_, err = parsedLayer.Parameters.Merge(ps_)`
- L3741: `pkg/cmds/sources/cobra.go:101:type ConfigFilesResolver func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]string, error)`
- L3742: `pkg/cmds/sources/cobra.go:103:// LoadParametersFromResolvedFilesForCobra loads parameters from a resolver-provided list of files`
- L3743: `pkg/cmds/sources/cobra.go:105:func LoadParametersFromResolvedFilesForCobra(`
- L3744: `pkg/cmds/sources/cobra.go:112:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3745: `pkg/cmds/sources/cobra.go:113:			if err := next(layers_, parsedLayers); err != nil {`
- L3746: `pkg/cmds/sources/cobra.go:116:			files, err := resolver(parsedLayers, cmd, args)`
- L3747: `pkg/cmds/sources/cobra.go:126:			return FromFiles(files, configOpts...)(func(_ *schema.Schema, _ *values.Values) error { return nil })(layers_, parsedLayers)`
- L3748: `pkg/cmds/sources/cobra.go:131:// GatherFlagsFromViper creates a middleware that loads parameter values from Viper configuration.`
- L3749: `pkg/cmds/sources/cobra.go:134:// It iterates through each layer, gathering flags from Viper for all parameters in that layer.`
- L3750: `pkg/cmds/sources/cobra.go:146:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3751: `pkg/cmds/sources/cobra.go:148:			err := next(layers_, parsedLayers)`
- L3752: `pkg/cmds/sources/cobra.go:152:			err = layers_.ForEachE(func(key string, l schema.Section) error {`
- L3753: `pkg/cmds/sources/cobra.go:156:						"layer":          l.GetName(),`
- L3754: `pkg/cmds/sources/cobra.go:157:						"layer_slug":     l.GetSlug(),`
- L3755: `pkg/cmds/sources/cobra.go:158:						"layer_prefix":   l.GetPrefix(),`
- L3756: `pkg/cmds/sources/cobra.go:163:				parsedLayer := parsedLayers.GetOrCreate(l)`
- L3757: `pkg/cmds/sources/cobra.go:164:				parameterDefinitions := l.GetDefinitions()`
- L3758: `pkg/cmds/sources/cobra.go:167:				ps, err := parameterDefinitions.GatherFlagsFromViper(true, prefix, options_...)`
- L3759: `pkg/cmds/sources/cobra.go:172:				_, err = parsedLayer.Parameters.Merge(ps)`
- L3760: `pkg/cmds/sources/cobra.go:189:// GatherSpecificFlagsFromViper creates a middleware that loads specific parameter values from Viper configuration.`
- L3761: `pkg/cmds/sources/cobra.go:192:// It's useful when you want to selectively load certain parameters from Viper while leaving others untouched.`
- L3762: `pkg/cmds/sources/cobra.go:207:		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L3763: `pkg/cmds/sources/cobra.go:208:			err := next(layers_, parsedLayers)`
- L3764: `pkg/cmds/sources/cobra.go:212:			err = layers_.ForEachE(func(key string, l schema.Section) error {`
- L3765: `pkg/cmds/sources/cobra.go:216:						"layer": l.GetName(),`
- L3766: `pkg/cmds/sources/cobra.go:220:				parsedLayer := parsedLayers.GetOrCreate(l)`
- L3767: `pkg/cmds/sources/cobra.go:221:				parameterDefinitions := l.GetDefinitions()`
- L3768: `pkg/cmds/sources/cobra.go:224:				// Filter the parameter definitions based on the specified flags`
- L3769: `pkg/cmds/sources/cobra.go:227:					if pd, ok := parameterDefinitions.Get(flag); ok {`
- L3770: `pkg/cmds/sources/cobra.go:237:				_, err = parsedLayer.Parameters.Merge(ps)`
- L3771: `pkg/cmds/sources/config-mapper-interface.go:3:// ConfigMapper is an interface that can map raw config data to layer maps.`
- L3772: `pkg/settings/settings_jq.go:21:type JqParameterLayer struct {`
- L3773: `pkg/settings/settings_jq.go:25:func NewJqParameterLayer(options ...schema.SectionOption) (*JqParameterLayer, error) {`
- L3774: `pkg/settings/settings_jq.go:26:	ret := &JqParameterLayer{}`
- L3775: `pkg/settings/settings_jq.go:27:	layer, err := schema.NewSectionFromYAML(jqFlagsYaml, options...)`
- L3776: `pkg/settings/settings_jq.go:29:		return nil, errors.Wrap(err, "Failed to create jq parameter layer")`
- L3777: `pkg/settings/settings_jq.go:31:	ret.SectionImpl = layer`
- L3778: `pkg/settings/settings_jq.go:35:func (f *JqParameterLayer) Clone() schema.Section {`
- L3779: `pkg/settings/settings_jq.go:36:	return &JqParameterLayer{`
- L3780: `pkg/settings/settings_jq.go:41:func NewJqSettingsFromParameters(glazedLayer *values.SectionValues) (*JqSettings, error) {`
- L3781: `pkg/settings/settings_jq.go:43:	err := glazedLayer.Parameters.InitializeStruct(s)`
- L3782: `pkg/settings/settings_jq.go:45:		return nil, errors.Wrap(err, "Failed to initialize jq settings from parameters")`
- L3783: `pkg/cmds/schema/layer_test.go:12:// Helper function to create a parameter layer`
- L3784: `pkg/cmds/schema/layer_test.go:13:func createParameterLayer(t *testing.T, slug, name string, paramDefs ...*fields.Definition) Section {`
- L3785: `pkg/cmds/schema/layer_test.go:14:	layer, err := NewSection(slug, name, WithFields(paramDefs...))`
- L3786: `pkg/cmds/schema/layer_test.go:16:	require.NotNil(t, layer)`
- L3787: `pkg/cmds/schema/layer_test.go:17:	return layer`
- L3788: `pkg/cmds/schema/layer_test.go:20:func TestNewParameterLayers(t *testing.T) {`
- L3789: `pkg/cmds/schema/layer_test.go:21:	layers := NewSchema()`
- L3790: `pkg/cmds/schema/layer_test.go:22:	assert.NotNil(t, layers)`
- L3791: `pkg/cmds/schema/layer_test.go:23:	assert.Equal(t, 0, layers.Len())`
- L3792: `pkg/cmds/schema/layer_test.go:26:func TestParameterLayersSubset(t *testing.T) {`
- L3793: `pkg/cmds/schema/layer_test.go:27:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3794: `pkg/cmds/schema/layer_test.go:28:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3795: `pkg/cmds/schema/layer_test.go:29:	layer3 := createParameterLayer(t, "layer3", "Layer 3")`
- L3796: `pkg/cmds/schema/layer_test.go:31:	layers := NewSchema(WithSections(layer1, layer2, layer3))`
- L3797: `pkg/cmds/schema/layer_test.go:33:	subset := layers.Subset("layer1", "layer3")`
- L3798: `pkg/cmds/schema/layer_test.go:36:	val, present := subset.Get("layer1")`
- L3799: `pkg/cmds/schema/layer_test.go:39:	val, present = subset.Get("layer2")`
- L3800: `pkg/cmds/schema/layer_test.go:42:	val, present = subset.Get("layer3")`
- L3801: `pkg/cmds/schema/layer_test.go:47:func TestParameterLayersForEach(t *testing.T) {`
- L3802: `pkg/cmds/schema/layer_test.go:48:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3803: `pkg/cmds/schema/layer_test.go:49:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3804: `pkg/cmds/schema/layer_test.go:51:	layers := NewSchema(WithSections(layer1, layer2))`
- L3805: `pkg/cmds/schema/layer_test.go:54:	layers.ForEach(func(key string, p Section) {`
- L3806: `pkg/cmds/schema/layer_test.go:56:		assert.Contains(t, []string{"layer1", "layer2"}, key)`
- L3807: `pkg/cmds/schema/layer_test.go:62:func TestParameterLayersForEachE(t *testing.T) {`
- L3808: `pkg/cmds/schema/layer_test.go:63:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3809: `pkg/cmds/schema/layer_test.go:64:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3810: `pkg/cmds/schema/layer_test.go:66:	layers := NewSchema(WithSections(layer1, layer2))`
- L3811: `pkg/cmds/schema/layer_test.go:69:	err := layers.ForEachE(func(key string, p Section) error {`
- L3812: `pkg/cmds/schema/layer_test.go:78:func TestParameterLayersAppendLayers(t *testing.T) {`
- L3813: `pkg/cmds/schema/layer_test.go:79:	layers := NewSchema()`
- L3814: `pkg/cmds/schema/layer_test.go:80:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3815: `pkg/cmds/schema/layer_test.go:81:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3816: `pkg/cmds/schema/layer_test.go:83:	layers.AppendLayers(layer1, layer2)`
- L3817: `pkg/cmds/schema/layer_test.go:85:	assert.Equal(t, 2, layers.Len())`
- L3818: `pkg/cmds/schema/layer_test.go:86:	val, present := layers.Get("layer1")`
- L3819: `pkg/cmds/schema/layer_test.go:87:	assert.Equal(t, layer1, val)`
- L3820: `pkg/cmds/schema/layer_test.go:89:	val, present = layers.Get("layer2")`
- L3821: `pkg/cmds/schema/layer_test.go:90:	assert.Equal(t, layer2, val)`
- L3822: `pkg/cmds/schema/layer_test.go:94:func TestParameterLayersPrependLayers(t *testing.T) {`
- L3823: `pkg/cmds/schema/layer_test.go:95:	layer0 := createParameterLayer(t, "layer0", "Layer 0")`
- L3824: `pkg/cmds/schema/layer_test.go:97:	layers := NewSchema(`
- L3825: `pkg/cmds/schema/layer_test.go:98:		WithSections(layer0),`
- L3826: `pkg/cmds/schema/layer_test.go:100:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3827: `pkg/cmds/schema/layer_test.go:101:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3828: `pkg/cmds/schema/layer_test.go:103:	layers.PrependLayers(layer1, layer2)`
- L3829: `pkg/cmds/schema/layer_test.go:105:	assert.Equal(t, 3, layers.Len())`
- L3830: `pkg/cmds/schema/layer_test.go:106:	first := layers.Oldest()`
- L3831: `pkg/cmds/schema/layer_test.go:107:	assert.Equal(t, "layer1", first.Key)`
- L3832: `pkg/cmds/schema/layer_test.go:108:	assert.Equal(t, layer1, first.Value)`
- L3833: `pkg/cmds/schema/layer_test.go:110:	assert.Equal(t, "layer2", second.Key)`
- L3834: `pkg/cmds/schema/layer_test.go:111:	assert.Equal(t, layer2, second.Value)`
- L3835: `pkg/cmds/schema/layer_test.go:113:	assert.Equal(t, "layer0", third.Key)`
- L3836: `pkg/cmds/schema/layer_test.go:114:	assert.Equal(t, "Layer 0", third.Value.GetName())`
- L3837: `pkg/cmds/schema/layer_test.go:118:func TestParameterLayersMerge(t *testing.T) {`
- L3838: `pkg/cmds/schema/layer_test.go:119:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3839: `pkg/cmds/schema/layer_test.go:120:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3840: `pkg/cmds/schema/layer_test.go:121:	layers1 := NewSchema(WithSections(layer1))`
- L3841: `pkg/cmds/schema/layer_test.go:122:	layers2 := NewSchema(WithSections(layer2))`
- L3842: `pkg/cmds/schema/layer_test.go:124:	merged := layers1.Merge(layers2)`
- L3843: `pkg/cmds/schema/layer_test.go:127:	val, present := merged.Get("layer1")`
- L3844: `pkg/cmds/schema/layer_test.go:130:	val, present = merged.Get("layer2")`
- L3845: `pkg/cmds/schema/layer_test.go:135:func TestParameterLayersAsList(t *testing.T) {`
- L3846: `pkg/cmds/schema/layer_test.go:136:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3847: `pkg/cmds/schema/layer_test.go:137:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3848: `pkg/cmds/schema/layer_test.go:138:	layers := NewSchema(WithSections(layer1, layer2))`
- L3849: `pkg/cmds/schema/layer_test.go:140:	list := layers.AsList()`
- L3850: `pkg/cmds/schema/layer_test.go:143:	assert.Contains(t, list, layer1)`
- L3851: `pkg/cmds/schema/layer_test.go:144:	assert.Contains(t, list, layer2)`
- L3852: `pkg/cmds/schema/layer_test.go:147:func TestParameterLayersClone(t *testing.T) {`
- L3853: `pkg/cmds/schema/layer_test.go:148:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3854: `pkg/cmds/schema/layer_test.go:149:	layers := NewSchema(WithSections(layer1))`
- L3855: `pkg/cmds/schema/layer_test.go:151:	cloned := layers.Clone()`
- L3856: `pkg/cmds/schema/layer_test.go:153:	assert.Equal(t, layers.Len(), cloned.Len())`
- L3857: `pkg/cmds/schema/layer_test.go:154:	v1, p1 := layers.Get("layer1")`
- L3858: `pkg/cmds/schema/layer_test.go:157:	v2, p2 := cloned.Get("layer1")`
- L3859: `pkg/cmds/schema/layer_test.go:164:func TestParameterLayersGetAllDefinitions(t *testing.T) {`
- L3860: `pkg/cmds/schema/layer_test.go:165:	layer1 := createParameterLayer(t, "layer1", "Layer 1",`
- L3861: `pkg/cmds/schema/layer_test.go:168:	layer2 := createParameterLayer(t, "layer2", "Layer 2",`
- L3862: `pkg/cmds/schema/layer_test.go:172:	layers := NewSchema(WithSections(layer1, layer2))`
- L3863: `pkg/cmds/schema/layer_test.go:174:	allDefs := layers.GetAllDefinitions()`
- L3864: `pkg/cmds/schema/layer_test.go:185:func TestParameterLayersWithLayers(t *testing.T) {`
- L3865: `pkg/cmds/schema/layer_test.go:186:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3866: `pkg/cmds/schema/layer_test.go:187:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3867: `pkg/cmds/schema/layer_test.go:189:	layers := NewSchema(WithSections(layer1, layer2))`
- L3868: `pkg/cmds/schema/layer_test.go:191:	assert.Equal(t, 2, layers.Len())`
- L3869: `pkg/cmds/schema/layer_test.go:192:	val, present := layers.Get("layer1")`
- L3870: `pkg/cmds/schema/layer_test.go:194:	assert.Equal(t, layer1, val)`
- L3871: `pkg/cmds/schema/layer_test.go:195:	val, present = layers.Get("layer2")`
- L3872: `pkg/cmds/schema/layer_test.go:197:	assert.Equal(t, layer2, val)`
- L3873: `pkg/cmds/schema/layer_test.go:200:func TestParameterLayersWithDuplicateSlugs(t *testing.T) {`
- L3874: `pkg/cmds/schema/layer_test.go:201:	layer1 := createParameterLayer(t, "duplicate", "Layer 1")`
- L3875: `pkg/cmds/schema/layer_test.go:202:	layer2 := createParameterLayer(t, "duplicate", "Layer 2")`
- L3876: `pkg/cmds/schema/layer_test.go:204:	layers := NewSchema(WithSections(layer1, layer2))`
- L3877: `pkg/cmds/schema/layer_test.go:206:	assert.Equal(t, 1, layers.Len())`
- L3878: `pkg/cmds/schema/layer_test.go:207:	val, present := layers.Get("duplicate")`
- L3879: `pkg/cmds/schema/layer_test.go:209:	assert.Equal(t, "Layer 2", val.GetName())`
- L3880: `pkg/cmds/schema/layer_test.go:212:func TestParameterLayersSubsetWithNonExistentLayers(t *testing.T) {`
- L3881: `pkg/cmds/schema/layer_test.go:213:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L3882: `pkg/cmds/schema/layer_test.go:214:	layers := NewSchema(WithSections(layer1))`
- L3883: `pkg/cmds/schema/layer_test.go:216:	subset := layers.Subset("layer1", "non_existent")`
- L3884: `pkg/cmds/schema/layer_test.go:219:	_, present := subset.Get("layer1")`
- L3885: `pkg/cmds/schema/layer_test.go:225:func TestParameterLayersMergeWithOverlappingLayers(t *testing.T) {`
- L3886: `pkg/cmds/schema/layer_test.go:226:	layer1 := createParameterLayer(t, "layer1", "Layer 1 - Original")`
- L3887: `pkg/cmds/schema/layer_test.go:227:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L3888: `pkg/cmds/schema/layer_test.go:228:	layers1 := NewSchema(WithSections(layer1, layer2))`
- L3889: `pkg/cmds/schema/layer_test.go:230:	layer1Duplicate := createParameterLayer(t, "layer1", "Layer 1 - Duplicate")`
- L3890: `pkg/cmds/schema/layer_test.go:231:	layer3 := createParameterLayer(t, "layer3", "Layer 3")`
- L3891: `pkg/cmds/schema/layer_test.go:232:	layers2 := NewSchema(WithSections(layer1Duplicate, layer3))`
- L3892: `pkg/cmds/schema/layer_test.go:234:	merged := layers1.Merge(layers2)`
- L3893: `pkg/cmds/schema/layer_test.go:237:	val, present := merged.Get("layer1")`
- L3894: `pkg/cmds/schema/layer_test.go:239:	assert.Equal(t, "Layer 1 - Duplicate", val.GetName())`
- L3895: `pkg/cmds/schema/layer_test.go:240:	_, present = merged.Get("layer2")`
- L3896: `pkg/cmds/schema/layer_test.go:242:	_, present = merged.Get("layer3")`
- L3897: `pkg/cmds/schema/layer_test.go:246:func TestParameterLayersWithLargeNumberOfLayers(t *testing.T) {`
- L3898: `pkg/cmds/schema/layer_test.go:247:	numLayers := 1000`
- L3899: `pkg/cmds/schema/layer_test.go:248:	layers := NewSchema()`
- L3900: `pkg/cmds/schema/layer_test.go:250:	for i := 0; i < numLayers; i++ {`
- L3901: `pkg/cmds/schema/layer_test.go:251:		layer := createParameterLayer(t, fmt.Sprintf("layer%d", i), fmt.Sprintf("Layer %d", i))`
- L3902: `pkg/cmds/schema/layer_test.go:252:		layers.AppendLayers(layer)`
- L3903: `pkg/cmds/schema/layer_test.go:255:	assert.Equal(t, numLayers, layers.Len())`
- L3904: `pkg/cmds/schema/layer_test.go:256:	_, present := layers.Get("layer0")`
- L3905: `pkg/cmds/schema/layer_test.go:258:	_, present = layers.Get(fmt.Sprintf("layer%d", numLayers-1))`
- L3906: `pkg/cmds/schema/layer_test.go:262:func TestParameterLayersWithUnicodeLayerNames(t *testing.T) {`
- L3907: `pkg/cmds/schema/layer_test.go:263:	layer1 := createParameterLayer(t, "layer1", "Layer 1 - ‰Ω†Â•Ω")`
- L3908: `pkg/cmds/schema/layer_test.go:264:	layer2 := createParameterLayer(t, "layer2", "Layer 2 - „Åì„Çì„Å´„Å°„ÅØ")`
- L3909: `pkg/cmds/schema/layer_test.go:266:	layers := NewSchema(WithSections(layer1, layer2))`
- L3910: `pkg/cmds/schema/layer_test.go:268:	assert.Equal(t, 2, layers.Len())`
- L3911: `pkg/cmds/schema/layer_test.go:269:	val, present := layers.Get("layer1")`
- L3912: `pkg/cmds/schema/layer_test.go:271:	assert.Equal(t, "Layer 1 - ‰Ω†Â•Ω", val.GetName())`
- L3913: `pkg/cmds/schema/layer_test.go:272:	val, present = layers.Get("layer2")`
- L3914: `pkg/cmds/schema/layer_test.go:274:	assert.Equal(t, "Layer 2 - „Åì„Çì„Å´„Å°„ÅØ", val.GetName())`
- L3915: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:17:		setupLayers func(t *testing.T) *schema.Schema`
- L3916: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:26:			setupLayers: createTestLayers,`
- L3917: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:30:					TargetLayer:     "demo",`
- L3918: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:31:					TargetParameter: "api-key",`
- L3919: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:40:			setupLayers: createTestLayers,`
- L3920: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:44:					TargetLayer:     "demo",`
- L3921: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:45:					TargetParameter: "api-key",`
- L3922: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:64:			setupLayers: createTestLayers,`
- L3923: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:68:					TargetLayer:     "demo",`
- L3924: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:69:					TargetParameter: "api-key",`
- L3925: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:96:			setupLayers: createTestLayers,`
- L3926: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:100:					TargetLayer:     "demo",`
- L3927: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:101:					TargetParameter: "api-key",`
- L3928: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:122:			setupLayers: createTestLayers,`
- L3929: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:126:					TargetLayer:     "demo",`
- L3930: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:127:					TargetParameter: "threshold",`
- L3931: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:146:			setupLayers: func(t *testing.T) *schema.Schema {`
- L3932: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:147:				layer, err := schema.NewSection(`
- L3933: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:149:					"Demo Layer",`
- L3934: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:155:				return schema.NewSchema(schema.WithSections(layer))`
- L3935: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:160:					TargetLayer:     "demo",`
- L3936: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:161:					TargetParameter: "enabled",`
- L3937: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:180:			setupLayers: func(t *testing.T) *schema.Schema {`
- L3938: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:181:				layer, err := schema.NewSection(`
- L3939: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:183:					"Demo Layer",`
- L3940: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:189:				return schema.NewSchema(schema.WithSections(layer))`
- L3941: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:194:					TargetLayer:     "demo",`
- L3942: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:195:					TargetParameter: "{env}-api-key",`
- L3943: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:214:			setupLayers: createTestLayers,`
- L3944: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:218:					TargetLayer:     "demo",`
- L3945: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:219:					TargetParameter: "api-key",`
- L3946: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:247:			testLayers := tt.setupLayers(t)`
- L3947: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:248:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L3948: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:275:	testLayers := createTestLayers(t)`
- L3949: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:289:					TargetLayer:     "demo",`
- L3950: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:290:					TargetParameter: "api-key",`
- L3951: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:309:			name: "parameter does not exist - shows pattern and layer",`
- L3952: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:313:					TargetLayer:     "demo",`
- L3953: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:314:					TargetParameter: "nonexistent-param",`
- L3954: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:326:				"target parameter",`
- L3955: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:337:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L3956: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:360:// TestLayerPrefix tests handling of layer prefixes`
- L3957: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:361:func TestLayerPrefix(t *testing.T) {`
- L3958: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:362:	// Create a layer with a prefix`
- L3959: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:363:	layer, err := schema.NewSection(`
- L3960: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:365:		"Demo Layer",`
- L3961: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:374:	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3962: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:384:			name: "parameter name without prefix - should add prefix",`
- L3963: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:388:					TargetLayer:     "demo",`
- L3964: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:389:					TargetParameter: "api-key",`
- L3965: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:407:			name: "parameter name with prefix - should not double prefix",`
- L3966: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:411:					TargetLayer:     "demo",`
- L3967: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:412:					TargetParameter: "demo-api-key",`
- L3968: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:433:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L3969: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:450:	// Create test layers with environment-region parameters`
- L3970: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:451:	layer, err := schema.NewSection(`
- L3971: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:453:		"Demo Layer",`
- L3972: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:462:	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3973: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:476:					TargetLayer:     "demo",`
- L3974: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:477:					TargetParameter: "{region}-{env}-api-key",`
- L3975: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:507:					TargetLayer: "demo",`
- L3976: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:509:						{Source: "api_key", TargetParameter: "{region}-{env}-api-key"},`
- L3977: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:537:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L3978: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:554:	layer, err := schema.NewSection(`
- L3979: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:556:		"Demo Layer",`
- L3980: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:567:	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L3981: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:569:	mapper, err := pm.NewConfigMapper(testLayers,`
- L3982: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:572:			TargetLayer:     "demo",`
- L3983: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:573:			TargetParameter: "string-param",`
- L3984: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:577:			TargetLayer:     "demo",`
- L3985: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:578:			TargetParameter: "int-param",`
- L3986: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:582:			TargetLayer:     "demo",`
- L3987: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:583:			TargetParameter: "float-param",`
- L3988: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:587:			TargetLayer:     "demo",`
- L3989: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:588:			TargetParameter: "bool-param",`
- L3990: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:592:			TargetLayer:     "demo",`
- L3991: `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go:593:			TargetParameter: "list-param",`
- L3992: `pkg/settings/settings_fields-filters.go:27:type FieldsFiltersParameterLayer struct {`
- L3993: `pkg/settings/settings_fields-filters.go:31:var _ schema.CobraSection = &FieldsFiltersParameterLayer{}`
- L3994: `pkg/settings/settings_fields-filters.go:32:var _ schema.Section = &FieldsFiltersParameterLayer{}`
- L3995: `pkg/settings/settings_fields-filters.go:34:func (f *FieldsFiltersParameterLayer) Clone() schema.Section {`
- L3996: `pkg/settings/settings_fields-filters.go:35:	return &FieldsFiltersParameterLayer{`
- L3997: `pkg/settings/settings_fields-filters.go:51:func NewFieldsFiltersParameterLayer(options ...schema.SectionOption) (*FieldsFiltersParameterLayer, error) {`
- L3998: `pkg/settings/settings_fields-filters.go:52:	ret := &FieldsFiltersParameterLayer{}`
- L3999: `pkg/settings/settings_fields-filters.go:53:	layer, err := schema.NewSectionFromYAML(fieldsFiltersFlagsYaml, options...)`
- L4000: `pkg/settings/settings_fields-filters.go:55:		return nil, errors.Wrap(err, "Failed to create fields and filters parameter layer")`
- L4001: `pkg/settings/settings_fields-filters.go:57:	ret.SectionImpl = layer`
- L4002: `pkg/settings/settings_fields-filters.go:62:func (f *FieldsFiltersParameterLayer) AddLayerToCobraCommand(cmd *cobra.Command) error {`
- L4003: `pkg/settings/settings_fields-filters.go:64:	err := f.InitializeStructFromParameterDefaults(defaults)`
- L4004: `pkg/settings/settings_fields-filters.go:79:	return f.SectionImpl.AddLayerToCobraCommand(cmd)`
- L4005: `pkg/settings/settings_fields-filters.go:82:func (f *FieldsFiltersParameterLayer) ParseLayerFromCobraCommand(`
- L4006: `pkg/settings/settings_fields-filters.go:86:	l, err := f.SectionImpl.ParseLayerFromCobraCommand(cmd, options...)`
- L4007: `pkg/settings/settings_fields-filters.go:93:	// This means we'd have to store if a flag was changed in the parsed layer`
- L4008: `pkg/settings/settings_fields-filters.go:95:		parsedFilter, ok := l.Parameters.Get("filter")`
- L4009: `pkg/settings/settings_fields-filters.go:100:				return nil, errors.New("Failed to find default filter parameter definition")`
- L4010: `pkg/settings/settings_fields-filters.go:102:			p := &fields.ParsedParameter{`
- L4011: `pkg/settings/settings_fields-filters.go:107:				return nil, errors.Wrap(err, "Failed to update filter parameter")`
- L4012: `pkg/settings/settings_fields-filters.go:109:			l.Parameters.Set("filter", p)`
- L4013: `pkg/settings/settings_fields-filters.go:113:				return nil, errors.Wrap(err, "Failed to update filter parameter")`
- L4014: `pkg/settings/settings_fields-filters.go:121:func NewFieldsFilterSettings(glazedLayer *values.SectionValues) (*FieldsFilterSettings, error) {`
- L4015: `pkg/settings/settings_fields-filters.go:123:	err := glazedLayer.Parameters.InitializeStruct(s)`
- L4016: `pkg/cmds/sources/tests/multi-update-from-map.yaml:3:    description: "Applying an empty sequence of update maps should not change ParameterLayers or ParsedLayers."`
- L4017: `pkg/cmds/sources/tests/multi-update-from-map.yaml:4:    parameterLayers: []`
- L4018: `pkg/cmds/sources/tests/multi-update-from-map.yaml:5:    parsedLayers: []`
- L4019: `pkg/cmds/sources/tests/multi-update-from-map.yaml:6:    expectedLayers: []`
- L4020: `pkg/cmds/sources/tests/multi-update-from-map.yaml:12:    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L4021: `pkg/cmds/sources/tests/multi-update-from-map.yaml:13:    parameterLayers:`
- L4022: `pkg/cmds/sources/tests/multi-update-from-map.yaml:14:      - name: "layer1"`
- L4023: `pkg/cmds/sources/tests/multi-update-from-map.yaml:19:    parsedLayers:`
- L4024: `pkg/cmds/sources/tests/multi-update-from-map.yaml:20:      - name: "layer1"`
- L4025: `pkg/cmds/sources/tests/multi-update-from-map.yaml:21:        parameters:`
- L4026: `pkg/cmds/sources/tests/multi-update-from-map.yaml:24:    expectedLayers:`
- L4027: `pkg/cmds/sources/tests/multi-update-from-map.yaml:25:      - name: "layer1"`
- L4028: `pkg/cmds/sources/tests/multi-update-from-map.yaml:30:      - layer1:`
- L4029: `pkg/cmds/sources/tests/multi-update-from-map.yaml:35:    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L4030: `pkg/cmds/sources/tests/multi-update-from-map.yaml:36:    parameterLayers:`
- L4031: `pkg/cmds/sources/tests/multi-update-from-map.yaml:37:      - name: "layer1"`
- L4032: `pkg/cmds/sources/tests/multi-update-from-map.yaml:42:    parsedLayers:`
- L4033: `pkg/cmds/sources/tests/multi-update-from-map.yaml:43:      - name: "layer1"`
- L4034: `pkg/cmds/sources/tests/multi-update-from-map.yaml:44:        parameters:`
- L4035: `pkg/cmds/sources/tests/multi-update-from-map.yaml:47:    expectedLayers:`
- L4036: `pkg/cmds/sources/tests/multi-update-from-map.yaml:48:      - name: "layer1"`
- L4037: `pkg/cmds/sources/tests/multi-update-from-map.yaml:53:      - layer1:`
- L4038: `pkg/cmds/sources/tests/multi-update-from-map.yaml:58:    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L4039: `pkg/cmds/sources/tests/multi-update-from-map.yaml:59:    parameterLayers:`
- L4040: `pkg/cmds/sources/tests/multi-update-from-map.yaml:60:      - name: "layer1"`
- L4041: `pkg/cmds/sources/tests/multi-update-from-map.yaml:67:    parsedLayers:`
- L4042: `pkg/cmds/sources/tests/multi-update-from-map.yaml:68:      - name: "layer1"`
- L4043: `pkg/cmds/sources/tests/multi-update-from-map.yaml:69:        parameters:`
- L4044: `pkg/cmds/sources/tests/multi-update-from-map.yaml:74:    expectedLayers:`
- L4045: `pkg/cmds/sources/tests/multi-update-from-map.yaml:75:      - name: "layer1"`
- L4046: `pkg/cmds/sources/tests/multi-update-from-map.yaml:80:      - layer1:`
- L4047: `pkg/cmds/sources/tests/multi-update-from-map.yaml:85:    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L4048: `pkg/cmds/sources/tests/multi-update-from-map.yaml:86:    parameterLayers:`
- L4049: `pkg/cmds/sources/tests/multi-update-from-map.yaml:87:      - name: "layer1"`
- L4050: `pkg/cmds/sources/tests/multi-update-from-map.yaml:96:    parsedLayers:`
- L4051: `pkg/cmds/sources/tests/multi-update-from-map.yaml:97:      - name: "layer1"`
- L4052: `pkg/cmds/sources/tests/multi-update-from-map.yaml:98:        parameters:`
- L4053: `pkg/cmds/sources/tests/multi-update-from-map.yaml:103:    expectedLayers:`
- L4054: `pkg/cmds/sources/tests/multi-update-from-map.yaml:104:      - name: "layer1"`
- L4055: `pkg/cmds/sources/tests/multi-update-from-map.yaml:109:      - layer1:`
- L4056: `pkg/cmds/sources/tests/multi-update-from-map.yaml:114:    description: "Multiple update maps should apply updates in sequence to the ParsedLayers."`
- L4057: `pkg/cmds/sources/tests/multi-update-from-map.yaml:115:    parameterLayers:`
- L4058: `pkg/cmds/sources/tests/multi-update-from-map.yaml:116:      - name: "layer1"`
- L4059: `pkg/cmds/sources/tests/multi-update-from-map.yaml:124:    parsedLayers:`
- L4060: `pkg/cmds/sources/tests/multi-update-from-map.yaml:125:      - name: "layer1"`
- L4061: `pkg/cmds/sources/tests/multi-update-from-map.yaml:126:        parameters:`
- L4062: `pkg/cmds/sources/tests/multi-update-from-map.yaml:131:    expectedLayers:`
- L4063: `pkg/cmds/sources/tests/multi-update-from-map.yaml:132:      - name: "layer1"`
- L4064: `pkg/cmds/sources/tests/multi-update-from-map.yaml:138:      - layer1:`
- L4065: `pkg/cmds/sources/tests/multi-update-from-map.yaml:141:      - layer1:`
- L4066: `pkg/cmds/sources/tests/multi-update-from-map.yaml:148:    parameterLayers:`
- L4067: `pkg/cmds/sources/tests/multi-update-from-map.yaml:149:      - name: "layer1"`
- L4068: `pkg/cmds/sources/tests/multi-update-from-map.yaml:154:    parsedLayers:`
- L4069: `pkg/cmds/sources/tests/multi-update-from-map.yaml:155:      - name: "layer1"`
- L4070: `pkg/cmds/sources/tests/multi-update-from-map.yaml:156:    expectedLayers:`
- L4071: `pkg/cmds/sources/tests/multi-update-from-map.yaml:157:      - name: "layer1"`
- L4072: `pkg/cmds/sources/tests/multi-update-from-map.yaml:162:      - layer1:`
- L4073: `pkg/cmds/sources/tests/multi-update-from-map.yaml:164:      - layer1:`
- L4074: `pkg/cmds/sources/tests/multi-update-from-map.yaml:167:  # Test 5: Non-Existent Layers`
- L4075: `pkg/cmds/sources/tests/multi-update-from-map.yaml:168:  - name: "Non-Existent Layers"`
- L4076: `pkg/cmds/sources/tests/multi-update-from-map.yaml:169:    description: "Updates that reference non-existent layers should be ignored."`
- L4077: `pkg/cmds/sources/tests/multi-update-from-map.yaml:170:    parameterLayers:`
- L4078: `pkg/cmds/sources/tests/multi-update-from-map.yaml:171:      - name: "layer1"`
- L4079: `pkg/cmds/sources/tests/multi-update-from-map.yaml:176:    expectedLayers:`
- L4080: `pkg/cmds/sources/tests/multi-update-from-map.yaml:179:      - layer2: # This layer does not exist in parameterLayers`
- L4081: `pkg/cmds/sources/tests/multi-update-from-map.yaml:182:# Test 6: New Layers`
- L4082: `pkg/cmds/sources/tests/multi-update-from-map.yaml:183:- name: "New Layers"`
- L4083: `pkg/cmds/sources/tests/multi-update-from-map.yaml:184:  description: "Update maps that reference new layers should create those layers."`
- L4084: `pkg/cmds/sources/tests/multi-update-from-map.yaml:185:  parameterLayers:`
- L4085: `pkg/cmds/sources/tests/multi-update-from-map.yaml:186:    - name: "layer1"`
- L4086: `pkg/cmds/sources/tests/multi-update-from-map.yaml:191:    - name: "layer2"`
- L4087: `pkg/cmds/sources/tests/multi-update-from-map.yaml:196:  parsedLayers:`
- L4088: `pkg/cmds/sources/tests/multi-update-from-map.yaml:197:    - name: "layer1"`
- L4089: `pkg/cmds/sources/tests/multi-update-from-map.yaml:198:  expectedLayers:`
- L4090: `pkg/cmds/sources/tests/multi-update-from-map.yaml:199:    - name: "layer1"`
- L4091: `pkg/cmds/sources/tests/multi-update-from-map.yaml:202:    - name: "layer2"`
- L4092: `pkg/cmds/sources/tests/multi-update-from-map.yaml:204:        param1: "new-layer-value"`
- L4093: `pkg/cmds/sources/tests/multi-update-from-map.yaml:207:    - layer2:`
- L4094: `pkg/cmds/sources/tests/multi-update-from-map.yaml:208:        param1: "new-layer-value"`
- L4095: `pkg/cmds/sources/tests/multi-update-from-map.yaml:210:# Test 7: New inexistent layers`
- L4096: `pkg/cmds/sources/tests/multi-update-from-map.yaml:211:- name: "New inexistent layers"`
- L4097: `pkg/cmds/sources/tests/multi-update-from-map.yaml:212:  description: "Update maps that reference new layers should create those layers."`
- L4098: `pkg/cmds/sources/tests/multi-update-from-map.yaml:213:  parameterLayers:`
- L4099: `pkg/cmds/sources/tests/multi-update-from-map.yaml:214:    - name: "layer1"`
- L4100: `pkg/cmds/sources/tests/multi-update-from-map.yaml:219:    - name: "layer2"`
- L4101: `pkg/cmds/sources/tests/multi-update-from-map.yaml:224:  parsedLayers:`
- L4102: `pkg/cmds/sources/tests/multi-update-from-map.yaml:225:    - name: "layer1"`
- L4103: `pkg/cmds/sources/tests/multi-update-from-map.yaml:226:  expectedLayers:`
- L4104: `pkg/cmds/sources/tests/multi-update-from-map.yaml:227:    - name: "layer1"`
- L4105: `pkg/cmds/sources/tests/multi-update-from-map.yaml:229:        param1: "layer1-value"`
- L4106: `pkg/cmds/sources/tests/multi-update-from-map.yaml:230:    - name: "layer2"`
- L4107: `pkg/cmds/sources/tests/multi-update-from-map.yaml:232:        param1: "new-layer-value"`
- L4108: `pkg/cmds/sources/tests/multi-update-from-map.yaml:235:    - layer2:`
- L4109: `pkg/cmds/sources/tests/multi-update-from-map.yaml:236:        param1: "new-layer-value"`
- L4110: `pkg/cmds/sources/tests/multi-update-from-map.yaml:238:        param1: "inexistent-layer-value"`
- L4111: `pkg/cmds/sources/tests/multi-update-from-map.yaml:239:      layer1:`
- L4112: `pkg/cmds/sources/tests/multi-update-from-map.yaml:240:        param1: "layer1-value"`
- L4113: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:11:	layers *schema.Schema`
- L4114: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:18:		layers: l,`
- L4115: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:25:func (b *ConfigMapperBuilder) Map(source string, targetLayer string, targetParameter string, required ...bool) *ConfigMapperBuilder {`
- L4116: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:28:		TargetLayer:     targetLayer,`
- L4117: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:29:		TargetParameter: targetParameter,`
- L4118: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:39:func (b *ConfigMapperBuilder) MapObject(parentSource string, targetLayer string, childRules []MappingRule) *ConfigMapperBuilder {`
- L4119: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:42:		TargetLayer: targetLayer,`
- L4120: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:51:	return NewConfigMapper(b.layers, b.rules...)`
- L4121: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:55:func Child(source string, targetParameter string) MappingRule {`
- L4122: `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go:56:	return MappingRule{Source: source, TargetParameter: targetParameter}`
- L4123: `pkg/settings/settings_template.go:48:type TemplateParameterLayer struct {`
- L4124: `pkg/settings/settings_template.go:52:const GlazedTemplateLayerSlug = "glazed-template"`
- L4125: `pkg/settings/settings_template.go:54:func NewTemplateParameterLayer(options ...schema.SectionOption) (*TemplateParameterLayer, error) {`
- L4126: `pkg/settings/settings_template.go:55:	ret := &TemplateParameterLayer{}`
- L4127: `pkg/settings/settings_template.go:56:	layer, err := schema.NewSectionFromYAML(templateFlagsYaml, options...)`
- L4128: `pkg/settings/settings_template.go:58:		return nil, errors.Wrap(err, "Failed to create template parameter layer")`
- L4129: `pkg/settings/settings_template.go:60:	ret.SectionImpl = layer`
- L4130: `pkg/settings/settings_template.go:65:func (f *TemplateParameterLayer) Clone() schema.Section {`
- L4131: `pkg/settings/settings_template.go:66:	return &TemplateParameterLayer{`
- L4132: `pkg/settings/settings_template.go:71:func NewTemplateSettings(layer *values.SectionValues) (*TemplateSettings, error) {`
- L4133: `pkg/settings/settings_template.go:77:	templateArgument, ok := layer.Parameters.GetValue("template").(string)`
- L4134: `pkg/settings/settings_template.go:81:		v := layer.Parameters.GetValue("template-field")`
- L4135: `pkg/settings/settings_template.go:95:	useRowTemplates, ok := layer.Parameters.GetValue("use-row-templates").(bool)`
- L4136: `pkg/cmds/schema/layer-impl.go:18:	ChildLayers []Section           `yaml:"childLayers,omitempty"``
- L4137: `pkg/cmds/schema/layer-impl.go:103:			return p.InitializeDefaultsFromParameters(m)`
- L4138: `pkg/cmds/schema/layer-impl.go:110:func WithFields(parameterDefinitions ...*fields.Definition) SectionOption {`
- L4139: `pkg/cmds/schema/layer-impl.go:112:		for _, f := range parameterDefinitions {`
- L4140: `pkg/cmds/schema/layer-impl.go:136:		_, err := f_.Value.CheckParameterDefaultValueValidity()`
- L4141: `pkg/cmds/schema/layer-impl.go:168:// GetDefinitions returns a map that maps all parameters (flags and arguments) to their name.`
- L4142: `pkg/cmds/schema/layer-impl.go:179:// InitializeDefaultsFromStruct initializes the `ParameterDefinition` of the layer,`
- L4143: `pkg/cmds/schema/layer-impl.go:182:// This is in some ways the opposite of `InitializeStructFromParameterDefaults`.`
- L4144: `pkg/cmds/schema/layer-impl.go:184:// to initialize the `ParameterDefinition` with a matching name. If no matching`
- L4145: `pkg/cmds/schema/layer-impl.go:185:// `ParameterDefinition` is found, an error is returned.`
- L4146: `pkg/cmds/schema/layer-impl.go:196:// InitializeDefaultsFromParameters initializes the parameter definitions`
- L4147: `pkg/cmds/schema/layer-impl.go:197:// of the layer from the given map of parameter values. The parameter definitions`
- L4148: `pkg/cmds/schema/layer-impl.go:199:func (p *SectionImpl) InitializeDefaultsFromParameters(`
- L4149: `pkg/cmds/schema/layer-impl.go:207:func (p *SectionImpl) InitializeStructFromParameterDefaults(s interface{}) error {`
- L4150: `pkg/cmds/schema/layer-impl.go:216:// AddLayerToCobraCommand adds all flags of the layer to the given Cobra command.`
- L4151: `pkg/cmds/schema/layer-impl.go:217:// It also creates a flag group representing the layer and adds it to the command.`
- L4152: `pkg/cmds/schema/layer-impl.go:218:// If the layer has a prefix, the flags are added with that prefix.`
- L4153: `pkg/cmds/schema/layer-impl.go:219:func (p *SectionImpl) AddLayerToCobraCommand(cmd *cobra.Command) error {`
- L4154: `pkg/cmds/schema/layer-impl.go:220:	err := p.Definitions.AddParametersToCobraCommand(cmd, p.Prefix)`
- L4155: `pkg/cmds/schema/layer-impl.go:230:// ParseLayerFromCobraCommand parses the flags of the layer from the given Cobra command.`
- L4156: `pkg/cmds/schema/layer-impl.go:231:// If the layer has a prefix, the flags are parsed with that prefix (meaning, the prefix`
- L4157: `pkg/cmds/schema/layer-impl.go:235:// of the layer.`
- L4158: `pkg/cmds/schema/layer-impl.go:236:func (p *SectionImpl) ParseLayerFromCobraCommand(`
- L4159: `pkg/cmds/schema/layer-impl.go:256:		Layer:      p,`
- L4160: `pkg/cmds/schema/layer-impl.go:257:		Parameters: ps,`
- L4161: `pkg/cmds/schema/layer-impl.go:261:func (p *SectionImpl) GatherParametersFromMap(`
- L4162: `pkg/cmds/schema/layer-impl.go:264:) (*fields.ParsedParameters, error) {`
- L4163: `pkg/cmds/schema/layer-impl.go:265:	return p.Definitions.GatherParametersFromMap(m, onlyProvided, options...)`
- L4164: `pkg/cmds/sources/patternmapper/exports.go:12:func ExtractCaptureReferences(targetParameter string) map[string]bool {`
- L4165: `pkg/cmds/sources/patternmapper/exports.go:13:	return extractCaptureReferences(targetParameter)`
- L4166: `pkg/cmds/sources/patternmapper/exports.go:16:// ResolveTargetParameter exposes internal resolveTargetParameter for testing and tooling.`
- L4167: `pkg/cmds/sources/patternmapper/exports.go:17:func ResolveTargetParameter(targetParameter string, captures map[string]string) (string, error) {`
- L4168: `pkg/cmds/sources/patternmapper/exports.go:18:	return resolveTargetParameter(targetParameter, captures)`
- L4169: `pkg/cmds/fields/gather-arguments_test.go:31:// Test the parsing of every kind of parameter type for provided args`
- L4170: `pkg/cmds/fields/gather-arguments_test.go:32:// This should be broken down into individual tests for each parameter types.`
- L4171: `pkg/cmds/fields/gather-arguments_test.go:49:// Test parsing of list-type parameter with multiple arguments`
- L4172: `pkg/cmds/fields/gather-arguments_test.go:50:func TestGatherArguments_ListParameterParsing(t *testing.T) {`
- L4173: `pkg/cmds/fields/gather-arguments_test.go:261:func TestSingleParametersFollowedByListDefaults(t *testing.T) {`
- L4174: `pkg/cmds/fields/gather-arguments_test.go:286:func TestThreeSingleParametersFollowedByListDefaults(t *testing.T) {`
- L4175: `pkg/cmds/fields/gather-arguments_test.go:327:func TestThreeSingleParametersFollowedByListDefaultsOnlyTwoValues(t *testing.T) {`
- L4176: `pkg/settings/settings_sort.go:20:func NewSortSettingsFromParameters(glazedLayer *values.SectionValues) (*SortFlagsSettings, error) {`
- L4177: `pkg/settings/settings_sort.go:22:	err := glazedLayer.Parameters.InitializeStruct(s)`
- L4178: `pkg/settings/settings_sort.go:24:		return nil, errors.Wrap(err, "Failed to initialize sort settings from parameters")`
- L4179: `pkg/settings/settings_sort.go:30:type SortParameterLayer struct {`
- L4180: `pkg/settings/settings_sort.go:34:func NewSortParameterLayer(options ...schema.SectionOption) (*SortParameterLayer, error) {`
- L4181: `pkg/settings/settings_sort.go:35:	ret := &SortParameterLayer{}`
- L4182: `pkg/settings/settings_sort.go:36:	layer, err := schema.NewSectionFromYAML(sortFlagsYaml, options...)`
- L4183: `pkg/settings/settings_sort.go:38:		return nil, errors.Wrap(err, "Failed to create sort parameter layer")`
- L4184: `pkg/settings/settings_sort.go:40:	ret.SectionImpl = layer`
- L4185: `pkg/settings/settings_sort.go:45:func (f *SortParameterLayer) Clone() schema.Section {`
- L4186: `pkg/settings/settings_sort.go:46:	return &SortParameterLayer{`
- L4187: `pkg/cmds/schema/wrappers.go:5:type WhitelistParameterLayer struct {`
- L4188: `pkg/cmds/schema/wrappers.go:7:	WhitelistedParameters map[string]interface{}`
- L4189: `pkg/cmds/schema/wrappers.go:10:var _ Section = (*WhitelistParameterLayer)(nil)`
- L4190: `pkg/cmds/schema/wrappers.go:12:func NewWhitelistParameterLayer(layer Section, whitelistedParameters map[string]interface{}) *WhitelistParameterLayer {`
- L4191: `pkg/cmds/schema/wrappers.go:13:	return &WhitelistParameterLayer{`
- L4192: `pkg/cmds/schema/wrappers.go:14:		Section:               layer,`
- L4193: `pkg/cmds/schema/wrappers.go:15:		WhitelistedParameters: whitelistedParameters,`
- L4194: `pkg/cmds/schema/wrappers.go:19:func (l *WhitelistParameterLayer) GetDefinitions() *fields.Definitions {`
- L4195: `pkg/cmds/schema/wrappers.go:23:		if _, ok := l.WhitelistedParameters[pd.Name]; ok {`
- L4196: `pkg/cmds/schema/wrappers.go:30:type BlacklistParameterLayer struct {`
- L4197: `pkg/cmds/schema/wrappers.go:32:	BlacklistedParameters map[string]interface{}`
- L4198: `pkg/cmds/schema/wrappers.go:35:var _ Section = (*BlacklistParameterLayer)(nil)`
- L4199: `pkg/cmds/schema/wrappers.go:37:func NewBlacklistParameterLayer(layer Section, blacklistedParameters map[string]interface{}) *BlacklistParameterLayer {`
- L4200: `pkg/cmds/schema/wrappers.go:38:	return &BlacklistParameterLayer{`
- L4201: `pkg/cmds/schema/wrappers.go:39:		Section:               layer,`
- L4202: `pkg/cmds/schema/wrappers.go:40:		BlacklistedParameters: blacklistedParameters,`
- L4203: `pkg/cmds/schema/wrappers.go:44:func (l *BlacklistParameterLayer) GetDefinitions() *fields.Definitions {`
- L4204: `pkg/cmds/schema/wrappers.go:48:		if _, ok := l.BlacklistedParameters[pd.Name]; !ok {`
- L4205: `pkg/settings/settings_replace.go:42:type ReplaceParameterLayer struct {`
- L4206: `pkg/settings/settings_replace.go:49:func NewReplaceParameterLayer(options ...schema.SectionOption) (*ReplaceParameterLayer, error) {`
- L4207: `pkg/settings/settings_replace.go:50:	ret := &ReplaceParameterLayer{}`
- L4208: `pkg/settings/settings_replace.go:51:	layer, err := schema.NewSectionFromYAML(replaceFlagsYaml, options...)`
- L4209: `pkg/settings/settings_replace.go:55:	ret.SectionImpl = layer`
- L4210: `pkg/settings/settings_replace.go:59:func (f *ReplaceParameterLayer) Clone() schema.Section {`
- L4211: `pkg/settings/settings_replace.go:60:	return &ReplaceParameterLayer{`
- L4212: `pkg/settings/settings_replace.go:65:func NewReplaceSettingsFromParameters(glazedLayer *values.SectionValues) (*ReplaceSettings, error) {`
- L4213: `pkg/settings/settings_replace.go:67:	err := glazedLayer.Parameters.InitializeStruct(s)`
- L4214: `pkg/settings/settings_replace.go:69:		return nil, errors.Wrap(err, "failed to initialize replace settings from parameters")`
- L4215: `pkg/helpers/templating/templating.go:99:	"toUrlParameter": toUrlParameter,`
- L4216: `pkg/helpers/templating/templating.go:127:// toUrlParameter encodes the value as a string that can be passed for url parameter decoding`
- L4217: `pkg/helpers/templating/templating.go:128:func toUrlParameter(s interface{}) (string, error) {`
- L4218: `pkg/helpers/templating/templating.go:647:// NOTE(manuel, 2023-04-18) Interestingly, we have a baseDir parameter here but only one pattern`
- L4219: `pkg/settings/settings_select.go:21:func NewSelectSettingsFromParameters(glazedLayer *values.SectionValues) (*SelectSettings, error) {`
- L4220: `pkg/settings/settings_select.go:23:	err := glazedLayer.Parameters.InitializeStruct(s)`
- L4221: `pkg/settings/settings_select.go:25:		return nil, errors.Wrap(err, "Failed to initialize select settings from parameters")`
- L4222: `pkg/settings/settings_select.go:39:type SelectParameterLayer struct {`
- L4223: `pkg/settings/settings_select.go:43:func NewSelectParameterLayer(options ...schema.SectionOption) (*SelectParameterLayer, error) {`
- L4224: `pkg/settings/settings_select.go:44:	ret := &SelectParameterLayer{}`
- L4225: `pkg/settings/settings_select.go:45:	layer, err := schema.NewSectionFromYAML(selectFlagsYaml, options...)`
- L4226: `pkg/settings/settings_select.go:47:		return nil, errors.Wrap(err, "Failed to create select parameter layer")`
- L4227: `pkg/settings/settings_select.go:49:	ret.SectionImpl = layer`
- L4228: `pkg/settings/settings_select.go:54:func (f *SelectParameterLayer) Clone() schema.Section {`
- L4229: `pkg/settings/settings_select.go:55:	return &SelectParameterLayer{`
- L4230: `pkg/cmds/schema/serialize.go:10:// SerializableParameterLayer represents a parameter layer in a format suitable for`
- L4231: `pkg/cmds/schema/serialize.go:12:type SerializableParameterLayer struct {`
- L4232: `pkg/cmds/schema/serialize.go:17:	Parameters  *fields.Definitions `yaml:"parameters" json:"parameters"``
- L4233: `pkg/cmds/schema/serialize.go:21:func ToSerializable(layer Section) *SerializableParameterLayer {`
- L4234: `pkg/cmds/schema/serialize.go:22:	return &SerializableParameterLayer{`
- L4235: `pkg/cmds/schema/serialize.go:23:		Name:        layer.GetName(),`
- L4236: `pkg/cmds/schema/serialize.go:24:		Slug:        layer.GetSlug(),`
- L4237: `pkg/cmds/schema/serialize.go:25:		Description: layer.GetDescription(),`
- L4238: `pkg/cmds/schema/serialize.go:26:		Prefix:      layer.GetPrefix(),`
- L4239: `pkg/cmds/schema/serialize.go:27:		Parameters:  layer.GetDefinitions(),`
- L4240: `pkg/cmds/schema/serialize.go:31:// SerializableLayers represents a collection of parameter layers in a format suitable`
- L4241: `pkg/cmds/schema/serialize.go:32:// for YAML/JSON serialization, maintaining the order of layers`
- L4242: `pkg/cmds/schema/serialize.go:33:type SerializableLayers struct {`
- L4243: `pkg/cmds/schema/serialize.go:34:	// Using orderedmap to maintain layer order while having slug-based access`
- L4244: `pkg/cmds/schema/serialize.go:35:	Layers *orderedmap.OrderedMap[string, *SerializableParameterLayer] `yaml:"layers" json:"layers"``
- L4245: `pkg/cmds/schema/serialize.go:38:// LayersToSerializable converts a Schema collection to its serializable representation`
- L4246: `pkg/cmds/schema/serialize.go:39:func LayersToSerializable(layers *Schema) *SerializableLayers {`
- L4247: `pkg/cmds/schema/serialize.go:40:	ret := &SerializableLayers{`
- L4248: `pkg/cmds/schema/serialize.go:41:		Layers: orderedmap.New[string, *SerializableParameterLayer](),`
- L4249: `pkg/cmds/schema/serialize.go:44:	layers.ForEach(func(_ string, layer Section) {`
- L4250: `pkg/cmds/schema/serialize.go:45:		serialized := ToSerializable(layer)`
- L4251: `pkg/cmds/schema/serialize.go:46:		ret.Layers.Set(layer.GetSlug(), serialized)`
- L4252: `pkg/cmds/schema/serialize.go:52:// MarshalYAML implements yaml.Marshaler for SerializableLayers`
- L4253: `pkg/cmds/schema/serialize.go:53:func (sl *SerializableLayers) MarshalYAML() (interface{}, error) {`
- L4254: `pkg/cmds/schema/serialize.go:55:	m := make(map[string]*SerializableParameterLayer)`
- L4255: `pkg/cmds/schema/serialize.go:56:	for pair := sl.Layers.Oldest(); pair != nil; pair = pair.Next() {`
- L4256: `pkg/cmds/schema/serialize.go:62:// MarshalJSON implements json.Marshaler for SerializableLayers`
- L4257: `pkg/cmds/schema/serialize.go:63:func (sl *SerializableLayers) MarshalJSON() ([]byte, error) {`
- L4258: `pkg/cmds/schema/serialize.go:65:	m := make(map[string]*SerializableParameterLayer)`
- L4259: `pkg/cmds/schema/serialize.go:66:	for pair := sl.Layers.Oldest(); pair != nil; pair = pair.Next() {`
- L4260: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:1:- name: "Blacklist Single Layer"`
- L4261: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:2:  description: "A single layer is blacklisted and should be removed from ParameterLayers."`
- L4262: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:3:  parameterLayers:`
- L4263: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:4:    - name: layer1`
- L4264: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:9:    - name: layer2`
- L4265: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:14:  parsedLayers: []`
- L4266: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:16:    layer1:`
- L4267: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:19:    - "layer1"`
- L4268: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:22:- name: "Blacklist Multiple Layers"`
- L4269: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:23:  description: "Multiple layers are blacklisted and should be removed from ParameterLayers."`
- L4270: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:24:  parameterLayers:`
- L4271: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:25:    - name: "layer1"`
- L4272: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:30:    - name: "layer2"`
- L4273: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:35:    - name: "layer3"`
- L4274: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:40:  expectedLayers:`
- L4275: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:41:    - name: layer2`
- L4276: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:45:    layer1:`
- L4277: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:47:    layer2:`
- L4278: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:49:    layer3:`
- L4279: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:52:    - "layer1"`
- L4280: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:53:    - "layer3"`
- L4281: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:58:  parameterLayers:`
- L4282: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:59:    - name: "layer1"`
- L4283: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:64:    - name: "layer2"`
- L4284: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:69:    - name: "layer3"`
- L4285: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:74:    - name: "layer4"`
- L4286: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:79:  parsedLayers: []`
- L4287: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:81:    layer2:`
- L4288: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:83:    layer4:`
- L4289: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:86:    - "layer1"`
- L4290: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:87:    - "layer3"`
- L4291: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:89:  expectedLayers:`
- L4292: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:90:    - name: layer1`
- L4293: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:93:    - name: layer2`
- L4294: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:96:    - name: layer3`
- L4295: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:99:    - name: layer4`
- L4296: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:103:    layer1:`
- L4297: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:105:    layer2:`
- L4298: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:107:    layer3:`
- L4299: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:110:    layer1:`
- L4300: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:112:    layer3:`
- L4301: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:114:    layer4:`
- L4302: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:117:- name: "Whitelist single layer"`
- L4303: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:118:  description: "A single layer is whitelisted and should be kept in ParameterLayers."`
- L4304: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:119:  parameterLayers:`
- L4305: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:120:    - name: layer1`
- L4306: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:125:    - name: layer2`
- L4307: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:130:  parsedLayers: []`
- L4308: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:131:  expectedLayers:`
- L4309: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:132:    - name: layer1`
- L4310: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:136:    layer1:`
- L4311: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:139:    - "layer1"`
- L4312: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:142:- name: "Whitelist multiple layers"`
- L4313: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:143:  description: "Multiple layers are whitelisted and should be kept in ParameterLayers."`
- L4314: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:144:  parameterLayers:`
- L4315: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:145:    - name: "layer1"`
- L4316: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:150:    - name: "layer2"`
- L4317: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:155:    - name: "layer3"`
- L4318: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:160:  expectedLayers:`
- L4319: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:161:    - name: layer1`
- L4320: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:164:    - name: layer3`
- L4321: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:168:    layer1:`
- L4322: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:170:    layer3:`
- L4323: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:173:    - "layer1"`
- L4324: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:174:    - "layer3"`
- L4325: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:179:  parameterLayers:`
- L4326: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:180:    - name: "layer1"`
- L4327: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:185:    - name: "layer2"`
- L4328: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:190:    - name: "layer3"`
- L4329: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:195:    - name: "layer4"`
- L4330: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:200:  parsedLayers: []`
- L4331: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:202:    layer1:`
- L4332: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:204:    layer3:`
- L4333: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:207:    - "layer1"`
- L4334: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:208:    - "layer3"`
- L4335: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:210:  expectedLayers:`
- L4336: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:211:    - name: layer1`
- L4337: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:214:    - name: layer2`
- L4338: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:217:    - name: layer3`
- L4339: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:220:    - name: layer4`
- L4340: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:224:    layer1:`
- L4341: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:226:    layer2:`
- L4342: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:228:    layer3:`
- L4343: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:231:    layer1:`
- L4344: `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml:233:    layer4:`
- L4345: `pkg/settings/settings_rename.go:57:type RenameParameterLayer struct {`
- L4346: `pkg/settings/settings_rename.go:61:func NewRenameParameterLayer(options ...schema.SectionOption) (*RenameParameterLayer, error) {`
- L4347: `pkg/settings/settings_rename.go:62:	ret := &RenameParameterLayer{}`
- L4348: `pkg/settings/settings_rename.go:63:	layer, err := schema.NewSectionFromYAML(renameFlagsYaml, options...)`
- L4349: `pkg/settings/settings_rename.go:65:		return nil, errors.Wrap(err, "Failed to create rename parameter layer")`
- L4350: `pkg/settings/settings_rename.go:67:	ret.SectionImpl = layer`
- L4351: `pkg/settings/settings_rename.go:71:func (f *RenameParameterLayer) Clone() schema.Section {`
- L4352: `pkg/settings/settings_rename.go:72:	return &RenameParameterLayer{`
- L4353: `pkg/settings/settings_rename.go:77:func NewRenameSettingsFromParameters(glazedLayer *values.SectionValues) (*RenameSettings, error) {`
- L4354: `pkg/settings/settings_rename.go:78:	ps := glazedLayer.Parameters`
- L4355: `pkg/cmds/schema/layer-impl_test.go:11:func createSimpleParameterLayer(t *testing.T, options ...SectionOption) *SectionImpl {`
- L4356: `pkg/cmds/schema/layer-impl_test.go:17:	layer, err := NewSection("simple", "Simple", options_...)`
- L4357: `pkg/cmds/schema/layer-impl_test.go:20:	return layer`
- L4358: `pkg/cmds/schema/layer-impl_test.go:24:	layer := createSimpleParameterLayer(t)`
- L4359: `pkg/cmds/schema/layer-impl_test.go:30:	err := layer.AddLayerToCobraCommand(cmd)`
- L4360: `pkg/cmds/schema/layer-impl_test.go:49:	layer := createSimpleParameterLayer(t, WithPrefix("test-"))`
- L4361: `pkg/cmds/schema/layer-impl_test.go:55:	err := layer.AddLayerToCobraCommand(cmd)`
- L4362: `pkg/settings/settings_template_test.go:15:	layer, err := NewTemplateParameterLayer()`
- L4363: `pkg/settings/settings_template_test.go:17:	err = layer.InitializeDefaultsFromStruct(defaults)`
- L4364: `pkg/settings/settings_template_test.go:20:	layers_ := schema.NewSchema(schema.WithSections(layer))`
- L4365: `pkg/settings/settings_template_test.go:21:	parsedLayers := values.New()`
- L4366: `pkg/settings/settings_template_test.go:22:	err = sources.Execute(layers_, parsedLayers,`
- L4367: `pkg/settings/settings_template_test.go:28:	ps, ok := parsedLayers.Get(GlazedTemplateLayerSlug)`
- L4368: `pkg/cmds/sources/patternmapper/pattern_mapper.go:15:// MappingRule defines a pattern-based mapping from config file structure to layer fields.`
- L4369: `pkg/cmds/sources/patternmapper/pattern_mapper.go:18://   - TargetLayer: Which layer to place the value in`
- L4370: `pkg/cmds/sources/patternmapper/pattern_mapper.go:19://   - TargetParameter: Which parameter name to use (supports capture references like "{env}-api-key")`
- L4371: `pkg/cmds/sources/patternmapper/pattern_mapper.go:30:	// Target layer slug (e.g., "demo")`
- L4372: `pkg/cmds/sources/patternmapper/pattern_mapper.go:32:	TargetLayer string`
- L4373: `pkg/cmds/sources/patternmapper/pattern_mapper.go:34:	// Target parameter name (supports captures like "{env}-api-key")`
- L4374: `pkg/cmds/sources/patternmapper/pattern_mapper.go:36:	TargetParameter string`
- L4375: `pkg/cmds/sources/patternmapper/pattern_mapper.go:50:	layers           *schema.Schema`
- L4376: `pkg/cmds/sources/patternmapper/pattern_mapper.go:66://   - All target parameters exist in their respective layers`
- L4377: `pkg/cmds/sources/patternmapper/pattern_mapper.go:67://   - Capture references in target parameters match captures in source patterns`
- L4378: `pkg/cmds/sources/patternmapper/pattern_mapper.go:68:func NewConfigMapper(layers *schema.Schema, rules ...MappingRule) (sources.ConfigMapper, error) {`
- L4379: `pkg/cmds/sources/patternmapper/pattern_mapper.go:69:	if layers == nil {`
- L4380: `pkg/cmds/sources/patternmapper/pattern_mapper.go:70:		return nil, errors.New("layers cannot be nil")`
- L4381: `pkg/cmds/sources/patternmapper/pattern_mapper.go:75:		layers: layers,`
- L4382: `pkg/cmds/sources/patternmapper/pattern_mapper.go:139:	// Validate target parameter if this is a leaf rule (no nested rules)`
- L4383: `pkg/cmds/sources/patternmapper/pattern_mapper.go:141:		// Validate target layer exists`
- L4384: `pkg/cmds/sources/patternmapper/pattern_mapper.go:142:		if rule.TargetLayer == "" {`
- L4385: `pkg/cmds/sources/patternmapper/pattern_mapper.go:143:			return nil, errors.New("target layer is required for leaf rules")`
- L4386: `pkg/cmds/sources/patternmapper/pattern_mapper.go:146:		_, ok := m.layers.Get(rule.TargetLayer)`
- L4387: `pkg/cmds/sources/patternmapper/pattern_mapper.go:148:			return nil, errors.Errorf("target layer %q does not exist", rule.TargetLayer)`
- L4388: `pkg/cmds/sources/patternmapper/pattern_mapper.go:151:		// Validate capture references in target parameter`
- L4389: `pkg/cmds/sources/patternmapper/pattern_mapper.go:153:		if err := validateCaptureReferences(allCaptures, rule.TargetParameter); err != nil {`
- L4390: `pkg/cmds/sources/patternmapper/pattern_mapper.go:154:			return nil, errors.Wrapf(err, "invalid capture reference in target parameter")`
- L4391: `pkg/cmds/sources/patternmapper/pattern_mapper.go:157:		// Proposal 5: Early validation for static target parameters (no capture refs)`
- L4392: `pkg/cmds/sources/patternmapper/pattern_mapper.go:158:		if len(extractCaptureReferences(rule.TargetParameter)) == 0 {`
- L4393: `pkg/cmds/sources/patternmapper/pattern_mapper.go:159:			layer, _ := m.layers.Get(rule.TargetLayer)`
- L4394: `pkg/cmds/sources/patternmapper/pattern_mapper.go:160:			if layer != nil {`
- L4395: `pkg/cmds/sources/patternmapper/pattern_mapper.go:161:				canonical := resolveCanonicalParameterName(layer, rule.TargetParameter)`
- L4396: `pkg/cmds/sources/patternmapper/pattern_mapper.go:162:				if pd, ok := layer.GetDefinitions().Get(canonical); !ok || pd == nil {`
- L4397: `pkg/cmds/sources/patternmapper/pattern_mapper.go:163:					if canonical != rule.TargetParameter {`
- L4398: `pkg/cmds/sources/patternmapper/pattern_mapper.go:164:						return nil, errors.Errorf("target parameter %q (checked as %q) does not exist in layer %q", rule.TargetParameter, canonical, rule.TargetLayer)`
- L4399: `pkg/cmds/sources/patternmapper/pattern_mapper.go:166:					return nil, errors.Errorf("target parameter %q does not exist in layer %q", rule.TargetParameter, rule.TargetLayer)`
- L4400: `pkg/cmds/sources/patternmapper/pattern_mapper.go:189:			// Inherit target layer if not set`
- L4401: `pkg/cmds/sources/patternmapper/pattern_mapper.go:190:			if childRule.TargetLayer == "" {`
- L4402: `pkg/cmds/sources/patternmapper/pattern_mapper.go:191:				childRule.TargetLayer = rule.TargetLayer`
- L4403: `pkg/cmds/sources/patternmapper/pattern_mapper.go:219:	// Key: layer+"."+paramName, Value: pattern source that last wrote to it`
- L4404: `pkg/cmds/sources/patternmapper/pattern_mapper.go:230:		// Key: resolved target parameter name, Value: list of distinct values`
- L4405: `pkg/cmds/sources/patternmapper/pattern_mapper.go:235:			// Resolve target parameter name (replace captures)`
- L4406: `pkg/cmds/sources/patternmapper/pattern_mapper.go:236:			targetParam, err := resolveTargetParameter(compiled.rule.TargetParameter, match.captures)`
- L4407: `pkg/cmds/sources/patternmapper/pattern_mapper.go:238:				return nil, errors.Wrapf(err, "failed to resolve target parameter")`
- L4408: `pkg/cmds/sources/patternmapper/pattern_mapper.go:241:			// Validate parameter exists`
- L4409: `pkg/cmds/sources/patternmapper/pattern_mapper.go:242:			layer, ok := m.layers.Get(match.layer)`
- L4410: `pkg/cmds/sources/patternmapper/pattern_mapper.go:244:				return nil, errors.Errorf("target layer %q does not exist", match.layer)`
- L4411: `pkg/cmds/sources/patternmapper/pattern_mapper.go:247:			// Resolve canonical parameter name (using helper from proposal 9)`
- L4412: `pkg/cmds/sources/patternmapper/pattern_mapper.go:248:			paramName := resolveCanonicalParameterName(layer, targetParam)`
- L4413: `pkg/cmds/sources/patternmapper/pattern_mapper.go:250:			paramDef, ok := layer.GetDefinitions().Get(paramName)`
- L4414: `pkg/cmds/sources/patternmapper/pattern_mapper.go:254:				errorMsg := fmt.Sprintf("target parameter %q", targetParam)`
- L4415: `pkg/cmds/sources/patternmapper/pattern_mapper.go:258:				errorMsg += fmt.Sprintf(" does not exist in layer %q (pattern: %q)", match.layer, compiled.rule.Source)`
- L4416: `pkg/cmds/sources/patternmapper/pattern_mapper.go:278:						"pattern %q matched multiple distinct values for parameter %q: found %d distinct values",`
- L4417: `pkg/cmds/sources/patternmapper/pattern_mapper.go:288:		// Track which parameters were written by this rule to avoid false collision detection`
- L4418: `pkg/cmds/sources/patternmapper/pattern_mapper.go:291:			// Resolve target parameter name (replace captures)`
- L4419: `pkg/cmds/sources/patternmapper/pattern_mapper.go:292:			targetParam, err := resolveTargetParameter(compiled.rule.TargetParameter, match.captures)`
- L4420: `pkg/cmds/sources/patternmapper/pattern_mapper.go:294:				return nil, errors.Wrapf(err, "failed to resolve target parameter")`
- L4421: `pkg/cmds/sources/patternmapper/pattern_mapper.go:297:			layer, _ := m.layers.Get(match.layer)`
- L4422: `pkg/cmds/sources/patternmapper/pattern_mapper.go:298:			paramName := resolveCanonicalParameterName(layer, targetParam)`
- L4423: `pkg/cmds/sources/patternmapper/pattern_mapper.go:301:			// Only check for collisions if this parameter wasn't already written by this rule`
- L4424: `pkg/cmds/sources/patternmapper/pattern_mapper.go:302:			collisionKey := match.layer + "." + paramName`
- L4425: `pkg/cmds/sources/patternmapper/pattern_mapper.go:305:					// Collision detected (different rule writing to same parameter): error`
- L4426: `pkg/cmds/sources/patternmapper/pattern_mapper.go:307:						"collision: parameter %q in layer %q is written by multiple patterns: %q and %q",`
- L4427: `pkg/cmds/sources/patternmapper/pattern_mapper.go:309:						match.layer,`
- L4428: `pkg/cmds/sources/patternmapper/pattern_mapper.go:318:			// Initialize layer map if needed`
- L4429: `pkg/cmds/sources/patternmapper/pattern_mapper.go:319:			if result[match.layer] == nil {`
- L4430: `pkg/cmds/sources/patternmapper/pattern_mapper.go:320:				result[match.layer] = make(map[string]interface{})`
- L4431: `pkg/cmds/sources/patternmapper/pattern_mapper.go:324:			result[match.layer][paramName] = match.value`
- L4432: `pkg/cmds/sources/patternmapper/pattern_mapper.go:333:	layer    string`
- L4433: `pkg/cmds/sources/patternmapper/pattern_mapper.go:479:			layer:    compiled.rule.TargetLayer,`
- L4434: `pkg/cmds/sources/patternmapper/pattern_mapper.go:521:// validateCaptureReferences validates that all capture references in target parameter`
- L4435: `pkg/cmds/sources/patternmapper/pattern_mapper.go:523:func validateCaptureReferences(availableCaptures []string, targetParameter string) error {`
- L4436: `pkg/cmds/sources/patternmapper/pattern_mapper.go:524:	// Extract capture references from target parameter`
- L4437: `pkg/cmds/sources/patternmapper/pattern_mapper.go:525:	targetRefs := extractCaptureReferences(targetParameter)`
- L4438: `pkg/cmds/sources/patternmapper/pattern_mapper.go:537:			return errors.Errorf("capture reference {%s} in target parameter not found in source pattern", ref)`
- L4439: `pkg/cmds/sources/patternmapper/pattern_mapper.go:557:// extractCaptureReferences extracts all capture references from a target parameter string`
- L4440: `pkg/cmds/sources/patternmapper/pattern_mapper.go:558:func extractCaptureReferences(targetParameter string) map[string]bool {`
- L4441: `pkg/cmds/sources/patternmapper/pattern_mapper.go:562:	matches := re.FindAllStringSubmatch(targetParameter, -1)`
- L4442: `pkg/cmds/sources/patternmapper/pattern_mapper.go:603:// resolveCanonicalParameterName resolves the canonical parameter name including prefix`
- L4443: `pkg/cmds/sources/patternmapper/pattern_mapper.go:604:// This is proposal 9: explicit helper for canonical parameter name resolution`
- L4444: `pkg/cmds/sources/patternmapper/pattern_mapper.go:605:func resolveCanonicalParameterName(layer schema.Section, targetParam string) string {`
- L4445: `pkg/cmds/sources/patternmapper/pattern_mapper.go:606:	if layer.GetPrefix() != "" {`
- L4446: `pkg/cmds/sources/patternmapper/pattern_mapper.go:607:		// If layer has prefix, check if targetParam already includes it`
- L4447: `pkg/cmds/sources/patternmapper/pattern_mapper.go:608:		if !strings.HasPrefix(targetParam, layer.GetPrefix()) {`
- L4448: `pkg/cmds/sources/patternmapper/pattern_mapper.go:609:			return layer.GetPrefix() + targetParam`
- L4449: `pkg/cmds/sources/patternmapper/pattern_mapper.go:615:// resolveTargetParameter resolves capture references in target parameter name`
- L4450: `pkg/cmds/sources/patternmapper/pattern_mapper.go:616:func resolveTargetParameter(targetParameter string, captures map[string]string) (string, error) {`
- L4451: `pkg/cmds/sources/patternmapper/pattern_mapper.go:617:	result := targetParameter`
- L4452: `pkg/cmds/sources/patternmapper/pattern_mapper.go:619:	matches := re.FindAllStringSubmatch(targetParameter, -1)`
- L4453: `pkg/settings/settings_skip_limit.go:19:func NewSkipLimitSettingsFromParameters(glazedLayer *values.SectionValues) (*SkipLimitSettings, error) {`
- L4454: `pkg/settings/settings_skip_limit.go:21:	err := glazedLayer.Parameters.InitializeStruct(s)`
- L4455: `pkg/settings/settings_skip_limit.go:23:		return nil, errors.Wrap(err, "Failed to initialize skipLimit settings from parameters")`
- L4456: `pkg/settings/settings_skip_limit.go:29:type SkipLimitParameterLayer struct {`
- L4457: `pkg/settings/settings_skip_limit.go:33:func NewSkipLimitParameterLayer(options ...schema.SectionOption) (*SkipLimitParameterLayer, error) {`
- L4458: `pkg/settings/settings_skip_limit.go:34:	ret := &SkipLimitParameterLayer{}`
- L4459: `pkg/settings/settings_skip_limit.go:35:	layer, err := schema.NewSectionFromYAML(skipLimitFlagsYaml, options...)`
- L4460: `pkg/settings/settings_skip_limit.go:37:		return nil, errors.Wrap(err, "Failed to create skipLimit parameter layer")`
- L4461: `pkg/settings/settings_skip_limit.go:39:	ret.SectionImpl = layer`
- L4462: `pkg/settings/settings_skip_limit.go:43:func (f *SkipLimitParameterLayer) Clone() schema.Section {`
- L4463: `pkg/settings/settings_skip_limit.go:44:	return &SkipLimitParameterLayer{`
- L4464: `pkg/cmds/schema/cobra.go:11:	// AddLayerToCobraCommand adds all the flags and arguments defined in this layer to the given cobra command.`
- L4465: `pkg/cmds/schema/cobra.go:12:	AddLayerToCobraCommand(cmd *cobra.Command) error`
- L4466: `pkg/cmds/schema/cobra.go:13:	ParseLayerFromCobraCommand(cmd *cobra.Command, options ...fields.ParseOption) (*values.SectionValues, error)`
- L4467: `pkg/settings/settings_output.go:55:type OutputParameterLayer struct {`
- L4468: `pkg/settings/settings_output.go:59:func NewOutputParameterLayer(options ...schema.SectionOption) (*OutputParameterLayer, error) {`
- L4469: `pkg/settings/settings_output.go:60:	ret := &OutputParameterLayer{}`
- L4470: `pkg/settings/settings_output.go:61:	layer, err := schema.NewSectionFromYAML(outputFlagsYaml, options...)`
- L4471: `pkg/settings/settings_output.go:65:	ret.SectionImpl = layer`
- L4472: `pkg/settings/settings_output.go:70:func (f *OutputParameterLayer) Clone() schema.Section {`
- L4473: `pkg/settings/settings_output.go:71:	return &OutputParameterLayer{`
- L4474: `pkg/settings/settings_output.go:76:func NewOutputFormatterSettings(glazedLayer *values.SectionValues) (*OutputFormatterSettings, error) {`
- L4475: `pkg/settings/settings_output.go:78:	err := glazedLayer.Parameters.InitializeStruct(s)`
- L4476: `pkg/cmds/schema/errors.go:12:		return fmt.Sprintf("invalid parameter layer: %s", e.Name)`
- L4477: `pkg/cmds/schema/errors.go:14:	return fmt.Sprintf("invalid parameter layer: %s (expected %s)", e.Name, e.Expected)`
- L4478: `pkg/cmds/template.go:29:	Layers    schema.Schema        `yaml:"layers,omitempty"``
- L4479: `pkg/cmds/template.go:48:func (t *TemplateCommand) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {`
- L4480: `pkg/cmds/template.go:55:	err = tmpl.Execute(w, parsedLayers.GetDataMap())`
- L4481: `pkg/cmds/template.go:95:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4482: `pkg/cmds/template.go:104:		WithLayersList(tcd.Layers.AsList()...),`
- L4483: `pkg/cmds/template.go:105:		WithLayersList(defaultLayer),`
- L4484: `pkg/cmds/schema/layer.go:13:// Section is a struct that is used by one specific functionality layer`
- L4485: `pkg/cmds/schema/layer.go:14:// to group and describe all the parameter definitions that it uses.`
- L4486: `pkg/cmds/schema/layer.go:41:func WithSections(layers ...Section) SchemaOption {`
- L4487: `pkg/cmds/schema/layer.go:43:		for _, l := range layers {`
- L4488: `pkg/cmds/schema/layer.go:92:func (pl *Schema) AppendLayers(layers ...Section) {`
- L4489: `pkg/cmds/schema/layer.go:93:	for _, l := range layers {`
- L4490: `pkg/cmds/schema/layer.go:98:func (pl *Schema) PrependLayers(layers ...Section) {`
- L4491: `pkg/cmds/schema/layer.go:99:	list.Reverse[Section](layers)`
- L4492: `pkg/cmds/schema/layer.go:101:	for _, l := range layers {`
- L4493: `pkg/cmds/schema/layer.go:143:			err := v.(CobraSection).AddLayerToCobraCommand(cmd)`
- L4494: `pkg/cmds/schema/layer.go:165:	parsedLayer *values.SectionValues,`
- L4495: `pkg/cmds/schema/layer.go:171:		v, err := pd.CheckParameterDefaultValueValidity()`
- L4496: `pkg/cmds/schema/layer.go:176:			err := parsedLayer.Parameters.SetAsDefault(pd.Name, pd, v, options...)`
- L4497: `pkg/cmds/schema/layer.go:191:func (pl *Schema) UpdateWithDefaults(parsedLayers *values.Values, options ...fields.ParseOption) error {`
- L4498: `pkg/cmds/schema/layer.go:193:		parsedLayer := parsedLayers.GetOrCreate(v)`
- L4499: `pkg/cmds/schema/layer.go:194:		return InitializeSectionWithDefaults(v, parsedLayer, options...)`
- L4500: `pkg/cmds/schema/layer.go:202:	return LayersToSerializable(pl), nil`
- L4501: `pkg/cmds/schema/layer.go:207:	return json.Marshal(LayersToSerializable(pl))`
- L4502: `pkg/cmds/sources/tests/set-from-defaults.yaml:1:- name: "Empty layers and parsedLayers"`
- L4503: `pkg/cmds/sources/tests/set-from-defaults.yaml:2:  description: "Empty layers should result in empty parsed layers"`
- L4504: `pkg/cmds/sources/tests/set-from-defaults.yaml:3:  parameterLayers: [ ]`
- L4505: `pkg/cmds/sources/tests/set-from-defaults.yaml:4:  parsedLayers: [ ]`
- L4506: `pkg/cmds/sources/tests/set-from-defaults.yaml:5:  expectedLayers: [ ]`
- L4507: `pkg/cmds/sources/tests/set-from-defaults.yaml:8:- name: "Single layer with default"`
- L4508: `pkg/cmds/sources/tests/set-from-defaults.yaml:9:  description: "Single layer with default values should result in a single layer with these values"`
- L4509: `pkg/cmds/sources/tests/set-from-defaults.yaml:10:  parameterLayers:`
- L4510: `pkg/cmds/sources/tests/set-from-defaults.yaml:11:    - name: "layer1"`
- L4511: `pkg/cmds/sources/tests/set-from-defaults.yaml:16:  parsedLayers:`
- L4512: `pkg/cmds/sources/tests/set-from-defaults.yaml:17:    - name: "layer1"`
- L4513: `pkg/cmds/sources/tests/set-from-defaults.yaml:18:  expectedLayers:`
- L4514: `pkg/cmds/sources/tests/set-from-defaults.yaml:19:    - name: "layer1"`
- L4515: `pkg/cmds/sources/tests/set-from-defaults.yaml:27:- name: "Single layer with list type default"`
- L4516: `pkg/cmds/sources/tests/set-from-defaults.yaml:28:  description: "Single layer with default values should result in a single layer with these values"`
- L4517: `pkg/cmds/sources/tests/set-from-defaults.yaml:29:  parameterLayers:`
- L4518: `pkg/cmds/sources/tests/set-from-defaults.yaml:30:    - name: "layer1"`
- L4519: `pkg/cmds/sources/tests/set-from-defaults.yaml:35:  parsedLayers:`
- L4520: `pkg/cmds/sources/tests/set-from-defaults.yaml:36:    - name: "layer1"`
- L4521: `pkg/cmds/sources/tests/set-from-defaults.yaml:37:  expectedLayers:`
- L4522: `pkg/cmds/sources/tests/set-from-defaults.yaml:38:    - name: "layer1"`
- L4523: `pkg/cmds/sources/tests/set-from-defaults.yaml:46:- name: "Single layer with objectFromFile type default"`
- L4524: `pkg/cmds/sources/tests/set-from-defaults.yaml:47:  description: "Single layer with default values should result in a single layer with these values"`
- L4525: `pkg/cmds/sources/tests/set-from-defaults.yaml:48:  parameterLayers:`
- L4526: `pkg/cmds/sources/tests/set-from-defaults.yaml:49:    - name: "layer1"`
- L4527: `pkg/cmds/sources/tests/set-from-defaults.yaml:56:  parsedLayers:`
- L4528: `pkg/cmds/sources/tests/set-from-defaults.yaml:57:    - name: "layer1"`
- L4529: `pkg/cmds/sources/tests/set-from-defaults.yaml:58:  expectedLayers:`
- L4530: `pkg/cmds/sources/tests/set-from-defaults.yaml:59:    - name: "layer1"`
- L4531: `pkg/cmds/sources/tests/set-from-defaults.yaml:65:- name: "Single layer with objectListFromFile type default"`
- L4532: `pkg/cmds/sources/tests/set-from-defaults.yaml:66:  description: "Single layer with default values should result in a single layer with these values"`
- L4533: `pkg/cmds/sources/tests/set-from-defaults.yaml:67:  parameterLayers:`
- L4534: `pkg/cmds/sources/tests/set-from-defaults.yaml:68:    - name: "layer1"`
- L4535: `pkg/cmds/sources/tests/set-from-defaults.yaml:77:  parsedLayers:`
- L4536: `pkg/cmds/sources/tests/set-from-defaults.yaml:78:    - name: "layer1"`
- L4537: `pkg/cmds/sources/tests/set-from-defaults.yaml:79:  expectedLayers:`
- L4538: `pkg/cmds/sources/tests/set-from-defaults.yaml:80:    - name: "layer1"`
- L4539: `pkg/cmds/sources/tests/set-from-defaults.yaml:96:- name: "Layer with existing values"`
- L4540: `pkg/cmds/sources/tests/set-from-defaults.yaml:97:  parameterLayers:`
- L4541: `pkg/cmds/sources/tests/set-from-defaults.yaml:98:    - name: "layer1"`
- L4542: `pkg/cmds/sources/tests/set-from-defaults.yaml:106:  parsedLayers:`
- L4543: `pkg/cmds/sources/tests/set-from-defaults.yaml:107:    - name: "layer1"`
- L4544: `pkg/cmds/sources/tests/set-from-defaults.yaml:108:      parameters:`
- L4545: `pkg/cmds/sources/tests/set-from-defaults.yaml:111:  expectedLayers:`
- L4546: `pkg/cmds/sources/tests/set-from-defaults.yaml:112:    - name: "layer1"`
- L4547: `pkg/cmds/sources/tests/set-from-defaults.yaml:118:- name: "Multiple layers with defaults"`
- L4548: `pkg/cmds/sources/tests/set-from-defaults.yaml:119:  description: "Multiple layers with defaults should result in multiple layers with these values"`
- L4549: `pkg/cmds/sources/tests/set-from-defaults.yaml:120:  parameterLayers:`
- L4550: `pkg/cmds/sources/tests/set-from-defaults.yaml:121:    - name: "layer1"`
- L4551: `pkg/cmds/sources/tests/set-from-defaults.yaml:129:    - name: "layer2"`
- L4552: `pkg/cmds/sources/tests/set-from-defaults.yaml:134:  parsedLayers:`
- L4553: `pkg/cmds/sources/tests/set-from-defaults.yaml:135:    - name: "layer1"`
- L4554: `pkg/cmds/sources/tests/set-from-defaults.yaml:136:      parameters: [ ]`
- L4555: `pkg/cmds/sources/tests/set-from-defaults.yaml:137:    - name: "layer2"`
- L4556: `pkg/cmds/sources/tests/set-from-defaults.yaml:138:      parameters: [ ]`
- L4557: `pkg/cmds/sources/tests/set-from-defaults.yaml:139:  expectedLayers:`
- L4558: `pkg/cmds/sources/tests/set-from-defaults.yaml:140:    - name: "layer1"`
- L4559: `pkg/cmds/sources/tests/set-from-defaults.yaml:144:    - name: "layer2"`
- L4560: `pkg/cmds/sources/tests/set-from-defaults.yaml:149:- name: "Multiple layers with defaults (no defined target layers, should be created)"`
- L4561: `pkg/cmds/sources/tests/set-from-defaults.yaml:150:  description: "Multiple layers with defaults should result in multiple layers with these values"`
- L4562: `pkg/cmds/sources/tests/set-from-defaults.yaml:151:  parameterLayers:`
- L4563: `pkg/cmds/sources/tests/set-from-defaults.yaml:152:    - name: "layer1"`
- L4564: `pkg/cmds/sources/tests/set-from-defaults.yaml:160:    - name: "layer2"`
- L4565: `pkg/cmds/sources/tests/set-from-defaults.yaml:165:  parsedLayers: [ ]`
- L4566: `pkg/cmds/sources/tests/set-from-defaults.yaml:166:  expectedLayers:`
- L4567: `pkg/cmds/sources/tests/set-from-defaults.yaml:167:    - name: "layer1"`
- L4568: `pkg/cmds/sources/tests/set-from-defaults.yaml:171:    - name: "layer2"`
- L4569: `pkg/cmds/sources/tests/set-from-defaults.yaml:176:- name: "Layer with no default values"`
- L4570: `pkg/cmds/sources/tests/set-from-defaults.yaml:177:  parameterLayers:`
- L4571: `pkg/cmds/sources/tests/set-from-defaults.yaml:178:    - name: "layer1"`
- L4572: `pkg/cmds/sources/tests/set-from-defaults.yaml:184:  parsedLayers:`
- L4573: `pkg/cmds/sources/tests/set-from-defaults.yaml:185:    - name: "layer1"`
- L4574: `pkg/cmds/sources/tests/set-from-defaults.yaml:186:      parameters: [ ]`
- L4575: `pkg/cmds/sources/tests/set-from-defaults.yaml:187:  expectedLayers:`
- L4576: `pkg/cmds/sources/tests/set-from-defaults.yaml:188:    - name: "layer1"`
- L4577: `pkg/cmds/sources/tests/set-from-defaults.yaml:192:- name: "Layer with partially set values"`
- L4578: `pkg/cmds/sources/tests/set-from-defaults.yaml:193:  parameterLayers:`
- L4579: `pkg/cmds/sources/tests/set-from-defaults.yaml:194:    - name: "layer1"`
- L4580: `pkg/cmds/sources/tests/set-from-defaults.yaml:202:  parsedLayers:`
- L4581: `pkg/cmds/sources/tests/set-from-defaults.yaml:203:    - name: "layer1"`
- L4582: `pkg/cmds/sources/tests/set-from-defaults.yaml:204:      parameters:`
- L4583: `pkg/cmds/sources/tests/set-from-defaults.yaml:207:  expectedLayers:`
- L4584: `pkg/cmds/sources/tests/set-from-defaults.yaml:208:    - name: "layer1"`
- L4585: `pkg/cmds/sources/tests/set-from-defaults.yaml:214:- name: "Layer with invalid default values"`
- L4586: `pkg/cmds/sources/tests/set-from-defaults.yaml:215:  parameterLayers:`
- L4587: `pkg/cmds/sources/tests/set-from-defaults.yaml:216:    - name: "layer1"`
- L4588: `pkg/cmds/sources/tests/set-from-defaults.yaml:221:  expectedLayers: [ ]`
- L4589: `pkg/cmds/sources/tests/set-from-defaults.yaml:224:- name: "Layer with invalid default values"`
- L4590: `pkg/cmds/sources/tests/set-from-defaults.yaml:225:  parameterLayers:`
- L4591: `pkg/cmds/sources/tests/set-from-defaults.yaml:226:    - name: "layer1"`
- L4592: `pkg/cmds/sources/tests/set-from-defaults.yaml:232:  expectedLayers: [ ]`
- L4593: `pkg/cmds/sources/tests/set-from-defaults.yaml:235:- name: "Layer with required parameters without defaults"`
- L4594: `pkg/cmds/sources/tests/set-from-defaults.yaml:236:  parameterLayers:`
- L4595: `pkg/cmds/sources/tests/set-from-defaults.yaml:237:    - name: "layer1"`
- L4596: `pkg/cmds/sources/tests/set-from-defaults.yaml:242:  parsedLayers:`
- L4597: `pkg/cmds/sources/tests/set-from-defaults.yaml:243:    - name: "layer1"`
- L4598: `pkg/cmds/sources/tests/set-from-defaults.yaml:244:      parameters: [ ]`
- L4599: `pkg/cmds/sources/tests/set-from-defaults.yaml:245:  expectedLayers:`
- L4600: `pkg/cmds/sources/tests/set-from-defaults.yaml:246:    - name: "layer1"`
- L4601: `pkg/cmds/sources/tests/set-from-defaults.yaml:250:- name: "Layer with optional parameters without defaults"`
- L4602: `pkg/cmds/sources/tests/set-from-defaults.yaml:251:  parameterLayers:`
- L4603: `pkg/cmds/sources/tests/set-from-defaults.yaml:252:    - name: "layer1"`
- L4604: `pkg/cmds/sources/tests/set-from-defaults.yaml:256:  parsedLayers:`
- L4605: `pkg/cmds/sources/tests/set-from-defaults.yaml:257:    - name: "layer1"`
- L4606: `pkg/cmds/sources/tests/set-from-defaults.yaml:258:      parameters: [ ]`
- L4607: `pkg/cmds/sources/tests/set-from-defaults.yaml:259:  expectedLayers:`
- L4608: `pkg/cmds/sources/tests/set-from-defaults.yaml:260:    - name: "layer1"`
- L4609: `pkg/cmds/schema/cobra_flag_groups.go:18:// It limits us in the sense that we can't just get the full ParameterDefinition`
- L4610: `pkg/cmds/schema/cobra_flag_groups.go:70:// template. Parameters that are not assigned to any group are passed as the "" group, with the`
- L4611: `pkg/cmds/schema/cobra_flag_groups.go:89:// through layers usually.`
- L4612: `pkg/cmds/schema/cobra_flag_groups.go:143:	// (usually through the ParameterDefinition), and add them to the correct`
- L4613: `pkg/cmds/logging/README.md:1:# Clay Logging Layer`
- L4614: `pkg/cmds/logging/README.md:3:This package provides a Glazed parameter layer for configuring logging in Clay applications.`
- L4615: `pkg/cmds/logging/README.md:7:**üìñ For API reference and detailed usage**, see: [Logging Layer API Reference](../../doc/reference/logging-layer.md)`
- L4616: `pkg/cmds/logging/README.md:9:**üéì To learn how to create custom layers**, see: [Custom Layer Tutorial](../../doc/tutorials/custom-layer.md)`
- L4617: `pkg/cmds/logging/README.md:13:The logging layer provides:`
- L4618: `pkg/cmds/logging/README.md:26:if err := logging.SetupLoggingFromParsedLayers(parsedLayers); err != nil {`
- L4619: `pkg/cmds/logging/init.go:128:// Deprecated: Initialize logging from parsed layers using SetupLoggingFromValues instead.`
- L4620: `pkg/cmds/logging/init.go:150:// Flags are added by AddLoggingLayerToRootCommand.`
- L4621: `pkg/settings/glazed_layer.go:22:type GlazedParameterLayers struct {`
- L4622: `pkg/settings/glazed_layer.go:23:	FieldsFiltersParameterLayer *FieldsFiltersParameterLayer `yaml:"fieldsFiltersParameterLayer"``
- L4623: `pkg/settings/glazed_layer.go:24:	OutputParameterLayer        *OutputParameterLayer        `yaml:"outputParameterLayer"``
- L4624: `pkg/settings/glazed_layer.go:25:	RenameParameterLayer        *RenameParameterLayer        `yaml:"renameParameterLayer"``
- L4625: `pkg/settings/glazed_layer.go:26:	ReplaceParameterLayer       *ReplaceParameterLayer       `yaml:"replaceParameterLayer"``
- L4626: `pkg/settings/glazed_layer.go:27:	SelectParameterLayer        *SelectParameterLayer        `yaml:"selectParameterLayer"``
- L4627: `pkg/settings/glazed_layer.go:28:	TemplateParameterLayer      *TemplateParameterLayer      `yaml:"templateParameterLayer"``
- L4628: `pkg/settings/glazed_layer.go:29:	JqParameterLayer            *JqParameterLayer            `yaml:"jqParameterLayer"``
- L4629: `pkg/settings/glazed_layer.go:30:	SortParameterLayer          *SortParameterLayer          `yaml:"sortParameterLayer"``
- L4630: `pkg/settings/glazed_layer.go:31:	SkipLimitParameterLayer     *SkipLimitParameterLayer     `yaml:"skipLimitParameterLayer"``
- L4631: `pkg/settings/glazed_layer.go:36:var _ schema.Section = (*GlazedParameterLayers)(nil)`
- L4632: `pkg/settings/glazed_layer.go:37:var _ schema.CobraSection = (*GlazedParameterLayers)(nil)`
- L4633: `pkg/settings/glazed_layer.go:40:// It wraps NewGlazedParameterLayers for the schema facade package.`
- L4634: `pkg/settings/glazed_layer.go:41:func NewGlazedSchema(options ...GlazeParameterLayerOption) (schema.Section, error) {`
- L4635: `pkg/settings/glazed_layer.go:42:	return NewGlazedParameterLayers(options...)`
- L4636: `pkg/settings/glazed_layer.go:45:func (g *GlazedParameterLayers) Clone() schema.Section {`
- L4637: `pkg/settings/glazed_layer.go:46:	return &GlazedParameterLayers{`
- L4638: `pkg/settings/glazed_layer.go:47:		FieldsFiltersParameterLayer: g.FieldsFiltersParameterLayer.Clone().(*FieldsFiltersParameterLayer),`
- L4639: `pkg/settings/glazed_layer.go:48:		OutputParameterLayer:        g.OutputParameterLayer.Clone().(*OutputParameterLayer),`
- L4640: `pkg/settings/glazed_layer.go:49:		RenameParameterLayer:        g.RenameParameterLayer.Clone().(*RenameParameterLayer),`
- L4641: `pkg/settings/glazed_layer.go:50:		ReplaceParameterLayer:       g.ReplaceParameterLayer.Clone().(*ReplaceParameterLayer),`
- L4642: `pkg/settings/glazed_layer.go:51:		SelectParameterLayer:        g.SelectParameterLayer.Clone().(*SelectParameterLayer),`
- L4643: `pkg/settings/glazed_layer.go:52:		TemplateParameterLayer:      g.TemplateParameterLayer.Clone().(*TemplateParameterLayer),`
- L4644: `pkg/settings/glazed_layer.go:53:		JqParameterLayer:            g.JqParameterLayer.Clone().(*JqParameterLayer),`
- L4645: `pkg/settings/glazed_layer.go:54:		SortParameterLayer:          g.SortParameterLayer.Clone().(*SortParameterLayer),`
- L4646: `pkg/settings/glazed_layer.go:55:		SkipLimitParameterLayer:     g.SkipLimitParameterLayer.Clone().(*SkipLimitParameterLayer),`
- L4647: `pkg/settings/glazed_layer.go:59:func (g *GlazedParameterLayers) MarshalYAML() (interface{}, error) {`
- L4648: `pkg/settings/glazed_layer.go:65:		ChildLayers: []schema.Section{`
- L4649: `pkg/settings/glazed_layer.go:66:			g.FieldsFiltersParameterLayer,`
- L4650: `pkg/settings/glazed_layer.go:67:			g.OutputParameterLayer,`
- L4651: `pkg/settings/glazed_layer.go:68:			g.RenameParameterLayer,`
- L4652: `pkg/settings/glazed_layer.go:69:			g.ReplaceParameterLayer,`
- L4653: `pkg/settings/glazed_layer.go:70:			g.SelectParameterLayer,`
- L4654: `pkg/settings/glazed_layer.go:71:			g.TemplateParameterLayer,`
- L4655: `pkg/settings/glazed_layer.go:72:			g.JqParameterLayer,`
- L4656: `pkg/settings/glazed_layer.go:73:			g.SortParameterLayer,`
- L4657: `pkg/settings/glazed_layer.go:78:func (g *GlazedParameterLayers) GetName() string {`
- L4658: `pkg/settings/glazed_layer.go:82:func (g *GlazedParameterLayers) GetSlug() string {`
- L4659: `pkg/settings/glazed_layer.go:86:func (g *GlazedParameterLayers) GetDescription() string {`
- L4660: `pkg/settings/glazed_layer.go:90:func (g *GlazedParameterLayers) GetPrefix() string {`
- L4661: `pkg/settings/glazed_layer.go:91:	return g.FieldsFiltersParameterLayer.GetPrefix()`
- L4662: `pkg/settings/glazed_layer.go:94:func (g *GlazedParameterLayers) AddFields(...*fields.Definition) {`
- L4663: `pkg/settings/glazed_layer.go:98:func (g *GlazedParameterLayers) GetDefinitions() *fields.Definitions {`
- L4664: `pkg/settings/glazed_layer.go:100:	ret.Merge(g.OutputParameterLayer.GetDefinitions()).`
- L4665: `pkg/settings/glazed_layer.go:101:		Merge(g.FieldsFiltersParameterLayer.GetDefinitions()).`
- L4666: `pkg/settings/glazed_layer.go:102:		Merge(g.SelectParameterLayer.GetDefinitions()).`
- L4667: `pkg/settings/glazed_layer.go:103:		Merge(g.TemplateParameterLayer.GetDefinitions()).`
- L4668: `pkg/settings/glazed_layer.go:104:		Merge(g.RenameParameterLayer.GetDefinitions()).`
- L4669: `pkg/settings/glazed_layer.go:105:		Merge(g.ReplaceParameterLayer.GetDefinitions()).`
- L4670: `pkg/settings/glazed_layer.go:106:		Merge(g.JqParameterLayer.GetDefinitions()).`
- L4671: `pkg/settings/glazed_layer.go:107:		Merge(g.SortParameterLayer.GetDefinitions()).`
- L4672: `pkg/settings/glazed_layer.go:108:		Merge(g.SkipLimitParameterLayer.GetDefinitions())`
- L4673: `pkg/settings/glazed_layer.go:113:func (g *GlazedParameterLayers) AddLayerToCobraCommand(cmd *cobra.Command) error {`
- L4674: `pkg/settings/glazed_layer.go:114:	layers := []schema.CobraSection{`
- L4675: `pkg/settings/glazed_layer.go:115:		g.OutputParameterLayer,`
- L4676: `pkg/settings/glazed_layer.go:116:		g.FieldsFiltersParameterLayer,`
- L4677: `pkg/settings/glazed_layer.go:117:		g.SelectParameterLayer,`
- L4678: `pkg/settings/glazed_layer.go:118:		g.TemplateParameterLayer,`
- L4679: `pkg/settings/glazed_layer.go:119:		g.RenameParameterLayer,`
- L4680: `pkg/settings/glazed_layer.go:120:		g.ReplaceParameterLayer,`
- L4681: `pkg/settings/glazed_layer.go:121:		g.JqParameterLayer,`
- L4682: `pkg/settings/glazed_layer.go:122:		g.SortParameterLayer,`
- L4683: `pkg/settings/glazed_layer.go:123:		g.SkipLimitParameterLayer,`
- L4684: `pkg/settings/glazed_layer.go:126:	for _, layer := range layers {`
- L4685: `pkg/settings/glazed_layer.go:127:		if err := layer.AddLayerToCobraCommand(cmd); err != nil {`
- L4686: `pkg/settings/glazed_layer.go:134:func (g *GlazedParameterLayers) ParseLayerFromCobraCommand(`
- L4687: `pkg/settings/glazed_layer.go:139:		Layer: g,`
- L4688: `pkg/settings/glazed_layer.go:141:	ps := fields.NewParsedParameters()`
- L4689: `pkg/settings/glazed_layer.go:143:	layers := []schema.CobraSection{`
- L4690: `pkg/settings/glazed_layer.go:144:		g.OutputParameterLayer,`
- L4691: `pkg/settings/glazed_layer.go:145:		g.SelectParameterLayer,`
- L4692: `pkg/settings/glazed_layer.go:146:		g.RenameParameterLayer,`
- L4693: `pkg/settings/glazed_layer.go:147:		g.TemplateParameterLayer,`
- L4694: `pkg/settings/glazed_layer.go:148:		g.FieldsFiltersParameterLayer,`
- L4695: `pkg/settings/glazed_layer.go:149:		g.ReplaceParameterLayer,`
- L4696: `pkg/settings/glazed_layer.go:150:		g.JqParameterLayer,`
- L4697: `pkg/settings/glazed_layer.go:151:		g.SortParameterLayer,`
- L4698: `pkg/settings/glazed_layer.go:152:		g.SkipLimitParameterLayer,`
- L4699: `pkg/settings/glazed_layer.go:155:	for _, layer := range layers {`
- L4700: `pkg/settings/glazed_layer.go:156:		l, err := layer.ParseLayerFromCobraCommand(cmd, options...)`
- L4701: `pkg/settings/glazed_layer.go:160:		if _, err = ps.Merge(l.Parameters); err != nil {`
- L4702: `pkg/settings/glazed_layer.go:165:	res.Parameters = ps`
- L4703: `pkg/settings/glazed_layer.go:169:func (g *GlazedParameterLayers) GatherParametersFromMap(`
- L4704: `pkg/settings/glazed_layer.go:172:) (*fields.ParsedParameters, error) {`
- L4705: `pkg/settings/glazed_layer.go:173:	ps := fields.NewParsedParameters()`
- L4706: `pkg/settings/glazed_layer.go:175:	layers := []schema.Section{`
- L4707: `pkg/settings/glazed_layer.go:176:		g.OutputParameterLayer,`
- L4708: `pkg/settings/glazed_layer.go:177:		g.SelectParameterLayer,`
- L4709: `pkg/settings/glazed_layer.go:178:		g.RenameParameterLayer,`
- L4710: `pkg/settings/glazed_layer.go:179:		g.TemplateParameterLayer,`
- L4711: `pkg/settings/glazed_layer.go:180:		g.FieldsFiltersParameterLayer,`
- L4712: `pkg/settings/glazed_layer.go:181:		g.ReplaceParameterLayer,`
- L4713: `pkg/settings/glazed_layer.go:182:		g.JqParameterLayer,`
- L4714: `pkg/settings/glazed_layer.go:183:		g.SortParameterLayer,`
- L4715: `pkg/settings/glazed_layer.go:184:		g.SkipLimitParameterLayer,`
- L4716: `pkg/settings/glazed_layer.go:187:	for _, layer := range layers {`
- L4717: `pkg/settings/glazed_layer.go:188:		ps_, err := layer.GetDefinitions().GatherParametersFromMap(m, onlyProvided, options...)`
- L4718: `pkg/settings/glazed_layer.go:200:func (g *GlazedParameterLayers) InitializeDefaultsFromStruct(s interface{}) error {`
- L4719: `pkg/settings/glazed_layer.go:201:	layers := []schema.Section{`
- L4720: `pkg/settings/glazed_layer.go:202:		g.OutputParameterLayer,`
- L4721: `pkg/settings/glazed_layer.go:203:		g.FieldsFiltersParameterLayer,`
- L4722: `pkg/settings/glazed_layer.go:204:		g.SelectParameterLayer,`
- L4723: `pkg/settings/glazed_layer.go:205:		g.TemplateParameterLayer,`
- L4724: `pkg/settings/glazed_layer.go:206:		g.RenameParameterLayer,`
- L4725: `pkg/settings/glazed_layer.go:207:		g.ReplaceParameterLayer,`
- L4726: `pkg/settings/glazed_layer.go:208:		g.JqParameterLayer,`
- L4727: `pkg/settings/glazed_layer.go:209:		g.SortParameterLayer,`
- L4728: `pkg/settings/glazed_layer.go:210:		g.SkipLimitParameterLayer,`
- L4729: `pkg/settings/glazed_layer.go:213:	for _, layer := range layers {`
- L4730: `pkg/settings/glazed_layer.go:214:		if err := layer.InitializeDefaultsFromStruct(s); err != nil {`
- L4731: `pkg/settings/glazed_layer.go:221:type GlazeParameterLayerOption func(*GlazedParameterLayers) error`
- L4732: `pkg/settings/glazed_layer.go:223:func WithOutputParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4733: `pkg/settings/glazed_layer.go:224:	return func(g *GlazedParameterLayers) error {`
- L4734: `pkg/settings/glazed_layer.go:226:			err := option(g.OutputParameterLayer.SectionImpl)`
- L4735: `pkg/settings/glazed_layer.go:235:func WithSelectParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4736: `pkg/settings/glazed_layer.go:236:	return func(g *GlazedParameterLayers) error {`
- L4737: `pkg/settings/glazed_layer.go:238:			err := option(g.SelectParameterLayer.SectionImpl)`
- L4738: `pkg/settings/glazed_layer.go:247:func WithTemplateParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4739: `pkg/settings/glazed_layer.go:248:	return func(g *GlazedParameterLayers) error {`
- L4740: `pkg/settings/glazed_layer.go:250:			err := option(g.TemplateParameterLayer.SectionImpl)`
- L4741: `pkg/settings/glazed_layer.go:259:func WithRenameParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4742: `pkg/settings/glazed_layer.go:260:	return func(g *GlazedParameterLayers) error {`
- L4743: `pkg/settings/glazed_layer.go:262:			err := option(g.RenameParameterLayer.SectionImpl)`
- L4744: `pkg/settings/glazed_layer.go:271:func WithReplaceParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4745: `pkg/settings/glazed_layer.go:272:	return func(g *GlazedParameterLayers) error {`
- L4746: `pkg/settings/glazed_layer.go:274:			err := option(g.ReplaceParameterLayer.SectionImpl)`
- L4747: `pkg/settings/glazed_layer.go:283:func WithFieldsFiltersParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4748: `pkg/settings/glazed_layer.go:284:	return func(g *GlazedParameterLayers) error {`
- L4749: `pkg/settings/glazed_layer.go:286:			err := option(g.FieldsFiltersParameterLayer.SectionImpl)`
- L4750: `pkg/settings/glazed_layer.go:295:func WithJqParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4751: `pkg/settings/glazed_layer.go:296:	return func(g *GlazedParameterLayers) error {`
- L4752: `pkg/settings/glazed_layer.go:298:			err := option(g.JqParameterLayer.SectionImpl)`
- L4753: `pkg/settings/glazed_layer.go:307:func WithSortParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4754: `pkg/settings/glazed_layer.go:308:	return func(g *GlazedParameterLayers) error {`
- L4755: `pkg/settings/glazed_layer.go:310:			err := option(g.SortParameterLayer.SectionImpl)`
- L4756: `pkg/settings/glazed_layer.go:319:func WithSkipLimitParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L4757: `pkg/settings/glazed_layer.go:320:	return func(g *GlazedParameterLayers) error {`
- L4758: `pkg/settings/glazed_layer.go:322:			err := option(g.SkipLimitParameterLayer.SectionImpl)`
- L4759: `pkg/settings/glazed_layer.go:331:func NewGlazedParameterLayers(options ...GlazeParameterLayerOption) (*GlazedParameterLayers, error) {`
- L4760: `pkg/settings/glazed_layer.go:332:	fieldsFiltersParameterLayer, err := NewFieldsFiltersParameterLayer()`
- L4761: `pkg/settings/glazed_layer.go:336:	outputParameterLayer, err := NewOutputParameterLayer()`
- L4762: `pkg/settings/glazed_layer.go:340:	renameParameterLayer, err := NewRenameParameterLayer()`
- L4763: `pkg/settings/glazed_layer.go:344:	replaceParameterLayer, err := NewReplaceParameterLayer()`
- L4764: `pkg/settings/glazed_layer.go:348:	selectParameterLayer, err := NewSelectParameterLayer()`
- L4765: `pkg/settings/glazed_layer.go:352:	templateParameterLayer, err := NewTemplateParameterLayer()`
- L4766: `pkg/settings/glazed_layer.go:356:	jqParameterLayer, err := NewJqParameterLayer()`
- L4767: `pkg/settings/glazed_layer.go:360:	sortParameterLayer, err := NewSortParameterLayer()`
- L4768: `pkg/settings/glazed_layer.go:364:	skipLimitParameterLayer, err := NewSkipLimitParameterLayer()`
- L4769: `pkg/settings/glazed_layer.go:368:	ret := &GlazedParameterLayers{`
- L4770: `pkg/settings/glazed_layer.go:369:		FieldsFiltersParameterLayer: fieldsFiltersParameterLayer,`
- L4771: `pkg/settings/glazed_layer.go:370:		OutputParameterLayer:        outputParameterLayer,`
- L4772: `pkg/settings/glazed_layer.go:371:		RenameParameterLayer:        renameParameterLayer,`
- L4773: `pkg/settings/glazed_layer.go:372:		ReplaceParameterLayer:       replaceParameterLayer,`
- L4774: `pkg/settings/glazed_layer.go:373:		SelectParameterLayer:        selectParameterLayer,`
- L4775: `pkg/settings/glazed_layer.go:374:		TemplateParameterLayer:      templateParameterLayer,`
- L4776: `pkg/settings/glazed_layer.go:375:		JqParameterLayer:            jqParameterLayer,`
- L4777: `pkg/settings/glazed_layer.go:376:		SortParameterLayer:          sortParameterLayer,`
- L4778: `pkg/settings/glazed_layer.go:377:		SkipLimitParameterLayer:     skipLimitParameterLayer,`
- L4779: `pkg/settings/glazed_layer.go:390:func SetupRowOutputFormatter(glazedLayer *values.SectionValues) (formatters.RowOutputFormatter, error) {`
- L4780: `pkg/settings/glazed_layer.go:391:	outputSettings, err := NewOutputFormatterSettings(glazedLayer)`
- L4781: `pkg/settings/glazed_layer.go:404:func SetupTableOutputFormatter(glazedLayer *values.SectionValues) (formatters.TableOutputFormatter, error) {`
- L4782: `pkg/settings/glazed_layer.go:405:	selectSettings, err := NewSelectSettingsFromParameters(glazedLayer)`
- L4783: `pkg/settings/glazed_layer.go:410:	outputSettings, err := NewOutputFormatterSettings(glazedLayer)`
- L4784: `pkg/settings/glazed_layer.go:447:// DO(manuel, 2023-06-30) It would be good to used a parsedLayer here, if we ever refactor that part`
- L4785: `pkg/settings/glazed_layer.go:449:	glazedLayer *values.SectionValues,`
- L4786: `pkg/settings/glazed_layer.go:455:	templateSettings, err := NewTemplateSettings(glazedLayer)`
- L4787: `pkg/settings/glazed_layer.go:459:	selectSettings, err := NewSelectSettingsFromParameters(glazedLayer)`
- L4788: `pkg/settings/glazed_layer.go:463:	renameSettings, err := NewRenameSettingsFromParameters(glazedLayer)`
- L4789: `pkg/settings/glazed_layer.go:467:	fieldsFilterSettings, err := NewFieldsFilterSettings(glazedLayer)`
- L4790: `pkg/settings/glazed_layer.go:471:	replaceSettings, err := NewReplaceSettingsFromParameters(glazedLayer)`
- L4791: `pkg/settings/glazed_layer.go:475:	jqSettings, err := NewJqSettingsFromParameters(glazedLayer)`
- L4792: `pkg/settings/glazed_layer.go:479:	sortSettings, err := NewSortSettingsFromParameters(glazedLayer)`
- L4793: `pkg/settings/glazed_layer.go:483:	outputSettings, err := NewOutputFormatterSettings(glazedLayer)`
- L4794: `pkg/settings/glazed_layer.go:487:	skipLimitSettings, err := NewSkipLimitSettingsFromParameters(glazedLayer)`
- L4795: `pkg/settings/glazed_layer.go:545:	// to the API that we currently use (which is a unordered hashmap, and parsed layers that lose the positioning)`
- L4796: `pkg/settings/glazed_layer.go:569:	glazedLayer *values.SectionValues,`
- L4797: `pkg/settings/glazed_layer.go:573:	rowOf, err := SetupRowOutputFormatter(glazedLayer)`
- L4798: `pkg/settings/glazed_layer.go:587:		of, err := SetupTableOutputFormatter(glazedLayer)`
- L4799: `pkg/cmds/logging/init-logging.go:30:// Deprecated: Use Glazed config middlewares (LoadParametersFromFiles + UpdateFromEnv) and InitGlazed/InitLoggerFromCobra.`
- L4800: `pkg/cmds/logging/init-early.go:77:// Defaults match AddLoggingLayerToRootCommand in layer.go.`
- L4801: `pkg/cmds/logging/init-early.go:92:	// Defaults must match glazed/pkg/cmds/logging/layer.go:AddLoggingLayerToRootCommand`
- L4802: `pkg/cmds/logging/layer.go:13:// LoggingSettings holds the logging configuration parameters`
- L4803: `pkg/cmds/logging/layer.go:28:const LoggingLayerSlug = "logging"`
- L4804: `pkg/cmds/logging/layer.go:30:// NewLoggingLayer creates a new parameter layer for logging configuration`
- L4805: `pkg/cmds/logging/layer.go:31:func NewLoggingLayer() (schema.Section, error) {`
- L4806: `pkg/cmds/logging/layer.go:33:		LoggingLayerSlug,`
- L4807: `pkg/cmds/logging/layer.go:110:// AddLoggingLayerToCommand adds the logging layer to a Glazed command`
- L4808: `pkg/cmds/logging/layer.go:111:func AddLoggingLayerToCommand(cmd cmds.Command) (cmds.Command, error) {`
- L4809: `pkg/cmds/logging/layer.go:112:	loggingLayer, err := NewLoggingLayer()`
- L4810: `pkg/cmds/logging/layer.go:117:	cmd.Description().Layers.Set(LoggingLayerSlug, loggingLayer)`
- L4811: `pkg/cmds/logging/layer.go:122:func AddLoggingLayerToRootCommand(rootCmd *cobra.Command, appName string) error {`
- L4812: `pkg/cmds/logging/layer.go:123:	loggingLayer, err := NewLoggingLayer()`
- L4813: `pkg/cmds/logging/layer.go:127:	_ = loggingLayer`
- L4814: `pkg/cmds/logging/layer.go:129:	// XXX this would be the proper way to do it if we could easily add parameter definitions as persistent flags. For now, do it manually.`
- L4815: `pkg/cmds/logging/layer.go:132:	// loggingLayer.GetDefinitions().ForEachE(func(definition *fields.Definition) error {`
- L4816: `pkg/cmds/logging/layer.go:154:// SetupLoggingFromValues configures global logger from command-line parameters`
- L4817: `pkg/cmds/logging/layer.go:155:func SetupLoggingFromValues(parsedLayers *values.Values) error {`
- L4818: `pkg/cmds/logging/layer.go:156:	settings, err := GetLoggingSettings(parsedLayers)`
- L4819: `pkg/cmds/logging/layer.go:164:func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {`
- L4820: `pkg/cmds/logging/layer.go:166:	err := parsedLayers.InitializeStruct(LoggingLayerSlug, &settings)`
- L4821: `pkg/cmds/runner/run.go:39:// RunCommand executes a Glazed command with the given parsed parameters and options`
- L4822: `pkg/cmds/runner/run.go:43:	parsedLayers *values.Values,`
- L4823: `pkg/cmds/runner/run.go:59:		return c.Run(ctx, parsedLayers)`
- L4824: `pkg/cmds/runner/run.go:62:		return c.RunIntoWriter(ctx, parsedLayers, opts.Writer)`
- L4825: `pkg/cmds/runner/run.go:67:			glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L4826: `pkg/cmds/runner/run.go:69:				return fmt.Errorf("glazed layer not found")`
- L4827: `pkg/cmds/runner/run.go:71:			gp, err := settings.SetupTableProcessor(glazedLayer)`
- L4828: `pkg/cmds/runner/run.go:75:			_, err = settings.SetupProcessorOutput(gp, glazedLayer, opts.Writer)`
- L4829: `pkg/cmds/runner/run.go:82:		err := c.RunIntoGlazeProcessor(ctx, parsedLayers, opts.GlazeProcessor)`
- L4830: `pkg/cmds/runner/run.go:94:// ParseOptions contains configuration for parameter parsing`
- L4831: `pkg/cmds/runner/run.go:96:	ValuesForLayers       map[string]map[string]interface{}`
- L4832: `pkg/cmds/runner/run.go:106:// WithValuesForLayers sets values for parameters in specified layers`
- L4833: `pkg/cmds/runner/run.go:107:func WithValuesForLayers(values map[string]map[string]interface{}) ParseOption {`
- L4834: `pkg/cmds/runner/run.go:109:		o.ValuesForLayers = values`
- L4835: `pkg/cmds/runner/run.go:127:// WithViper enables loading parameters from Viper configuration`
- L4836: `pkg/cmds/runner/run.go:149:// ParseCommandParameters parses parameters for a command using a configurable middleware chain`
- L4837: `pkg/cmds/runner/run.go:150:func ParseCommandParameters(`
- L4838: `pkg/cmds/runner/run.go:187:	// Add values for layers middleware if provided`
- L4839: `pkg/cmds/runner/run.go:188:	if opts.ValuesForLayers != nil {`
- L4840: `pkg/cmds/runner/run.go:190:			cmd_sources.FromMap(opts.ValuesForLayers,`
- L4841: `pkg/cmds/runner/run.go:203:	// Create parsed layers and execute middleware chain`
- L4842: `pkg/cmds/runner/run.go:204:	parsedLayers := values.New()`
- L4843: `pkg/cmds/runner/run.go:206:		cmd.Description().Layers,`
- L4844: `pkg/cmds/runner/run.go:207:		parsedLayers,`
- L4845: `pkg/cmds/runner/run.go:211:		return nil, fmt.Errorf("failed to parse parameters: %w", err)`
- L4846: `pkg/cmds/runner/run.go:214:	return parsedLayers, nil`
- L4847: `pkg/cmds/runner/run.go:217:// ParseAndRun combines parameter parsing and command execution into a single function`
- L4848: `pkg/cmds/runner/run.go:224:	parsedLayers, err := ParseCommandParameters(cmd, parseOptions...)`
- L4849: `pkg/cmds/runner/run.go:229:	return RunCommand(ctx, cmd, parsedLayers, runOptions...)`
- L4850: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:14:func buildTestLayers(t *testing.T, defs ...*fields.Definition) *schema.Schema {`
- L4851: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:20:		t.Fatalf("failed to create layer: %v", err)`
- L4852: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:29:    target_layer: "demo"`
- L4853: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:32:        target_parameter: "api-key"`
- L4854: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:34:        target_parameter: "threshold"`
- L4855: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:44:	if rules[0].Source != "app.settings" || rules[0].TargetLayer != "demo" {`
- L4856: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:55:  target_layer: "demo"`
- L4857: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:56:  target_parameter: "api-key"`
- L4858: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:58:  target_layer: "demo"`
- L4859: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:59:  target_parameter: "threshold"`
- L4860: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:76:    target_layer: "demo"`
- L4861: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:79:        target_parameter: "{env}-api-key"`
- L4862: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:87:	// Layers with expected params`
- L4863: `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go:92:	pls := buildTestLayers(t, defs...)`
- L4864: `pkg/cmds/values/serialize_parsed.go:24:	Parameters *fields.SerializableParsedParameters `yaml:"parameters" json:"parameters"``
- L4865: `pkg/cmds/values/serialize_parsed.go:30:	if pl.Layer != nil {`
- L4866: `pkg/cmds/values/serialize_parsed.go:32:			Name:        pl.Layer.GetName(),`
- L4867: `pkg/cmds/values/serialize_parsed.go:33:			Slug:        pl.Layer.GetSlug(),`
- L4868: `pkg/cmds/values/serialize_parsed.go:34:			Description: pl.Layer.GetDescription(),`
- L4869: `pkg/cmds/values/serialize_parsed.go:35:			Prefix:      pl.Layer.GetPrefix(),`
- L4870: `pkg/cmds/values/serialize_parsed.go:36:			Fields:      pl.Layer.GetDefinitions(),`
- L4871: `pkg/cmds/values/serialize_parsed.go:41:		Parameters: fields.ToSerializableParsedParameters(pl.Parameters),`
- L4872: `pkg/cmds/values/serialize_parsed.go:49:	Layers *orderedmap.OrderedMap[string, *SerializableSectionValues] `yaml:"layers" json:"layers"``
- L4873: `pkg/cmds/values/serialize_parsed.go:55:		Layers: orderedmap.New[string, *SerializableSectionValues](),`
- L4874: `pkg/cmds/values/serialize_parsed.go:60:		ret.Layers.Set(key, serialized)`
- L4875: `pkg/cmds/values/serialize_parsed.go:70:	for pair := spl.Layers.Oldest(); pair != nil; pair = pair.Next() {`
- L4876: `pkg/cmds/values/serialize_parsed.go:80:	for pair := spl.Layers.Oldest(); pair != nil; pair = pair.Next() {`
- L4877: `pkg/cmds/values/test_helpers_test.go:38:func createParameterLayer(t *testing.T, slug, name string, paramDefs ...*fields.Definition) Section {`
- L4878: `pkg/cmds/values/test_helpers_test.go:52:func createSectionValues(t *testing.T, layer Section, parsedValues map[string]interface{}) *SectionValues {`
- L4879: `pkg/cmds/values/test_helpers_test.go:53:	sectionValues, err := NewSectionValues(layer)`
- L4880: `pkg/cmds/values/test_helpers_test.go:60:		definition, ok := layer.GetDefinitions().Get(key)`
- L4881: `pkg/cmds/values/test_helpers_test.go:62:		parsed := &fields.ParsedParameter{Definition: definition}`
- L4882: `pkg/cmds/values/test_helpers_test.go:65:		sectionValues.Parameters.Set(key, parsed)`
- L4883: `pkg/cmds/cobra_test.go:22:	err := definitions.AddParametersToCobraCommand(cmd, "")`
- L4884: `pkg/cmds/cobra_test.go:30:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4885: `pkg/cmds/cobra_test.go:40:		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),`
- L4886: `pkg/cmds/cobra_test.go:42:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4887: `pkg/cmds/cobra_test.go:66:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4888: `pkg/cmds/cobra_test.go:81:	desc := NewCommandDescription("test", WithLayersList(defaultLayer))`
- L4889: `pkg/cmds/cobra_test.go:82:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4890: `pkg/cmds/cobra_test.go:113:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4891: `pkg/cmds/cobra_test.go:129:		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),`
- L4892: `pkg/cmds/cobra_test.go:131:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4893: `pkg/cmds/cobra_test.go:168:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4894: `pkg/cmds/cobra_test.go:178:	desc := NewCommandDescription("test", WithLayersList(defaultLayer))`
- L4895: `pkg/cmds/cobra_test.go:179:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4896: `pkg/cmds/cobra_test.go:204:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4897: `pkg/cmds/cobra_test.go:215:		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),`
- L4898: `pkg/cmds/cobra_test.go:217:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4899: `pkg/cmds/cobra_test.go:262:		defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4900: `pkg/cmds/cobra_test.go:272:		err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4901: `pkg/cmds/cobra_test.go:282:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4902: `pkg/cmds/cobra_test.go:293:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4903: `pkg/cmds/cobra_test.go:304:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4904: `pkg/cmds/cobra_test.go:316:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4905: `pkg/cmds/cobra_test.go:322:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4906: `pkg/cmds/cobra_test.go:332:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4907: `pkg/cmds/cobra_test.go:343:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4908: `pkg/cmds/cobra_test.go:353:	desc := NewCommandDescription("test", WithLayersList(defaultLayer))`
- L4909: `pkg/cmds/cobra_test.go:354:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4910: `pkg/cmds/cobra_test.go:383:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4911: `pkg/cmds/cobra_test.go:395:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4912: `pkg/cmds/cobra_test.go:401:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4913: `pkg/cmds/cobra_test.go:411:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4914: `pkg/cmds/cobra_test.go:422:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4915: `pkg/cmds/cobra_test.go:436:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4916: `pkg/cmds/cobra_test.go:447:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4917: `pkg/cmds/cobra_test.go:461:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4918: `pkg/cmds/cobra_test.go:471:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4919: `pkg/cmds/cobra_test.go:486:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4920: `pkg/cmds/cobra_test.go:497:	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4921: `pkg/cmds/cobra_test.go:510:	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L4922: `pkg/cmds/cobra_test.go:515:// which is a list of parsed flag parameters, a list of parsed arguments parameters,`
- L4923: `pkg/cmds/cobra_test.go:521:	ExpectedArgumentParameters map[string]interface{} `yaml:"argumentParameters"``
- L4924: `pkg/cmds/cobra_test.go:522:	ExpectedFlagParameters     map[string]interface{} `yaml:"flagParameters"``
- L4925: `pkg/cmds/cobra_test.go:556:		layer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L4926: `pkg/cmds/cobra_test.go:561:		testSuite.Description.Layers = schema.NewSchema(schema.WithSections(layer))`
- L4927: `pkg/cmds/cobra_test.go:570:			if test2.ExpectedArgumentParameters == nil {`
- L4928: `pkg/cmds/cobra_test.go:571:				test2.ExpectedArgumentParameters = map[string]interface{}{}`
- L4929: `pkg/cmds/cobra_test.go:573:			if test2.ExpectedFlagParameters == nil {`
- L4930: `pkg/cmds/cobra_test.go:574:				test2.ExpectedFlagParameters = map[string]interface{}{}`
- L4931: `pkg/cmds/cobra_test.go:593:	var flagParameters *fields.ParsedParameters`
- L4932: `pkg/cmds/cobra_test.go:594:	var argumentParameters *fields.ParsedParameters`
- L4933: `pkg/cmds/cobra_test.go:598:			flagParameters, flagsError = desc.GetDefaultFlags().GatherFlagsFromCobraCommand(cmd, false, false, "")`
- L4934: `pkg/cmds/cobra_test.go:602:			argumentParameters, argsError = desc.GetDefaultArguments().GatherArguments(args, false, false)`
- L4935: `pkg/cmds/cobra_test.go:609:	defaultLayer, ok := desc.GetDefaultLayer()`
- L4936: `pkg/cmds/cobra_test.go:611:	defaultLayer_, ok := defaultLayer.(schema.CobraSection)`
- L4937: `pkg/cmds/cobra_test.go:614:	err := defaultLayer_.AddLayerToCobraCommand(cmd)`
- L4938: `pkg/cmds/cobra_test.go:646:	assertJsonEquivalent(t, expected.ExpectedArgumentParameters, argumentParameters)`
- L4939: `pkg/cmds/cobra_test.go:647:	assertJsonEquivalent(t, expected.ExpectedFlagParameters, flagParameters)`
- L4940: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:2:  description: "Verify that calling UpdateFromMapAsDefault with an empty map does not alter parsedParameters."`
- L4941: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:3:  parameterLayers:`
- L4942: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:4:    - name: "layer1"`
- L4943: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:15:  parsedLayers:`
- L4944: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:16:    - name: "layer1"`
- L4945: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:17:      parameters:`
- L4946: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:25:  expectedLayers:`
- L4947: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:26:    - name: "layer1"`
- L4948: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:33:- name: "Test with non-empty input maps but empty parsedParameters"`
- L4949: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:34:  description: "Ensure that all default values from the input map are set in parsedParameters."`
- L4950: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:35:  parameterLayers:`
- L4951: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:36:    - name: "layer1"`
- L4952: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:44:  parsedLayers: []`
- L4953: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:46:    layer1:`
- L4954: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:49:  expectedLayers:`
- L4955: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:50:    - name: "layer1"`
- L4956: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:56:- name: "Test with existing values in parsedParameters"`
- L4957: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:57:  description: "Confirm that existing values in parsedParameters are not overwritten by the defaults in the input map."`
- L4958: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:58:  parameterLayers:`
- L4959: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:59:    - name: "layer1"`
- L4960: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:67:  parsedLayers:`
- L4961: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:68:    - name: "layer1"`
- L4962: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:69:      parameters:`
- L4963: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:73:    layer1:`
- L4964: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:76:  expectedLayers:`
- L4965: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:77:    - name: "layer1"`
- L4966: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:84:  description: "Check that only the non-existing keys in parsedParameters are updated with the default values from the input map."`
- L4967: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:85:  parameterLayers:`
- L4968: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:86:    - name: "layer1"`
- L4969: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:94:  parsedLayers:`
- L4970: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:95:    - name: "layer1"`
- L4971: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:96:      parameters:`
- L4972: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:100:    layer1:`
- L4973: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:102:  expectedLayers:`
- L4974: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:103:    - name: "layer1"`
- L4975: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:110:  description: "Ensure that none of the values in parsedParameters are changed when the input map contains all the same keys but with different values."`
- L4976: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:111:  parameterLayers:`
- L4977: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:112:    - name: "layer1"`
- L4978: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:120:  parsedLayers:`
- L4979: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:121:    - name: "layer1"`
- L4980: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:122:      parameters:`
- L4981: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:128:    layer1:`
- L4982: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:131:  expectedLayers:`
- L4983: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:132:    - name: "layer1"`
- L4984: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:139:  description: "Attempt to update parsedParameters with defaults of incorrect types and verify that it results in an error."`
- L4985: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:140:  parameterLayers:`
- L4986: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:141:    - name: "layer1"`
- L4987: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:149:  parsedLayers:`
- L4988: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:150:    - name: "layer1"`
- L4989: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:151:      parameters: []`
- L4990: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:153:    layer1:`
- L4991: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:156:  expectedLayers: []`
- L4992: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:159:- name: "Test with ParameterLayer not present in layers_"`
- L4993: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:160:  description: "Confirm that the middleware skips any layers not present in layers_ and does not throw an error."`
- L4994: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:161:  parameterLayers:`
- L4995: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:162:    - name: "layer1"`
- L4996: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:167:  parsedLayers: []`
- L4997: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:169:    layer2:  # This layer is not defined in parameterLayers`
- L4998: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:171:  expectedLayers: []`
- L4999: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:174:- name: "Test with ParameterDefinition choices"`
- L5000: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:175:  description: "When a parameter has specific choices, verify that defaults not in the choices do not get set and result in an error."`
- L5001: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:176:  parameterLayers:`
- L5002: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:177:    - name: "layer1"`
- L5003: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:183:  parsedLayers:`
- L5004: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:184:    - name: "layer1"`
- L5005: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:185:      parameters: []`
- L5006: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:187:    layer1:`
- L5007: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:189:  expectedLayers: []`
- L5008: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:192:- name: "Test with multiple layers"`
- L5009: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:193:  description: "Verify that the middleware correctly updates defaults across multiple layers without affecting already set parameters in any layer."`
- L5010: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:194:  parameterLayers:`
- L5011: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:195:    - name: "layer1"`
- L5012: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:200:    - name: "layer2"`
- L5013: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:205:  parsedLayers:`
- L5014: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:206:    - name: "layer1"`
- L5015: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:207:      parameters:`
- L5016: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:210:    - name: "layer2"`
- L5017: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:211:      parameters: []`
- L5018: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:213:    layer1:`
- L5019: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:215:    layer2:`
- L5020: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:217:  expectedLayers:`
- L5021: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:218:    - name: "layer1"`
- L5022: `pkg/cmds/sources/tests/update-from-map-as-default.yaml:221:    - name: "layer2"`
- L5023: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:13:// createTestLayers creates a test parameter layer structure`
- L5024: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:14:func createTestLayers(t *testing.T) *schema.Schema {`
- L5025: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:15:	demoLayer, err := schema.NewSection(`
- L5026: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:17:		"Demo Layer",`
- L5027: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:32:		schema.WithSections(demoLayer),`
- L5028: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:48:					TargetLayer:     "demo",`
- L5029: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:49:					TargetParameter: "api-key",`
- L5030: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:59:					TargetLayer:     "demo",`
- L5031: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:60:					TargetParameter: "{env}-api-key",`
- L5032: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:70:					TargetLayer:     "demo",`
- L5033: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:71:					TargetParameter: "api-key",`
- L5034: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:81:					TargetLayer:     "demo",`
- L5035: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:82:					TargetParameter: "api-key",`
- L5036: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:93:					TargetLayer:     "demo",`
- L5037: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:94:					TargetParameter: "api-key",`
- L5038: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:105:					TargetLayer:     "demo",`
- L5039: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:106:					TargetParameter: "api-key",`
- L5040: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:117:					TargetLayer:     "demo",`
- L5041: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:118:					TargetParameter: "api-key",`
- L5042: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:129:					TargetLayer:     "demo",`
- L5043: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:130:					TargetParameter: "{env}-api-key",`
- L5044: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:134:			errorMsg:    "capture reference {env} in target parameter not found in source pattern",`
- L5045: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:137:			name: "invalid target layer - does not exist",`
- L5046: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:141:					TargetLayer:     "nonexistent",`
- L5047: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:142:					TargetParameter: "api-key",`
- L5048: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:146:			errorMsg:    "target layer \"nonexistent\" does not exist",`
- L5049: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:153:					TargetLayer: "demo",`
- L5050: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:155:						{Source: "api_key", TargetParameter: "api-key"},`
- L5051: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:156:						{Source: "threshold", TargetParameter: "threshold"},`
- L5052: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:167:					TargetLayer: "demo",`
- L5053: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:169:						{Source: "api_key", TargetParameter: "{env}-api-key"},`
- L5054: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:176:			name: "invalid static target parameter at compile time",`
- L5055: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:180:					TargetLayer:     "demo",`
- L5056: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:181:					TargetParameter: "nonexistent", // Should fail at compile time`
- L5057: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:185:			errorMsg:    "target parameter \"nonexistent\" does not exist in layer \"demo\"",`
- L5058: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:191:			layers_ := createTestLayers(t)`
- L5059: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:192:			_, err := pm.NewConfigMapper(layers_, tt.rules...)`
- L5060: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:219:					TargetLayer:     "demo",`
- L5061: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:220:					TargetParameter: "api-key",`
- L5062: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:242:					TargetLayer:     "demo",`
- L5063: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:243:					TargetParameter: "api-key",`
- L5064: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:247:					TargetLayer:     "demo",`
- L5065: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:248:					TargetParameter: "threshold",`
- L5066: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:272:					TargetLayer:     "demo",`
- L5067: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:273:					TargetParameter: "{env}-api-key",`
- L5068: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:299:					TargetLayer:     "demo",`
- L5069: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:300:					TargetParameter: "api-key",`
- L5070: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:325:					TargetLayer: "demo",`
- L5071: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:327:						{Source: "api_key", TargetParameter: "api-key"},`
- L5072: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:328:						{Source: "threshold", TargetParameter: "threshold"},`
- L5073: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:353:					TargetLayer: "demo",`
- L5074: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:355:						{Source: "api_key", TargetParameter: "{env}-api-key"},`
- L5075: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:356:						{Source: "threshold", TargetParameter: "{env}-threshold"},`
- L5076: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:391:					TargetLayer:     "demo",`
- L5077: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:392:					TargetParameter: "api-key",`
- L5078: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:411:					TargetLayer:     "demo",`
- L5079: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:412:					TargetParameter: "api-key",`
- L5080: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:430:			testLayers := createTestLayers(t)`
- L5081: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:431:			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L5082: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:609:func TestResolveTargetParameter(t *testing.T) {`
- L5083: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:660:			result, err := pm.ResolveTargetParameter(tt.target, tt.captures)`
- L5084: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:672:func TestIntegrationWithLoadParametersFromFile(t *testing.T) {`
- L5085: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:674:	testLayers := createTestLayers(t)`
- L5086: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:677:	mapper, err := pm.NewConfigMapper(testLayers, pm.MappingRule{`
- L5087: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:679:		TargetLayer:     "demo",`
- L5088: `pkg/cmds/sources/patternmapper/pattern_mapper_test.go:680:		TargetParameter: "api-key",`
- L5089: `pkg/cmds/sources/tests/middlewares.yaml:1:- name: "Empty middlewares and parsedLayers"`
- L5090: `pkg/cmds/sources/tests/middlewares.yaml:2:  description: "Empty middlewares should result in empty parsed layers"`
- L5091: `pkg/cmds/sources/tests/middlewares.yaml:3:  parameterLayers: [ ]`
- L5092: `pkg/cmds/sources/tests/middlewares.yaml:4:  parsedLayers: [ ]`
- L5093: `pkg/cmds/sources/tests/middlewares.yaml:5:  expectedLayers: [ ]`
- L5094: `pkg/cmds/sources/tests/middlewares.yaml:9:- name: "Empty parsedLayers, set from defaults"`
- L5095: `pkg/cmds/sources/tests/middlewares.yaml:10:  description: "Only set from defaults middlewares, with empty parsed layers"`
- L5096: `pkg/cmds/sources/tests/middlewares.yaml:11:  parameterLayers: [ ]`
- L5097: `pkg/cmds/sources/tests/middlewares.yaml:12:  parsedLayers: [ ]`
- L5098: `pkg/cmds/sources/tests/middlewares.yaml:13:  expectedLayers: [ ]`
- L5099: `pkg/cmds/sources/tests/middlewares.yaml:21:- name: "Single parameter, set from defaults"`
- L5100: `pkg/cmds/sources/tests/middlewares.yaml:22:  description: "Only set from defaults middlewares, with single parameter"`
- L5101: `pkg/cmds/sources/tests/middlewares.yaml:23:  parameterLayers:`
- L5102: `pkg/cmds/sources/tests/middlewares.yaml:24:    - name: "layer1"`
- L5103: `pkg/cmds/sources/tests/middlewares.yaml:29:  parsedLayers: [ ]`
- L5104: `pkg/cmds/sources/tests/middlewares.yaml:30:  expectedLayers:`
- L5105: `pkg/cmds/sources/tests/middlewares.yaml:31:    - name: "layer1"`
- L5106: `pkg/cmds/sources/tests/middlewares.yaml:45:- name: "Single parameter, set from defaults and then update from map"`
- L5107: `pkg/cmds/sources/tests/middlewares.yaml:46:  description: "Set from defaults then map middlewares, with single parameter"`
- L5108: `pkg/cmds/sources/tests/middlewares.yaml:47:  parameterLayers:`
- L5109: `pkg/cmds/sources/tests/middlewares.yaml:48:    - name: "layer1"`
- L5110: `pkg/cmds/sources/tests/middlewares.yaml:53:  parsedLayers: [ ]`
- L5111: `pkg/cmds/sources/tests/middlewares.yaml:54:  expectedLayers:`
- L5112: `pkg/cmds/sources/tests/middlewares.yaml:55:    - name: "layer1"`
- L5113: `pkg/cmds/sources/tests/middlewares.yaml:73:        layer1:`
- L5114: `pkg/cmds/values/parsed-layer.go:66:	Layer      Section`
- L5115: `pkg/cmds/values/parsed-layer.go:67:	Parameters *fields.ParsedParameters`
- L5116: `pkg/cmds/values/parsed-layer.go:72:func WithParameterValue(`
- L5117: `pkg/cmds/values/parsed-layer.go:77:		pd, ok := pl.Layer.GetDefinitions().Get(key)`
- L5118: `pkg/cmds/values/parsed-layer.go:79:			return errors.Errorf("parameter definition %s not found in layer %s", key, pl.Layer.GetName())`
- L5119: `pkg/cmds/values/parsed-layer.go:81:		p := &fields.ParsedParameter{`
- L5120: `pkg/cmds/values/parsed-layer.go:88:		pl.Parameters.Set(key, p)`
- L5121: `pkg/cmds/values/parsed-layer.go:94:func WithParameters(pds *fields.ParsedParameters) SectionValuesOption {`
- L5122: `pkg/cmds/values/parsed-layer.go:96:		pds.ForEach(func(k string, v *fields.ParsedParameter) {`
- L5123: `pkg/cmds/values/parsed-layer.go:97:			pl.Parameters.Set(k, v)`
- L5124: `pkg/cmds/values/parsed-layer.go:103:func NewSectionValues(layer Section, options ...SectionValuesOption) (*SectionValues, error) {`
- L5125: `pkg/cmds/values/parsed-layer.go:105:		Layer:      layer,`
- L5126: `pkg/cmds/values/parsed-layer.go:106:		Parameters: fields.NewParsedParameters(),`
- L5127: `pkg/cmds/values/parsed-layer.go:119:// Clone returns a copy of the parsedParameterLayer with a fresh Parameters map.`
- L5128: `pkg/cmds/values/parsed-layer.go:120:// However, neither the Layer nor the Parameters are deep copied.`
- L5129: `pkg/cmds/values/parsed-layer.go:122:	parameters_, err := fields.NewParsedParameters().Merge(ppl.Parameters)`
- L5130: `pkg/cmds/values/parsed-layer.go:127:		Layer:      ppl.Layer,`
- L5131: `pkg/cmds/values/parsed-layer.go:128:		Parameters: parameters_,`
- L5132: `pkg/cmds/values/parsed-layer.go:130:	ppl.Parameters.ForEach(func(k string, v *fields.ParsedParameter) {`
- L5133: `pkg/cmds/values/parsed-layer.go:131:		ret.Parameters.Set(k, v)`
- L5134: `pkg/cmds/values/parsed-layer.go:136:// MergeParameters merges the other SectionValues into this one, overwriting any`
- L5135: `pkg/cmds/values/parsed-layer.go:137:// existing values. This doesn't replace the actual Layer pointer.`
- L5136: `pkg/cmds/values/parsed-layer.go:138:func (ppl *SectionValues) MergeParameters(other *SectionValues) error {`
- L5137: `pkg/cmds/values/parsed-layer.go:139:	_, err := ppl.Parameters.Merge(other.Parameters)`
- L5138: `pkg/cmds/values/parsed-layer.go:143:func (ppl *SectionValues) GetParameter(k string) (interface{}, bool) {`
- L5139: `pkg/cmds/values/parsed-layer.go:144:	v, ok := ppl.Parameters.Get(k)`
- L5140: `pkg/cmds/values/parsed-layer.go:152:	return ppl.Parameters.InitializeStruct(s)`
- L5141: `pkg/cmds/values/parsed-layer.go:191:			err := v.MergeParameters(o)`
- L5142: `pkg/cmds/values/parsed-layer.go:206:			err := o_.MergeParameters(v)`
- L5143: `pkg/cmds/values/parsed-layer.go:219:func (p *Values) GetOrCreate(layer Section) *SectionValues {`
- L5144: `pkg/cmds/values/parsed-layer.go:220:	if layer == nil {`
- L5145: `pkg/cmds/values/parsed-layer.go:221:		panic("layer must not be nil")`
- L5146: `pkg/cmds/values/parsed-layer.go:223:	slug := layer.GetSlug()`
- L5147: `pkg/cmds/values/parsed-layer.go:227:			Layer:      layer,`
- L5148: `pkg/cmds/values/parsed-layer.go:228:			Parameters: fields.NewParsedParameters(),`
- L5149: `pkg/cmds/values/parsed-layer.go:235:// GetDataMap is useful when rendering out templates using all passed in layers.`
- L5150: `pkg/cmds/values/parsed-layer.go:239:		v.Parameters.ForEach(func(k string, v *fields.ParsedParameter) {`
- L5151: `pkg/cmds/values/parsed-layer.go:247:// If the key is "default", it creates a fresh empty default layer for defaults and initializes the struct with it.`
- L5152: `pkg/cmds/values/parsed-layer.go:248:// If the layer specified by the key is not found, it returns an error.`
- L5153: `pkg/cmds/values/parsed-layer.go:249:// The struct must be passed by reference as the s parameter.`
- L5154: `pkg/cmds/values/parsed-layer.go:250:func (p *Values) InitializeStruct(layerKey string, dst interface{}) error {`
- L5155: `pkg/cmds/values/parsed-layer.go:251:	// We special case Default because we will create a fresh empty default layer for defaults.`
- L5156: `pkg/cmds/values/parsed-layer.go:253:	if layerKey == DefaultSlug {`
- L5157: `pkg/cmds/values/parsed-layer.go:254:		return p.GetDefaultParameterLayer().InitializeStruct(dst)`
- L5158: `pkg/cmds/values/parsed-layer.go:256:	v, ok := p.Get(layerKey)`
- L5159: `pkg/cmds/values/parsed-layer.go:258:		return errors.Errorf("layer %s not found", layerKey)`
- L5160: `pkg/cmds/values/parsed-layer.go:263:// GetAllParsedParameters returns a new instance of fields.ParsedParameters`
- L5161: `pkg/cmds/values/parsed-layer.go:264:// that merges the parameters from all Values.`
- L5162: `pkg/cmds/values/parsed-layer.go:265:// The returned parameters are a deep clone of the fields.`
- L5163: `pkg/cmds/values/parsed-layer.go:266:func (p *Values) GetAllParsedParameters() *fields.ParsedParameters {`
- L5164: `pkg/cmds/values/parsed-layer.go:267:	ret := fields.NewParsedParameters()`
- L5165: `pkg/cmds/values/parsed-layer.go:270:			_, err := ret.Merge(v.Parameters.Clone())`
- L5166: `pkg/cmds/values/parsed-layer.go:280:func (p *Values) GetParameter(slug string, key string) (*fields.ParsedParameter, bool) {`
- L5167: `pkg/cmds/values/parsed-layer.go:281:	layer, ok := p.Get(slug)`
- L5168: `pkg/cmds/values/parsed-layer.go:285:	return layer.Parameters.Get(key)`
- L5169: `pkg/cmds/values/parsed-layer.go:288:func (p *Values) GetDefaultParameterLayer() *SectionValues {`
- L5170: `pkg/cmds/values/parsed-layer.go:293:	defaultParameterLayer := newDefaultSection(DefaultSlug, "Default")`
- L5171: `pkg/cmds/values/parsed-layer.go:294:	defaultLayer := &SectionValues{`
- L5172: `pkg/cmds/values/parsed-layer.go:295:		Layer:      defaultParameterLayer,`
- L5173: `pkg/cmds/values/parsed-layer.go:296:		Parameters: fields.NewParsedParameters(),`
- L5174: `pkg/cmds/values/parsed-layer.go:298:	p.Set(DefaultSlug, defaultLayer)`
- L5175: `pkg/cmds/values/parsed-layer.go:300:	return defaultLayer`
- L5176: `pkg/cmds/sources/tests/update-from-map.yaml:1:- name: "Update single layer with valid map"`
- L5177: `pkg/cmds/sources/tests/update-from-map.yaml:2:  description: "Updating a single layer with valid values should correctly merge these values"`
- L5178: `pkg/cmds/sources/tests/update-from-map.yaml:3:  parameterLayers:`
- L5179: `pkg/cmds/sources/tests/update-from-map.yaml:4:    - name: "layer1"`
- L5180: `pkg/cmds/sources/tests/update-from-map.yaml:10:  parsedLayers:`
- L5181: `pkg/cmds/sources/tests/update-from-map.yaml:11:    - name: "layer1"`
- L5182: `pkg/cmds/sources/tests/update-from-map.yaml:12:      parameters:`
- L5183: `pkg/cmds/sources/tests/update-from-map.yaml:16:    layer1:`
- L5184: `pkg/cmds/sources/tests/update-from-map.yaml:19:  expectedLayers:`
- L5185: `pkg/cmds/sources/tests/update-from-map.yaml:20:    - name: "layer1"`
- L5186: `pkg/cmds/sources/tests/update-from-map.yaml:26:- name: "Update non-existent layer"`
- L5187: `pkg/cmds/sources/tests/update-from-map.yaml:27:  description: "Updating a non-existent layer should be ignored and no error should be thrown"`
- L5188: `pkg/cmds/sources/tests/update-from-map.yaml:28:  parameterLayers:`
- L5189: `pkg/cmds/sources/tests/update-from-map.yaml:29:    - name: "layer1"`
- L5190: `pkg/cmds/sources/tests/update-from-map.yaml:33:  parsedLayers:`
- L5191: `pkg/cmds/sources/tests/update-from-map.yaml:34:    - name: "layer1"`
- L5192: `pkg/cmds/sources/tests/update-from-map.yaml:36:    layer2:`
- L5193: `pkg/cmds/sources/tests/update-from-map.yaml:38:  expectedLayers:`
- L5194: `pkg/cmds/sources/tests/update-from-map.yaml:39:    - name: "layer1"`
- L5195: `pkg/cmds/sources/tests/update-from-map.yaml:43:- name: "Invalid parameter type in update map"`
- L5196: `pkg/cmds/sources/tests/update-from-map.yaml:44:  description: "An invalid parameter type in the update map should result in an error"`
- L5197: `pkg/cmds/sources/tests/update-from-map.yaml:45:  parameterLayers:`
- L5198: `pkg/cmds/sources/tests/update-from-map.yaml:46:    - name: "layer1"`
- L5199: `pkg/cmds/sources/tests/update-from-map.yaml:50:  parsedLayers:`
- L5200: `pkg/cmds/sources/tests/update-from-map.yaml:51:    - name: "layer1"`
- L5201: `pkg/cmds/sources/tests/update-from-map.yaml:53:    layer1:`
- L5202: `pkg/cmds/sources/tests/update-from-map.yaml:55:  expectedLayers: null`
- L5203: `pkg/cmds/sources/tests/update-from-map.yaml:59:  description: "Updating with an empty map should leave the layers unchanged"`
- L5204: `pkg/cmds/sources/tests/update-from-map.yaml:60:  parameterLayers:`
- L5205: `pkg/cmds/sources/tests/update-from-map.yaml:61:    - name: "layer1"`
- L5206: `pkg/cmds/sources/tests/update-from-map.yaml:65:  parsedLayers:`
- L5207: `pkg/cmds/sources/tests/update-from-map.yaml:66:    - name: "layer1"`
- L5208: `pkg/cmds/sources/tests/update-from-map.yaml:67:      parameters:`
- L5209: `pkg/cmds/sources/tests/update-from-map.yaml:71:    layer1: {}`
- L5210: `pkg/cmds/sources/tests/update-from-map.yaml:72:  expectedLayers:`
- L5211: `pkg/cmds/sources/tests/update-from-map.yaml:73:    - name: "layer1"`
- L5212: `pkg/cmds/sources/tests/update-from-map.yaml:79:  description: "Extra keys in the map that are not defined in the ParameterLayer are ignored"`
- L5213: `pkg/cmds/sources/tests/update-from-map.yaml:80:  parameterLayers:`
- L5214: `pkg/cmds/sources/tests/update-from-map.yaml:81:    - name: "layer1"`
- L5215: `pkg/cmds/sources/tests/update-from-map.yaml:85:  parsedLayers:`
- L5216: `pkg/cmds/sources/tests/update-from-map.yaml:86:    - name: "layer1"`
- L5217: `pkg/cmds/sources/tests/update-from-map.yaml:88:    layer1:`
- L5218: `pkg/cmds/sources/tests/update-from-map.yaml:91:  expectedLayers:`
- L5219: `pkg/cmds/sources/tests/update-from-map.yaml:92:    - name: "layer1"`
- L5220: `pkg/cmds/sources/tests/update-from-map.yaml:99:  parameterLayers:`
- L5221: `pkg/cmds/sources/tests/update-from-map.yaml:100:    - name: "layer1"`
- L5222: `pkg/cmds/sources/tests/update-from-map.yaml:107:  parsedLayers:`
- L5223: `pkg/cmds/sources/tests/update-from-map.yaml:108:    - name: "layer1"`
- L5224: `pkg/cmds/sources/tests/update-from-map.yaml:110:    layer1:`
- L5225: `pkg/cmds/sources/tests/update-from-map.yaml:112:  expectedLayers: null`
- L5226: `pkg/cmds/sources/tests/update-from-map.yaml:115:- name: "TestUpdateFromMapWithMultipleLayers"`
- L5227: `pkg/cmds/sources/tests/update-from-map.yaml:116:  description: "Correctly updates parsedLayers for multiple layers"`
- L5228: `pkg/cmds/sources/tests/update-from-map.yaml:117:  parameterLayers:`
- L5229: `pkg/cmds/sources/tests/update-from-map.yaml:118:    - name: "layer1"`
- L5230: `pkg/cmds/sources/tests/update-from-map.yaml:122:    - name: "layer2"`
- L5231: `pkg/cmds/sources/tests/update-from-map.yaml:126:  parsedLayers:`
- L5232: `pkg/cmds/sources/tests/update-from-map.yaml:127:    - name: "layer1"`
- L5233: `pkg/cmds/sources/tests/update-from-map.yaml:128:    - name: "layer2"`
- L5234: `pkg/cmds/sources/tests/update-from-map.yaml:130:    layer1:`
- L5235: `pkg/cmds/sources/tests/update-from-map.yaml:132:    layer2:`
- L5236: `pkg/cmds/sources/tests/update-from-map.yaml:134:  expectedLayers:`
- L5237: `pkg/cmds/sources/tests/update-from-map.yaml:135:    - name: "layer1"`
- L5238: `pkg/cmds/sources/tests/update-from-map.yaml:138:    - name: "layer2"`
- L5239: `pkg/cmds/sources/patternmapper/loader.go:22:	TargetLayer     string        `yaml:"target_layer" json:"target_layer"``
- L5240: `pkg/cmds/sources/patternmapper/loader.go:23:	TargetParameter string        `yaml:"target_parameter" json:"target_parameter"``
- L5241: `pkg/cmds/sources/patternmapper/loader.go:31:		TargetLayer:     mr.TargetLayer,`
- L5242: `pkg/cmds/sources/patternmapper/loader.go:32:		TargetParameter: mr.TargetParameter,`
- L5243: `pkg/cmds/sources/patternmapper/loader.go:96:// LoadMapperFromFile loads a ConfigMapper from a YAML/JSON mapping file using the provided layers.`
- L5244: `pkg/cmds/sources/patternmapper/loader.go:97:func LoadMapperFromFile(layers_ *schema.Schema, filename string) (sources.ConfigMapper, error) {`
- L5245: `pkg/cmds/sources/patternmapper/loader.go:102:	return NewConfigMapper(layers_, rules...)`
- L5246: `pkg/cmds/values/parsed-layer_test.go:12:	parsedLayers := New()`
- L5247: `pkg/cmds/values/parsed-layer_test.go:13:	assert.NotNil(t, parsedLayers)`
- L5248: `pkg/cmds/values/parsed-layer_test.go:14:	assert.Equal(t, 0, parsedLayers.Len())`
- L5249: `pkg/cmds/values/parsed-layer_test.go:18:	layer := createParameterLayer(t, "test", "Test Layer")`
- L5250: `pkg/cmds/values/parsed-layer_test.go:19:	parsedLayer := createSectionValues(t, layer, nil)`
- L5251: `pkg/cmds/values/parsed-layer_test.go:21:	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L5252: `pkg/cmds/values/parsed-layer_test.go:23:	assert.Equal(t, 1, parsedLayers.Len())`
- L5253: `pkg/cmds/values/parsed-layer_test.go:24:	val, present := parsedLayers.Get("test")`
- L5254: `pkg/cmds/values/parsed-layer_test.go:26:	assert.Equal(t, parsedLayer, val)`
- L5255: `pkg/cmds/values/parsed-layer_test.go:30:	layer := createParameterLayer(t, "test", "Test Layer")`
- L5256: `pkg/cmds/values/parsed-layer_test.go:31:	parsedLayer := createSectionValues(t, layer, nil)`
- L5257: `pkg/cmds/values/parsed-layer_test.go:32:	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L5258: `pkg/cmds/values/parsed-layer_test.go:34:	cloned := parsedLayers.Clone()`
- L5259: `pkg/cmds/values/parsed-layer_test.go:36:	assert.Equal(t, parsedLayers.Len(), cloned.Len())`
- L5260: `pkg/cmds/values/parsed-layer_test.go:37:	originalVal, _ := parsedLayers.Get("test")`
- L5261: `pkg/cmds/values/parsed-layer_test.go:41:	assert.Equal(t, originalVal.Layer, clonedVal.Layer)`
- L5262: `pkg/cmds/values/parsed-layer_test.go:45:	parsedLayers := New()`
- L5263: `pkg/cmds/values/parsed-layer_test.go:46:	layer := createParameterLayer(t, "test", "Test Layer")`
- L5264: `pkg/cmds/values/parsed-layer_test.go:48:	// Get non-existent layer (should create)`
- L5265: `pkg/cmds/values/parsed-layer_test.go:49:	parsedLayer := parsedLayers.GetOrCreate(layer)`
- L5266: `pkg/cmds/values/parsed-layer_test.go:50:	assert.NotNil(t, parsedLayer)`
- L5267: `pkg/cmds/values/parsed-layer_test.go:51:	assert.Equal(t, layer, parsedLayer.Layer)`
- L5268: `pkg/cmds/values/parsed-layer_test.go:53:	// Get existing layer`
- L5269: `pkg/cmds/values/parsed-layer_test.go:54:	sameLayer := parsedLayers.GetOrCreate(layer)`
- L5270: `pkg/cmds/values/parsed-layer_test.go:55:	assert.Equal(t, parsedLayer, sameLayer)`
- L5271: `pkg/cmds/values/parsed-layer_test.go:59:	layer1 := createParameterLayer(t, "layer1", "Layer 1",`
- L5272: `pkg/cmds/values/parsed-layer_test.go:62:	parsedLayer1 := createSectionValues(t, layer1, map[string]interface{}{"param1": "value1"})`
- L5273: `pkg/cmds/values/parsed-layer_test.go:64:	layer2 := createParameterLayer(t, "layer2", "Layer 2",`
- L5274: `pkg/cmds/values/parsed-layer_test.go:67:	parsedLayer2 := createSectionValues(t, layer2, map[string]interface{}{"param2": 42})`
- L5275: `pkg/cmds/values/parsed-layer_test.go:69:	parsedLayers := New(`
- L5276: `pkg/cmds/values/parsed-layer_test.go:70:		WithSectionValues("layer1", parsedLayer1),`
- L5277: `pkg/cmds/values/parsed-layer_test.go:71:		WithSectionValues("layer2", parsedLayer2),`
- L5278: `pkg/cmds/values/parsed-layer_test.go:74:	dataMap := parsedLayers.GetDataMap()`
- L5279: `pkg/cmds/values/parsed-layer_test.go:86:	layer := createParameterLayer(t, "test", "Test Layer",`
- L5280: `pkg/cmds/values/parsed-layer_test.go:90:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{`
- L5281: `pkg/cmds/values/parsed-layer_test.go:94:	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L5282: `pkg/cmds/values/parsed-layer_test.go:97:	err := parsedLayers.InitializeStruct("test", &result)`
- L5283: `pkg/cmds/values/parsed-layer_test.go:103:func TestValuesGetAllParsedParameters(t *testing.T) {`
- L5284: `pkg/cmds/values/parsed-layer_test.go:104:	layer1 := createParameterLayer(t, "layer1", "Layer 1",`
- L5285: `pkg/cmds/values/parsed-layer_test.go:107:	parsedLayer1 := createSectionValues(t, layer1, map[string]interface{}{"param1": "value1"})`
- L5286: `pkg/cmds/values/parsed-layer_test.go:109:	layer2 := createParameterLayer(t, "layer2", "Layer 2",`
- L5287: `pkg/cmds/values/parsed-layer_test.go:112:	parsedLayer2 := createSectionValues(t, layer2, map[string]interface{}{"param2": 42})`
- L5288: `pkg/cmds/values/parsed-layer_test.go:114:	parsedLayers := New(`
- L5289: `pkg/cmds/values/parsed-layer_test.go:115:		WithSectionValues("layer1", parsedLayer1),`
- L5290: `pkg/cmds/values/parsed-layer_test.go:116:		WithSectionValues("layer2", parsedLayer2),`
- L5291: `pkg/cmds/values/parsed-layer_test.go:119:	allParams := parsedLayers.GetAllParsedParameters()`
- L5292: `pkg/cmds/values/parsed-layer_test.go:129:func TestValuesGetParameter(t *testing.T) {`
- L5293: `pkg/cmds/values/parsed-layer_test.go:130:	layer := createParameterLayer(t, "test", "Test Layer",`
- L5294: `pkg/cmds/values/parsed-layer_test.go:133:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"param": "value"})`
- L5295: `pkg/cmds/values/parsed-layer_test.go:134:	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L5296: `pkg/cmds/values/parsed-layer_test.go:136:	param, present := parsedLayers.GetParameter("test", "param")`
- L5297: `pkg/cmds/values/parsed-layer_test.go:140:	_, present = parsedLayers.GetParameter("non_existent", "param")`
- L5298: `pkg/cmds/values/parsed-layer_test.go:143:	_, present = parsedLayers.GetParameter("test", "non_existent")`
- L5299: `pkg/cmds/values/parsed-layer_test.go:147:func TestValuesGetDefaultParameterLayer(t *testing.T) {`
- L5300: `pkg/cmds/values/parsed-layer_test.go:148:	parsedLayers := New()`
- L5301: `pkg/cmds/values/parsed-layer_test.go:150:	defaultLayer := parsedLayers.GetDefaultParameterLayer()`
- L5302: `pkg/cmds/values/parsed-layer_test.go:151:	assert.NotNil(t, defaultLayer)`
- L5303: `pkg/cmds/values/parsed-layer_test.go:152:	assert.Equal(t, DefaultSlug, defaultLayer.Layer.GetSlug())`
- L5304: `pkg/cmds/values/parsed-layer_test.go:154:	// Calling it again should return the same layer`
- L5305: `pkg/cmds/values/parsed-layer_test.go:155:	sameDefaultLayer := parsedLayers.GetDefaultParameterLayer()`
- L5306: `pkg/cmds/values/parsed-layer_test.go:156:	assert.Equal(t, defaultLayer, sameDefaultLayer)`
- L5307: `pkg/cmds/values/parsed-layer_test.go:160:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L5308: `pkg/cmds/values/parsed-layer_test.go:161:	parsedLayer1 := createSectionValues(t, layer1, nil)`
- L5309: `pkg/cmds/values/parsed-layer_test.go:163:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L5310: `pkg/cmds/values/parsed-layer_test.go:164:	parsedLayer2 := createSectionValues(t, layer2, nil)`
- L5311: `pkg/cmds/values/parsed-layer_test.go:166:	parsedLayers := New(`
- L5312: `pkg/cmds/values/parsed-layer_test.go:167:		WithSectionValues("layer1", parsedLayer1),`
- L5313: `pkg/cmds/values/parsed-layer_test.go:168:		WithSectionValues("layer2", parsedLayer2),`
- L5314: `pkg/cmds/values/parsed-layer_test.go:172:	parsedLayers.ForEach(func(k string, v *SectionValues) {`
- L5315: `pkg/cmds/values/parsed-layer_test.go:174:		assert.Contains(t, []string{"layer1", "layer2"}, k)`
- L5316: `pkg/cmds/values/parsed-layer_test.go:180:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L5317: `pkg/cmds/values/parsed-layer_test.go:181:	parsedLayer1 := createSectionValues(t, layer1, nil)`
- L5318: `pkg/cmds/values/parsed-layer_test.go:183:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L5319: `pkg/cmds/values/parsed-layer_test.go:184:	parsedLayer2 := createSectionValues(t, layer2, nil)`
- L5320: `pkg/cmds/values/parsed-layer_test.go:186:	parsedLayers := New(`
- L5321: `pkg/cmds/values/parsed-layer_test.go:187:		WithSectionValues("layer1", parsedLayer1),`
- L5322: `pkg/cmds/values/parsed-layer_test.go:188:		WithSectionValues("layer2", parsedLayer2),`
- L5323: `pkg/cmds/values/parsed-layer_test.go:192:	err := parsedLayers.ForEachE(func(k string, v *SectionValues) error {`
- L5324: `pkg/cmds/values/parsed-layer_test.go:200:	errorOnSecond := parsedLayers.ForEachE(func(k string, v *SectionValues) error {`
- L5325: `pkg/cmds/values/parsed-layer_test.go:201:		if k == "layer2" {`
- L5326: `pkg/cmds/values/parsed-layer_test.go:210:	layer := createParameterLayer(t, "test", "Test Layer",`
- L5327: `pkg/cmds/values/parsed-layer_test.go:213:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"exported": "value"})`
- L5328: `pkg/cmds/values/parsed-layer_test.go:223:	err := parsedLayer.InitializeStruct(&result)`
- L5329: `pkg/cmds/values/parsed-layer_test.go:231:	parsedLayers := New()`
- L5330: `pkg/cmds/values/parsed-layer_test.go:232:	layer := createParameterLayer(t, "test", "Test Layer",`
- L5331: `pkg/cmds/values/parsed-layer_test.go:235:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"param": "value"})`
- L5332: `pkg/cmds/values/parsed-layer_test.go:236:	parsedLayers.Set("test", parsedLayer)`
- L5333: `pkg/cmds/values/parsed-layer_test.go:243:	err := parsedLayers.InitializeStruct("test", result) // Note: passing result, not &result`
- L5334: `pkg/cmds/values/parsed-layer_test.go:248:func TestValuesGetParameterNonExistentLayer(t *testing.T) {`
- L5335: `pkg/cmds/values/parsed-layer_test.go:249:	parsedLayers := New()`
- L5336: `pkg/cmds/values/parsed-layer_test.go:251:	_, present := parsedLayers.GetParameter("non_existent", "param")`
- L5337: `pkg/cmds/values/parsed-layer_test.go:255:func TestValuesGetOrCreateNilLayer(t *testing.T) {`
- L5338: `pkg/cmds/values/parsed-layer_test.go:256:	parsedLayers := New()`
- L5339: `pkg/cmds/values/parsed-layer_test.go:258:	// Depending on how you want to handle this case, you might expect an error or a new empty layer`
- L5340: `pkg/cmds/values/parsed-layer_test.go:260:	assert.Panics(t, func() { parsedLayers.GetOrCreate(nil) })`
- L5341: `pkg/cmds/values/parsed-layer_test.go:264:	layer := createParameterLayer(t, "test", "Test Layer",`
- L5342: `pkg/cmds/values/parsed-layer_test.go:274:		options = append(options, WithParameterValue(key, value))`
- L5343: `pkg/cmds/values/parsed-layer_test.go:276:	_, err := NewSectionValues(layer, options...)`
- L5344: `pkg/cmds/values/parsed-layer_test.go:281:	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L5345: `pkg/cmds/values/parsed-layer_test.go:282:	parsedLayer1 := createSectionValues(t, layer1, nil)`
- L5346: `pkg/cmds/values/parsed-layer_test.go:283:	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L5347: `pkg/cmds/values/parsed-layer_test.go:284:	parsedLayer2 := createSectionValues(t, layer2, nil)`
- L5348: `pkg/cmds/values/parsed-layer_test.go:286:	parsedLayers := New(`
- L5349: `pkg/cmds/values/parsed-layer_test.go:287:		WithSectionValues("layer1", parsedLayer1),`
- L5350: `pkg/cmds/values/parsed-layer_test.go:288:		WithSectionValues("layer2", parsedLayer2),`
- L5351: `pkg/cmds/values/parsed-layer_test.go:292:	err := parsedLayers.ForEachE(func(k string, v *SectionValues) error {`
- L5352: `pkg/cmds/values/parsed-layer_test.go:294:		if k == "layer2" {`
- L5353: `pkg/cmds/values/parsed-layer_test.go:302:	assert.Equal(t, 2, count) // The loop should have proceeded to the second layer before stopping`
- L5354: `pkg/cmds/values/parsed-layer_test.go:320:	// Create a parameter layer with all the necessary definitions`
- L5355: `pkg/cmds/values/parsed-layer_test.go:321:	layer := createParameterLayer(t, "test", "Test Layer",`
- L5356: `pkg/cmds/values/parsed-layer_test.go:330:	// Create a parsed layer with test values`
- L5357: `pkg/cmds/values/parsed-layer_test.go:331:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{`
- L5358: `pkg/cmds/values/parsed-layer_test.go:340:	// Create Values and add the parsed layer`
- L5359: `pkg/cmds/values/parsed-layer_test.go:341:	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L5360: `pkg/cmds/values/parsed-layer_test.go:345:	err := parsedLayers.InitializeStruct("test", &result)`
- L5361: `pkg/cmds/values/parsed-layer_test.go:379:	// Create a parameter layer with all the necessary definitions`
- L5362: `pkg/cmds/values/parsed-layer_test.go:380:	layer := createParameterLayer(t, "test", "Test Layer",`
- L5363: `pkg/cmds/values/parsed-layer_test.go:386:	// Create a parsed layer with test values`
- L5364: `pkg/cmds/values/parsed-layer_test.go:387:	parsedLayer := createSectionValues(t, layer, map[string]interface{}{`
- L5365: `pkg/cmds/values/parsed-layer_test.go:393:	// Create Values and add the parsed layer`
- L5366: `pkg/cmds/values/parsed-layer_test.go:394:	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L5367: `pkg/cmds/values/parsed-layer_test.go:398:	err := parsedLayers.InitializeStruct("test", &result)`

### `ttmp/_guidelines/script.md`
- L13: `- Document all required parameters`

## Files with content matches (Go source)
### `cmd/examples/appconfig-parser/main.go`
- L13: `	RedisSlug appconfig.LayerSlug = "redis"`
- L14: `	DBSlug    appconfig.LayerSlug = "db"`
- L40: `	redisLayer := mustSection(schema.NewSection(`
- L50: `	dbLayer := mustSection(schema.NewSection(`
- L61: `		appconfig.WithValuesForLayers(map[string]map[string]interface{}{`
- L71: `	if err := parser.Register(RedisSlug, redisLayer, func(t *AppSettings) any { return &t.Redis }); err != nil {`
- L72: `		fmt.Fprintf(os.Stderr, "failed to register redis layer: %v\n", err)`
- L75: `	if err := parser.Register(DBSlug, dbLayer, func(t *AppSettings) any { return &t.DB }); err != nil {`
- L76: `		fmt.Fprintf(os.Stderr, "failed to register db layer: %v\n", err)`

### `cmd/examples/appconfig-profiles/main.go`
- L47: `	redisLayer := mustSection(schema.NewSection(`
- L107: `			if err := parser.Register("redis", redisLayer, func(t *AppSettings) any { return &t.Redis }); err != nil {`
- L129: `	_ = addLayer(root, redisLayer)`
- L130: `	if psLayer, err := cli.NewProfileSettingsLayer(); err == nil {`
- L131: `		_ = addLayer(root, psLayer)`
- L148: `func addLayer(cmd *cobra.Command, layer schema.Section) error {`
- L149: `	cobraLayer, ok := layer.(schema.CobraSection)`
- L151: `		return errors.Errorf("layer %s is not a CobraSection", layer.GetSlug())`
- L153: `	return cobraLayer.AddLayerToCobraCommand(cmd)`

### `cmd/examples/config-custom-mapper/main.go`
- L29: `	demoLayer, err := schema.NewSection(`
- L54: `		cmds.WithLayersList(demoLayer),`
- L80: `// flatConfigMapper transforms a flat config structure to the layer map format.`
- L96: `	// Map flat keys to layer parameters`
- L135: `			SkipCommandSettingsLayer: true,`
- L136: `			MiddlewaresFunc: func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]sources.Middleware, error) {`
- L157: `	// validate command: validate config.yaml using the custom mapper and layer definitions`
- L183: `			// Validate mapped structure against known layers and params`
- L184: `			for layerSlug, kv := range mapped {`
- L185: `				layer, ok := demo.Description().Layers.Get(layerSlug)`
- L187: `					issues = append(issues, fmt.Sprintf("unknown layer: %s", layerSlug))`
- L191: `				pds := layer.GetDefinitions()`
- L196: `						issues = append(issues, fmt.Sprintf("unknown parameter in layer %s: %s", layerSlug, key))`
- L201: `						issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))`

### `cmd/examples/config-overlay/main.go`
- L37: `	desc := cmds.NewCommandDescription("overlay", cmds.WithShort("Multiple config overlays"), cmds.WithLayersList(demo))`
- L80: `			SkipCommandSettingsLayer: true,`
- L117: `				for layerSlug, v := range raw {`
- L118: `					layer, ok := overlayCmd.Description().Layers.Get(layerSlug)`
- L120: `						issues = append(issues, fmt.Sprintf("%s: unknown layer %s", f, layerSlug))`
- L125: `						issues = append(issues, fmt.Sprintf("%s: layer %s must be an object", f, layerSlug))`
- L128: `					pds := layer.GetDefinitions()`
- L133: `							issues = append(issues, fmt.Sprintf("%s: unknown parameter %s.%s", f, layerSlug, key))`
- L138: `							issues = append(issues, fmt.Sprintf("%s: invalid value for %s.%s: %v", f, layerSlug, key, err))`

### `cmd/examples/config-pattern-mapper/main.go`
- L49: `	demoLayer, err := schema.NewSection(`
- L51: `		"Demo Layer",`
- L64: `	paramLayers := schema.NewSchema(schema.WithSections(demoLayer))`
- L78: `		mapper, err := pm.NewConfigMapper(paramLayers, rules...)`
- L100: `		mapper, err := pm.NewConfigMapper(paramLayers,`
- L103: `				TargetLayer:     "demo",`
- L104: `				TargetParameter: "api-key",`
- L108: `				TargetLayer:     "demo",`
- L109: `				TargetParameter: "threshold",`
- L133: `		mapper, err := pm.NewConfigMapper(paramLayers,`
- L136: `				TargetLayer:     "demo",`
- L137: `				TargetParameter: "{env}-api-key",`
- L161: `		mapper, err := pm.NewConfigMapper(paramLayers,`
- L164: `				TargetLayer: "demo",`
- L166: `					{Source: "api_key", TargetParameter: "api-key"},`
- L167: `					{Source: "threshold", TargetParameter: "threshold"},`
- L168: `					{Source: "timeout", TargetParameter: "timeout"},`
- L193: `		mapper, err := pm.NewConfigMapper(paramLayers,`
- L196: `				TargetLayer: "demo",`
- L199: `					{Source: "api_key", TargetParameter: "{env}-api-key"},`
- L221: `	// Example 5: Using with LoadParametersFromFile middleware`
- L222: `	fmt.Println("=== Example 5: Integration with LoadParametersFromFile ===")`
- L224: `		mapper, err := pm.NewConfigMapper(paramLayers,`
- L227: `				TargetLayer:     "demo",`
- L228: `				TargetParameter: "api-key",`
- L235: `		// Use the pattern mapper with sources.FromFile (wraps LoadParametersFromFile)`
- L242: `		fmt.Println("Pattern mapper can be used with LoadParametersFromFile middleware")`
- L249: `		b := pm.NewConfigMapperBuilder(paramLayers).`
- L274: `		b := pm.NewConfigMapperBuilder(paramLayers).`
- L301: `		b := pm.NewConfigMapperBuilder(paramLayers).`
- L330: `		mapper, err := pm.NewConfigMapper(paramLayers, rules...)`

### `cmd/examples/config-single/main.go`
- L51: `		cmds.WithShort("Minimal custom layer with single config file"),`
- L52: `		cmds.WithLayersList(demoSection),`
- L90: `			SkipCommandSettingsLayer: true,`
- L100: `	// validate command: checks the config file against layer definitions`
- L103: `		Short: "Validate the config file for known layers, parameters, and types",`
- L108: `			// Recreate layers like the main command`
- L125: `			// Validate top-level layers and parameters`
- L126: `			for layerSlug, v := range raw {`
- L127: `				layer, ok := demoCmd.Description().Layers.Get(layerSlug)`
- L129: `					issues = append(issues, fmt.Sprintf("unknown layer: %s", layerSlug))`
- L134: `					issues = append(issues, fmt.Sprintf("layer %s must be an object", layerSlug))`
- L137: `				pds := layer.GetDefinitions()`
- L138: `				// Build set of known parameter names`
- L145: `						issues = append(issues, fmt.Sprintf("unknown parameter in layer %s: %s", layerSlug, key))`
- L150: `						issues = append(issues, fmt.Sprintf("invalid value for %s.%s: %v", layerSlug, key, err))`

### `cmd/examples/middlewares-config-env/main.go`
- L18: `// DemoSettings maps to the demo layer parameters`
- L59: `		cmds.WithLayersList(glazedSection, demoSection),`
- L100: `			// AppName enables env prefix APP_<LAYER_PREFIX+FLAG>`

### `cmd/examples/new-api-build-first-command/main.go`
- L154: `			ShortHelpLayers: []string{schema.DefaultSlug},`

### `cmd/examples/overlay-override/main.go`
- L38: `	desc := cmds.NewCommandDescription("overlay-override", cmds.WithShort("--config-file + <base>.override.yaml pattern"), cmds.WithLayersList(demo))`

### `cmd/examples/parameter-types/main.go`
- L25: `type ParameterTypesSettings struct {`
- L56: `type ParameterTypesCommand struct {`
- L60: `var _ cmds.GlazeCommand = (*ParameterTypesCommand)(nil)`
- L62: `func NewParameterTypesCommand() (*ParameterTypesCommand, error) {`
- L65: `		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L68: `	return &ParameterTypesCommand{`
- L70: `			"parameter-types",`
- L71: `			cmds.WithShort("Showcase all parameter types available in glazed"),`
- L72: `			cmds.WithLong(`This command demonstrates all the different parameter types available in the glazed framework.`
- L75: `Parameter types demonstrated:`
- L81: `Use --help to see all available parameters and their descriptions.`),`
- L87: `					fields.WithHelp("A simple string parameter"),`
- L93: `					fields.WithHelp("A secret parameter (will be masked when displayed)"),`
- L99: `					fields.WithHelp("An integer parameter"),`
- L105: `					fields.WithHelp("A floating point parameter"),`
- L111: `					fields.WithHelp("A boolean parameter"),`
- L117: `					fields.WithHelp("A date parameter (RFC3339 format or natural language)"),`
- L123: `					fields.WithHelp("A choice parameter with predefined options"),`
- L159: `					fields.WithHelp("A file parameter that loads file metadata"),`
- L210: `			cmds.WithLayersList(`
- L217: `func (c *ParameterTypesCommand) RunIntoGlazeProcessor(`
- L222: `	s := &ParameterTypesSettings{}`
- L225: `		return errors.Wrap(err, "Failed to initialize settings from parameters")`
- L228: `	// We'll use hardcoded metadata since layer access is complex`
- L230: `	// Create a result row for each parameter`
- L231: `	parameterData := []struct {`
- L240: `		{"string-param", fields.TypeString, s.StringParam, "A simple string parameter", false, nil, "default-string"},`
- L241: `		{"secret-param", fields.TypeSecret, s.SecretParam, "A secret parameter (will be masked when displayed)", false, nil, "secret-value"},`
- L242: `		{"integer-param", fields.TypeInteger, s.IntegerParam, "An integer parameter", false, nil, 42},`
- L243: `		{"float-param", fields.TypeFloat, s.FloatParam, "A floating point parameter", false, nil, 3.14},`
- L244: `		{"bool-param", fields.TypeBool, s.BoolParam, "A boolean parameter", false, nil, true},`
- L245: `		{"date-param", fields.TypeDate, s.DateParam, "A date parameter (RFC3339 format or natural language)", false, nil, "2024-01-01T00:00:00Z"},`
- L246: `		{"choice-param", fields.TypeChoice, s.ChoiceParam, "A choice parameter with predefined options", false, []string{"option1", "option2", "option3"}, "option1"},`
- L251: `		{"file-param", fields.TypeFile, s.FileParam, "A file parameter that loads file metadata", false, nil, nil},`
- L263: `	for _, param := range parameterData {`
- L302: `			types.MRP("parameter_name", param.name),`
- L303: `			types.MRP("parameter_type", string(param.paramType)),`
- L324: `	cmd, err := NewParameterTypesCommand()`
- L331: `		Use:   "parameter-types",`
- L332: `		Short: "Showcase all glazed parameter types",`

### `cmd/examples/refactor-new-packages/main.go`
- L19: `// AppSettings maps to the app section parameters`
- L26: `// OutputSettings maps to the output section parameters`
- L99: `		schema.WithDescription("Default parameters"),`
- L198: `			// AppName enables env prefix DEMO_<LAYER_PREFIX+FLAG>`

### `cmd/examples/sources-example/main.go`
- L117: `	// cmd.Layers is *schema.Schema, but we convert to schema.Schema (type alias)`
- L119: `	cmdSchema := (*schema.Schema)(cmd.Layers)`

### `cmd/glaze/cmds/csv.go`
- L25: `	glazedLayer, err := settings.NewGlazedSchema()`
- L73: `			cmds.WithLayersList(`
- L74: `				glazedLayer,`
- L93: `		return errors.Wrap(err, "failed to initialize csv settings from parameters")`

### `cmd/glaze/cmds/docs.go`
- L52: `	// This is an example of selective use of glazed parameter schema.`
- L56: `	glazedLayer, err := settings.NewGlazedSchema(`
- L57: `		settings.WithFieldsFiltersParameterLayerOptions(`
- L79: `	cobraLayer, ok := glazedLayer.(schema.CobraSection)`
- L81: `		panic("glazed layer is not a CobraSection")`
- L84: `	err = cobraLayer.AddLayerToCobraCommand(DocsCmd)`

### `cmd/glaze/cmds/example.go`
- L31: `	glazedLayer, err := settings.NewGlazedSchema()`
- L33: `		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L56: `			cmds.WithLayersList(`
- L57: `				glazedLayer,`
- L65: `// parsedLayers contains the result of parsing each layer that has been`
- L66: `// registered with the command description. These layers can be glazed structured data`
- L67: `// flags, database connection parameters, application specification fields.`
- L76: `		return errors.Wrap(err, "failed to initialize example settings from parameters")`

### `cmd/glaze/cmds/html/cmds.go`
- L55: `	glazedLayer, err := settings.NewGlazedSchema()`
- L59: `	cobraLayer, ok := glazedLayer.(schema.CobraSection)`
- L61: `		return nil, fmt.Errorf("glazed layer is not a CobraSection")`
- L64: `	err = cobraLayer.AddLayerToCobraCommand(parseCmd)`
- L119: `	err = cobraLayer.AddLayerToCobraCommand(extractCmd)`

### `cmd/glaze/cmds/json.go`
- L38: `	glazedLayer, err := settings.NewGlazedSchema()`
- L40: `		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L79: `			cmds.WithLayersList(`
- L80: `				glazedLayer,`
- L90: `		return errors.Wrap(err, "Failed to initialize json settings from parameters")`

### `cmd/glaze/cmds/markdown.go`
- L428: `	glazedLayer, err := settings.NewGlazedSchema()`
- L432: `	cobraLayer, ok := glazedLayer.(schema.CobraSection)`
- L434: `		panic("glazed layer is not a CobraSection")`
- L437: `	err = cobraLayer.AddLayerToCobraCommand(parseCmd)`
- L447: `	err = cobraLayer.AddLayerToCobraCommand(splitByHeadingCmd)`

### `cmd/glaze/cmds/yaml.go`
- L30: `	glazedLayer, err := settings.NewGlazedSchema()`
- L32: `		return nil, errors.Wrap(err, "could not create Glazed parameter layer")`
- L66: `			cmds.WithLayersList(`
- L67: `				glazedLayer,`
- L84: `		return errors.Wrap(err, "Failed to initialize yaml settings from parameters")`

### `cmd/glaze/main.go`
- L26: `	err := logging.AddLoggingLayerToRootCommand(rootCmd, "glaze")`

### `pkg/appconfig/doc.go`
- L5: `// deriving layers from structs. Instead, callers explicitly register Glazed`
- L6: `// ParameterLayers and bind them to fields inside a grouped settings struct T.`

### `pkg/appconfig/options.go`
- L80: `// WithValuesForLayers configures programmatic values for layers (optional).`
- L81: `func WithValuesForLayers(values map[string]map[string]interface{}) ParserOption {`
- L176: `// It does a mini "bootstrap parse" for the `profile-settings` layer to resolve:`
- L193: `// must ensure those flags exist on the command (typically by adding the ProfileSettings layer`
- L222: `				return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L224: `					psLayer, err := cli.NewProfileSettingsLayer()`
- L229: `					bootstrapLayers := schema.NewSchema(schema.WithSections(psLayer))`
- L268: `					if err := cmd_sources.Execute(bootstrapLayers, bootstrapParsed, bootstrapMiddlewares...); err != nil {`
- L291: `					if err := next(layers_, parsedLayers); err != nil {`
- L295: `					// 3) Apply profiles.yaml at the intended precedence layer.`
- L308: `					return handler(layers_, parsedLayers)`

### `pkg/appconfig/parser.go`
- L13: `	slug  LayerSlug`
- L14: `	layer schema.Section`
- L18: `// LayerSlug is a distinct type to encourage declaring layer slugs as constants.`
- L22: `//	const RedisSlug appconfig.LayerSlug = "redis"`
- L23: `type LayerSlug string`
- L26: `// - callers register layers and bind them to sub-struct pointers inside T`
- L52: `// Register associates a layer slug and ParameterLayer with a binder that returns`
- L57: `// - layer must be non-nil`
- L59: `// - slug must match layer.GetSlug() (to avoid mismatches between registration keys and parsed layer keys)`
- L60: `func (p *Parser[T]) Register(slug LayerSlug, layer schema.Section, bind func(*T) any) error {`
- L64: `	if layer == nil {`
- L65: `		return errors.New("layer must not be nil")`
- L70: `	if layer.GetSlug() != string(slug) {`
- L71: `		return errors.Errorf("slug %q does not match layer.GetSlug() %q", string(slug), layer.GetSlug())`
- L75: `			return errors.Errorf("layer slug %q already registered", string(slug))`
- L78: `	p.regs = append(p.regs, registration[T]{slug: slug, layer: layer, bind: bind})`
- L85: `		return nil, errors.New("no layers registered")`
- L88: `	paramLayers := schema.NewSchema()`
- L90: `		paramLayers.Set(string(r.slug), r.layer)`
- L104: `	parsedLayers := values.New()`
- L105: `	if err := cmd_sources.Execute(paramLayers, parsedLayers, execMiddlewares...); err != nil {`
- L106: `		return nil, errors.Wrap(err, "failed to parse parameters")`
- L113: `			return nil, errors.Errorf("bind returned nil for layer %q", string(r.slug))`
- L117: `			return nil, errors.Errorf("bind for layer %q must return a non-nil pointer, got %T", string(r.slug), dst)`
- L119: `		if err := parsedLayers.InitializeStruct(string(r.slug), dst); err != nil {`
- L120: `			return nil, errors.Wrapf(err, "failed to initialize settings for layer %q", string(r.slug))`

### `pkg/appconfig/parser_test.go`
- L26: `func newTestRedisLayer(defaultHost string) schema.Section {`
- L27: `	layer, err := schema.NewSection(`
- L42: `	return layer`
- L46: `	const redisSlug LayerSlug = "redis"`
- L47: `	layer := newTestRedisLayer("default")`
- L52: `		err = p.Register("", layer, func(t *testAppSettings) any { return &t.Redis })`
- L56: `	t.Run("nil layer", func(t *testing.T) {`
- L66: `		err = p.Register(redisSlug, layer, nil)`
- L70: `	t.Run("slug mismatch with layer.GetSlug", func(t *testing.T) {`
- L73: `		err = p.Register(LayerSlug("not-redis"), layer, func(t *testAppSettings) any { return &t.Redis })`
- L80: `		require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))`
- L81: `		err = p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis })`
- L87: `	const redisSlug LayerSlug = "redis"`
- L88: `	layer := newTestRedisLayer("default")`
- L91: `		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{`
- L95: `		require.NoError(t, p.Register(redisSlug, layer, func(_ *testAppSettings) any { return nil }))`
- L102: `		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{`
- L106: `		require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return t.Redis }))`
- L113: `		p, err := NewParser[testAppSettings](WithValuesForLayers(map[string]map[string]interface{}{`
- L117: `		require.NoError(t, p.Register(redisSlug, layer, func(_ *testAppSettings) any {`
- L128: `	const redisSlug LayerSlug = "redis"`
- L129: `	layer := newTestRedisLayer("default")`
- L135: `	p, err := NewParser[app](WithValuesForLayers(map[string]map[string]interface{}{`
- L139: `	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L148: `	const redisSlug LayerSlug = "redis"`
- L149: `	layer := newTestRedisLayer("from-default")`
- L163: `	require.NoError(t, p.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))`
- L171: `	const redisSlug LayerSlug = "redis"`
- L172: `	layer := newTestRedisLayer("from-default")`
- L186: `			require.NoError(t, parser.Register(redisSlug, layer, func(t *testAppSettings) any { return &t.Redis }))`
- L195: `	// IMPORTANT: appconfig.Parser expects the layer flags to already be on the cobra command.`
- L196: `	cobraLayer, ok := layer.(schema.CobraSection)`
- L197: `	require.True(t, ok, "test layer must implement schema.CobraSection")`
- L198: `	require.NoError(t, cobraLayer.AddLayerToCobraCommand(rootCmd))`

### `pkg/appconfig/profile_test.go`
- L15: `	const redisSlug LayerSlug = "redis"`
- L16: `	layer := newTestRedisLayer("from-default")`
- L40: `	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L48: `	const redisSlug LayerSlug = "redis"`
- L49: `	layer := newTestRedisLayer("from-default")`
- L75: `	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L83: `	const redisSlug LayerSlug = "redis"`
- L84: `	layer := newTestRedisLayer("from-default")`
- L114: `	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L122: `	const redisSlug LayerSlug = "redis"`
- L123: `	layer := newTestRedisLayer("from-default")`
- L151: `			require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L161: `	psLayer, err := cli.NewProfileSettingsLayer()`
- L163: `	require.NoError(t, psLayer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L165: `	// Also add the redis layer flags (not strictly needed for this test, but keeps the pattern consistent).`
- L166: `	require.NoError(t, layer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L173: `	const redisSlug LayerSlug = "redis"`
- L174: `	layer := newTestRedisLayer("from-default")`
- L208: `			require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L218: `	require.NoError(t, layer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L219: `	psLayer, err := cli.NewProfileSettingsLayer()`
- L221: `	require.NoError(t, psLayer.(schema.CobraSection).AddLayerToCobraCommand(rootCmd))`
- L228: `	const redisSlug LayerSlug = "redis"`
- L229: `	layer := newTestRedisLayer("from-default")`
- L247: `	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L255: `	const redisSlug LayerSlug = "redis"`
- L256: `	layer := newTestRedisLayer("from-default")`
- L275: `	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`
- L282: `	const redisSlug LayerSlug = "redis"`
- L283: `	layer := newTestRedisLayer("from-default")`
- L303: `	require.NoError(t, p.Register(redisSlug, layer, func(t *app) any { return &t.Redis }))`

### `pkg/cli/cli.go`
- L10: `func NewCreateCommandSettingsLayer() (schema.Section, error) {`
- L11: `	createCommandSettingsLayer, err := schema.NewSection(`
- L36: `	return createCommandSettingsLayer, nil`
- L52: `func NewProfileSettingsLayer() (schema.Section, error) {`
- L53: `	profileSettingsLayer, err := schema.NewSection(`
- L73: `	return profileSettingsLayer, nil`
- L79: `	PrintParsedParameters  bool   `glazed:"print-parsed-parameters"``
- L80: `	LoadParametersFromFile string `glazed:"load-parameters-from-file"``
- L87: `func NewCommandSettingsLayer() (schema.Section, error) {`
- L88: `	glazedMinimalCommandLayer, err := schema.NewSection(`
- L98: `				"print-parsed-parameters",`
- L100: `				fields.WithHelp("Print the parsed parameters"),`
- L102: `			// Deprecated: legacy per-command parameter file injection (removed from default flow)`
- L119: `	return glazedMinimalCommandLayer, nil`

### `pkg/cli/cliopatra/capture.go`
- L10: `func getCliopatraParameters(`
- L12: `	ps *fields.ParsedParameters,`
- L14: `) []*Parameter {`
- L15: `	ret := []*Parameter{}`
- L32: `		param := &Parameter{`
- L65: `// the description and the parsed layers a glazed command.`
- L67: `// It will go over all the ParameterDefinition (from all layers, which now also include the default layers).`
- L69: `// of layered fields.`
- L71: `// Values in the parameter map that are not present under the form of a ParameterDefinition`
- L76: `	parsedLayers *values.Values,`
- L84: `	description.Layers.ForEach(func(_ string, layer schema.Section) {`
- L85: `		if layer.GetSlug() == "glazed-command" {`
- L89: `		parsedLayer, ok := parsedLayers.Get(layer.GetSlug())`
- L95: `		parameters_ := getCliopatraParameters(`
- L96: `			layer.GetDefinitions(),`
- L97: `			parsedLayer.Parameters,`
- L98: `			layer.GetPrefix())`
- L99: `		flags := []*Parameter{}`
- L100: `		arguments := []*Parameter{}`
- L102: `		for _, p := range parameters_ {`

### `pkg/cli/cliopatra/capture_test.go`
- L14: `func makeParsedDefaultLayer(desc *cmds.CommandDescription, ps *fields.ParsedParameters) *values.Values {`
- L15: `	defaultLayer, ok := desc.GetLayer(schema.DefaultSlug)`
- L22: `		Layer:      defaultLayer,`
- L23: `		Parameters: ps,`
- L38: `		makeParsedDefaultLayer(desc, fields.NewParsedParameters(fields.WithParsedParameter(testPd, "test", "foobar"))),`
- L61: `	p := NewProgramFromCapture(d, makeParsedDefaultLayer(d, fields.NewParsedParameters(fields.WithParsedParameter(pdTest, "test", "foobar"))))`
- L67: `	p = NewProgramFromCapture(d, makeParsedDefaultLayer(d, fields.NewParsedParameters(fields.WithParsedParameter(pdTest, "test", "foobar2"))))`
- L90: `		makeParsedDefaultLayer(d, fields.NewParsedParameters(`
- L91: `			fields.WithParsedParameter(pd1, "test", "foobar"),`
- L92: `			fields.WithParsedParameter(pd2, "test2", "foobar2"),`
- L117: `		makeParsedDefaultLayer(d,`
- L118: `			fields.NewParsedParameters(`
- L119: `				fields.WithParsedParameter(pd, "test", "foobar"))))`
- L147: `		makeParsedDefaultLayer(d, fields.NewParsedParameters(`
- L148: `			fields.WithParsedParameter(pd1, "test", "foobar"),`
- L149: `			fields.WithParsedParameter(pd2, "test2", "foobar2"),`
- L150: `			fields.WithParsedParameter(pd3, "test3", "foobar3"),`
- L151: `			fields.WithParsedParameter(pd4, "test4", "foobar4"),`
- L177: `func TestSingleLayer(t *testing.T) {`
- L179: `	layer, err2 := schema.NewSection("test-layer", "test-layer",`
- L187: `		cmds.WithLayersList(`
- L188: `			layer,`
- L193: `	ret.Set("test-layer", &values.SectionValues{`
- L194: `		Layer: layer,`
- L195: `		Parameters: fields.NewParsedParameters(`
- L196: `			fields.WithParsedParameter(pd, "test", "foobar"))})`

### `pkg/cli/cliopatra/program.go`
- L19: `// Parameter describes a cliopatra parameter, which can be either a flag or an argument.`
- L26: `type Parameter struct {`
- L42: `func (p *Parameter) Clone() *Parameter {`
- L66: `	Flags []*Parameter `yaml:"flags,omitempty"``
- L67: `	// Args is an ordered list of Parameters. The Flag field is ignored.`
- L68: `	Args []*Parameter `yaml:"args,omitempty"``
- L134: `func WithFlags(flags ...*Parameter) ProgramOption {`
- L140: `func WithAddFlags(flags ...*Parameter) ProgramOption {`
- L146: `func WithReplaceFlags(flags ...*Parameter) ProgramOption {`
- L164: `func WithArgs(args ...*Parameter) ProgramOption {`
- L170: `func WithAddArgs(args ...*Parameter) ProgramOption {`
- L176: `func WithReplaceArgs(args ...*Parameter) ProgramOption {`
- L248: `	clone.Flags = make([]*Parameter, len(p.Flags))`
- L252: `	clone.Args = make([]*Parameter, len(p.Args))`
- L319: `	parsedLayers *values.Values,`
- L331: `	ps := parsedLayers.GetAllParsedParameters()`
- L393: `func (p *Program) ComputeArgs(ps *fields.ParsedParameters) ([]string, error) {`
- L420: `		parsedParameter, ok := ps.Get(flag.Name)`
- L425: `			value_, err = parsedParameter.RenderValue()`

### `pkg/cli/cobra-parser.go`
- L20: `// It is mostly used to add a "load from json" layer set in the GlazedCommandSettings.`
- L22: `	parsedCommandLayers *values.Values,`
- L28: `// the middlewares used in a Cobra command. It handles parsing parameters`
- L30: `// default values. The middlewares gather all these parameters into a`
- L31: `// ParsedParameters object.`
- L33: `// If the commandSettings specify parameters to be loaded from a file, this gets added as a middleware.`
- L35: `	parsedCommandLayers *values.Values,`
- L40: `	err := parsedCommandLayers.InitializeStruct(CommandSettingsSlug, commandSettings)`
- L68: `// This returns a CobraParser that can be used to parse the registered Layers`
- L71: `	Layers *schema.Schema`
- L77: `	// This hooks allows the implementor to specify additional ways of loading parameters`
- L78: `	// (for example, sqleton loads the dbt and sql connection parameters from env as well).`
- L80: `	// List of layers to be shown in short help, empty: always show all`
- L81: `	shortHelpLayers []string`
- L82: `	// skipCommandSettingsLayer controls whether the CommandSettingsLayer should be automatically added`
- L83: `	skipCommandSettingsLayer bool`
- L84: `	// enableProfileSettingsLayer controls whether the ProfileSettingsLayer should be added`
- L85: `	enableProfileSettingsLayer bool`
- L86: `	// enableCreateCommandSettingsLayer controls whether the CreateCommandSettingsLayer should be added`
- L87: `	enableCreateCommandSettingsLayer bool`
- L93: `	ShortHelpLayers                  []string`
- L94: `	SkipCommandSettingsLayer         bool`
- L95: `	EnableProfileSettingsLayer       bool`
- L96: `	EnableCreateCommandSettingsLayer bool`
- L101: `	ConfigFilesFunc func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]string, error)`
- L115: `// NewCobraParserFromLayers creates a new CobraParser instance from a`
- L117: `// parameters specified in the Layers CommandDescription to the cobra command.`
- L118: `func NewCobraParserFromLayers(`
- L119: `	paramLayers *schema.Schema,`
- L124: `		Layers:                           paramLayers,`
- L126: `		shortHelpLayers:                  []string{},`
- L127: `		skipCommandSettingsLayer:         false,`
- L128: `		enableProfileSettingsLayer:       false,`
- L129: `		enableCreateCommandSettingsLayer: false,`
- L136: `		ret.shortHelpLayers = cfg.ShortHelpLayers`
- L137: `		ret.skipCommandSettingsLayer = cfg.SkipCommandSettingsLayer`
- L138: `		ret.enableProfileSettingsLayer = cfg.EnableProfileSettingsLayer`
- L139: `		ret.enableCreateCommandSettingsLayer = cfg.EnableCreateCommandSettingsLayer`
- L143: `			ret.middlewaresFunc = func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]cmd_sources.Middleware, error) {`
- L192: `				// Wrap resolver to bind parsedCommandLayers captured earlier`
- L194: `					return resolver(parsedCommandLayers, cmd_, args_)`
- L197: `					cmd_sources.LoadParametersFromResolvedFilesForCobra(`
- L215: `	// Only add the glazed command layer if not explicitly skipped`
- L216: `	if !ret.skipCommandSettingsLayer {`
- L217: `		commandSettingsLayer, err := NewCommandSettingsLayer()`
- L221: `		ret.Layers.Set(commandSettingsLayer.GetSlug(), commandSettingsLayer)`
- L224: `	// Only add the profile settings layer if explicitly enabled`
- L225: `	if ret.enableProfileSettingsLayer {`
- L226: `		profileSettingsLayer, err := NewProfileSettingsLayer()`
- L230: `		ret.Layers.Set(profileSettingsLayer.GetSlug(), profileSettingsLayer)`
- L233: `	// Only add the create command settings layer if explicitly enabled`
- L234: `	if ret.enableCreateCommandSettingsLayer {`
- L235: `		createCommandSettingsLayer, err := NewCreateCommandSettingsLayer()`
- L239: `		ret.Layers.Set(createCommandSettingsLayer.GetSlug(), createCommandSettingsLayer)`
- L246: `	// NOTE(manuel, 2024-01-03) Maybe add some middleware functionality to whitelist/blacklist the Layers/parameters that get added to the CLI`
- L247: `	// If we want to remove some parameters from the CLI args (for example some output settings or so)`
- L248: `	err := c.Layers.ForEachE(func(_ string, layer schema.Section) error {`
- L249: `		// check that layer is a CobraSection`
- L251: `		cobraLayer, ok := layer.(schema.CobraSection)`
- L253: `			log.Error().Str("layer", layer.GetName()).Msg("Layer is not a CobraSection")`
- L254: `			return errors.Errorf("layer %s is not a CobraSection", layer.GetName())`
- L257: `		err := cobraLayer.AddLayerToCobraCommand(cmd)`
- L259: `			log.Error().Err(err).Str("layer", layer.GetName()).Msg("Could not add layer to cobra command")`
- L269: `	if len(c.shortHelpLayers) > 0 {`
- L270: `		shortHelperLayer := strings.Join(c.shortHelpLayers, ",")`
- L271: `		cmd.Annotations["shortHelpLayers"] = shortHelperLayer`
- L283: `	parsedCommandLayers, err := ParseCommandSettingsLayer(cmd)`
- L290: `	middlewares_, err := c.middlewaresFunc(parsedCommandLayers, cmd, args)`
- L295: `	parsedLayers := values.New()`
- L296: `	err = cmd_sources.Execute(c.Layers, parsedLayers, middlewares_...)`
- L301: `	return parsedLayers, nil`
- L304: `// ParseGlazedCommandLayer parses the global glazed settings from the given cobra.Command, if not nil,`
- L306: `func ParseCommandSettingsLayer(cmd *cobra.Command) (*values.Values, error) {`
- L307: `	parsedLayers := values.New()`
- L308: `	commandSettingsLayer, err := NewCommandSettingsLayer()`
- L313: `	profileSettingsLayer, err := NewProfileSettingsLayer()`
- L318: `	createCommandSettingsLayer, err := NewCreateCommandSettingsLayer()`
- L323: `	commandSettingsLayers := schema.NewSchema(schema.WithSections(`
- L324: `		commandSettingsLayer,`
- L325: `		profileSettingsLayer,`
- L326: `		createCommandSettingsLayer,`
- L336: `	err = cmd_sources.Execute(commandSettingsLayers, parsedLayers, middlewares_...)`
- L341: `	return parsedLayers, nil`

### `pkg/cli/cobra.go`
- L28: `type CobraRunFunc func(ctx context.Context, parsedLayers *values.Values) error`
- L51: `		// Parse layers`
- L52: `		parsedLayers, err := parser.Parse(cmd, args)`
- L62: `		if minimalLayer, ok := parsedLayers.Get(CommandSettingsSlug); ok {`
- L63: `			var printYAML, printParsedParameters_, printSchema bool`
- L64: `			err = minimalLayer.InitializeStruct(commandSettings)`
- L67: `			printParsedParameters_ = commandSettings.PrintParsedParameters`
- L70: `			if printParsedParameters_ {`
- L71: `				printParsedParameters(parsedLayers)`
- L91: `		if createLayer, ok := parsedLayers.Get(CreateCommandSettingsSlug); ok {`
- L93: `			err = createLayer.InitializeStruct(createSettings)`
- L103: `					parsedLayers,`
- L149: `				layers_ := s.Description().Layers.Clone()`
- L154: `					Layers: layers_,`
- L187: `			glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L189: `				cobra.CheckErr(errors.New("glazed layer not found"))`
- L192: `			gp, err := settings.SetupTableProcessor(glazedLayer)`
- L194: `			_, err = settings.SetupProcessorOutput(gp, glazedLayer, os.Stdout)`
- L203: `			err = glazeCmd.RunIntoGlazeProcessor(ctx, parsedLayers, gp)`
- L224: `		err = runFunc(ctx, parsedLayers)`
- L251: `	// If the command implements GlazeCommand, ensure a glazed parameter layer is present`
- L253: `		originalLayers := description.Layers`
- L254: `		glazedLayers := originalLayers.Clone()`
- L255: `		if _, ok := glazedLayers.Get(settings.GlazedSlug); !ok {`
- L256: `			glLayer, err := settings.NewGlazedParameterLayers()`
- L260: `			glazedLayers.Set(settings.GlazedSlug, glLayer)`
- L264: `		newDesc.Layers = glazedLayers`
- L277: `	cobraParser, err := NewCobraParserFromLayers(description.Layers, &cfg.ParserCfg)`
- L384: `	runFunc := func(ctx context.Context, parsedLayers *values.Values) error {`
- L386: `			err := writerCmd.RunIntoWriter(ctx, parsedLayers, os.Stdout)`
- L396: `			err := bareCmd.Run(ctx, parsedLayers)`
- L503: `// WithCobraShortHelpLayers sets the layers shown in short help (deprecated)`
- L504: `func WithCobraShortHelpLayers(layers ...string) CobraOption {`
- L506: `		c.ParserCfg.ShortHelpLayers = layers`
- L544: `// WithSkipCommandSettingsLayer hides the command settings layer flags (deprecated)`
- L545: `func WithSkipCommandSettingsLayer() CobraOption {`
- L547: `		c.ParserCfg.SkipCommandSettingsLayer = true`
- L551: `// WithProfileSettingsLayer enables the profile settings layer (deprecated)`
- L552: `func WithProfileSettingsLayer() CobraOption {`
- L554: `		c.ParserCfg.EnableProfileSettingsLayer = true`
- L558: `// WithCreateCommandSettingsLayer enables the create-command settings layer (deprecated)`
- L559: `func WithCreateCommandSettingsLayer() CobraOption {`
- L561: `		c.ParserCfg.EnableCreateCommandSettingsLayer = true`

### `pkg/cli/helpers.go`
- L18: `// the glazed processing layer.`
- L21: `// abstraction to define your CLI applications, which allows you to use Layers and other nice features`
- L26: `	gpl, err := settings.NewGlazedParameterLayers()`
- L31: `	layers_ := schema.NewSchema(schema.WithSections(gpl))`
- L32: `	parser, err := NewCobraParserFromLayers(layers_, &CobraParserConfig{`
- L38: `	parsedLayers, err := parser.Parse(cmd, nil)`
- L43: `	parsedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L45: `		return nil, nil, errors.Errorf("layer %s not found", settings.GlazedSlug)`
- L48: `	gp, err := settings.SetupTableProcessor(parsedLayer)`
- L51: `	of, err := settings.SetupProcessorOutput(gp, parsedLayer, os.Stdout)`
- L58: `// the glazed processing layer to their CLI flags.`
- L59: `func AddGlazedProcessorFlagsToCobraCommand(cmd *cobra.Command, options ...settings.GlazeParameterLayerOption) error {`
- L60: `	gpl, err := settings.NewGlazedParameterLayers(options...)`
- L65: `	return gpl.AddLayerToCobraCommand(cmd)`
- L68: `func printParsedParameters(parsedLayers *values.Values) {`
- L69: `	layersMap := map[string]map[string]interface{}{}`
- L70: `	parsedLayers.ForEach(func(layerName string, layer *values.SectionValues) {`
- L72: `		layer.Parameters.ForEach(func(name string, parameter *fields.ParsedParameter) {`
- L74: `				"value": parameter.Value,`
- L76: `			logs := make([]map[string]interface{}, 0, len(parameter.Log))`
- L77: `			for _, l := range parameter.Log {`
- L92: `		layersMap[layerName] = params`
- L97: `	err := encoder.Encode(layersMap)`

### `pkg/cmds/alias/alias.go`
- L136: `func (a *CommandAlias) RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error {`
- L144: `	return glazeCommand.RunIntoGlazeProcessor(ctx, parsedLayers, gp)`
- L147: `func (a *CommandAlias) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {`
- L155: `	return writerCommand.RunIntoWriter(ctx, parsedLayers, w)`
- L177: `	newLayers := s.Layers.Clone()`
- L184: `		Layers:         newLayers,`

### `pkg/cmds/cmds.go`
- L26: `	Layers         *schema.Schema         `yaml:"layers,omitempty"``
- L77: `func WithLayersList(ls ...schema.Section) CommandDescriptionOption {`
- L80: `			c.Layers.Set(l.GetSlug(), l)`
- L85: `func WithLayers(ls *schema.Schema) CommandDescriptionOption {`
- L87: `		c.Layers.Merge(ls)`
- L91: `// WithSchema is an alias for WithLayers that accepts a schema.Schema.`
- L94: `	return WithLayers((*schema.Schema)(s))`
- L97: `// WithLayersMap registers layers using explicit slugs from the provided map.`
- L98: `// The map key is used as the registration slug. If a layer's internal slug`
- L102: `//   - Prefer cloning the layer and overriding the slug on the clone when the`
- L105: `//   - Otherwise, the layer is registered under the provided key as-is.`
- L108: `// from its internal slug, middlewares that derive parsed layer slugs from the`
- L109: `// layer's GetSlug() may use the internal slug instead of the registration key.`
- L112: `func WithLayersMap(m map[string]schema.Section) CommandDescriptionOption {`
- L116: `				// Try a generic clone: many wrapper types embed ParameterLayerImpl,`
- L117: `				// whose Clone returns *ParameterLayerImpl. If so, set the slug.`
- L121: `					c.Layers.Set(slug, impl)`
- L122: `					log.Debug().Str("slug", slug).Str("internalSlug", l.GetSlug()).Msg("WithLayersMap: cloned layer and set overridden slug")`
- L125: `				// Fallback: keep original layer but register under provided key.`
- L126: `				// Parsed layers may still use the internal slug when indexing.`
- L127: `				log.Warn().Str("slug", slug).Str("internalSlug", l.GetSlug()).Msg("WithLayersMap: registering layer with mismatched internal slug; parsed layers may use internal slug")`
- L129: `			c.Layers.Set(slug, l)`
- L134: `// WithFlags is a convenience function to add arguments to the default layer, useful`
- L135: `// to make the transition from explicit flags and arguments to a default layer a bit easier.`
- L140: `		layer, ok := c.GetDefaultLayer()`
- L143: `			layer, err = schema.NewSection(schema.DefaultSlug, "Flags")`
- L147: `			c.Layers.Set(layer.GetSlug(), layer)`
- L148: `			err = c.Layers.MoveToFront(layer.GetSlug())`
- L153: `		layer.AddFields(flags...)`
- L157: `// WithArguments is a convenience function to add arguments to the default layer, useful`
- L158: `// to make the transition from explicit flags and arguments to a default layer a bit easier.`
- L163: `		layer, ok := c.GetDefaultLayer()`
- L166: `			layer, err = schema.NewSection(schema.DefaultSlug, "Arguments")`
- L170: `			c.Layers.Set(layer.GetSlug(), layer)`
- L171: `			err = c.Layers.MoveToFront(layer.GetSlug())`
- L180: `		layer.AddFields(arguments...)`
- L190: `func WithReplaceLayers(layers_ ...schema.Section) CommandDescriptionOption {`
- L192: `		for _, l := range layers_ {`
- L193: `			c.Layers.Set(l.GetSlug(), l)`
- L231: `		Layers: schema.NewSchema(),`
- L254: `func (cd *CommandDescription) GetDefaultLayer() (schema.Section, bool) {`
- L255: `	return cd.GetLayer(schema.DefaultSlug)`
- L259: `	l, ok := cd.GetDefaultLayer()`
- L267: `	l, ok := cd.GetDefaultLayer()`
- L275: `// GetDefaultsMap returns a map of parameter names to their default values`
- L281: `	params, err := flags.ParsedParametersFromDefaults()`
- L286: `	argsParams, err := arguments.ParsedParametersFromDefaults()`
- L299: `func (cd *CommandDescription) GetLayer(name string) (schema.Section, bool) {`
- L300: `	return cd.Layers.Get(name)`
- L303: `func (cd *CommandDescription) Clone(cloneLayers bool, options ...CommandDescriptionOption) *CommandDescription {`
- L305: `	layers_ := schema.NewSchema()`
- L306: `	if cloneLayers {`
- L307: `		layers_ = cd.Layers.Clone()`
- L318: `		Layers:  layers_,`
- L343: `func (cd *CommandDescription) SetLayers(layers ...schema.Section) {`
- L344: `	for _, l := range layers {`
- L345: `		cd.Layers.Set(l.GetSlug(), l)`
- L356: `	Metadata(ctx context.Context, parsedLayers *values.Values) (map[string]interface{}, error)`
- L368: `	Run(ctx context.Context, parsedLayers *values.Values) error`
- L373: `	RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error`
- L380: `	// NOTE(manuel, 2023-02-27) We can probably simplify this to only take parsed layers`
- L382: `	// The ps and GlazeProcessor calls could be replaced by a GlazeCommand specific layer,`
- L384: `	// is just something created by the passed in GlazeLayer anyway.`
- L392: `	RunIntoGlazeProcessor(ctx context.Context, parsedLayers *values.Values, gp middlewares.Processor) error`

### `pkg/cmds/cobra_test.go`
- L22: `	err := definitions.AddParametersToCobraCommand(cmd, "")`
- L30: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L40: `		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),`
- L42: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L66: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L81: `	desc := NewCommandDescription("test", WithLayersList(defaultLayer))`
- L82: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L113: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L129: `		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),`
- L131: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L168: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L178: `	desc := NewCommandDescription("test", WithLayersList(defaultLayer))`
- L179: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L204: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L215: `		Layers: schema.NewSchema(schema.WithSections(defaultLayer)),`
- L217: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L262: `		defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L272: `		err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L282: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L293: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L304: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L316: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L322: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L332: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L343: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L353: `	desc := NewCommandDescription("test", WithLayersList(defaultLayer))`
- L354: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L383: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L395: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L401: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L411: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L422: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L436: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L447: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L461: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L471: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L486: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L497: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L510: `	err = defaultLayer.AddLayerToCobraCommand(cmd)`
- L515: `// which is a list of parsed flag parameters, a list of parsed arguments parameters,`
- L521: `	ExpectedArgumentParameters map[string]interface{} `yaml:"argumentParameters"``
- L522: `	ExpectedFlagParameters     map[string]interface{} `yaml:"flagParameters"``
- L556: `		layer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L561: `		testSuite.Description.Layers = schema.NewSchema(schema.WithSections(layer))`
- L570: `			if test2.ExpectedArgumentParameters == nil {`
- L571: `				test2.ExpectedArgumentParameters = map[string]interface{}{}`
- L573: `			if test2.ExpectedFlagParameters == nil {`
- L574: `				test2.ExpectedFlagParameters = map[string]interface{}{}`
- L593: `	var flagParameters *fields.ParsedParameters`
- L594: `	var argumentParameters *fields.ParsedParameters`
- L598: `			flagParameters, flagsError = desc.GetDefaultFlags().GatherFlagsFromCobraCommand(cmd, false, false, "")`
- L602: `			argumentParameters, argsError = desc.GetDefaultArguments().GatherArguments(args, false, false)`
- L609: `	defaultLayer, ok := desc.GetDefaultLayer()`
- L611: `	defaultLayer_, ok := defaultLayer.(schema.CobraSection)`
- L614: `	err := defaultLayer_.AddLayerToCobraCommand(cmd)`
- L646: `	assertJsonEquivalent(t, expected.ExpectedArgumentParameters, argumentParameters)`
- L647: `	assertJsonEquivalent(t, expected.ExpectedFlagParameters, flagParameters)`

### `pkg/cmds/fields/cobra.go`
- L13: `// GenerateUseString creates a string representation of the 'Use' field for a given cobra command and a list of parameter definitions. The first word of the existing 'Use' field is treated as the verb for the command.`
- L15: `//   - Required parameters are enclosed in '<>'.`
- L16: `//   - Optional parameters are enclosed in '[]'.`
- L17: `//   - Optional parameters that accept multiple input (TypeStringList or TypeIntegerList) are followed by '...'.`
- L18: `//   - If a parameter has a default value, it is specified after parameter name like 'parameter (default: value)'.`
- L21: `//   - If there is a required parameter 'name', and an optional parameter 'age' with a default value of '30', the resulting string will be: 'verb <name> [age (default: 30)]'.`
- L22: `//   - If there is a required parameter 'name', and an optional parameter 'colors' of type TypeStringList, the resulting Use string will be: 'verb <name> [colors...]'`
- L85: `		_, err := argument.CheckParameterDefaultValueValidity()`
- L120: `// AddParametersToCobraCommand takes the parameters from a CommandDescription and converts them`
- L121: `// to cobra flags, before adding them to the Parameters() of a the passed cobra command.`
- L122: `func (pds *Definitions) AddParametersToCobraCommand(`
- L133: `	err = pds.GetFlags().ForEachE(func(parameter *Definition) error {`
- L134: `		_, err := parameter.CheckParameterDefaultValueValidity()`
- L136: `			return errors.Wrapf(err, "Invalid default value for argument %s", parameter.Name)`
- L139: `		flagName := prefix + parameter.Name`
- L142: `		shortFlag := parameter.ShortFlag`
- L154: `		helpText := parameter.Help`
- L155: `		helpText = fmt.Sprintf("%s - <%s>", helpText, parameter.Type)`
- L157: `		switch parameter.Type {`
- L165: `			if parameter.ShortFlag != "" {`
- L177: `			if parameter.ShortFlag != "" {`
- L186: `			if parameter.Default != nil {`
- L187: `				defaultValue, err = cast.ToString(*parameter.Default)`
- L189: `					return errors.Errorf("Default value for parameter %s is not a string: %v", parameter.Name, *parameter.Default)`
- L193: `			if parameter.ShortFlag != "" {`
- L201: `			if parameter.Default != nil {`
- L202: `				defaultValue, ok = cast.CastNumberInterfaceToInt[int](*parameter.Default)`
- L204: `					return errors.Errorf("Default value for parameter %s is not an integer: %v", parameter.Name, *parameter.Default)`
- L208: `			if parameter.ShortFlag != "" {`
- L217: `			if parameter.Default != nil {`
- L218: `				defaultValue, ok = cast.CastFloatInterfaceToFloat[float64](*parameter.Default)`
- L220: `					return errors.Errorf("Default value for parameter %s is not a float: %v", parameter.Name, *parameter.Default)`
- L224: `			if parameter.ShortFlag != "" {`
- L233: `			if parameter.Default != nil {`
- L234: `				defaultValue, ok = (*parameter.Default).(bool)`
- L236: `					return errors.Errorf("Default value for parameter %s is not a bool: %v", parameter.Name, *parameter.Default)`
- L240: `			if parameter.ShortFlag != "" {`
- L249: `			if parameter.Default != nil {`
- L250: `				switch v_ := (*parameter.Default).(type) {`
- L261: `					return errors.Errorf("Default value for parameter %s is not a valid date: %v", parameter.Name, *parameter.Default)`
- L265: `			if parameter.ShortFlag != "" {`
- L274: `			if parameter.Default != nil {`
- L275: `				stringList, ok := (*parameter.Default).([]string)`
- L277: `					defaultValue, ok := (*parameter.Default).([]interface{})`
- L279: `						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)`
- L285: `						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)`
- L292: `			if parameter.ShortFlag != "" {`
- L301: `			if parameter.Default != nil {`
- L302: `				stringMap, ok := (*parameter.Default).(map[string]string)`
- L304: `					defaultValue, ok := (*parameter.Default).(map[string]interface{})`
- L306: `						return errors.Errorf("Default value for parameter %s is not a string list: %v", parameter.Name, *parameter.Default)`
- L325: `				return errors.Wrapf(err, "Could not convert default value for parameter %s to string list: %v", parameter.Name, *parameter.Default)`
- L328: `			if parameter.ShortFlag != "" {`
- L336: `			if parameter.Default != nil {`
- L337: `				defaultValue, ok = cast.CastInterfaceToIntList[int](*parameter.Default)`
- L339: `					return errors.Errorf("Default value for parameter %s is not an integer list: %v", parameter.Name, *parameter.Default)`
- L343: `			if parameter.ShortFlag != "" {`
- L351: `			if parameter.Default != nil {`
- L352: `				defaultValue, ok = cast.CastInterfaceToFloatList[float64](*parameter.Default)`
- L354: `					return errors.Errorf("Default value for parameter %s is not a float list: %v", parameter.Name, *parameter.Default)`
- L357: `			if parameter.ShortFlag != "" {`
- L366: `			if parameter.Default != nil {`
- L367: `				defaultValue, err = cast.ToString(*parameter.Default)`
- L369: `					return errors.Errorf("Default value for parameter %s is not a string: %v", parameter.Name, *parameter.Default)`
- L373: `			choiceString := strings.Join(parameter.Choices, ",")`
- L375: `			if parameter.ShortFlag != "" {`
- L382: `			return errors.Errorf("Unknown parameter type for parameter %s: %s", parameter.Name, parameter.Type)`
- L395: `// to the parameter description passed in params. The result is a map of parameter`
- L398: `// If onlyProvided is true, only parameters that are provided`
- L401: `// If a parameter cannot be parsed correctly, or is missing even though it is not optional,`
- L404: `// The required argument checks that all the required parameter definitions are present.`
- L413: `) (*ParsedParameters, error) {`
- L414: `	ps := NewParsedParameters()`
- L417: `		p := &ParsedParameter{`
- L435: `				return errors.Errorf("Parameter %s is required", pd.Name)`
- L468: `			v2, err := pd.ParseParameter([]string{v}, options...)`
- L515: `			v2, err := pd.ParseParameter(v, options...)`
- L552: `				v2, err := pd.ParseParameter(v, options...)`

### `pkg/cmds/fields/errors.go`
- L12: `	return fmt.Sprintf("invalid value %v for parameter %s of type %s", e.Value, e.Name, e.Type)`

### `pkg/cmds/fields/gather-arguments.go`
- L13: `// Only the last parameter definitions can be a list parameter type.`
- L28: `) (*ParsedParameters, error) {`
- L30: `	result := NewParsedParameters()`
- L38: `		p := &ParsedParameter{`
- L70: `		i2, err := argument.ParseParameter(v, parseOptions...)`

### `pkg/cmds/fields/gather-arguments_test.go`
- L31: `// Test the parsing of every kind of parameter type for provided args`
- L32: `// This should be broken down into individual tests for each parameter types.`
- L49: `// Test parsing of list-type parameter with multiple arguments`
- L50: `func TestGatherArguments_ListParameterParsing(t *testing.T) {`
- L261: `func TestSingleParametersFollowedByListDefaults(t *testing.T) {`
- L286: `func TestThreeSingleParametersFollowedByListDefaults(t *testing.T) {`
- L327: `func TestThreeSingleParametersFollowedByListDefaultsOnlyTwoValues(t *testing.T) {`

### `pkg/cmds/fields/gather-parameters.go`
- L9: `// GatherParametersFromMap gathers parameter values from a map.`
- L13: `// - If the parameter is missing and required, an error is returned.`
- L14: `// - If the parameter is missing and optional, the default value is used.`
- L17: `// Values are looked up by parameter name, as well as short flag if provided.`
- L19: `// The returned map contains the gathered parameter values, with defaults filled in`
- L21: `func (pds *Definitions) GatherParametersFromMap(`
- L25: `) (*ParsedParameters, error) {`
- L26: `	ret := NewParsedParameters()`
- L29: `		parsed := &ParsedParameter{`
- L52: `					return errors.Errorf("Missing required parameter %s", p.Name)`
- L62: `			v__, err := p.ParseParameter([]string{s})`
- L64: `				return errors.Wrapf(err, "Invalid value for parameter %s", p.Name)`
- L72: `			return errors.Wrapf(err, "Invalid value for parameter %s", p.Name)`

### `pkg/cmds/fields/gather-parameters_test.go`
- L14: `	ParameterDefs []*Definition `yaml:"parameterDefs"``
- L15: `	// The actual map fromwhich the parameters are gathered`
- L17: `	// Only gather parameters that are provided in the map`
- L25: `var gatherParametersYAML string`
- L27: `func TestGatherParametersFromMap(t *testing.T) {`
- L28: `	tests, err := yaml.LoadTestFromYAML[[]TestCase](gatherParametersYAML)`
- L33: `			pds := NewDefinitions(WithDefinitionList(tt.ParameterDefs))`
- L35: `			parsedParameters, err := pds.GatherParametersFromMap(tt.Data, tt.OnlyProvided)`
- L41: `				require.Equal(t, tt.ExpectedResult, parsedParameters.ToMap())`

### `pkg/cmds/fields/initialize-struct.go`
- L55: `// InitializeStruct initializes a struct from a ParsedParameters map.`
- L59: `// parameter value in the ParsedParameters map and set the field's value.`
- L61: `// If the tag open `from_json` is appended to `glazed` and the parameter`
- L64: `// If the tag contains a wildcard, the function will match parameter names against the`
- L76: `// ps is the ParsedParameters map to lookup parameter values from.`
- L130: `// - A tagged field does not have a matching parameter value in ps`
- L132: `func (p *ParsedParameters) InitializeStruct(s interface{}) error {`
- L160: `				return errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)`
- L166: `			parameter, ok := p.Get(options.Name)`
- L171: `			if err := p.setTargetValue(dst, parameter.Value, options.FromJson); err != nil {`
- L179: `// setWildcardValues matches parameter names from ParsedParameters against a supplied pattern using the`
- L187: `// using the parameter name as the key and the parameter value as the map value.`
- L191: `// Parameters:`
- L192: `//   - dst: A reflect.Value acting as the container for storing the matched keys and their parameter values.`
- L193: `//   - pattern: String pattern used for matching parameter names. It can include literal characters,`
- L195: `func (p *ParsedParameters) setWildcardValues(dst reflect.Value, pattern string, fromJson bool) error {`
- L208: `	err := p.ForEachE(func(paramName string, parameter *ParsedParameter) error {`
- L210: `			// Check if the type of parameter.Value is compatible with the map's value type`
- L211: `			if reflect.TypeOf(parameter.Value) != elemType {`
- L212: `				return errors.Errorf("type mismatch: expected type %s, got %s", elemType, reflect.TypeOf(parameter.Value))`
- L215: `			paramValue := reflect.ValueOf(parameter.Value)`
- L217: `			// Check if the type of parameter.Value is directly assignable to the map's value type`
- L219: `				// Check if the type of parameter.Value can be converted to the map's value type`
- L281: `func (p *ParsedParameters) handleFromJSON(dst reflect.Value, value interface{}) error {`
- L307: `func (p *ParsedParameters) handleFileData(dst reflect.Value, value interface{}) (bool, error) {`
- L389: `func (p *ParsedParameters) setTargetValue(dst reflect.Value, value interface{}, fromJson bool) error {`
- L482: `				return nil, errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)`

### `pkg/cmds/fields/initialize-struct_test.go`
- L17: `// TestInitializeStructWithValidStruct tests initializing a struct with valid parameters`
- L19: `	parsedParams := fields.NewParsedParameters(`
- L20: `		fields.WithParsedParameter(`
- L26: `		fields.WithParsedParameter(`
- L44: `	parsedParams := &fields.ParsedParameters{}`
- L54: `	parsedParams := &fields.ParsedParameters{}`
- L65: `	parsedParams := &fields.ParsedParameters{}`
- L74: `// TestInitializeStructWithMissingParameters tests initializing a struct with missing parameters`
- L75: `func TestInitializeStructWithMissingParameters(t *testing.T) {`
- L76: `	parsedParams := fields.NewParsedParameters(`
- L77: `		fields.WithParsedParameter(`
- L100: `	parsedParams := fields.NewParsedParameters(`
- L101: `		fields.WithParsedParameter(`
- L123: `	parsedParams := fields.NewParsedParameters(`
- L124: `		fields.WithParsedParameter(`
- L146: `	parsedParams := fields.NewParsedParameters(`
- L147: `		fields.WithParsedParameter(`
- L169: `	parsedParams := fields.NewParsedParameters(`
- L170: `		fields.WithParsedParameter(`
- L199: `	parsedParams := fields.NewParsedParameters(`
- L200: `		fields.WithParsedParameter(`
- L222: `	parsedParams := fields.NewParsedParameters(`
- L223: `		fields.WithParsedParameter(`
- L244: `// TestInitializeStructWithWildcardMultipleMatches tests wildcard pattern matching multiple parameters`
- L246: `	parsedParams := fields.NewParsedParameters(`
- L247: `		fields.WithParsedParameter(`
- L253: `		fields.WithParsedParameter(`
- L271: `// TestInitializeStructWithWildcardNoMatches tests wildcard pattern matching no parameters`
- L273: `	parsedParams := fields.NewParsedParameters()`
- L288: `	parsedParams := fields.NewParsedParameters(`
- L289: `		fields.WithParsedParameter(`
- L301: `	assert.Contains(t, err.Error(), "wildcard parameters require a map field")`
- L310: `	parsedParams := fields.NewParsedParameters(`
- L311: `		fields.WithParsedParameter(`
- L317: `		fields.WithParsedParameter(`
- L334: `	parsedParams := fields.NewParsedParameters(`
- L335: `		fields.WithParsedParameter(`
- L358: `	parsedParams := fields.NewParsedParameters(`
- L359: `		fields.WithParsedParameter(`
- L365: `		fields.WithParsedParameter(`
- L371: `		fields.WithParsedParameter(`
- L395: `	parsedParams := fields.NewParsedParameters(`
- L396: `		fields.WithParsedParameter(`
- L451: `	assert.Contains(t, err.Error(), "wildcard parameters require a map field")`
- L528: `	parsedParams := fields.NewParsedParameters(`
- L529: `		fields.WithParsedParameter(`
- L563: `	parsedParams := fields.NewParsedParameters(`
- L564: `		fields.WithParsedParameter(`
- L591: `	parsedParams := fields.NewParsedParameters(`
- L592: `		fields.WithParsedParameter(`
- L617: `	parsedParams := fields.NewParsedParameters(`
- L618: `		fields.WithParsedParameter(`
- L643: `	parsedParams := fields.NewParsedParameters(`
- L644: `		fields.WithParsedParameter(`
- L679: `	parsedParams := fields.NewParsedParameters(`
- L680: `		fields.WithParsedParameter(`
- L706: `	parsedParams := fields.NewParsedParameters(`
- L707: `		fields.WithParsedParameter(`
- L746: `	parsedParams := fields.NewParsedParameters(`
- L747: `		fields.WithParsedParameter(`

### `pkg/cmds/fields/parameter-type.go`
- L49: `// NeedsFileContent returns true if the parameter type is one that loads one or more files, when provided with the given`
- L71: `// NeedsMultipleFileContent returns true if the parameter type is one that loads multiple files.`
- L98: `// IsList returns true if the parameter has to be parsed from a list of strings,`

### `pkg/cmds/fields/parameters.go`
- L16: `// Definition is a declarative way of describing a command line parameter.`
- L71: `	parameterType Type,`
- L76: `		Type: parameterType,`
- L87: `	return fmt.Sprintf("{Parameter: %s - %s}", p.Name, p.Type)`
- L124: `		return errors.Errorf("invalid value for parameter %s: %v", p.Name, value.Interface())`
- L151: `// InitializeValueToEmptyValue initializes the given value to the empty value of the type of the parameter.`
- L182: `		return errors.Errorf("unknown parameter type %s", p.Type)`
- L189: `// various supported parameter types.`
- L200: `			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, v)`
- L207: `			return errors.Errorf("expected bool value for parameter %s, got %T", p.Name, v)`
- L220: `			return errors.Errorf("expected string list for parameter %s, got %T", p.Name, v)`
- L227: `			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, v)`
- L231: `			return errors.Wrapf(err, "error parsing value for parameter %s", p.Name)`
- L244: `			return errors.Errorf("expected list of files for parameter %s, got %T", p.Name, v)`
- L251: `			return errors.Errorf("expected list of maps for parameter %s, got %T", p.Name, v)`
- L258: `			return errors.Errorf("expected map for parameter %s, got %T", p.Name, v)`
- L265: `			return errors.Errorf("expected map for parameter %s, got %T", p.Name, v)`
- L269: `			return errors.Errorf("expected map of strings for parameter %s, got %T", p.Name, v)`
- L274: `		return errors.Errorf("unknown parameter type %s", p.Type)`
- L279: `// ParsedParametersFromDefaults uses the parameter definitions default values to create a ParsedParameters`
- L281: `func (pds *Definitions) ParsedParametersFromDefaults() (*ParsedParameters, error) {`
- L282: `	ret := NewParsedParameters()`
- L302: `// InitializeStructFromDefaults initializes a struct from a map of parameter definitions.`
- L308: `	parsedParameters, err := pds.ParsedParametersFromDefaults()`
- L312: `	return parsedParameters.InitializeStruct(s)`
- L315: `// InitializeDefaultsFromStruct initializes the parameters definitions from a struct.`
- L317: `// the default value of the corresponding definition in `parameterDefinitions`.`
- L355: `						return errors.Errorf("wildcard parameters require a map field, field %s is not a map", field.Name)`
- L358: `						return errors.Errorf("wildcard parameters require a map of strings, field %s is not a map of strings", field.Name)`
- L378: `		parameter, ok := pds.Get(tagOptions.Name)`
- L380: `			return errors.Errorf("unknown parameter %s when initializing defaults from struct", tag)`
- L384: `		err = parameter.SetDefaultFromValue(value)`
- L397: `		parameter, ok := pds.Get(k)`
- L399: `			return errors.Errorf("unknown parameter when initializing defaults from map: %s", k)`
- L401: `		err := parameter.SetDefaultFromValue(reflect.ValueOf(v))`
- L410: `// CheckParameterDefaultValueValidity checks if the Definition's Default is valid.`
- L412: `func (p *Definition) CheckParameterDefaultValueValidity() (interface{}, error) {`
- L421: `		return nil, errors.Wrapf(err, "invalid default value for parameter %s", p.Name)`
- L444: `			return nil, errors.Errorf("Value for parameter %s is not a string: %v", p.Name, v)`
- L453: `			return nil, errors.Errorf("Value for parameter %s (type %T) is not a list of objects: %v", p.Name, v, v)`
- L460: `			return nil, errors.Errorf("Value for parameter %s is not an object: %v", p.Name, v)`
- L467: `			return nil, errors.Errorf("Value for parameter %s is not an integer: %v", p.Name, v)`
- L474: `			return nil, errors.Errorf("Value for parameter %s is not a float: %v", p.Name, v)`
- L481: `			return nil, errors.Errorf("Value for parameter %s is not a bool: %v", p.Name, v)`
- L490: `				return nil, errors.Wrapf(err, "Value for parameter %s is not a valid date: %v", p.Name, v)`
- L496: `			return nil, errors.Errorf("Value for parameter %s is not a valid date: %v", p.Name, v)`
- L502: `			return nil, errors.Errorf("Value for parameter %s is not a file (got type %T): %v", p.Name, v, v)`
- L509: `			return nil, errors.Errorf("Value for parameter %s is not a file list: %v", p.Name, v)`
- L522: `				return nil, errors.Errorf("Value for parameter %s is not a string list: %v", p.Name, v)`
- L528: `				return nil, errors.Errorf("Value for parameter %s is not a string list: %v", p.Name, v)`
- L537: `			return nil, errors.Errorf("Default value for parameter %s is not an integer list: %v", p.Name, v)`
- L544: `			return nil, errors.Errorf("Value for parameter %s is not a float list: %v", p.Name, v)`
- L550: `			return nil, errors.Errorf("Definition %s is a choice parameter but has no choices", p.Name)`
- L555: `			return nil, errors.Errorf("Value for parameter %s is not a string: %v", p.Name, v)`
- L566: `			return nil, errors.Errorf("Definition %s is a choice parameter but has no choices", p.Name)`
- L571: `			return nil, errors.Errorf("Value for parameter %s is not a choice list: %v", p.Name, v)`
- L590: `			return nil, errors.Errorf("Value for parameter %s is not a key value map: %v", p.Name, v)`
- L595: `			return nil, errors.Errorf("Value for parameter %s is not a key value map: %v", p.Name, v)`
- L600: `		return nil, errors.Errorf("unknown parameter type %s", p.Type)`
- L610: `	return errors.Errorf("Value %s is not a valid choice for parameter %s. Valid choices are: %v", choice, p.Name, p.Choices)`
- L617: `	parameters_ := NewDefinitions()`
- L620: `	var parameters []*Definition`
- L622: `	err = yaml.Unmarshal(yamlContent, &parameters)`
- L627: `	for _, p := range parameters {`
- L628: `		_, err := p.CheckParameterDefaultValueValidity()`
- L630: `			panic(errors.Wrap(err, "Failed to check parameter default value validity"))`
- L632: `		parameters_.Set(p.Name, p)`
- L635: `	return parameters_`
- L645: `func WithDefinitions(parameterDefinitions *Definitions) DefinitionsOption {`
- L647: `		p.Merge(parameterDefinitions)`
- L651: `func WithDefinitionList(parameterDefinitions []*Definition) DefinitionsOption {`
- L653: `		for _, pd := range parameterDefinitions {`
- L672: `// The parameter definitions are cloned as well.`
- L677: `// Merge merges the parameter definitions from m into p.`
- L678: `// It clones each parameter definition before adding it to p`
- L688: `// fields. The parameter definitions are not cloned.`
- L718: `// fields. The parameter definitions are not cloned.`
- L731: `// ForEachE calls the given function f on each parameter definition in p.`
- L744: `// ForEach calls the given function f on each parameter definition in p.`
- L760: `	var parameterDefinitions []*Definition`
- L761: `	err := value.Decode(&parameterDefinitions)`
- L766: `	for _, pd_ := range parameterDefinitions {`
- L782: `			return errors.Errorf("expected string value for parameter %s, got %T", p.Name, value)`
- L789: `			return errors.Errorf("expected bool value for parameter %s, got %T", p.Name, value)`
- L802: `			return errors.Errorf("expected string list for parameter %s, got %T", p.Name, value)`
- L809: `			return errors.Errorf("expected time.Time value for parameter %s, got %T", p.Name, value)`
- L822: `			return errors.Errorf("expected list of files for parameter %s, got %T", p.Name, value)`
- L829: `			return errors.Errorf("expected list of maps for parameter %s, got %T", p.Name, value)`
- L836: `			return errors.Errorf("expected map for parameter %s, got %T", p.Name, value)`
- L843: `			return errors.Errorf("expected map of strings for parameter %s, got %T", p.Name, value)`
- L848: `		return errors.Errorf("unknown parameter type %s", p.Type)`

### `pkg/cmds/fields/parameters_from_defaults_test.go`
- L12: `func TestParsedParametersFromDefaults_BasicTypes(t *testing.T) {`
- L15: `		parameterDefinitions *Definitions`
- L21: `			parameterDefinitions: NewDefinitions(`
- L61: `			parameterDefinitions: NewDefinitions(`
- L83: `			result, err := tt.parameterDefinitions.ParsedParametersFromDefaults()`
- L94: `				assert.True(t, ok, "parameter %s should exist", paramName)`
- L95: `				assert.Equal(t, expectedValue, param.Value, "parameter %s should have correct value", paramName)`
- L98: `			// Special check for date parameter in the first test case`
- L101: `				assert.True(t, ok, "date parameter should exist")`
- L103: `				assert.True(t, ok, "date parameter should be time.Time")`
- L111: `func TestParsedParametersFromDefaults_EdgeCases(t *testing.T) {`
- L114: `		parameterDefinitions *Definitions`
- L119: `			name:                 "empty parameter definitions",`
- L120: `			parameterDefinitions: NewDefinitions(),`
- L125: `			parameterDefinitions: NewDefinitions(`
- L143: `			parameterDefinitions: NewDefinitions(`
- L172: `			result, err := tt.parameterDefinitions.ParsedParametersFromDefaults()`
- L180: `			// Check that we have exactly the expected number of parameters`
- L182: `				"number of parameters should match expected")`
- L187: `				assert.True(t, ok, "parameter %s should exist", paramName)`
- L188: `				assert.Equal(t, expectedValue, param.Value, "parameter %s should have correct value", paramName)`
- L194: `func TestParsedParametersFromDefaults_ListTypes(t *testing.T) {`
- L221: `	result, err := pd.ParsedParametersFromDefaults()`
- L227: `	assert.True(t, ok, "string-list parameter should exist")`
- L232: `	assert.True(t, ok, "integer-list parameter should exist")`
- L237: `	assert.True(t, ok, "choice-list parameter should exist")`
- L242: `	assert.True(t, ok, "float-list parameter should exist")`
- L246: `func TestParsedParametersFromDefaults_MapTypes(t *testing.T) {`
- L262: `	result, err := pd.ParsedParametersFromDefaults()`
- L268: `	assert.True(t, ok, "key-value parameter should exist")`
- L273: `	assert.True(t, ok, "object-from-file parameter should exist")`
- L277: `func TestParsedParametersFromDefaults_FileLoadingTypes(t *testing.T) {`
- L296: `	result, err := pd.ParsedParametersFromDefaults()`
- L302: `	assert.True(t, ok, "string-list-from-file parameter should exist")`
- L307: `	assert.True(t, ok, "object-list-from-file parameter should exist")`
- L314: `func TestParsedParametersFromDefaults_EmptyCollections(t *testing.T) {`
- L335: `	result, err := pd.ParsedParametersFromDefaults()`
- L341: `	assert.True(t, ok, "empty-string-list parameter should exist")`
- L346: `	assert.True(t, ok, "empty-key-value parameter should exist")`
- L351: `	assert.True(t, ok, "empty-object parameter should exist")`
- L355: `func TestParsedParametersFromDefaults_NilComplexTypes(t *testing.T) {`
- L417: `	result, err := pd.ParsedParametersFromDefaults()`
- L421: `	// All parameters should be excluded since they have nil defaults`
- L422: `	assert.Equal(t, 0, result.Len(), "no parameters should be included")`
- L424: `	// Verify each parameter is not present`
- L434: `		assert.False(t, ok, "parameter %s should not exist", name)`

### `pkg/cmds/fields/parameters_test.go`
- L15: `//go:embed "test-data/parameters_test.yaml"`
- L18: `var testParameterDefinitions *Definitions`
- L26: `	parameterDefinition *Definition`
- L32: `//go:embed "test-data/parameters_validity_test.yaml"`
- L35: `var testParameterValidList []*ValidityTest`
- L45: `		test.parameterDefinition = &Definition{`
- L58: `var testParametersTypesYaml []byte`
- L67: `func loadParameterTypeTests(yamlData []byte) ([]TypeTest, error) {`
- L76: `var testParameterTypeTests []TypeTest`
- L78: `func initialParameterTests() {`
- L79: `	testParameterDefinitions = LoadDefinitionsFromYAML(testFlagsYaml)`
- L81: `	testParameterValidList, err = loadValidityTestDataFromYAML(validityTestYaml)`
- L86: `	testParameterTypeTests, err = loadParameterTypeTests(testParametersTypesYaml)`
- L92: `func TestParameterTypes(t *testing.T) {`
- L93: `	initialParameterTests()`
- L94: `	for _, test := range testParameterTypeTests {`
- L103: `func TestParameterValidity(t *testing.T) {`
- L104: `	initialParameterTests()`
- L105: `	for _, validityTest := range testParameterValidList {`
- L107: `			_, err := validityTest.parameterDefinition.CheckValueValidity(validityTest.Value)`
- L118: `	initialParameterTests()`
- L119: `	intFlag, _ := testParameterDefinitions.Get("int-flag")`
- L130: `	intFlag, _ = testParameterDefinitions.Get("int-flag-without-default")`
- L137: `	intFlag, _ = testParameterDefinitions.Get("int-flag-with-empty-default")`
- L144: `	initialParameterTests()`
- L145: `	intFlag, _ := testParameterDefinitions.Get("int-flag")`
- L156: `	intFlag, _ = testParameterDefinitions.Get("int-flag-without-default")`
- L163: `	intFlag, _ = testParameterDefinitions.Get("int-flag-with-empty-default")`
- L171: `	initialParameterTests()`
- L172: `	floatFlag, _ := testParameterDefinitions.Get("float-flag")`
- L183: `	floatFlag, _ = testParameterDefinitions.Get("float-flag-without-default")`
- L190: `	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-empty-default")`
- L195: `	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-int-default")`
- L202: `	initialParameterTests()`
- L203: `	floatFlag, _ := testParameterDefinitions.Get("float-flag")`
- L214: `	floatFlag, _ = testParameterDefinitions.Get("float-flag-without-default")`
- L221: `	floatFlag, _ = testParameterDefinitions.Get("float-flag-with-empty-default")`
- L228: `	initialParameterTests()`
- L229: `	dateFlag, _ := testParameterDefinitions.Get("date-flag")`
- L244: `	dateFlag, _ = testParameterDefinitions.Get("date-flag-without-default")`
- L251: `	initialParameterTests()`
- L252: `	stringFlag, _ := testParameterDefinitions.Get("string-flag")`
- L263: `	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")`
- L270: `	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")`
- L277: `	initialParameterTests()`
- L278: `	stringFlag, _ := testParameterDefinitions.Get("string-flag")`
- L289: `	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")`
- L296: `	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")`
- L303: `	initialParameterTests()`
- L304: `	stringFlag, _ := testParameterDefinitions.Get("string-flag")`
- L315: `	stringFlag, _ = testParameterDefinitions.Get("string-flag-without-default")`
- L322: `	stringFlag, _ = testParameterDefinitions.Get("string-flag-with-empty-default")`
- L328: `	boolFlag, _ := testParameterDefinitions.Get("bool-flag")`
- L339: `	boolFlag, _ = testParameterDefinitions.Get("bool-flag-without-default")`
- L346: `	boolFlag, _ = testParameterDefinitions.Get("bool-flag-with-empty-default")`
- L353: `	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")`
- L364: `	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")`
- L380: `	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")`
- L391: `	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")`
- L407: `	initialParameterTests()`
- L408: `	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")`
- L419: `	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")`
- L435: `	initialParameterTests()`
- L436: `	choiceFlag, _ := testParameterDefinitions.Get("choice-flag")`
- L447: `	choiceFlag, _ = testParameterDefinitions.Get("choice-flag-without-default")`
- L463: `	initialParameterTests()`
- L464: `	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")`
- L475: `	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")`
- L491: `	initialParameterTests()`
- L492: `	choiceListFlag, _ := testParameterDefinitions.Get("choice-list-flag")`
- L503: `	choiceListFlag, _ = testParameterDefinitions.Get("choice-list-flag-without-default")`
- L519: `	intListFlag, _ := testParameterDefinitions.Get("int-list-flag")`
- L530: `	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-without-default")`
- L537: `	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-with-empty-default")`
- L544: `	intListFlag, _ := testParameterDefinitions.Get("int-list-flag")`
- L556: `	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-without-default")`
- L564: `	intListFlag, _ = testParameterDefinitions.Get("int-list-flag-with-empty-default")`
- L572: `	floatListFlag, _ := testParameterDefinitions.Get("float-list-flag")`
- L583: `	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-without-default")`
- L590: `	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-with-empty-default")`
- L597: `	floatListFlag, _ := testParameterDefinitions.Get("float-list-flag")`
- L609: `	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-without-default")`
- L617: `	floatListFlag, _ = testParameterDefinitions.Get("float-list-flag-with-empty-default")`
- L625: `	objectFromFileFlag, _ := testParameterDefinitions.Get("object-from-file-flag")`
- L634: `	objectFromFileFlag, _ = testParameterDefinitions.Get("object-from-file-flag-without-default")`
- L641: `	objectFromFileFlag, _ = testParameterDefinitions.Get("object-from-file-flag-with-empty-default")`
- L648: `	objectListFromFileFlag, _ := testParameterDefinitions.Get("object-list-from-file-flag")`
- L660: `	objectListFromFileFlag, _ = testParameterDefinitions.Get("object-list-from-file-flag-without-default")`
- L667: `	objectListFromFileFlag, _ = testParameterDefinitions.Get("object-list-from-file-flag-with-empty-default")`
- L674: `	stringFromFileFlag, _ := testParameterDefinitions.Get("string-from-file-flag")`
- L683: `	stringFromFileFlag, _ = testParameterDefinitions.Get("string-from-file-flag-without-default")`
- L690: `	stringFromFileFlag, _ = testParameterDefinitions.Get("string-from-file-flag-with-empty-default")`
- L697: `	stringListFromFileFlag, _ := testParameterDefinitions.Get("string-list-from-file-flag")`
- L706: `	stringListFromFileFlag, _ = testParameterDefinitions.Get("string-list-from-file-flag-without-default")`
- L713: `	stringListFromFileFlag, _ = testParameterDefinitions.Get("string-list-from-file-flag-with-empty-default")`
- L720: `	initialParameterTests()`
- L721: `	stringListFlag, _ := testParameterDefinitions.Get("string-list-flag")`
- L732: `	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-without-default")`
- L739: `	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-with-empty-default")`
- L746: `	initialParameterTests()`
- L747: `	stringListFlag, _ := testParameterDefinitions.Get("string-list-flag")`
- L758: `	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-without-default")`
- L765: `	stringListFlag, _ = testParameterDefinitions.Get("string-list-flag-with-empty-default")`
- L772: `	keyValueFlag, _ := testParameterDefinitions.Get("key-value-flag")`
- L781: `	keyValueFlag, _ = testParameterDefinitions.Get("key-value-flag-without-default")`
- L788: `	keyValueFlag, _ = testParameterDefinitions.Get("key-value-flag-with-empty-default")`

### `pkg/cmds/fields/parse.go`
- L29: `// ParseParameter parses command line arguments according to the given Definition.`
- L30: `// It returns the parsed parameter value and a non-nil error if parsing failed.`
- L36: `// If the parameter is required and not provided, an error is returned.`
- L37: `// If the parameter is optional and not provided, the default value is returned.`
- L81: `func (p *Definition) ParseParameter(v []string, options ...ParseOption) (*ParsedParameter, error) {`
- L82: `	ret := &ParsedParameter{`
- L316: `				// TODO(2023-02-11): The separator could be stored in the parameter itself?`
- L342: `		return nil, errors.Errorf("Unknown parameter type %s", p.Type)`
- L355: `func parseFromFileName(fileName string, p *Definition, options ...ParseOption) (*ParsedParameter, error) {`
- L356: `	ret := &ParsedParameter{`
- L440: `// In the case of parameters taking multiple files, this needs to be called for each file`
- L445: `) (*ParsedParameter, error) {`
- L446: `	ret := &ParsedParameter{`
- L607: `		return nil, errors.New("Cannot parse from file for this parameter type")`
- L615: `) (*ParsedParameter, error) {`
- L616: `	ret := &ParsedParameter{`

### `pkg/cmds/fields/parse_test.go`
- L20: `type ParameterTestCase struct {`
- L66: `type ParameterTest struct {`
- L71: `	Cases        []ParameterTestCase`
- L74: `func TestParameterDate(t *testing.T) {`
- L75: `	cases := []ParameterTestCase{`
- L203: `	parameter := New(`
- L211: `			got, err := parameter.ParseParameter(tc.Input)`
- L225: `func TestParseParameter(t *testing.T) {`
- L226: `	tests := []ParameterTest{`
- L228: `			Name:         "ParameterString",`
- L231: `			Cases: []ParameterTestCase{`
- L238: `			Name:         "ParameterStringList",`
- L241: `			Cases: []ParameterTestCase{`
- L248: `			Name:         "ParameterInt",`
- L251: `			Cases: []ParameterTestCase{`
- L259: `			Name:         "ParameterIntegerList",`
- L262: `			Cases: []ParameterTestCase{`
- L271: `			Name:         "ParameterBool",`
- L274: `			Cases: []ParameterTestCase{`
- L283: `			Name:         "ParameterFloat",`
- L286: `			Cases: []ParameterTestCase{`
- L294: `			Name:         "ParameterFloatList",`
- L297: `			Cases: []ParameterTestCase{`
- L305: `			Name:         "ParameterChoice",`
- L309: `			Cases: []ParameterTestCase{`
- L317: `			Name:         "ParameterChoiceList",`
- L321: `			Cases: []ParameterTestCase{`
- L333: `			Cases: []ParameterTestCase{`
- L343: `		parameter := New(`
- L351: `				got, err := parameter.ParseParameter(tc.Input)`
- L364: `	parameter := New("test", TypeStringListFromFile,`
- L369: `	i, err := parameter.ParseFromReader(reader, "test.txt")`
- L374: `	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L379: `	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L385: `	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L391: `	i, err = parameter.ParseFromReader(reader, "test.json")`
- L397: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L402: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L407: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L412: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L417: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L422: `	i, err = parameter.ParseFromReader(reader, "test.json")`
- L429: `	i, err = parameter.ParseFromReader(reader, "test.yaml")`
- L435: `	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L442: `	parameter := New("test", TypeObjectFromFile,`
- L447: `	i, err := parameter.ParseFromReader(reader, "test.json")`
- L452: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L456: `	i, err = parameter.ParseFromReader(reader, "test.json")`
- L461: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L466: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L471: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L476: `	_, err = parameter.ParseFromReader(reader, "test.json")`
- L481: `	i, err = parameter.ParseFromReader(reader, "test.yaml")`
- L486: `	i, err = parameter.ParseFromReader(reader, "test.yml")`
- L492: `	i, err = parameter.ParseFromReader(reader, "test.yaml")`
- L498: `	_, err = parameter.ParseFromReader(reader, "test.yaml")`
- L503: `	_, err = parameter.ParseFromReader(reader, "test.yaml")`
- L509: `	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L517: `	_, err = parameter.ParseFromReader(reader, "test.csv")`
- L522: `	_, err = parameter.ParseFromReader(reader, "test.csv")`
- L527: `	_, err = parameter.ParseFromReader(reader, "test.csv")`
- L533: `	i, err = parameter.ParseFromReader(reader, "test.tsv")`
- L540: `	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L547: `	i, err = parameter.ParseFromReader(reader, "test.csv")`
- L553: `	parameter := New("test", TypeObjectListFromFile,`
- L557: `	v, err := parseObjectListFromString(parameter, `[{"test":"test"}]`, "test.json")`
- L562: `	v, err = parseObjectListFromString(parameter, `[{"test":"test"},{"test2":"test2"}]`, "test.json")`
- L566: `	_, err = parseObjectListFromString(parameter, `{"test":"test"`, "test.json")`
- L569: `	v, err = parseObjectListFromString(parameter, `[{"test":{"test":"test"}}]`, "test.json")`
- L574: `	v, err = parseObjectListFromString(parameter, `[]`, "test.json")`
- L579: `	_, err = parseObjectListFromString(parameter, ``, "test.json")`
- L583: `	_, err = parseObjectListFromString(parameter, `["test"]`, "test.json")`
- L587: `	v, err = parseObjectListFromString(parameter, `{"test":"test"}`
- L593: `	_, err = parseObjectListFromString(parameter, `{"test":"test"}{"test2":"test2"}`, "test.ndjson")`
- L597: `	v, err = parseObjectListFromString(parameter, `{"test":"test"}`, "test.ndjson")`
- L602: `	_, err = parseObjectListFromString(parameter, `{"test":"test"}`
- L607: `	v, err = parseObjectListFromString(parameter, `- test: test`, "test.yaml")`
- L611: `	v, err = parseObjectListFromString(parameter, `- test: test`, "test.yml")`
- L616: `	v, err = parseObjectListFromString(parameter, `- test: test`
- L622: `	v, err = parseObjectListFromString(parameter, `- test: {test: test}`, "test.yaml")`
- L627: `	_, err = parseObjectListFromString(parameter, `- test`
- L632: `	v, err = parseObjectListFromString(parameter, `test: test`, "test.yaml")`
- L637: `	v, err = parseObjectListFromString(parameter, `[]`, "test.yaml")`
- L642: `	_, err = parseObjectListFromString(parameter, ``, "test.yaml")`
- L646: `	v, err = parseObjectListFromString(parameter, `test,test2`
- L652: `	v, err = parseObjectListFromString(parameter, `test,test2`
- L659: `	_, err = parseObjectListFromString(parameter, `test,test2`, "test.csv")`
- L663: `	v, err = parseObjectListFromString(parameter, ``, "test.csv")`
- L668: `	v, err = parseObjectListFromString(parameter, `test,test2`
- L675: `func parseObjectListFromString(parameter *Definition, input string, fileName string) ([]map[string]interface{}, error) {`
- L677: `	i, err := parameter.ParseFromReader(reader, fileName)`
- L689: `	parameter := New("test", TypeStringFromFile,`
- L694: `	i, err := parameter.ParseFromReader(reader, "test.txt")`
- L700: `	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L705: `	i, err = parameter.ParseFromReader(reader, "test.txt")`
- L711: `	parameter := New("test", TypeStringFromFile,`
- L715: `	v, err := parameter.ParseParameter([]string{"test-data/string.txt"})`
- L719: `	parameter = New("test", TypeStringFromFiles,`
- L722: `	v, err = parameter.ParseParameter([]string{"test-data/string.txt"})`
- L726: `	v, err = parameter.ParseParameter([]string{"test-data/string.txt", "test-data/string2.txt"})`
- L732: `	parameter := New("test", TypeStringListFromFile,`
- L736: `	v, err := parameter.ParseParameter([]string{"test-data/string.txt"})`
- L740: `	v, err = parameter.ParseParameter([]string{"test-data/stringList.csv"})`
- L744: `	v, err = parameter.ParseParameter([]string{"test-data/stringList.csv", "test-data/stringList2.csv"})`
- L748: `	parameter = New("test", TypeStringListFromFiles,`
- L751: `	v, err = parameter.ParseParameter([]string{"test-data/string.txt"})`
- L755: `	v, err = parameter.ParseParameter([]string{"test-data/string.txt", "test-data/string2.txt"})`
- L761: `	parameter := New("test", TypeObjectListFromFile,`
- L765: `	v, err := parameter.ParseParameter([]string{"test-data/object.json"})`
- L769: `	v, err = parameter.ParseParameter([]string{"test-data/objectList.json"})`
- L783: `	v, err = parameter.ParseParameter([]string{"test-data/objectList3.csv"})`
- L797: `	parameter = New("test", TypeObjectListFromFiles,`
- L801: `	v, err = parameter.ParseParameter([]string{"test-data/object.json"})`
- L805: `	v, err = parameter.ParseParameter([]string{"test-data/object.json", "test-data/object2.json"})`
- L820: `	v, err = parameter.ParseParameter([]string{`
- L931: `			_, err := param.CheckParameterDefaultValueValidity()`
- L944: `	_, err := param.CheckParameterDefaultValueValidity()`
- L961: `		_, err := param.CheckParameterDefaultValueValidity()`

### `pkg/cmds/fields/parsed-parameter.go`
- L11: `type ParsedParameter struct {`
- L54: `// Update sets the value of the parsedParameter, and appends a new parseStep.`
- L55: `func (p *ParsedParameter) Update(value interface{}, options ...ParseOption) error {`
- L73: `func (p *ParsedParameter) RenderValue() (string, error) {`
- L77: `// UpdateWithLog sets the value of the parsedParameter, and appends the given log.`
- L78: `func (p *ParsedParameter) UpdateWithLog(value interface{}, log ...ParseStep) error {`
- L89: `// Set sets the value of the parsedParameter, and manually updates the log`
- L90: `func (p *ParsedParameter) Set(value interface{}, log ...ParseStep) {`
- L100: `func (p *ParsedParameter) Merge(v *ParsedParameter, options ...ParseOption) {`
- L107: `func (p *ParsedParameter) Clone() *ParsedParameter {`
- L108: `	ret := &ParsedParameter{`
- L117: `// GetInterfaceValue returns the value as an interface{}. If the type of the parameter is a list,`
- L120: `func (p *ParsedParameter) GetInterfaceValue() (interface{}, error) {`
- L121: `	parameterType := p.Definition.Type`
- L123: `	case parameterType.IsList():`
- L130: `	case parameterType.IsObject(),`
- L131: `		parameterType.IsKeyValue():`
- L134: `	case parameterType.IsObjectList():`
- L155: `type ParsedParameters struct {`
- L156: `	*orderedmap.OrderedMap[string, *ParsedParameter]`
- L159: `type ParsedParametersOption func(*ParsedParameters)`
- L161: `func WithParsedParameter(pd *Definition, key string, value interface{}) ParsedParametersOption {`
- L162: `	return func(p *ParsedParameters) {`
- L163: `		p.Set(key, &ParsedParameter{`
- L170: `func NewParsedParameters(options ...ParsedParametersOption) *ParsedParameters {`
- L171: `	ret := &ParsedParameters{`
- L172: `		OrderedMap: orderedmap.New[string, *ParsedParameter](),`
- L180: `func (p *ParsedParameters) GetValue(key string) interface{} {`
- L188: `func (p *ParsedParameters) Clone() *ParsedParameters {`
- L189: `	ret := NewParsedParameters()`
- L190: `	p.ForEach(func(k string, v *ParsedParameter) {`
- L196: `// UpdateExistingValue updates the value of an existing parameter, and returns true if the parameter existed.`
- L197: `// If the parameter did not exist, it returns false.`
- L198: `func (p *ParsedParameters) UpdateExistingValue(`
- L213: `func (p *ParsedParameters) Update(`
- L214: `	key string, pp *ParsedParameter,`
- L225: `func (p *ParsedParameters) UpdateValue(`
- L233: `		v_ = &ParsedParameter{`
- L245: `func (p *ParsedParameters) MustUpdateValue(`
- L252: `		return errors.Errorf("parameter %s not found", key)`
- L261: `func (p *ParsedParameters) UpdateWithLog(`
- L268: `		v_ = &ParsedParameter{`
- L280: `// SetAsDefault sets the current value of the parameter if no value has yet been set.`
- L281: `func (p *ParsedParameters) SetAsDefault(`
- L295: `// in ParsedParameters.`
- L296: `func (p *ParsedParameters) ForEach(f func(key string, value *ParsedParameter)) {`
- L303: `// ParsedParameters. It stops at, and returns, the first error encountered.`
- L304: `func (p *ParsedParameters) ForEachE(f func(key string, value *ParsedParameter) error) error {`
- L316: `// we actually merge the ParsedParameter themselves, by appending the entire history of the other parameter to the`
- L318: `func (p *ParsedParameters) Merge(other *ParsedParameters) (*ParsedParameters, error) {`
- L319: `	err := other.ForEachE(func(k string, v *ParsedParameter) error {`
- L333: `func (p *ParsedParameters) MergeAsDefault(other *ParsedParameters, options ...ParseOption) (*ParsedParameters, error) {`
- L334: `	err := other.ForEachE(func(k string, v *ParsedParameter) error {`
- L347: `// ToMap converts ParsedParameters to map[string]interface{} by assigning each ParsedParameter's value to its key.`
- L348: `func (p *ParsedParameters) ToMap() map[string]interface{} {`
- L350: `	p.ForEach(func(k string, v *ParsedParameter) {`
- L356: `// ToInterfaceMap converts ParsedParameters to map[string]interface{} by converting each ParsedParameter's value to interface{}.`
- L357: `// It returns an error if it fails to convert any ParsedParameter's value.`
- L358: `func (p *ParsedParameters) ToInterfaceMap() (map[string]interface{}, error) {`
- L360: `	err := p.ForEachE(func(k string, v *ParsedParameter) error {`
- L374: `// MarshalYAML implements yaml.Marshaler for ParsedParameters`
- L375: `func (p *ParsedParameters) MarshalYAML() (interface{}, error) {`
- L376: `	return ToSerializableParsedParameters(p), nil`
- L379: `// MarshalJSON implements json.Marshaler for ParsedParameters`
- L380: `func (p *ParsedParameters) MarshalJSON() ([]byte, error) {`
- L381: `	return json.Marshal(ToSerializableParsedParameters(p))`

### `pkg/cmds/fields/serialize.go`
- L9: `// SerializableParsedParameter represents a parsed parameter in a format suitable for`
- L11: `type SerializableParsedParameter struct {`
- L16: `// ToSerializableParsedParameter converts a ParsedParameter to its serializable representation`
- L17: `func ToSerializableParsedParameter(pp *ParsedParameter) *SerializableParsedParameter {`
- L18: `	return &SerializableParsedParameter{`
- L24: `// SerializableParsedParameters represents a collection of parsed parameters in a format suitable`
- L25: `// for YAML/JSON serialization, maintaining the order of parameters`
- L26: `type SerializableParsedParameters struct {`
- L27: `	// Using orderedmap to maintain parameter order while having name-based access`
- L28: `	Parameters *orderedmap.OrderedMap[string, *SerializableParsedParameter] `yaml:"parameters" json:"parameters"``
- L31: `// ToSerializableParsedParameters converts a ParsedParameters collection to its serializable representation`
- L32: `func ToSerializableParsedParameters(pp *ParsedParameters) *SerializableParsedParameters {`
- L33: `	ret := &SerializableParsedParameters{`
- L34: `		Parameters: orderedmap.New[string, *SerializableParsedParameter](),`
- L37: `	pp.ForEach(func(key string, value *ParsedParameter) {`
- L38: `		serialized := ToSerializableParsedParameter(value)`
- L39: `		ret.Parameters.Set(key, serialized)`
- L45: `// MarshalYAML implements yaml.Marshaler for SerializableParsedParameters`
- L46: `func (spp *SerializableParsedParameters) MarshalYAML() (interface{}, error) {`
- L48: `	m := make(map[string]*SerializableParsedParameter)`
- L49: `	for pair := spp.Parameters.Oldest(); pair != nil; pair = pair.Next() {`
- L55: `// MarshalJSON implements json.Marshaler for SerializableParsedParameters`
- L56: `func (spp *SerializableParsedParameters) MarshalJSON() ([]byte, error) {`
- L58: `	m := make(map[string]*SerializableParsedParameter)`
- L59: `	for pair := spp.Parameters.Oldest(); pair != nil; pair = pair.Next() {`

### `pkg/cmds/fields/strings.go`
- L8: `// GatherFlagsFromStringList parses command line arguments into a ParsedParameters`
- L12: `// It returns the parsed parameters map, any non-flag arguments, and any error`
- L32: `) (*ParsedParameters, []string, error) {`
- L37: `	// build a map of flag names to parameter definitions, including through shortflags`
- L119: `	result := NewParsedParameters()`
- L125: `		parsedValue, err := param.ParseParameter(values, parseOptions...)`
- L140: `				p := &ParsedParameter{`

### `pkg/cmds/fields/strings_test.go`
- L10: `// TestGatherFlagsFromStringList_ValidArgumentsAndParameters tests the function with valid arguments and fields.`
- L11: `func TestGatherFlagsFromStringList_ValidArgumentsAndParameters(t *testing.T) {`
- L366: `		// "--flag value" (empty parameters)`
- L368: `			name:    "EmptyParameters",`
- L373: `		// "--flag value" (parameters with empty ShortFlag)`
- L375: `			name: "ParametersWithEmptyShortFlag",`
- L385: `		// "--flag value -f value" (parameters with the same Name and ShortFlag)`
- L386: `		// "--flag1 value1 -f value2" (parameters with different Name but the same ShortFlag)`
- L388: `			name: "ParametersWithDifferentNameSameShortFlag",`
- L396: `		// "--flag1 value1 --flag2 value2" (mix of valid and invalid parameters)`
- L398: `			name: "MixOfValidAndInvalidParameters",`
- L402: `				// Assuming invalid parameter doesn't have a type`
- L500: `			got_.ForEach(func(key string, p *ParsedParameter) {`

### `pkg/cmds/fields/viper.go`
- L17: `) (*ParsedParameters, error) {`
- L19: `		log.Warn().Msg("fields.GatherFlagsFromViper is deprecated; use LoadParametersFromFiles + UpdateFromEnv")`
- L21: `	ret := NewParsedParameters()`
- L26: `		parsed := &ParsedParameter{`
- L118: `			return nil, errors.Errorf("Unknown parameter type %s for flag %s", p.Type, p.Name)`

### `pkg/cmds/helpers/test-helpers.go`
- L17: `// Package parameters provides structures and helper functions required for`
- L32: `// 3. Use the New* functions to convert the data loaded from YAML into appropriate form for the glazed library (typically, Values, ParsedDefinitions, ParameterLayers)`
- L42: `// - name: "Empty layers and parsedLayers"`
- L43: `//  parameterLayers: []`
- L44: `//  parsedLayers: []`
- L45: `//  expectedLayers: []`
- L48: `//- name: "Single layer with default"`
- L49: `//  parameterLayers:`
- L50: `//    - name: "layer1"`
- L55: `//  parsedLayers:`
- L56: `//    - name: "layer1"`
- L57: `//  expectedLayers:`
- L58: `//    - name: "layer1"`
- L63: `//- name: "Multiple layers with defaults"`
- L64: `//  parameterLayers:`
- L65: `//    - name: "layer1"`
- L73: `//    - name: "layer2"`
- L78: `//  parsedLayers:`
- L79: `//    - name: "layer1"`
- L80: `//		parameters:`
- L83: `//    - name: "layer2"`
- L84: `//  expectedLayers:`
- L85: `//    - name: "layer1"`
- L89: `//    - name: "layer2"`
- L99: `// 	parameterLayers []fields.TestParameterLayer`
- L100: `// 	parsedLayers    []fields.TestSectionValues`
- L101: `// 	expectedLayers  []fields.TestExpectedLayer`
- L110: `// 			layers_ := fields.NewTestParameterLayers(tt.parameterLayers)`
- L111: `// 			parsedLayers := fields.NewTestValues(layers_, tt.parsedLayers)`
- L120: `// 			for _, l_ := range tt.expectedLayers {`
- L121: `// 				l, ok := parsedLayers.Get(l_.Name)`
- L124: `// 				actual := l.Parameters.ToMap()`
- L131: `type TestParameterLayer struct {`
- L137: `type TestParsedParameter struct {`
- L144: `	Parameters []TestParsedParameter `yaml:"parameters"``
- L147: `type TestExpectedLayer struct {`
- L159: `const TestWhitelistLayers = "whitelistLayers"`
- L160: `const TestWhitelistLayersFirst = "whitelistLayersFirst"`
- L161: `const TestWhitelistLayerParameters = "whitelistLayerParameters"`
- L162: `const TestWhitelistLayerParametersFirst = "whitelistLayerParametersFirst"`
- L163: `const TestBlacklistLayers = "blacklistLayers"`
- L164: `const TestBlacklistLayersFirst = "blacklistLayersFirst"`
- L165: `const TestBlacklistLayerParameters = "blacklistLayerParameters"`
- L166: `const TestBlacklistLayerParametersFirst = "blacklistLayerParametersFirst"`
- L184: `	Layers     *[]string                          `yaml:"layers"``
- L185: `	Parameters *map[string][]string               `yaml:"parameters"``
- L216: `		case TestWhitelistLayers:`
- L217: `			ret = append(ret, sources.WhitelistLayers(*m.Layers))`
- L218: `		case TestWhitelistLayersFirst:`
- L219: `			ret = append(ret, sources.WhitelistLayersFirst(*m.Layers))`
- L220: `		case TestWhitelistLayerParameters:`
- L221: `			ret = append(ret, sources.WhitelistLayerParameters(*m.Parameters))`
- L222: `		case TestWhitelistLayerParametersFirst:`
- L223: `			ret = append(ret, sources.WhitelistLayerParametersFirst(*m.Parameters))`
- L224: `		case TestBlacklistLayers:`
- L225: `			ret = append(ret, sources.BlacklistLayers(*m.Layers))`
- L226: `		case TestBlacklistLayersFirst:`
- L227: `			ret = append(ret, sources.BlacklistLayersFirst(*m.Layers))`
- L228: `		case TestBlacklistLayerParameters:`
- L229: `			ret = append(ret, sources.BlacklistLayerParameters(*m.Parameters))`
- L230: `		case TestBlacklistLayerParametersFirst:`
- L231: `			ret = append(ret, sources.BlacklistLayerParametersFirst(*m.Parameters))`
- L240: `// NewTestParameterLayer is a helper function to create a ParameterLayer from parameterDefinition`
- L241: `func NewTestParameterLayer(l TestParameterLayer) schema.Section {`
- L253: `func NewTestParameterLayers(ls []TestParameterLayer) *schema.Schema {`
- L256: `		ret.Set(l.Name, NewTestParameterLayer(l))`
- L261: `// NewTestSectionValues helper function to create a Values from TestParsedParameter`
- L263: `	params_ := fields.NewParsedParameters()`
- L265: `	for _, p := range l.Parameters {`
- L268: `			panic("parameter definition not found")`
- L276: `	ret, err := values.NewSectionValues(pl, values.WithParameters(params_))`
- L289: `			panic("parameter layer not found")`
- L307: `func TestExpectedOutputs(t *testing.T, expectedLayers []TestExpectedLayer, parsedLayers *values.Values) {`
- L308: `	expectedLayers_ := map[string]TestExpectedLayer{}`
- L309: `	for _, l_ := range expectedLayers {`
- L310: `		expectedLayers_[l_.Name] = l_`
- L311: `		l, ok := parsedLayers.Get(l_.Name)`
- L314: `		actual, err := l.Parameters.ToInterfaceMap()`
- L323: `			actual, ok := l.Parameters.Get(k)`
- L336: `	parsedLayers.ForEach(func(key string, l *values.SectionValues) {`
- L337: `		if _, ok := expectedLayers_[key]; !ok {`
- L338: `			t.Errorf("did not expect layer %s to be present", key)`

### `pkg/cmds/json-schema.go`
- L29: `// parameterTypeToJsonSchema converts a parameter definition to a JSON schema property`
- L30: `func parameterTypeToJsonSchema(param *fields.Definition) (*JsonSchemaProperty, error) {`
- L110: `	// File-based parameter types`
- L145: `		return nil, fmt.Errorf("unsupported parameter type: %s", param.Type)`
- L162: `		prop, err := parameterTypeToJsonSchema(flag)`
- L178: `		prop, err := parameterTypeToJsonSchema(arg)`

### `pkg/cmds/layout/layout.go`
- L24: `	// These can be specified to override the values read from the flag / layer parameter definition`

### `pkg/cmds/logging/init-early.go`
- L77: `// Defaults match AddLoggingLayerToRootCommand in layer.go.`
- L92: `	// Defaults must match glazed/pkg/cmds/logging/layer.go:AddLoggingLayerToRootCommand`

### `pkg/cmds/logging/init-logging.go`
- L30: `// Deprecated: Use Glazed config middlewares (LoadParametersFromFiles + UpdateFromEnv) and InitGlazed/InitLoggerFromCobra.`

### `pkg/cmds/logging/init.go`
- L128: `// Deprecated: Initialize logging from parsed layers using SetupLoggingFromValues instead.`
- L150: `// Flags are added by AddLoggingLayerToRootCommand.`

### `pkg/cmds/logging/layer.go`
- L13: `// LoggingSettings holds the logging configuration parameters`
- L28: `const LoggingLayerSlug = "logging"`
- L30: `// NewLoggingLayer creates a new parameter layer for logging configuration`
- L31: `func NewLoggingLayer() (schema.Section, error) {`
- L33: `		LoggingLayerSlug,`
- L110: `// AddLoggingLayerToCommand adds the logging layer to a Glazed command`
- L111: `func AddLoggingLayerToCommand(cmd cmds.Command) (cmds.Command, error) {`
- L112: `	loggingLayer, err := NewLoggingLayer()`
- L117: `	cmd.Description().Layers.Set(LoggingLayerSlug, loggingLayer)`
- L122: `func AddLoggingLayerToRootCommand(rootCmd *cobra.Command, appName string) error {`
- L123: `	loggingLayer, err := NewLoggingLayer()`
- L127: `	_ = loggingLayer`
- L129: `	// XXX this would be the proper way to do it if we could easily add parameter definitions as persistent flags. For now, do it manually.`
- L132: `	// loggingLayer.GetDefinitions().ForEachE(func(definition *fields.Definition) error {`
- L154: `// SetupLoggingFromValues configures global logger from command-line parameters`
- L155: `func SetupLoggingFromValues(parsedLayers *values.Values) error {`
- L156: `	settings, err := GetLoggingSettings(parsedLayers)`
- L164: `func GetLoggingSettings(parsedLayers *values.Values) (*LoggingSettings, error) {`
- L166: `	err := parsedLayers.InitializeStruct(LoggingLayerSlug, &settings)`

### `pkg/cmds/runner/run.go`
- L39: `// RunCommand executes a Glazed command with the given parsed parameters and options`
- L43: `	parsedLayers *values.Values,`
- L59: `		return c.Run(ctx, parsedLayers)`
- L62: `		return c.RunIntoWriter(ctx, parsedLayers, opts.Writer)`
- L67: `			glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L69: `				return fmt.Errorf("glazed layer not found")`
- L71: `			gp, err := settings.SetupTableProcessor(glazedLayer)`
- L75: `			_, err = settings.SetupProcessorOutput(gp, glazedLayer, opts.Writer)`
- L82: `		err := c.RunIntoGlazeProcessor(ctx, parsedLayers, opts.GlazeProcessor)`
- L94: `// ParseOptions contains configuration for parameter parsing`
- L96: `	ValuesForLayers       map[string]map[string]interface{}`
- L106: `// WithValuesForLayers sets values for parameters in specified layers`
- L107: `func WithValuesForLayers(values map[string]map[string]interface{}) ParseOption {`
- L109: `		o.ValuesForLayers = values`
- L127: `// WithViper enables loading parameters from Viper configuration`
- L149: `// ParseCommandParameters parses parameters for a command using a configurable middleware chain`
- L150: `func ParseCommandParameters(`
- L187: `	// Add values for layers middleware if provided`
- L188: `	if opts.ValuesForLayers != nil {`
- L190: `			cmd_sources.FromMap(opts.ValuesForLayers,`
- L203: `	// Create parsed layers and execute middleware chain`
- L204: `	parsedLayers := values.New()`
- L206: `		cmd.Description().Layers,`
- L207: `		parsedLayers,`
- L211: `		return nil, fmt.Errorf("failed to parse parameters: %w", err)`
- L214: `	return parsedLayers, nil`
- L217: `// ParseAndRun combines parameter parsing and command execution into a single function`
- L224: `	parsedLayers, err := ParseCommandParameters(cmd, parseOptions...)`
- L229: `	return RunCommand(ctx, cmd, parsedLayers, runOptions...)`

### `pkg/cmds/schema/cobra.go`
- L11: `	// AddLayerToCobraCommand adds all the flags and arguments defined in this layer to the given cobra command.`
- L12: `	AddLayerToCobraCommand(cmd *cobra.Command) error`
- L13: `	ParseLayerFromCobraCommand(cmd *cobra.Command, options ...fields.ParseOption) (*values.SectionValues, error)`

### `pkg/cmds/schema/cobra_flag_groups.go`
- L18: `// It limits us in the sense that we can't just get the full ParameterDefinition`
- L70: `// template. Parameters that are not assigned to any group are passed as the "" group, with the`
- L89: `// through layers usually.`
- L143: `	// (usually through the ParameterDefinition), and add them to the correct`

### `pkg/cmds/schema/errors.go`
- L12: `		return fmt.Sprintf("invalid parameter layer: %s", e.Name)`
- L14: `	return fmt.Sprintf("invalid parameter layer: %s (expected %s)", e.Name, e.Expected)`

### `pkg/cmds/schema/layer-impl.go`
- L18: `	ChildLayers []Section           `yaml:"childLayers,omitempty"``
- L103: `			return p.InitializeDefaultsFromParameters(m)`
- L110: `func WithFields(parameterDefinitions ...*fields.Definition) SectionOption {`
- L112: `		for _, f := range parameterDefinitions {`
- L136: `		_, err := f_.Value.CheckParameterDefaultValueValidity()`
- L168: `// GetDefinitions returns a map that maps all parameters (flags and arguments) to their name.`
- L179: `// InitializeDefaultsFromStruct initializes the `ParameterDefinition` of the layer,`
- L182: `// This is in some ways the opposite of `InitializeStructFromParameterDefaults`.`
- L184: `// to initialize the `ParameterDefinition` with a matching name. If no matching`
- L185: `// `ParameterDefinition` is found, an error is returned.`
- L196: `// InitializeDefaultsFromParameters initializes the parameter definitions`
- L197: `// of the layer from the given map of parameter values. The parameter definitions`
- L199: `func (p *SectionImpl) InitializeDefaultsFromParameters(`
- L207: `func (p *SectionImpl) InitializeStructFromParameterDefaults(s interface{}) error {`
- L216: `// AddLayerToCobraCommand adds all flags of the layer to the given Cobra command.`
- L217: `// It also creates a flag group representing the layer and adds it to the command.`
- L218: `// If the layer has a prefix, the flags are added with that prefix.`
- L219: `func (p *SectionImpl) AddLayerToCobraCommand(cmd *cobra.Command) error {`
- L220: `	err := p.Definitions.AddParametersToCobraCommand(cmd, p.Prefix)`
- L230: `// ParseLayerFromCobraCommand parses the flags of the layer from the given Cobra command.`
- L231: `// If the layer has a prefix, the flags are parsed with that prefix (meaning, the prefix`
- L235: `// of the layer.`
- L236: `func (p *SectionImpl) ParseLayerFromCobraCommand(`
- L256: `		Layer:      p,`
- L257: `		Parameters: ps,`
- L261: `func (p *SectionImpl) GatherParametersFromMap(`
- L264: `) (*fields.ParsedParameters, error) {`
- L265: `	return p.Definitions.GatherParametersFromMap(m, onlyProvided, options...)`

### `pkg/cmds/schema/layer-impl_test.go`
- L11: `func createSimpleParameterLayer(t *testing.T, options ...SectionOption) *SectionImpl {`
- L17: `	layer, err := NewSection("simple", "Simple", options_...)`
- L20: `	return layer`
- L24: `	layer := createSimpleParameterLayer(t)`
- L30: `	err := layer.AddLayerToCobraCommand(cmd)`
- L49: `	layer := createSimpleParameterLayer(t, WithPrefix("test-"))`
- L55: `	err := layer.AddLayerToCobraCommand(cmd)`

### `pkg/cmds/schema/layer.go`
- L13: `// Section is a struct that is used by one specific functionality layer`
- L14: `// to group and describe all the parameter definitions that it uses.`
- L41: `func WithSections(layers ...Section) SchemaOption {`
- L43: `		for _, l := range layers {`
- L92: `func (pl *Schema) AppendLayers(layers ...Section) {`
- L93: `	for _, l := range layers {`
- L98: `func (pl *Schema) PrependLayers(layers ...Section) {`
- L99: `	list.Reverse[Section](layers)`
- L101: `	for _, l := range layers {`
- L143: `			err := v.(CobraSection).AddLayerToCobraCommand(cmd)`
- L165: `	parsedLayer *values.SectionValues,`
- L171: `		v, err := pd.CheckParameterDefaultValueValidity()`
- L176: `			err := parsedLayer.Parameters.SetAsDefault(pd.Name, pd, v, options...)`
- L191: `func (pl *Schema) UpdateWithDefaults(parsedLayers *values.Values, options ...fields.ParseOption) error {`
- L193: `		parsedLayer := parsedLayers.GetOrCreate(v)`
- L194: `		return InitializeSectionWithDefaults(v, parsedLayer, options...)`
- L202: `	return LayersToSerializable(pl), nil`
- L207: `	return json.Marshal(LayersToSerializable(pl))`

### `pkg/cmds/schema/layer_test.go`
- L12: `// Helper function to create a parameter layer`
- L13: `func createParameterLayer(t *testing.T, slug, name string, paramDefs ...*fields.Definition) Section {`
- L14: `	layer, err := NewSection(slug, name, WithFields(paramDefs...))`
- L16: `	require.NotNil(t, layer)`
- L17: `	return layer`
- L20: `func TestNewParameterLayers(t *testing.T) {`
- L21: `	layers := NewSchema()`
- L22: `	assert.NotNil(t, layers)`
- L23: `	assert.Equal(t, 0, layers.Len())`
- L26: `func TestParameterLayersSubset(t *testing.T) {`
- L27: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L28: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L29: `	layer3 := createParameterLayer(t, "layer3", "Layer 3")`
- L31: `	layers := NewSchema(WithSections(layer1, layer2, layer3))`
- L33: `	subset := layers.Subset("layer1", "layer3")`
- L36: `	val, present := subset.Get("layer1")`
- L39: `	val, present = subset.Get("layer2")`
- L42: `	val, present = subset.Get("layer3")`
- L47: `func TestParameterLayersForEach(t *testing.T) {`
- L48: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L49: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L51: `	layers := NewSchema(WithSections(layer1, layer2))`
- L54: `	layers.ForEach(func(key string, p Section) {`
- L56: `		assert.Contains(t, []string{"layer1", "layer2"}, key)`
- L62: `func TestParameterLayersForEachE(t *testing.T) {`
- L63: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L64: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L66: `	layers := NewSchema(WithSections(layer1, layer2))`
- L69: `	err := layers.ForEachE(func(key string, p Section) error {`
- L78: `func TestParameterLayersAppendLayers(t *testing.T) {`
- L79: `	layers := NewSchema()`
- L80: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L81: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L83: `	layers.AppendLayers(layer1, layer2)`
- L85: `	assert.Equal(t, 2, layers.Len())`
- L86: `	val, present := layers.Get("layer1")`
- L87: `	assert.Equal(t, layer1, val)`
- L89: `	val, present = layers.Get("layer2")`
- L90: `	assert.Equal(t, layer2, val)`
- L94: `func TestParameterLayersPrependLayers(t *testing.T) {`
- L95: `	layer0 := createParameterLayer(t, "layer0", "Layer 0")`
- L97: `	layers := NewSchema(`
- L98: `		WithSections(layer0),`
- L100: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L101: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L103: `	layers.PrependLayers(layer1, layer2)`
- L105: `	assert.Equal(t, 3, layers.Len())`
- L106: `	first := layers.Oldest()`
- L107: `	assert.Equal(t, "layer1", first.Key)`
- L108: `	assert.Equal(t, layer1, first.Value)`
- L110: `	assert.Equal(t, "layer2", second.Key)`
- L111: `	assert.Equal(t, layer2, second.Value)`
- L113: `	assert.Equal(t, "layer0", third.Key)`
- L114: `	assert.Equal(t, "Layer 0", third.Value.GetName())`
- L118: `func TestParameterLayersMerge(t *testing.T) {`
- L119: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L120: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L121: `	layers1 := NewSchema(WithSections(layer1))`
- L122: `	layers2 := NewSchema(WithSections(layer2))`
- L124: `	merged := layers1.Merge(layers2)`
- L127: `	val, present := merged.Get("layer1")`
- L130: `	val, present = merged.Get("layer2")`
- L135: `func TestParameterLayersAsList(t *testing.T) {`
- L136: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L137: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L138: `	layers := NewSchema(WithSections(layer1, layer2))`
- L140: `	list := layers.AsList()`
- L143: `	assert.Contains(t, list, layer1)`
- L144: `	assert.Contains(t, list, layer2)`
- L147: `func TestParameterLayersClone(t *testing.T) {`
- L148: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L149: `	layers := NewSchema(WithSections(layer1))`
- L151: `	cloned := layers.Clone()`
- L153: `	assert.Equal(t, layers.Len(), cloned.Len())`
- L154: `	v1, p1 := layers.Get("layer1")`
- L157: `	v2, p2 := cloned.Get("layer1")`
- L164: `func TestParameterLayersGetAllDefinitions(t *testing.T) {`
- L165: `	layer1 := createParameterLayer(t, "layer1", "Layer 1",`
- L168: `	layer2 := createParameterLayer(t, "layer2", "Layer 2",`
- L172: `	layers := NewSchema(WithSections(layer1, layer2))`
- L174: `	allDefs := layers.GetAllDefinitions()`
- L185: `func TestParameterLayersWithLayers(t *testing.T) {`
- L186: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L187: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L189: `	layers := NewSchema(WithSections(layer1, layer2))`
- L191: `	assert.Equal(t, 2, layers.Len())`
- L192: `	val, present := layers.Get("layer1")`
- L194: `	assert.Equal(t, layer1, val)`
- L195: `	val, present = layers.Get("layer2")`
- L197: `	assert.Equal(t, layer2, val)`
- L200: `func TestParameterLayersWithDuplicateSlugs(t *testing.T) {`
- L201: `	layer1 := createParameterLayer(t, "duplicate", "Layer 1")`
- L202: `	layer2 := createParameterLayer(t, "duplicate", "Layer 2")`
- L204: `	layers := NewSchema(WithSections(layer1, layer2))`
- L206: `	assert.Equal(t, 1, layers.Len())`
- L207: `	val, present := layers.Get("duplicate")`
- L209: `	assert.Equal(t, "Layer 2", val.GetName())`
- L212: `func TestParameterLayersSubsetWithNonExistentLayers(t *testing.T) {`
- L213: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L214: `	layers := NewSchema(WithSections(layer1))`
- L216: `	subset := layers.Subset("layer1", "non_existent")`
- L219: `	_, present := subset.Get("layer1")`
- L225: `func TestParameterLayersMergeWithOverlappingLayers(t *testing.T) {`
- L226: `	layer1 := createParameterLayer(t, "layer1", "Layer 1 - Original")`
- L227: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L228: `	layers1 := NewSchema(WithSections(layer1, layer2))`
- L230: `	layer1Duplicate := createParameterLayer(t, "layer1", "Layer 1 - Duplicate")`
- L231: `	layer3 := createParameterLayer(t, "layer3", "Layer 3")`
- L232: `	layers2 := NewSchema(WithSections(layer1Duplicate, layer3))`
- L234: `	merged := layers1.Merge(layers2)`
- L237: `	val, present := merged.Get("layer1")`
- L239: `	assert.Equal(t, "Layer 1 - Duplicate", val.GetName())`
- L240: `	_, present = merged.Get("layer2")`
- L242: `	_, present = merged.Get("layer3")`
- L246: `func TestParameterLayersWithLargeNumberOfLayers(t *testing.T) {`
- L247: `	numLayers := 1000`
- L248: `	layers := NewSchema()`
- L250: `	for i := 0; i < numLayers; i++ {`
- L251: `		layer := createParameterLayer(t, fmt.Sprintf("layer%d", i), fmt.Sprintf("Layer %d", i))`
- L252: `		layers.AppendLayers(layer)`
- L255: `	assert.Equal(t, numLayers, layers.Len())`
- L256: `	_, present := layers.Get("layer0")`
- L258: `	_, present = layers.Get(fmt.Sprintf("layer%d", numLayers-1))`
- L262: `func TestParameterLayersWithUnicodeLayerNames(t *testing.T) {`
- L263: `	layer1 := createParameterLayer(t, "layer1", "Layer 1 - ‰Ω†Â•Ω")`
- L264: `	layer2 := createParameterLayer(t, "layer2", "Layer 2 - „Åì„Çì„Å´„Å°„ÅØ")`
- L266: `	layers := NewSchema(WithSections(layer1, layer2))`
- L268: `	assert.Equal(t, 2, layers.Len())`
- L269: `	val, present := layers.Get("layer1")`
- L271: `	assert.Equal(t, "Layer 1 - ‰Ω†Â•Ω", val.GetName())`
- L272: `	val, present = layers.Get("layer2")`
- L274: `	assert.Equal(t, "Layer 2 - „Åì„Çì„Å´„Å°„ÅØ", val.GetName())`

### `pkg/cmds/schema/serialize.go`
- L10: `// SerializableParameterLayer represents a parameter layer in a format suitable for`
- L12: `type SerializableParameterLayer struct {`
- L17: `	Parameters  *fields.Definitions `yaml:"parameters" json:"parameters"``
- L21: `func ToSerializable(layer Section) *SerializableParameterLayer {`
- L22: `	return &SerializableParameterLayer{`
- L23: `		Name:        layer.GetName(),`
- L24: `		Slug:        layer.GetSlug(),`
- L25: `		Description: layer.GetDescription(),`
- L26: `		Prefix:      layer.GetPrefix(),`
- L27: `		Parameters:  layer.GetDefinitions(),`
- L31: `// SerializableLayers represents a collection of parameter layers in a format suitable`
- L32: `// for YAML/JSON serialization, maintaining the order of layers`
- L33: `type SerializableLayers struct {`
- L34: `	// Using orderedmap to maintain layer order while having slug-based access`
- L35: `	Layers *orderedmap.OrderedMap[string, *SerializableParameterLayer] `yaml:"layers" json:"layers"``
- L38: `// LayersToSerializable converts a Schema collection to its serializable representation`
- L39: `func LayersToSerializable(layers *Schema) *SerializableLayers {`
- L40: `	ret := &SerializableLayers{`
- L41: `		Layers: orderedmap.New[string, *SerializableParameterLayer](),`
- L44: `	layers.ForEach(func(_ string, layer Section) {`
- L45: `		serialized := ToSerializable(layer)`
- L46: `		ret.Layers.Set(layer.GetSlug(), serialized)`
- L52: `// MarshalYAML implements yaml.Marshaler for SerializableLayers`
- L53: `func (sl *SerializableLayers) MarshalYAML() (interface{}, error) {`
- L55: `	m := make(map[string]*SerializableParameterLayer)`
- L56: `	for pair := sl.Layers.Oldest(); pair != nil; pair = pair.Next() {`
- L62: `// MarshalJSON implements json.Marshaler for SerializableLayers`
- L63: `func (sl *SerializableLayers) MarshalJSON() ([]byte, error) {`
- L65: `	m := make(map[string]*SerializableParameterLayer)`
- L66: `	for pair := sl.Layers.Oldest(); pair != nil; pair = pair.Next() {`

### `pkg/cmds/schema/wrappers.go`
- L5: `type WhitelistParameterLayer struct {`
- L7: `	WhitelistedParameters map[string]interface{}`
- L10: `var _ Section = (*WhitelistParameterLayer)(nil)`
- L12: `func NewWhitelistParameterLayer(layer Section, whitelistedParameters map[string]interface{}) *WhitelistParameterLayer {`
- L13: `	return &WhitelistParameterLayer{`
- L14: `		Section:               layer,`
- L15: `		WhitelistedParameters: whitelistedParameters,`
- L19: `func (l *WhitelistParameterLayer) GetDefinitions() *fields.Definitions {`
- L23: `		if _, ok := l.WhitelistedParameters[pd.Name]; ok {`
- L30: `type BlacklistParameterLayer struct {`
- L32: `	BlacklistedParameters map[string]interface{}`
- L35: `var _ Section = (*BlacklistParameterLayer)(nil)`
- L37: `func NewBlacklistParameterLayer(layer Section, blacklistedParameters map[string]interface{}) *BlacklistParameterLayer {`
- L38: `	return &BlacklistParameterLayer{`
- L39: `		Section:               layer,`
- L40: `		BlacklistedParameters: blacklistedParameters,`
- L44: `func (l *BlacklistParameterLayer) GetDefinitions() *fields.Definitions {`
- L48: `		if _, ok := l.BlacklistedParameters[pd.Name]; !ok {`

### `pkg/cmds/sources/cobra.go`
- L13: `// FromCobra creates a middleware that parses parameter values from a Cobra command.`
- L16: `// It iterates through each layer, and if the layer implements the CobraSection interface,`
- L17: `// it parses the layer's parameters from the Cobra command.`
- L24: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L25: `			err := next(layers_, parsedLayers)`
- L30: `			err = layers_.ForEachE(func(key string, l schema.Section) error {`
- L33: `						"layer":          l.GetName(),`
- L34: `						"layer_slug":     l.GetSlug(),`
- L35: `						"layer_prefix":   l.GetPrefix(),`
- L40: `				parsedLayer := parsedLayers.GetOrCreate(l)`
- L42: `				if cobraLayer, ok := l.(schema.CobraSection); ok {`
- L43: `					cobraLayer, err := cobraLayer.ParseLayerFromCobraCommand(cmd, options_...)`
- L48: `					_, err = parsedLayer.Parameters.Merge(cobraLayer.Parameters)`
- L65: `// FromArgs creates a middleware that parses positional arguments for the default layer.`
- L74: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L75: `			err := next(layers_, parsedLayers)`
- L80: `			if defaultLayer, ok := layers_.Get(schema.DefaultSlug); ok {`
- L81: `				pds := defaultLayer.GetDefinitions()`
- L87: `				parsedLayer := parsedLayers.GetOrCreate(defaultLayer)`
- L88: `				_, err = parsedLayer.Parameters.Merge(ps_)`
- L101: `type ConfigFilesResolver func(parsedCommandLayers *values.Values, cmd *cobra.Command, args []string) ([]string, error)`
- L103: `// LoadParametersFromResolvedFilesForCobra loads parameters from a resolver-provided list of files`
- L105: `func LoadParametersFromResolvedFilesForCobra(`
- L112: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L113: `			if err := next(layers_, parsedLayers); err != nil {`
- L116: `			files, err := resolver(parsedLayers, cmd, args)`
- L126: `			return FromFiles(files, configOpts...)(func(_ *schema.Schema, _ *values.Values) error { return nil })(layers_, parsedLayers)`
- L131: `// GatherFlagsFromViper creates a middleware that loads parameter values from Viper configuration.`
- L134: `// It iterates through each layer, gathering flags from Viper for all parameters in that layer.`
- L146: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L148: `			err := next(layers_, parsedLayers)`
- L152: `			err = layers_.ForEachE(func(key string, l schema.Section) error {`
- L156: `						"layer":          l.GetName(),`
- L157: `						"layer_slug":     l.GetSlug(),`
- L158: `						"layer_prefix":   l.GetPrefix(),`
- L163: `				parsedLayer := parsedLayers.GetOrCreate(l)`
- L164: `				parameterDefinitions := l.GetDefinitions()`
- L167: `				ps, err := parameterDefinitions.GatherFlagsFromViper(true, prefix, options_...)`
- L172: `				_, err = parsedLayer.Parameters.Merge(ps)`
- L189: `// GatherSpecificFlagsFromViper creates a middleware that loads specific parameter values from Viper configuration.`
- L192: `// It's useful when you want to selectively load certain parameters from Viper while leaving others untouched.`
- L207: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L208: `			err := next(layers_, parsedLayers)`
- L212: `			err = layers_.ForEachE(func(key string, l schema.Section) error {`
- L216: `						"layer": l.GetName(),`
- L220: `				parsedLayer := parsedLayers.GetOrCreate(l)`
- L221: `				parameterDefinitions := l.GetDefinitions()`
- L224: `				// Filter the parameter definitions based on the specified flags`
- L227: `					if pd, ok := parameterDefinitions.Get(flag); ok {`
- L237: `				_, err = parsedLayer.Parameters.Merge(ps)`

### `pkg/cmds/sources/config-mapper-interface.go`
- L3: `// ConfigMapper is an interface that can map raw config data to layer maps.`

### `pkg/cmds/sources/custom-profiles_test.go`
- L36: `	// Create parameter definitions`
- L50: `	// Create layers`
- L51: `	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L56: `	parameterLayers := schema.NewSchema()`
- L57: `	parameterLayers.Set("config", layer)`
- L59: `	parsedLayers := values.New()`
- L69: `	err = handler(parameterLayers, parsedLayers)`
- L73: `	parsedLayer, ok := parsedLayers.Get("config")`
- L75: `	require.NotNil(t, parsedLayer)`
- L77: `	hostParamParsed, ok := parsedLayer.Parameters.Get("host")`
- L82: `	portParamParsed, ok := parsedLayer.Parameters.Get("port")`
- L87: `	debugParamParsed, ok := parsedLayer.Parameters.Get("debug")`
- L114: `	// Create parameter definitions`
- L128: `	// Create layers`
- L129: `	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L134: `	parameterLayers := schema.NewSchema()`
- L135: `	parameterLayers.Set("config", layer)`
- L137: `	parsedLayers := values.New()`
- L147: `	err = handler(parameterLayers, parsedLayers)`
- L151: `	parsedLayer, ok := parsedLayers.Get("config")`
- L153: `	require.NotNil(t, parsedLayer)`
- L155: `	hostParamParsed, ok := parsedLayer.Parameters.Get("host")`
- L160: `	portParamParsed, ok := parsedLayer.Parameters.Get("port")`
- L165: `	debugParamParsed, ok := parsedLayer.Parameters.Get("debug")`
- L172: `	// Create parameter definitions`
- L178: `	// Create layers`
- L179: `	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L184: `	parameterLayers := schema.NewSchema()`
- L185: `	parameterLayers.Set("config", layer)`
- L187: `	parsedLayers := values.New()`
- L197: `	err = handler(parameterLayers, parsedLayers)`
- L216: `	// Create parameter definitions`
- L222: `	// Create layers`
- L223: `	layer, err := schema.NewSection("config", "Config layer", schema.WithFields(`
- L228: `	parameterLayers := schema.NewSchema()`
- L229: `	parameterLayers.Set("config", layer)`
- L231: `	parsedLayers := values.New()`
- L242: `	err = handler(parameterLayers, parsedLayers)`

### `pkg/cmds/sources/layers.go`
- L9: `// ReplaceSectionValues is a middleware that replaces a parsed layer with a new one.`
- L10: `// It first calls next, then replaces the specified layer with a clone of the provided one.`
- L11: `// If the layer doesn't exist in the original parsedLayers, it will be added.`
- L12: `func ReplaceSectionValues(layerSlug string, newLayer *values.SectionValues) Middleware {`
- L14: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L15: `			err := next(layers_, parsedLayers)`
- L20: `			if newLayer == nil {`
- L21: `				return errors.New("cannot replace with nil layer")`
- L24: `			parsedLayers.Set(layerSlug, newLayer.Clone())`
- L30: `// ReplaceValues is a middleware that replaces multiple parsed layers at once.`
- L31: `// It first calls next, then replaces all specified layers with clones of the provided ones.`
- L32: `// If a layer doesn't exist in the original parsedLayers, it will be added.`
- L33: `func ReplaceValues(newLayers *values.Values) Middleware {`
- L35: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L36: `			err := next(layers_, parsedLayers)`
- L41: `			if newLayers == nil {`
- L42: `				return errors.New("cannot replace with nil layers")`
- L45: `			newLayers.ForEach(func(k string, v *values.SectionValues) {`
- L46: `				parsedLayers.Set(k, v.Clone())`
- L53: `// ReplaceValuesSelective is a middleware that replaces only the specified layers from the provided Values.`
- L54: `// It first calls next, then replaces only the layers specified in slugs with clones from newLayers.`
- L55: `// If a layer in slugs doesn't exist in newLayers, it is skipped.`
- L56: `func ReplaceValuesSelective(newLayers *values.Values, slugs []string) Middleware {`
- L58: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L59: `			err := next(layers_, parsedLayers)`
- L64: `			if newLayers == nil {`
- L65: `				return errors.New("cannot replace with nil layers")`
- L69: `				if layer, ok := newLayers.Get(slug); ok {`
- L70: `					parsedLayers.Set(slug, layer.Clone())`
- L78: `// MergeSectionValues is a middleware that merges a parsed layer into an existing one.`
- L79: `// It first calls next, then merges the provided layer into the specified one.`
- L80: `// If the target layer doesn't exist, it will be created.`
- L81: `func MergeSectionValues(layerSlug string, layerToMerge *values.SectionValues) Middleware {`
- L83: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L84: `			err := next(layers_, parsedLayers)`
- L89: `			if layerToMerge == nil {`
- L90: `				return errors.New("cannot merge nil layer")`
- L93: `			targetLayer, ok := parsedLayers.Get(layerSlug)`
- L95: `				parsedLayers.Set(layerSlug, layerToMerge.Clone())`
- L99: `			err = targetLayer.MergeParameters(layerToMerge)`
- L108: `// MergeValues is a middleware that merges multiple parsed layers at once.`
- L109: `// It first calls next, then merges all provided layers into the existing ones.`
- L110: `// If a target layer doesn't exist, it will be created.`
- L111: `func MergeValues(layersToMerge *values.Values) Middleware {`
- L113: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L114: `			err := next(layers_, parsedLayers)`
- L119: `			if layersToMerge == nil {`
- L120: `				return errors.New("cannot merge nil layers")`
- L123: `			err = parsedLayers.Merge(layersToMerge)`
- L132: `// MergeValuesSelective is a middleware that merges only the specified layers from the provided Values.`
- L133: `// It first calls next, then merges only the layers specified in slugs from layersToMerge into the existing layers.`
- L134: `// If a layer in slugs doesn't exist in layersToMerge, it is skipped.`
- L135: `// If a target layer doesn't exist in parsedLayers, it will be created.`
- L136: `func MergeValuesSelective(layersToMerge *values.Values, slugs []string) Middleware {`
- L138: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L139: `			err := next(layers_, parsedLayers)`
- L144: `			if layersToMerge == nil {`
- L145: `				return errors.New("cannot merge nil layers")`
- L149: `				if layer, ok := layersToMerge.Get(slug); ok {`
- L150: `					targetLayer, exists := parsedLayers.Get(slug)`
- L152: `						parsedLayers.Set(slug, layer.Clone())`
- L154: `						err = targetLayer.MergeParameters(layer)`

### `pkg/cmds/sources/load-parameters-from-json.go`
- L15: `// into the standard layer map format: map[layerSlug]map[parameterName]value.`
- L17: `// The output should map layer slugs to parameter name/value pairs.`
- L23: `// FromFile loads parameter definitions from a JSON or YAML file and applies them to the parameter layers.`
- L26: `//	layer-slug:`
- L27: `//	  parameter-name: value`
- L32: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L33: `			err := next(layers_, parsedLayers)`
- L43: `			m, err := readConfigFileToLayerMap(filename, opts.Mapper)`
- L47: `			return updateFromMap(layers_, parsedLayers, m, opts.ParseOptions...)`
- L57: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L58: `			if err := next(layers_, parsedLayers); err != nil {`
- L66: `				m, err := readConfigFileToLayerMap(f, opts.Mapper)`
- L77: `				if err := updateFromMap(layers_, parsedLayers, m, parseOpts...); err != nil {`
- L95: `// into the standard layer map format. If not provided, the default behavior expects:`
- L97: `//	layer-slug:`
- L98: `//	  parameter-name: value`
- L108: `// config file structures into the standard layer map format.`
- L116: `// WithParseOptions adds parse step options that will be applied when loading parameters from the config file.`
- L123: `func readConfigFileToLayerMap(filename string, mapper ConfigMapper) (map[string]map[string]interface{}, error) {`
- L151: `	// Default behavior: expect the standard layer map structure`
- L154: `		for layerSlug, layerData := range m {`
- L155: `			if layerMap, ok := layerData.(map[string]interface{}); ok {`
- L156: `				result[layerSlug] = layerMap`
- L158: `				return nil, errors.Errorf("expected map[string]interface{} for layer %s, got %T", layerSlug, layerData)`

### `pkg/cmds/sources/middlewares.go`
- L8: `type HandlerFunc func(layers *schema.Schema, parsedLayers *values.Values) error`
- L12: `// layer middlewares:`
- L13: `// - [x] whitelist (layers, parameters)`
- L14: `// - [x] blacklist (layers, parameters)`
- L18: `// - [x] from parameter definition defaults`
- L22: `func Identity(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L39: `// Finally, it calls the resulting handler with the provided layers and parsedLayers.`
- L44: `// [f1, f2, f3] will be executed as f1(f2(f3(handler)))(layers_, parsedLayers).`
- L49: `//   - if all you do is modify the parsedLayers, call `next` first.`
- L50: `//     This means that parsedLayers will be modified in the order of the middlewares.`
- L53: `//   - if you want to modify the layers before parsing, use the`
- L55: `//     get the newly updated ParameterLayers and thus potentially restrict which parameters they parse.`
- L56: `func Execute(layers_ *schema.Schema, parsedLayers *values.Values, middlewares ...Middleware) error {`
- L66: `	clonedLayers := layers_.Clone()`
- L67: `	return handler(clonedLayers, parsedLayers)`

### `pkg/cmds/sources/middlewares_test.go`
- L21: `	ParameterLayers []helpers.TestParameterLayer `yaml:"parameterLayers"``
- L22: `	Values          []helpers.TestSectionValues  `yaml:"parsedLayers"``
- L23: `	ExpectedLayers  []helpers.TestExpectedLayer  `yaml:"expectedLayers"``
- L40: `			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L41: `			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L44: `			err := middleware(func(layers *schema.Schema, parsedLayers *values.Values) error {`
- L46: `			})(layers_, parsedLayers)`
- L53: `				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L73: `			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L74: `			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L77: `				layers_, parsedLayers,`
- L85: `				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L100: `			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L101: `			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L104: `				layers_, parsedLayers,`
- L112: `				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L132: `			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L133: `			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L142: `				layers_, parsedLayers,`
- L155: `				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L161: `//go:embed tests/wrap-with-restricted-layers.yaml`
- L162: `var wrapWithRestrictedLayersTestsYAML string`
- L164: `type wrapWithRestrictedLayersTest struct {`
- L174: `func TestWrapWithRestrictedLayers(t *testing.T) {`
- L175: `	tests, err := yaml.LoadTestFromYAML[[]wrapWithRestrictedLayersTest](wrapWithRestrictedLayersTestsYAML)`
- L180: `			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L181: `			parsedLayers := values.New()`
- L189: `				ms_ = append(ms_, sources.WrapWithBlacklistedLayers(tt.BlacklistedSlugs,`
- L193: `				ms_ = append(ms_, sources.WrapWithWhitelistedLayers(tt.WhitelistedSlugs,`
- L201: `				layers_, parsedLayers,`
- L210: `				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`
- L230: `			layers_ := helpers.NewTestParameterLayers(tt.ParameterLayers)`
- L231: `			parsedLayers := helpers.NewTestValues(layers_, tt.Values...)`
- L236: `			err = sources.Execute(layers_, parsedLayers, middlewares_...)`
- L244: `				helpers.TestExpectedOutputs(t, tt.ExpectedLayers, parsedLayers)`

### `pkg/cmds/sources/patternmapper/exports.go`
- L12: `func ExtractCaptureReferences(targetParameter string) map[string]bool {`
- L13: `	return extractCaptureReferences(targetParameter)`
- L16: `// ResolveTargetParameter exposes internal resolveTargetParameter for testing and tooling.`
- L17: `func ResolveTargetParameter(targetParameter string, captures map[string]string) (string, error) {`
- L18: `	return resolveTargetParameter(targetParameter, captures)`

### `pkg/cmds/sources/patternmapper/loader.go`
- L22: `	TargetLayer     string        `yaml:"target_layer" json:"target_layer"``
- L23: `	TargetParameter string        `yaml:"target_parameter" json:"target_parameter"``
- L31: `		TargetLayer:     mr.TargetLayer,`
- L32: `		TargetParameter: mr.TargetParameter,`
- L96: `// LoadMapperFromFile loads a ConfigMapper from a YAML/JSON mapping file using the provided layers.`
- L97: `func LoadMapperFromFile(layers_ *schema.Schema, filename string) (sources.ConfigMapper, error) {`
- L102: `	return NewConfigMapper(layers_, rules...)`

### `pkg/cmds/sources/patternmapper/pattern_mapper.go`
- L15: `// MappingRule defines a pattern-based mapping from config file structure to layer fields.`
- L18: `//   - TargetLayer: Which layer to place the value in`
- L19: `//   - TargetParameter: Which parameter name to use (supports capture references like "{env}-api-key")`
- L30: `	// Target layer slug (e.g., "demo")`
- L32: `	TargetLayer string`
- L34: `	// Target parameter name (supports captures like "{env}-api-key")`
- L36: `	TargetParameter string`
- L50: `	layers           *schema.Schema`
- L66: `//   - All target parameters exist in their respective layers`
- L67: `//   - Capture references in target parameters match captures in source patterns`
- L68: `func NewConfigMapper(layers *schema.Schema, rules ...MappingRule) (sources.ConfigMapper, error) {`
- L69: `	if layers == nil {`
- L70: `		return nil, errors.New("layers cannot be nil")`
- L75: `		layers: layers,`
- L139: `	// Validate target parameter if this is a leaf rule (no nested rules)`
- L141: `		// Validate target layer exists`
- L142: `		if rule.TargetLayer == "" {`
- L143: `			return nil, errors.New("target layer is required for leaf rules")`
- L146: `		_, ok := m.layers.Get(rule.TargetLayer)`
- L148: `			return nil, errors.Errorf("target layer %q does not exist", rule.TargetLayer)`
- L151: `		// Validate capture references in target parameter`
- L153: `		if err := validateCaptureReferences(allCaptures, rule.TargetParameter); err != nil {`
- L154: `			return nil, errors.Wrapf(err, "invalid capture reference in target parameter")`
- L157: `		// Proposal 5: Early validation for static target parameters (no capture refs)`
- L158: `		if len(extractCaptureReferences(rule.TargetParameter)) == 0 {`
- L159: `			layer, _ := m.layers.Get(rule.TargetLayer)`
- L160: `			if layer != nil {`
- L161: `				canonical := resolveCanonicalParameterName(layer, rule.TargetParameter)`
- L162: `				if pd, ok := layer.GetDefinitions().Get(canonical); !ok || pd == nil {`
- L163: `					if canonical != rule.TargetParameter {`
- L164: `						return nil, errors.Errorf("target parameter %q (checked as %q) does not exist in layer %q", rule.TargetParameter, canonical, rule.TargetLayer)`
- L166: `					return nil, errors.Errorf("target parameter %q does not exist in layer %q", rule.TargetParameter, rule.TargetLayer)`
- L189: `			// Inherit target layer if not set`
- L190: `			if childRule.TargetLayer == "" {`
- L191: `				childRule.TargetLayer = rule.TargetLayer`
- L219: `	// Key: layer+"."+paramName, Value: pattern source that last wrote to it`
- L230: `		// Key: resolved target parameter name, Value: list of distinct values`
- L235: `			// Resolve target parameter name (replace captures)`
- L236: `			targetParam, err := resolveTargetParameter(compiled.rule.TargetParameter, match.captures)`
- L238: `				return nil, errors.Wrapf(err, "failed to resolve target parameter")`
- L241: `			// Validate parameter exists`
- L242: `			layer, ok := m.layers.Get(match.layer)`
- L244: `				return nil, errors.Errorf("target layer %q does not exist", match.layer)`
- L247: `			// Resolve canonical parameter name (using helper from proposal 9)`
- L248: `			paramName := resolveCanonicalParameterName(layer, targetParam)`
- L250: `			paramDef, ok := layer.GetDefinitions().Get(paramName)`
- L254: `				errorMsg := fmt.Sprintf("target parameter %q", targetParam)`
- L258: `				errorMsg += fmt.Sprintf(" does not exist in layer %q (pattern: %q)", match.layer, compiled.rule.Source)`
- L278: `						"pattern %q matched multiple distinct values for parameter %q: found %d distinct values",`
- L288: `		// Track which parameters were written by this rule to avoid false collision detection`
- L291: `			// Resolve target parameter name (replace captures)`
- L292: `			targetParam, err := resolveTargetParameter(compiled.rule.TargetParameter, match.captures)`
- L294: `				return nil, errors.Wrapf(err, "failed to resolve target parameter")`
- L297: `			layer, _ := m.layers.Get(match.layer)`
- L298: `			paramName := resolveCanonicalParameterName(layer, targetParam)`
- L301: `			// Only check for collisions if this parameter wasn't already written by this rule`
- L302: `			collisionKey := match.layer + "." + paramName`
- L305: `					// Collision detected (different rule writing to same parameter): error`
- L307: `						"collision: parameter %q in layer %q is written by multiple patterns: %q and %q",`
- L309: `						match.layer,`
- L318: `			// Initialize layer map if needed`
- L319: `			if result[match.layer] == nil {`
- L320: `				result[match.layer] = make(map[string]interface{})`
- L324: `			result[match.layer][paramName] = match.value`
- L333: `	layer    string`
- L479: `			layer:    compiled.rule.TargetLayer,`
- L521: `// validateCaptureReferences validates that all capture references in target parameter`
- L523: `func validateCaptureReferences(availableCaptures []string, targetParameter string) error {`
- L524: `	// Extract capture references from target parameter`
- L525: `	targetRefs := extractCaptureReferences(targetParameter)`
- L537: `			return errors.Errorf("capture reference {%s} in target parameter not found in source pattern", ref)`
- L557: `// extractCaptureReferences extracts all capture references from a target parameter string`
- L558: `func extractCaptureReferences(targetParameter string) map[string]bool {`
- L562: `	matches := re.FindAllStringSubmatch(targetParameter, -1)`
- L603: `// resolveCanonicalParameterName resolves the canonical parameter name including prefix`
- L604: `// This is proposal 9: explicit helper for canonical parameter name resolution`
- L605: `func resolveCanonicalParameterName(layer schema.Section, targetParam string) string {`
- L606: `	if layer.GetPrefix() != "" {`
- L607: `		// If layer has prefix, check if targetParam already includes it`
- L608: `		if !strings.HasPrefix(targetParam, layer.GetPrefix()) {`
- L609: `			return layer.GetPrefix() + targetParam`
- L615: `// resolveTargetParameter resolves capture references in target parameter name`
- L616: `func resolveTargetParameter(targetParameter string, captures map[string]string) (string, error) {`
- L617: `	result := targetParameter`
- L619: `	matches := re.FindAllStringSubmatch(targetParameter, -1)`

### `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go`
- L11: `	layers *schema.Schema`
- L18: `		layers: l,`
- L25: `func (b *ConfigMapperBuilder) Map(source string, targetLayer string, targetParameter string, required ...bool) *ConfigMapperBuilder {`
- L28: `		TargetLayer:     targetLayer,`
- L29: `		TargetParameter: targetParameter,`
- L39: `func (b *ConfigMapperBuilder) MapObject(parentSource string, targetLayer string, childRules []MappingRule) *ConfigMapperBuilder {`
- L42: `		TargetLayer: targetLayer,`
- L51: `	return NewConfigMapper(b.layers, b.rules...)`
- L55: `func Child(source string, targetParameter string) MappingRule {`
- L56: `	return MappingRule{Source: source, TargetParameter: targetParameter}`

### `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go`
- L17: `		setupLayers func(t *testing.T) *schema.Schema`
- L26: `			setupLayers: createTestLayers,`
- L30: `					TargetLayer:     "demo",`
- L31: `					TargetParameter: "api-key",`
- L40: `			setupLayers: createTestLayers,`
- L44: `					TargetLayer:     "demo",`
- L45: `					TargetParameter: "api-key",`
- L64: `			setupLayers: createTestLayers,`
- L68: `					TargetLayer:     "demo",`
- L69: `					TargetParameter: "api-key",`
- L96: `			setupLayers: createTestLayers,`
- L100: `					TargetLayer:     "demo",`
- L101: `					TargetParameter: "api-key",`
- L122: `			setupLayers: createTestLayers,`
- L126: `					TargetLayer:     "demo",`
- L127: `					TargetParameter: "threshold",`
- L146: `			setupLayers: func(t *testing.T) *schema.Schema {`
- L147: `				layer, err := schema.NewSection(`
- L149: `					"Demo Layer",`
- L155: `				return schema.NewSchema(schema.WithSections(layer))`
- L160: `					TargetLayer:     "demo",`
- L161: `					TargetParameter: "enabled",`
- L180: `			setupLayers: func(t *testing.T) *schema.Schema {`
- L181: `				layer, err := schema.NewSection(`
- L183: `					"Demo Layer",`
- L189: `				return schema.NewSchema(schema.WithSections(layer))`
- L194: `					TargetLayer:     "demo",`
- L195: `					TargetParameter: "{env}-api-key",`
- L214: `			setupLayers: createTestLayers,`
- L218: `					TargetLayer:     "demo",`
- L219: `					TargetParameter: "api-key",`
- L247: `			testLayers := tt.setupLayers(t)`
- L248: `			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L275: `	testLayers := createTestLayers(t)`
- L289: `					TargetLayer:     "demo",`
- L290: `					TargetParameter: "api-key",`
- L309: `			name: "parameter does not exist - shows pattern and layer",`
- L313: `					TargetLayer:     "demo",`
- L314: `					TargetParameter: "nonexistent-param",`
- L326: `				"target parameter",`
- L337: `			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L360: `// TestLayerPrefix tests handling of layer prefixes`
- L361: `func TestLayerPrefix(t *testing.T) {`
- L362: `	// Create a layer with a prefix`
- L363: `	layer, err := schema.NewSection(`
- L365: `		"Demo Layer",`
- L374: `	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L384: `			name: "parameter name without prefix - should add prefix",`
- L388: `					TargetLayer:     "demo",`
- L389: `					TargetParameter: "api-key",`
- L407: `			name: "parameter name with prefix - should not double prefix",`
- L411: `					TargetLayer:     "demo",`
- L412: `					TargetParameter: "demo-api-key",`
- L433: `			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L450: `	// Create test layers with environment-region parameters`
- L451: `	layer, err := schema.NewSection(`
- L453: `		"Demo Layer",`
- L462: `	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L476: `					TargetLayer:     "demo",`
- L477: `					TargetParameter: "{region}-{env}-api-key",`
- L507: `					TargetLayer: "demo",`
- L509: `						{Source: "api_key", TargetParameter: "{region}-{env}-api-key"},`
- L537: `			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L554: `	layer, err := schema.NewSection(`
- L556: `		"Demo Layer",`
- L567: `	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L569: `	mapper, err := pm.NewConfigMapper(testLayers,`
- L572: `			TargetLayer:     "demo",`
- L573: `			TargetParameter: "string-param",`
- L577: `			TargetLayer:     "demo",`
- L578: `			TargetParameter: "int-param",`
- L582: `			TargetLayer:     "demo",`
- L583: `			TargetParameter: "float-param",`
- L587: `			TargetLayer:     "demo",`
- L588: `			TargetParameter: "bool-param",`
- L592: `			TargetLayer:     "demo",`
- L593: `			TargetParameter: "list-param",`

### `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go`
- L14: `func buildTestLayers(t *testing.T, defs ...*fields.Definition) *schema.Schema {`
- L20: `		t.Fatalf("failed to create layer: %v", err)`
- L29: `    target_layer: "demo"`
- L32: `        target_parameter: "api-key"`
- L34: `        target_parameter: "threshold"`
- L44: `	if rules[0].Source != "app.settings" || rules[0].TargetLayer != "demo" {`
- L55: `  target_layer: "demo"`
- L56: `  target_parameter: "api-key"`
- L58: `  target_layer: "demo"`
- L59: `  target_parameter: "threshold"`
- L76: `    target_layer: "demo"`
- L79: `        target_parameter: "{env}-api-key"`
- L87: `	// Layers with expected params`
- L92: `	pls := buildTestLayers(t, defs...)`

### `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go`
- L17: `	// Create a simple layer`
- L18: `	layer, err := schema.NewSection(`
- L20: `		"Demo Layer",`
- L27: `	pls := schema.NewSchema(schema.WithSections(layer))`
- L33: `			TargetLayer:     "demo",`
- L34: `			TargetParameter: "api-key",`

### `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go`
- L16: `	// Create test layers`
- L17: `	layer, err := schema.NewSection(`
- L19: `		"Demo Layer",`
- L25: `	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L41: `			TargetLayer:     "demo",`
- L42: `			TargetParameter: "api-key",`
- L47: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L71: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L85: `	// Create test layers`
- L86: `	layer, err := schema.NewSection(`
- L88: `		"Demo Layer",`
- L94: `	testLayers := schema.NewSchema(schema.WithSections(layer))`
- L110: `			TargetLayer:     "demo",`
- L111: `			TargetParameter: "api-key",`
- L115: `			TargetLayer:     "demo",`
- L116: `			TargetParameter: "api-key",`
- L121: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L134: `	t.Run("no collision - different parameters", func(t *testing.T) {`
- L135: `		layerMulti, err := schema.NewSection(`
- L137: `			"Demo Layer",`
- L144: `		testLayersMulti := schema.NewSchema(schema.WithSections(layerMulti))`
- L149: `				TargetLayer:     "demo",`
- L150: `				TargetParameter: "api-key",`
- L154: `				TargetLayer:     "demo",`
- L155: `				TargetParameter: "threshold",`
- L170: `		mapper, err := pm.NewConfigMapper(testLayersMulti, rulesMulti...)`
- L175: `		// Should not error because different parameters`
- L186: `		// Create a layer with a prefix`
- L187: `		layer, err := schema.NewSection(`
- L189: `			"Demo Layer",`
- L196: `		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L201: `				TargetLayer:     "demo",`
- L202: `				TargetParameter: "api-key", // Without prefix`
- L214: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L223: `		// Create a layer with a prefix`
- L224: `		layer, err := schema.NewSection(`
- L226: `			"Demo Layer",`
- L234: `		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L239: `				TargetLayer:     "demo",`
- L240: `				TargetParameter: "api-key", // This will resolve to demo-api-key which doesn't exist`
- L246: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L255: `	t.Run("error message for parameter with prefix already included (compile-time)", func(t *testing.T) {`
- L256: `		// Create a layer with a prefix`
- L257: `		layer, err := schema.NewSection(`
- L259: `			"Demo Layer",`
- L266: `		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L271: `				TargetLayer:     "demo",`
- L272: `				TargetParameter: "demo-api-key", // With prefix already`
- L276: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L289: `		layer, err := schema.NewSection(`
- L291: `			"Demo Layer",`
- L297: `		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L303: `				TargetLayer: "demo",`
- L305: `					{Source: "{env}.api_key", TargetParameter: "{env}-api-key"},`
- L315: `		_, _ = pm.NewConfigMapper(testLayers, rules...)`
- L326: `		layer, err := schema.NewSection(`
- L328: `			"Demo Layer",`
- L334: `		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L353: `				TargetLayer:     "demo",`
- L354: `				TargetParameter: "api-key",`
- L358: `				TargetLayer:     "demo",`
- L359: `				TargetParameter: "api-key",`
- L363: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L374: `		layer, err := schema.NewSection(`
- L376: `			"Demo Layer",`
- L383: `		testLayers := schema.NewSchema(schema.WithSections(layer))`
- L399: `				TargetLayer:     "demo",`
- L400: `				TargetParameter: "api-key",`
- L404: `				TargetLayer:     "demo",`
- L405: `				TargetParameter: "api-key",`
- L409: `		mapper, err := pm.NewConfigMapper(testLayers, rules...)`
- L416: `		// Error should mention the resolved parameter name (with prefix)`

### `pkg/cmds/sources/patternmapper/pattern_mapper_test.go`
- L13: `// createTestLayers creates a test parameter layer structure`
- L14: `func createTestLayers(t *testing.T) *schema.Schema {`
- L15: `	demoLayer, err := schema.NewSection(`
- L17: `		"Demo Layer",`
- L32: `		schema.WithSections(demoLayer),`
- L48: `					TargetLayer:     "demo",`
- L49: `					TargetParameter: "api-key",`
- L59: `					TargetLayer:     "demo",`
- L60: `					TargetParameter: "{env}-api-key",`
- L70: `					TargetLayer:     "demo",`
- L71: `					TargetParameter: "api-key",`
- L81: `					TargetLayer:     "demo",`
- L82: `					TargetParameter: "api-key",`
- L93: `					TargetLayer:     "demo",`
- L94: `					TargetParameter: "api-key",`
- L105: `					TargetLayer:     "demo",`
- L106: `					TargetParameter: "api-key",`
- L117: `					TargetLayer:     "demo",`
- L118: `					TargetParameter: "api-key",`
- L129: `					TargetLayer:     "demo",`
- L130: `					TargetParameter: "{env}-api-key",`
- L134: `			errorMsg:    "capture reference {env} in target parameter not found in source pattern",`
- L137: `			name: "invalid target layer - does not exist",`
- L141: `					TargetLayer:     "nonexistent",`
- L142: `					TargetParameter: "api-key",`
- L146: `			errorMsg:    "target layer \"nonexistent\" does not exist",`
- L153: `					TargetLayer: "demo",`
- L155: `						{Source: "api_key", TargetParameter: "api-key"},`
- L156: `						{Source: "threshold", TargetParameter: "threshold"},`
- L167: `					TargetLayer: "demo",`
- L169: `						{Source: "api_key", TargetParameter: "{env}-api-key"},`
- L176: `			name: "invalid static target parameter at compile time",`
- L180: `					TargetLayer:     "demo",`
- L181: `					TargetParameter: "nonexistent", // Should fail at compile time`
- L185: `			errorMsg:    "target parameter \"nonexistent\" does not exist in layer \"demo\"",`
- L191: `			layers_ := createTestLayers(t)`
- L192: `			_, err := pm.NewConfigMapper(layers_, tt.rules...)`
- L219: `					TargetLayer:     "demo",`
- L220: `					TargetParameter: "api-key",`
- L242: `					TargetLayer:     "demo",`
- L243: `					TargetParameter: "api-key",`
- L247: `					TargetLayer:     "demo",`
- L248: `					TargetParameter: "threshold",`
- L272: `					TargetLayer:     "demo",`
- L273: `					TargetParameter: "{env}-api-key",`
- L299: `					TargetLayer:     "demo",`
- L300: `					TargetParameter: "api-key",`
- L325: `					TargetLayer: "demo",`
- L327: `						{Source: "api_key", TargetParameter: "api-key"},`
- L328: `						{Source: "threshold", TargetParameter: "threshold"},`
- L353: `					TargetLayer: "demo",`
- L355: `						{Source: "api_key", TargetParameter: "{env}-api-key"},`
- L356: `						{Source: "threshold", TargetParameter: "{env}-threshold"},`
- L391: `					TargetLayer:     "demo",`
- L392: `					TargetParameter: "api-key",`
- L411: `					TargetLayer:     "demo",`
- L412: `					TargetParameter: "api-key",`
- L430: `			testLayers := createTestLayers(t)`
- L431: `			mapper, err := pm.NewConfigMapper(testLayers, tt.rules...)`
- L609: `func TestResolveTargetParameter(t *testing.T) {`
- L660: `			result, err := pm.ResolveTargetParameter(tt.target, tt.captures)`
- L672: `func TestIntegrationWithLoadParametersFromFile(t *testing.T) {`
- L674: `	testLayers := createTestLayers(t)`
- L677: `	mapper, err := pm.NewConfigMapper(testLayers, pm.MappingRule{`
- L679: `		TargetLayer:     "demo",`
- L680: `		TargetParameter: "api-key",`

### `pkg/cmds/sources/profiles.go`
- L20: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L21: `			err := next(layers_, parsedLayers)`
- L57: `			//   layer1:`
- L58: `			//     parameterName: parameterValue`
- L59: `			//   layer2:`
- L60: `			//     parameterName: parameterValue`
- L70: `				return updateFromMap(layers_, parsedLayers, profileMap, options...)`
- L107: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L108: `			err := next(layers_, parsedLayers)`
- L148: `			return updateFromMap(layers_, parsedLayers, profileMap, config.ParseOptions...)`
- L223: `	//   layer1:`
- L224: `	//     parameterName: parameterValue`
- L225: `	//   layer2:`
- L226: `	//     parameterName: parameterValue`

### `pkg/cmds/sources/update.go`
- L12: `// FromDefaults is a middleware that sets default values from parameter definitions.`
- L13: `// It calls the next handler, and then iterates through each layer and parameter definition.`
- L14: `// If a default is defined, it sets that as the parameter value in the parsed layer.`
- L17: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L18: `			err := next(layers_, parsedLayers)`
- L22: `			err = layers_.UpdateWithDefaults(parsedLayers, options...)`
- L31: `// FromMap takes a map where the keys are layer slugs and the values are`
- L32: `// maps of parameter name -> value. It calls next, and then merges the provided`
- L33: `// values into the parsed layers, skipping any layers not present in layers_.`
- L36: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L37: `			err := next(layers_, parsedLayers)`
- L42: `			return updateFromMap(layers_, parsedLayers, m, options...)`
- L47: `// FromMapFirst takes a map where the keys are layer slugs and the values are`
- L48: `// maps of parameter name -> value. It calls next, and then merges the provided`
- L49: `// values into the parsed layers, skipping any layers not present in layers_.`
- L52: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L53: `			err := updateFromMap(layers_, parsedLayers, m, options...)`
- L58: `			return next(layers_, parsedLayers)`
- L63: `// FromMapAsDefault takes a map where the keys are layer slugs and the values are`
- L64: `// maps of parameter name -> value. It calls next, and then merges the provided`
- L65: `// values into the parsed layers if the parameter hasn't already been set, skipping any layers not present in layers_.`
- L68: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L69: `			err := next(layers_, parsedLayers)`
- L74: `			return updateFromMapAsDefault(layers_, parsedLayers, m, options...)`
- L79: `// FromMapAsDefaultFirst takes a map where the keys are layer slugs and the values are`
- L80: `// maps of parameter name -> value. It calls next, and then merges the provided`
- L81: `// values into the parsed layers if the parameter hasn't already been set, skipping any layers not present in layers_.`
- L84: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L85: `			err := updateFromMapAsDefault(layers_, parsedLayers, m, options...)`
- L90: `			return next(layers_, parsedLayers)`
- L96: `	layers_ *schema.Schema,`
- L97: `	parsedLayers *values.Values,`
- L101: `		layer, ok := layers_.Get(k)`
- L106: `		parsedLayer := parsedLayers.GetOrCreate(layer)`
- L107: `		ps, err := layer.GetDefinitions().GatherParametersFromMap(v, true, options...)`
- L111: `		_, err = parsedLayer.Parameters.Merge(ps)`
- L120: `	layers_ *schema.Schema,`
- L121: `	parsedLayers *values.Values,`
- L125: `		layer, ok := layers_.Get(k)`
- L130: `		parsedLayer := parsedLayers.GetOrCreate(layer)`
- L131: `		ps, err := layer.GetDefinitions().GatherParametersFromMap(v, true, options...)`
- L135: `		_, err = parsedLayer.Parameters.MergeAsDefault(ps)`
- L144: `	layers_ *schema.Schema,`
- L145: `	parsedLayers *values.Values,`
- L149: `	err := layers_.ForEachE(func(key string, l schema.Section) error {`
- L150: `		parsedLayer := parsedLayers.GetOrCreate(l)`
- L152: `		layerPrefix := l.GetPrefix()`
- L154: `			// Compute env key based on layer prefix + param name, hyphen->underscore, uppercase,`
- L156: `			base := layerPrefix + p.Name`
- L170: `				// Parse env string into the appropriate typed value using the parameter's parser.`
- L193: `				pp, err := p.ParseParameter(inputs, opts...)`
- L198: `				if err := parsedLayer.Parameters.UpdateWithLog(p.Name, p, pp.Value, pp.Log...); err != nil {`
- L215: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L216: `			err := next(layers_, parsedLayers)`
- L221: `			return updateFromEnv(layers_, parsedLayers, prefix, options...)`
- L226: `func updateFromStringList(layers_ *schema.Schema, parsedLayers *values.Values, prefix string, args []string, options ...fields.ParseOption) error {`
- L227: `	err := layers_.ForEachE(func(key string, l schema.Section) error {`
- L228: `		parsedLayer := parsedLayers.GetOrCreate(l)`
- L235: `		_, err = parsedLayer.Parameters.Merge(ps)`
- L245: `		_, err = parsedLayer.Parameters.Merge(ps)`
- L262: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L263: `			err := next(layers_, parsedLayers)`
- L268: `			return updateFromStringList(layers_, parsedLayers, prefix, args, options...)`

### `pkg/cmds/sources/update_test.go`
- L15: `	// Define a layer with a prefix so env keys are: PREFIX + "_" + UPPER(prefix+name)`
- L16: `	cfgLayer, err := schema.NewSection("cfg", "Config",`
- L33: `	pl := schema.NewSchema(schema.WithSections(cfgLayer))`
- L75: `	layer, ok := parsed.Get("cfg")`
- L79: `		v, ok := layer.Parameters.Get(name)`
- L80: `		require.True(t, ok, "parameter %s should be set", name)`
- L101: `	vp, ok := layer.Parameters.Get("verbose")`
- L117: `	cfgLayer, err := schema.NewSection("cfg", "Config",`
- L125: `	pl := schema.NewSchema(schema.WithSections(cfgLayer))`

### `pkg/cmds/sources/whitelist.go`
- L8: `// WhitelistLayersHandler only leaves the specified layers from the given ParameterLayers.`
- L9: `// It takes a slice of layer slugs, and deletes any layers in the ParameterLayers`
- L11: `func WhitelistLayersHandler(slugs []string) HandlerFunc {`
- L16: `	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L18: `		layers_.ForEach(func(key string, l schema.Section) {`
- L24: `			layers_.Delete(key)`
- L30: `func WhitelistLayerParametersHandler(parameters_ map[string][]string) HandlerFunc {`
- L31: `	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L32: `		layersToDelete := []string{}`
- L33: `		layersToUpdate := map[string]schema.Section{}`
- L34: `		layers_.ForEach(func(key string, l schema.Section) {`
- L35: `			if _, ok := parameters_[key]; !ok {`
- L36: `				layersToDelete = append(layersToDelete, key)`
- L40: `			parametersToKeep := map[string]interface{}{}`
- L41: `			for _, p := range parameters_[key] {`
- L42: `				parametersToKeep[p] = nil`
- L44: `			layersToUpdate[key] = schema.NewWhitelistParameterLayer(l, parametersToKeep)`
- L46: `		for _, key := range layersToDelete {`
- L47: `			layers_.Delete(key)`
- L49: `		for key, l := range layersToUpdate {`
- L50: `			layers_.Set(key, l)`
- L56: `func WhitelistLayers(slugs []string) Middleware {`
- L58: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L59: `			err := next(layers_, parsedLayers)`
- L64: `			return WhitelistLayersHandler(slugs)(layers_, parsedLayers)`
- L69: `func WhitelistLayersFirst(slugs []string) Middleware {`
- L71: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L72: `			err := WhitelistLayersHandler(slugs)(layers_, parsedLayers)`
- L77: `			return next(layers_, parsedLayers)`
- L82: `func WhitelistLayerParameters(parameters_ map[string][]string) Middleware {`
- L84: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L85: `			err := next(layers_, parsedLayers)`
- L90: `			return WhitelistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L95: `func WhitelistLayerParametersFirst(parameters_ map[string][]string) Middleware {`
- L97: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L98: `			err := WhitelistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L103: `			return next(layers_, parsedLayers)`
- L108: `// BlacklistLayersHandler removes the specified layers from the given ParameterLayers.`
- L109: `// It takes a slice of layer slugs, and deletes any layers in the ParameterLayers`
- L111: `func BlacklistLayersHandler(slugs []string) HandlerFunc {`
- L116: `	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L118: `		layers_.ForEach(func(key string, l schema.Section) {`
- L124: `			layers_.Delete(key)`
- L130: `func BlacklistLayerParametersHandler(parameters_ map[string][]string) HandlerFunc {`
- L131: `	return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L132: `		layersToDelete := []string{}`
- L133: `		layersToUpdate := map[string]schema.Section{}`
- L134: `		layers_.ForEach(func(key string, l schema.Section) {`
- L135: `			if _, ok := parameters_[key]; !ok {`
- L139: `			parametersToKeep := map[string]interface{}{}`
- L140: `			for _, p := range parameters_[key] {`
- L141: `				parametersToKeep[p] = nil`
- L143: `			layersToUpdate[key] = schema.NewBlacklistParameterLayer(l, parametersToKeep)`
- L145: `		for _, key := range layersToDelete {`
- L146: `			layers_.Delete(key)`
- L148: `		for key, l := range layersToUpdate {`
- L149: `			layers_.Set(key, l)`
- L155: `// BlacklistLayers is a middleware that removes the given layers from ParameterLayers after running `next`.`
- L156: `func BlacklistLayers(slugs []string) Middleware {`
- L158: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L159: `			err := next(layers_, parsedLayers)`
- L164: `			return BlacklistLayersHandler(slugs)(layers_, parsedLayers)`
- L169: `// BlacklistLayersFirst is a middleware that removes the given layers from ParameterLayers before running `next`.`
- L170: `func BlacklistLayersFirst(slugs []string) Middleware {`
- L172: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L173: `			err := next(layers_, parsedLayers)`
- L178: `			return BlacklistLayersHandler(slugs)(layers_, parsedLayers)`
- L183: `// BlacklistLayerParameters is a middleware that removes the given parameters from ParameterLayers after running `next`.`
- L184: `func BlacklistLayerParameters(parameters_ map[string][]string) Middleware {`
- L186: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L187: `			err := next(layers_, parsedLayers)`
- L192: `			return BlacklistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L197: `// BlacklistLayerParametersFirst is a middleware that removes the given parameters from ParameterLayers before running `next`.`
- L198: `func BlacklistLayerParametersFirst(parameters_ map[string][]string) Middleware {`
- L200: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L201: `			err := BlacklistLayerParametersHandler(parameters_)(layers_, parsedLayers)`
- L206: `			return next(layers_, parsedLayers)`
- L211: `// WrapWithLayerModifyingHandler wraps a middleware that modifies the layers`
- L212: `// with additional middlewares. It clones the original layers, calls the`
- L213: `// layer modifying middleware, chains any additional middlewares, calls`
- L214: `// next with the original layers, and returns any errors.`
- L217: `// restricted subset of layers. However, the normal set of middlewares is allowed`
- L219: `func WrapWithLayerModifyingHandler(m HandlerFunc, nextMiddlewares ...Middleware) Middleware {`
- L221: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L222: `			err := next(layers_, parsedLayers)`
- L229: `			clonedLayers := layers_.Clone()`
- L230: `			err = m(clonedLayers, parsedLayers)`
- L235: `			err = chain(Identity)(clonedLayers, parsedLayers)`
- L245: `// WrapWithWhitelistedLayers wraps a middleware that restricts layers`
- L248: `// certain restricted layers.`
- L249: `func WrapWithWhitelistedLayers(slugs []string, nextMiddlewares ...Middleware) Middleware {`
- L250: `	return WrapWithLayerModifyingHandler(WhitelistLayersHandler(slugs), nextMiddlewares...)`
- L253: `func WrapWithWhitelistedParameterLayers(parameters_ map[string][]string, nextMiddlewares ...Middleware) Middleware {`
- L254: `	return WrapWithLayerModifyingHandler(WhitelistLayerParametersHandler(parameters_), nextMiddlewares...)`
- L257: `// WrapWithBlacklistedLayers wraps a middleware that restricts layers`
- L260: `// certain restricted layers.`
- L261: `func WrapWithBlacklistedLayers(slugs []string, nextMiddlewares ...Middleware) Middleware {`
- L262: `	return WrapWithLayerModifyingHandler(BlacklistLayersHandler(slugs), nextMiddlewares...)`
- L265: `func WrapWithBlacklistedParameterLayers(parameters_ map[string][]string, nextMiddlewares ...Middleware) Middleware {`
- L266: `	return WrapWithLayerModifyingHandler(BlacklistLayerParametersHandler(parameters_), nextMiddlewares...)`

### `pkg/cmds/template.go`
- L29: `	Layers    schema.Schema        `yaml:"layers,omitempty"``
- L48: `func (t *TemplateCommand) RunIntoWriter(ctx context.Context, parsedLayers *values.Values, w io.Writer) error {`
- L55: `	err = tmpl.Execute(w, parsedLayers.GetDataMap())`
- L95: `	defaultLayer, err := schema.NewSection(schema.DefaultSlug, "Default",`
- L104: `		WithLayersList(tcd.Layers.AsList()...),`
- L105: `		WithLayersList(defaultLayer),`

### `pkg/cmds/values/parsed-layer.go`
- L66: `	Layer      Section`
- L67: `	Parameters *fields.ParsedParameters`
- L72: `func WithParameterValue(`
- L77: `		pd, ok := pl.Layer.GetDefinitions().Get(key)`
- L79: `			return errors.Errorf("parameter definition %s not found in layer %s", key, pl.Layer.GetName())`
- L81: `		p := &fields.ParsedParameter{`
- L88: `		pl.Parameters.Set(key, p)`
- L94: `func WithParameters(pds *fields.ParsedParameters) SectionValuesOption {`
- L96: `		pds.ForEach(func(k string, v *fields.ParsedParameter) {`
- L97: `			pl.Parameters.Set(k, v)`
- L103: `func NewSectionValues(layer Section, options ...SectionValuesOption) (*SectionValues, error) {`
- L105: `		Layer:      layer,`
- L106: `		Parameters: fields.NewParsedParameters(),`
- L119: `// Clone returns a copy of the parsedParameterLayer with a fresh Parameters map.`
- L120: `// However, neither the Layer nor the Parameters are deep copied.`
- L122: `	parameters_, err := fields.NewParsedParameters().Merge(ppl.Parameters)`
- L127: `		Layer:      ppl.Layer,`
- L128: `		Parameters: parameters_,`
- L130: `	ppl.Parameters.ForEach(func(k string, v *fields.ParsedParameter) {`
- L131: `		ret.Parameters.Set(k, v)`
- L136: `// MergeParameters merges the other SectionValues into this one, overwriting any`
- L137: `// existing values. This doesn't replace the actual Layer pointer.`
- L138: `func (ppl *SectionValues) MergeParameters(other *SectionValues) error {`
- L139: `	_, err := ppl.Parameters.Merge(other.Parameters)`
- L143: `func (ppl *SectionValues) GetParameter(k string) (interface{}, bool) {`
- L144: `	v, ok := ppl.Parameters.Get(k)`
- L152: `	return ppl.Parameters.InitializeStruct(s)`
- L191: `			err := v.MergeParameters(o)`
- L206: `			err := o_.MergeParameters(v)`
- L219: `func (p *Values) GetOrCreate(layer Section) *SectionValues {`
- L220: `	if layer == nil {`
- L221: `		panic("layer must not be nil")`
- L223: `	slug := layer.GetSlug()`
- L227: `			Layer:      layer,`
- L228: `			Parameters: fields.NewParsedParameters(),`
- L235: `// GetDataMap is useful when rendering out templates using all passed in layers.`
- L239: `		v.Parameters.ForEach(func(k string, v *fields.ParsedParameter) {`
- L247: `// If the key is "default", it creates a fresh empty default layer for defaults and initializes the struct with it.`
- L248: `// If the layer specified by the key is not found, it returns an error.`
- L249: `// The struct must be passed by reference as the s parameter.`
- L250: `func (p *Values) InitializeStruct(layerKey string, dst interface{}) error {`
- L251: `	// We special case Default because we will create a fresh empty default layer for defaults.`
- L253: `	if layerKey == DefaultSlug {`
- L254: `		return p.GetDefaultParameterLayer().InitializeStruct(dst)`
- L256: `	v, ok := p.Get(layerKey)`
- L258: `		return errors.Errorf("layer %s not found", layerKey)`
- L263: `// GetAllParsedParameters returns a new instance of fields.ParsedParameters`
- L264: `// that merges the parameters from all Values.`
- L265: `// The returned parameters are a deep clone of the fields.`
- L266: `func (p *Values) GetAllParsedParameters() *fields.ParsedParameters {`
- L267: `	ret := fields.NewParsedParameters()`
- L270: `			_, err := ret.Merge(v.Parameters.Clone())`
- L280: `func (p *Values) GetParameter(slug string, key string) (*fields.ParsedParameter, bool) {`
- L281: `	layer, ok := p.Get(slug)`
- L285: `	return layer.Parameters.Get(key)`
- L288: `func (p *Values) GetDefaultParameterLayer() *SectionValues {`
- L293: `	defaultParameterLayer := newDefaultSection(DefaultSlug, "Default")`
- L294: `	defaultLayer := &SectionValues{`
- L295: `		Layer:      defaultParameterLayer,`
- L296: `		Parameters: fields.NewParsedParameters(),`
- L298: `	p.Set(DefaultSlug, defaultLayer)`
- L300: `	return defaultLayer`

### `pkg/cmds/values/parsed-layer_test.go`
- L12: `	parsedLayers := New()`
- L13: `	assert.NotNil(t, parsedLayers)`
- L14: `	assert.Equal(t, 0, parsedLayers.Len())`
- L18: `	layer := createParameterLayer(t, "test", "Test Layer")`
- L19: `	parsedLayer := createSectionValues(t, layer, nil)`
- L21: `	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L23: `	assert.Equal(t, 1, parsedLayers.Len())`
- L24: `	val, present := parsedLayers.Get("test")`
- L26: `	assert.Equal(t, parsedLayer, val)`
- L30: `	layer := createParameterLayer(t, "test", "Test Layer")`
- L31: `	parsedLayer := createSectionValues(t, layer, nil)`
- L32: `	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L34: `	cloned := parsedLayers.Clone()`
- L36: `	assert.Equal(t, parsedLayers.Len(), cloned.Len())`
- L37: `	originalVal, _ := parsedLayers.Get("test")`
- L41: `	assert.Equal(t, originalVal.Layer, clonedVal.Layer)`
- L45: `	parsedLayers := New()`
- L46: `	layer := createParameterLayer(t, "test", "Test Layer")`
- L48: `	// Get non-existent layer (should create)`
- L49: `	parsedLayer := parsedLayers.GetOrCreate(layer)`
- L50: `	assert.NotNil(t, parsedLayer)`
- L51: `	assert.Equal(t, layer, parsedLayer.Layer)`
- L53: `	// Get existing layer`
- L54: `	sameLayer := parsedLayers.GetOrCreate(layer)`
- L55: `	assert.Equal(t, parsedLayer, sameLayer)`
- L59: `	layer1 := createParameterLayer(t, "layer1", "Layer 1",`
- L62: `	parsedLayer1 := createSectionValues(t, layer1, map[string]interface{}{"param1": "value1"})`
- L64: `	layer2 := createParameterLayer(t, "layer2", "Layer 2",`
- L67: `	parsedLayer2 := createSectionValues(t, layer2, map[string]interface{}{"param2": 42})`
- L69: `	parsedLayers := New(`
- L70: `		WithSectionValues("layer1", parsedLayer1),`
- L71: `		WithSectionValues("layer2", parsedLayer2),`
- L74: `	dataMap := parsedLayers.GetDataMap()`
- L86: `	layer := createParameterLayer(t, "test", "Test Layer",`
- L90: `	parsedLayer := createSectionValues(t, layer, map[string]interface{}{`
- L94: `	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L97: `	err := parsedLayers.InitializeStruct("test", &result)`
- L103: `func TestValuesGetAllParsedParameters(t *testing.T) {`
- L104: `	layer1 := createParameterLayer(t, "layer1", "Layer 1",`
- L107: `	parsedLayer1 := createSectionValues(t, layer1, map[string]interface{}{"param1": "value1"})`
- L109: `	layer2 := createParameterLayer(t, "layer2", "Layer 2",`
- L112: `	parsedLayer2 := createSectionValues(t, layer2, map[string]interface{}{"param2": 42})`
- L114: `	parsedLayers := New(`
- L115: `		WithSectionValues("layer1", parsedLayer1),`
- L116: `		WithSectionValues("layer2", parsedLayer2),`
- L119: `	allParams := parsedLayers.GetAllParsedParameters()`
- L129: `func TestValuesGetParameter(t *testing.T) {`
- L130: `	layer := createParameterLayer(t, "test", "Test Layer",`
- L133: `	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"param": "value"})`
- L134: `	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L136: `	param, present := parsedLayers.GetParameter("test", "param")`
- L140: `	_, present = parsedLayers.GetParameter("non_existent", "param")`
- L143: `	_, present = parsedLayers.GetParameter("test", "non_existent")`
- L147: `func TestValuesGetDefaultParameterLayer(t *testing.T) {`
- L148: `	parsedLayers := New()`
- L150: `	defaultLayer := parsedLayers.GetDefaultParameterLayer()`
- L151: `	assert.NotNil(t, defaultLayer)`
- L152: `	assert.Equal(t, DefaultSlug, defaultLayer.Layer.GetSlug())`
- L154: `	// Calling it again should return the same layer`
- L155: `	sameDefaultLayer := parsedLayers.GetDefaultParameterLayer()`
- L156: `	assert.Equal(t, defaultLayer, sameDefaultLayer)`
- L160: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L161: `	parsedLayer1 := createSectionValues(t, layer1, nil)`
- L163: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L164: `	parsedLayer2 := createSectionValues(t, layer2, nil)`
- L166: `	parsedLayers := New(`
- L167: `		WithSectionValues("layer1", parsedLayer1),`
- L168: `		WithSectionValues("layer2", parsedLayer2),`
- L172: `	parsedLayers.ForEach(func(k string, v *SectionValues) {`
- L174: `		assert.Contains(t, []string{"layer1", "layer2"}, k)`
- L180: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L181: `	parsedLayer1 := createSectionValues(t, layer1, nil)`
- L183: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L184: `	parsedLayer2 := createSectionValues(t, layer2, nil)`
- L186: `	parsedLayers := New(`
- L187: `		WithSectionValues("layer1", parsedLayer1),`
- L188: `		WithSectionValues("layer2", parsedLayer2),`
- L192: `	err := parsedLayers.ForEachE(func(k string, v *SectionValues) error {`
- L200: `	errorOnSecond := parsedLayers.ForEachE(func(k string, v *SectionValues) error {`
- L201: `		if k == "layer2" {`
- L210: `	layer := createParameterLayer(t, "test", "Test Layer",`
- L213: `	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"exported": "value"})`
- L223: `	err := parsedLayer.InitializeStruct(&result)`
- L231: `	parsedLayers := New()`
- L232: `	layer := createParameterLayer(t, "test", "Test Layer",`
- L235: `	parsedLayer := createSectionValues(t, layer, map[string]interface{}{"param": "value"})`
- L236: `	parsedLayers.Set("test", parsedLayer)`
- L243: `	err := parsedLayers.InitializeStruct("test", result) // Note: passing result, not &result`
- L248: `func TestValuesGetParameterNonExistentLayer(t *testing.T) {`
- L249: `	parsedLayers := New()`
- L251: `	_, present := parsedLayers.GetParameter("non_existent", "param")`
- L255: `func TestValuesGetOrCreateNilLayer(t *testing.T) {`
- L256: `	parsedLayers := New()`
- L258: `	// Depending on how you want to handle this case, you might expect an error or a new empty layer`
- L260: `	assert.Panics(t, func() { parsedLayers.GetOrCreate(nil) })`
- L264: `	layer := createParameterLayer(t, "test", "Test Layer",`
- L274: `		options = append(options, WithParameterValue(key, value))`
- L276: `	_, err := NewSectionValues(layer, options...)`
- L281: `	layer1 := createParameterLayer(t, "layer1", "Layer 1")`
- L282: `	parsedLayer1 := createSectionValues(t, layer1, nil)`
- L283: `	layer2 := createParameterLayer(t, "layer2", "Layer 2")`
- L284: `	parsedLayer2 := createSectionValues(t, layer2, nil)`
- L286: `	parsedLayers := New(`
- L287: `		WithSectionValues("layer1", parsedLayer1),`
- L288: `		WithSectionValues("layer2", parsedLayer2),`
- L292: `	err := parsedLayers.ForEachE(func(k string, v *SectionValues) error {`
- L294: `		if k == "layer2" {`
- L302: `	assert.Equal(t, 2, count) // The loop should have proceeded to the second layer before stopping`
- L320: `	// Create a parameter layer with all the necessary definitions`
- L321: `	layer := createParameterLayer(t, "test", "Test Layer",`
- L330: `	// Create a parsed layer with test values`
- L331: `	parsedLayer := createSectionValues(t, layer, map[string]interface{}{`
- L340: `	// Create Values and add the parsed layer`
- L341: `	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L345: `	err := parsedLayers.InitializeStruct("test", &result)`
- L379: `	// Create a parameter layer with all the necessary definitions`
- L380: `	layer := createParameterLayer(t, "test", "Test Layer",`
- L386: `	// Create a parsed layer with test values`
- L387: `	parsedLayer := createSectionValues(t, layer, map[string]interface{}{`
- L393: `	// Create Values and add the parsed layer`
- L394: `	parsedLayers := New(WithSectionValues("test", parsedLayer))`
- L398: `	err := parsedLayers.InitializeStruct("test", &result)`

### `pkg/cmds/values/serialize_parsed.go`
- L24: `	Parameters *fields.SerializableParsedParameters `yaml:"parameters" json:"parameters"``
- L30: `	if pl.Layer != nil {`
- L32: `			Name:        pl.Layer.GetName(),`
- L33: `			Slug:        pl.Layer.GetSlug(),`
- L34: `			Description: pl.Layer.GetDescription(),`
- L35: `			Prefix:      pl.Layer.GetPrefix(),`
- L36: `			Fields:      pl.Layer.GetDefinitions(),`
- L41: `		Parameters: fields.ToSerializableParsedParameters(pl.Parameters),`
- L49: `	Layers *orderedmap.OrderedMap[string, *SerializableSectionValues] `yaml:"layers" json:"layers"``
- L55: `		Layers: orderedmap.New[string, *SerializableSectionValues](),`
- L60: `		ret.Layers.Set(key, serialized)`
- L70: `	for pair := spl.Layers.Oldest(); pair != nil; pair = pair.Next() {`
- L80: `	for pair := spl.Layers.Oldest(); pair != nil; pair = pair.Next() {`

### `pkg/cmds/values/test_helpers_test.go`
- L38: `func createParameterLayer(t *testing.T, slug, name string, paramDefs ...*fields.Definition) Section {`
- L52: `func createSectionValues(t *testing.T, layer Section, parsedValues map[string]interface{}) *SectionValues {`
- L53: `	sectionValues, err := NewSectionValues(layer)`
- L60: `		definition, ok := layer.GetDefinitions().Get(key)`
- L62: `		parsed := &fields.ParsedParameter{Definition: definition}`
- L65: `		sectionValues.Parameters.Set(key, parsed)`

### `pkg/codegen/glazed.go`
- L16: `func ParameterDefinitionToDict(p *fields.Definition) (jen.Code, error) {`
- L43: `	d, err := p.CheckParameterDefaultValueValidity()`
- L51: `func FlagTypeToGoType(s *jen.Statement, parameterType fields.Type) *jen.Statement {`
- L52: `	switch parameterType {`
- L87: `		return s.Id(string(parameterType))`

### `pkg/config/editor.go`
- L102: `// GetDefaultConfigPath is updated to take an appName parameter`

### `pkg/help/cmd/cobra.go`
- L150: `	// if we are showing the short help and shortHelpLayers annotation was set,`
- L153: `		shortHelpLayers_, ok := c.Annotations["shortHelpLayers"]`
- L155: `			shortHelpLayers := map[string]interface{}{}`
- L156: `			for _, v := range strings.Split(shortHelpLayers_, ",") {`
- L157: `				shortHelpLayers[v] = true`
- L163: `				if _, ok = shortHelpLayers[f.Slug]; ok {`
- L168: `				if _, ok = shortHelpLayers[f.Slug]; ok {`

### `pkg/help/help.go`
- L474: `		fmt.Printf("Parameters: %v\n", args)`

### `pkg/help/store/compat.go`
- L11: `// HelpSystem provides a compatibility layer with the existing help system interface`

### `pkg/helpers/maps/maps.go`
- L74: `// GlazedStructToMap converts a struct pointer to a map of parameter names to values.`
- L91: `		parameterName, ok := field.Tag.Lookup("glazed")`
- L97: `		ret[parameterName] = value`

### `pkg/helpers/markdown/markdown.go`
- L100: `// them based on the `withQuotes` parameter to decide on the inclusion of the enclosing ``` marks.`

### `pkg/helpers/templating/templating.go`
- L99: `	"toUrlParameter": toUrlParameter,`
- L127: `// toUrlParameter encodes the value as a string that can be passed for url parameter decoding`
- L128: `func toUrlParameter(s interface{}) (string, error) {`
- L647: `// NOTE(manuel, 2023-04-18) Interestingly, we have a baseDir parameter here but only one pattern`

### `pkg/lua/cmds.go`
- L21: `// CallGlazedCommandFromLua executes a GlazeCommand with parameters from a Lua table`
- L23: `	// Create parsed layers`
- L24: `	parsedLayers := values.New()`
- L35: `	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)`
- L40: `	glazedLayer, ok := parsedLayers.Get(settings.GlazedSlug)`
- L42: `		return nil, fmt.Errorf("glazed layer not found")`
- L44: `	gp, err := settings.SetupTableProcessor(glazedLayer, middlewares2.WithTableMiddleware(&table.NullTableMiddleware{}))`
- L51: `	// Run the command with the parsed layers`
- L52: `	err = cmd.RunIntoGlazeProcessor(ctx, parsedLayers, gp)`
- L91: `// CallGlazedBareCommandFromLua executes a BareCcommand with parameters from a Lua table`
- L93: `	parsedLayers := values.New()`
- L100: `	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)`
- L107: `	// Run the command with the parsed layers`
- L108: `	err = cmd.Run(ctx, parsedLayers)`
- L116: `// CallGlazedWriterCommandFromLua executes a WriterCommand with parameters from a Lua table`
- L118: `	parsedLayers := values.New()`
- L125: `	err := sources.Execute(cmd.Description().Layers, parsedLayers, middlewares_...)`
- L135: `	// Run the command with the parsed layers`
- L136: `	err = cmd.RunIntoWriter(ctx, parsedLayers, &buf)`
- L244: `	// Update the parameter information global name`
- L250: `	// Create a table to hold all layers and their parameters`
- L251: `	layersTable := L.CreateTable(0, desc.Layers.Len())`
- L253: `	// Iterate through all layers`
- L254: `	desc.Layers.ForEach(func(layerName string, layer schema.Section) {`
- L255: `		layerTable := L.CreateTable(0, layer.GetDefinitions().Len())`
- L257: `		// Add parameters for this layer`
- L258: `		layer.GetDefinitions().ForEach(func(param *fields.Definition) {`
- L266: `			layerTable.RawSetString(param.Name, paramInfo)`
- L269: `		layersTable.RawSetString(layerName, layerTable)`
- L272: `	// Set the global variable with the layers table`
- L273: `	L.SetGlobal(paramsGlobalName, layersTable)`

### `pkg/lua/lua.go`
- L19: `func ParseNestedLuaTableToValues(L *lua.LState, luaTable *lua.LTable, parameterLayers *schema.Schema) (*values.Values, error) {`
- L20: `	parsedLayers := values.New()`
- L25: `			layerName := string(keyStr)`
- L26: `			layer, ok := parameterLayers.Get(layerName)`
- L28: `				conversionErrors = append(conversionErrors, fmt.Sprintf("layer '%s' not found", layerName))`
- L33: `				parsedLayer, err := ParseLuaTableToLayer(L, nestedTable, layer)`
- L37: `					parsedLayers.Set(layerName, parsedLayer)`
- L40: `				conversionErrors = append(conversionErrors, fmt.Sprintf("invalid value for layer '%s': expected table, got %s", layerName, value.Type()))`
- L46: `		return nil, fmt.Errorf("parameter conversion errors: %s", strings.Join(conversionErrors, "; "))`
- L49: `	return parsedLayers, nil`
- L52: `// ParseLuaTableToLayer parses a Lua table into a SectionValues`
- L53: `func ParseLuaTableToLayer(L *lua.LState, luaTable *lua.LTable, layer schema.Section) (*values.SectionValues, error) {`
- L59: `			paramDef, _ := layer.GetDefinitions().Get(string(keyStr))`
- L61: `				convertedValue, err := ParseParameterFromLua(L, value, paramDef)`
- L72: `		return nil, fmt.Errorf("parameter conversion errors: %s", strings.Join(conversionErrors, "; "))`
- L75: `	// Parse parameters using the layer's definitions`
- L76: `	parsedParams, err := layer.GetDefinitions().GatherParametersFromMap(params, true, fields.WithSource("lua"))`
- L81: `	// Create a parsed layer`
- L82: `	return values.NewSectionValues(layer, values.WithParameters(parsedParams))`
- L86: `func ParseLuaTableMiddleware(L *lua.LState, luaTable *lua.LTable, layerName string) sources.Middleware {`
- L88: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L89: `			// Look up the specific layer`
- L90: `			layer, ok := layers_.Get(layerName)`
- L92: `				return fmt.Errorf("layer '%s' not found", layerName)`
- L95: `			parsedLayer, err := ParseLuaTableToLayer(L, luaTable, layer)`
- L100: `			err = parsedLayers.GetOrCreate(layer).MergeParameters(parsedLayer)`
- L105: `			return next(layers_, parsedLayers)`
- L113: `		return func(layers_ *schema.Schema, parsedLayers *values.Values) error {`
- L114: `			newValues, err := ParseNestedLuaTableToValues(L, luaTable, layers_)`
- L119: `			// Merge the new parsed layers with the existing ones`
- L120: `			err = parsedLayers.Merge(newValues)`
- L125: `			return next(layers_, parsedLayers)`
- L130: `// ParseParameterFromLua parses a Lua value into a Go value based on the parameter definition`
- L131: `func ParseParameterFromLua(L *lua.LState, value lua.LValue, paramDef *fields.Definition) (interface{}, error) {`
- L137: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected string, got %s", paramDef.Name, value.Type())`
- L142: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected integer, got %s", paramDef.Name, value.Type())`
- L147: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected float, got %s", paramDef.Name, value.Type())`
- L152: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected boolean, got %s", paramDef.Name, value.Type())`
- L165: `				return nil, fmt.Errorf("invalid types in string list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L169: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (string list), got %s", paramDef.Name, value.Type())`
- L182: `				return nil, fmt.Errorf("invalid types in integer list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L186: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (integer list), got %s", paramDef.Name, value.Type())`
- L199: `				return nil, fmt.Errorf("invalid types in float list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L203: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (float list), got %s", paramDef.Name, value.Type())`
- L212: `			return nil, fmt.Errorf("invalid choice '%s' for parameter '%s'", choice, paramDef.Name)`
- L214: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected string (choice), got %s", paramDef.Name, value.Type())`
- L239: `				return nil, fmt.Errorf("invalid types in choice list for parameter '%s': %v", paramDef.Name, invalidTypes)`
- L242: `				return nil, fmt.Errorf("invalid choices %v for parameter '%s'", invalidChoices, paramDef.Name)`
- L246: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (choice list), got %s", paramDef.Name, value.Type())`
- L253: `			return nil, fmt.Errorf("invalid date '%s' for parameter '%s': %v", v, paramDef.Name, err)`
- L255: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected string (date), got %s", paramDef.Name, value.Type())`
- L266: `		return nil, fmt.Errorf("invalid type for parameter '%s': expected table (key-value), got %s", paramDef.Name, value.Type())`
- L276: `		return nil, fmt.Errorf("parameter type '%s' for '%s' is not implemented for Lua conversion", paramDef.Type, paramDef.Name)`
- L278: `	return nil, fmt.Errorf("unsupported parameter type '%s' for '%s'", paramDef.Type, paramDef.Name)`
- L419: `func SectionValuesToLuaTable(L *lua.LState, parsedLayer *values.SectionValues) *lua.LTable {`
- L420: `	luaTable := L.CreateTable(0, len(parsedLayer.Parameters.ToMap()))`
- L422: `	parsedLayer.Parameters.ForEach(func(name string, param *fields.ParsedParameter) {`
- L430: `func ValuesToLuaTable(L *lua.LState, parsedLayers *values.Values) *lua.LTable {`
- L431: `	luaTable := L.CreateTable(0, parsedLayers.Len())`
- L433: `	parsedLayers.ForEach(func(layerName string, parsedLayer *values.SectionValues) {`
- L434: `		layerTable := SectionValuesToLuaTable(L, parsedLayer)`
- L435: `		luaTable.RawSetString(layerName, layerTable)`

### `pkg/settings/glazed_layer.go`
- L22: `type GlazedParameterLayers struct {`
- L23: `	FieldsFiltersParameterLayer *FieldsFiltersParameterLayer `yaml:"fieldsFiltersParameterLayer"``
- L24: `	OutputParameterLayer        *OutputParameterLayer        `yaml:"outputParameterLayer"``
- L25: `	RenameParameterLayer        *RenameParameterLayer        `yaml:"renameParameterLayer"``
- L26: `	ReplaceParameterLayer       *ReplaceParameterLayer       `yaml:"replaceParameterLayer"``
- L27: `	SelectParameterLayer        *SelectParameterLayer        `yaml:"selectParameterLayer"``
- L28: `	TemplateParameterLayer      *TemplateParameterLayer      `yaml:"templateParameterLayer"``
- L29: `	JqParameterLayer            *JqParameterLayer            `yaml:"jqParameterLayer"``
- L30: `	SortParameterLayer          *SortParameterLayer          `yaml:"sortParameterLayer"``
- L31: `	SkipLimitParameterLayer     *SkipLimitParameterLayer     `yaml:"skipLimitParameterLayer"``
- L36: `var _ schema.Section = (*GlazedParameterLayers)(nil)`
- L37: `var _ schema.CobraSection = (*GlazedParameterLayers)(nil)`
- L40: `// It wraps NewGlazedParameterLayers for the schema facade package.`
- L41: `func NewGlazedSchema(options ...GlazeParameterLayerOption) (schema.Section, error) {`
- L42: `	return NewGlazedParameterLayers(options...)`
- L45: `func (g *GlazedParameterLayers) Clone() schema.Section {`
- L46: `	return &GlazedParameterLayers{`
- L47: `		FieldsFiltersParameterLayer: g.FieldsFiltersParameterLayer.Clone().(*FieldsFiltersParameterLayer),`
- L48: `		OutputParameterLayer:        g.OutputParameterLayer.Clone().(*OutputParameterLayer),`
- L49: `		RenameParameterLayer:        g.RenameParameterLayer.Clone().(*RenameParameterLayer),`
- L50: `		ReplaceParameterLayer:       g.ReplaceParameterLayer.Clone().(*ReplaceParameterLayer),`
- L51: `		SelectParameterLayer:        g.SelectParameterLayer.Clone().(*SelectParameterLayer),`
- L52: `		TemplateParameterLayer:      g.TemplateParameterLayer.Clone().(*TemplateParameterLayer),`
- L53: `		JqParameterLayer:            g.JqParameterLayer.Clone().(*JqParameterLayer),`
- L54: `		SortParameterLayer:          g.SortParameterLayer.Clone().(*SortParameterLayer),`
- L55: `		SkipLimitParameterLayer:     g.SkipLimitParameterLayer.Clone().(*SkipLimitParameterLayer),`
- L59: `func (g *GlazedParameterLayers) MarshalYAML() (interface{}, error) {`
- L65: `		ChildLayers: []schema.Section{`
- L66: `			g.FieldsFiltersParameterLayer,`
- L67: `			g.OutputParameterLayer,`
- L68: `			g.RenameParameterLayer,`
- L69: `			g.ReplaceParameterLayer,`
- L70: `			g.SelectParameterLayer,`
- L71: `			g.TemplateParameterLayer,`
- L72: `			g.JqParameterLayer,`
- L73: `			g.SortParameterLayer,`
- L78: `func (g *GlazedParameterLayers) GetName() string {`
- L82: `func (g *GlazedParameterLayers) GetSlug() string {`
- L86: `func (g *GlazedParameterLayers) GetDescription() string {`
- L90: `func (g *GlazedParameterLayers) GetPrefix() string {`
- L91: `	return g.FieldsFiltersParameterLayer.GetPrefix()`
- L94: `func (g *GlazedParameterLayers) AddFields(...*fields.Definition) {`
- L98: `func (g *GlazedParameterLayers) GetDefinitions() *fields.Definitions {`
- L100: `	ret.Merge(g.OutputParameterLayer.GetDefinitions()).`
- L101: `		Merge(g.FieldsFiltersParameterLayer.GetDefinitions()).`
- L102: `		Merge(g.SelectParameterLayer.GetDefinitions()).`
- L103: `		Merge(g.TemplateParameterLayer.GetDefinitions()).`
- L104: `		Merge(g.RenameParameterLayer.GetDefinitions()).`
- L105: `		Merge(g.ReplaceParameterLayer.GetDefinitions()).`
- L106: `		Merge(g.JqParameterLayer.GetDefinitions()).`
- L107: `		Merge(g.SortParameterLayer.GetDefinitions()).`
- L108: `		Merge(g.SkipLimitParameterLayer.GetDefinitions())`
- L113: `func (g *GlazedParameterLayers) AddLayerToCobraCommand(cmd *cobra.Command) error {`
- L114: `	layers := []schema.CobraSection{`
- L115: `		g.OutputParameterLayer,`
- L116: `		g.FieldsFiltersParameterLayer,`
- L117: `		g.SelectParameterLayer,`
- L118: `		g.TemplateParameterLayer,`
- L119: `		g.RenameParameterLayer,`
- L120: `		g.ReplaceParameterLayer,`
- L121: `		g.JqParameterLayer,`
- L122: `		g.SortParameterLayer,`
- L123: `		g.SkipLimitParameterLayer,`
- L126: `	for _, layer := range layers {`
- L127: `		if err := layer.AddLayerToCobraCommand(cmd); err != nil {`
- L134: `func (g *GlazedParameterLayers) ParseLayerFromCobraCommand(`
- L139: `		Layer: g,`
- L141: `	ps := fields.NewParsedParameters()`
- L143: `	layers := []schema.CobraSection{`
- L144: `		g.OutputParameterLayer,`
- L145: `		g.SelectParameterLayer,`
- L146: `		g.RenameParameterLayer,`
- L147: `		g.TemplateParameterLayer,`
- L148: `		g.FieldsFiltersParameterLayer,`
- L149: `		g.ReplaceParameterLayer,`
- L150: `		g.JqParameterLayer,`
- L151: `		g.SortParameterLayer,`
- L152: `		g.SkipLimitParameterLayer,`
- L155: `	for _, layer := range layers {`
- L156: `		l, err := layer.ParseLayerFromCobraCommand(cmd, options...)`
- L160: `		if _, err = ps.Merge(l.Parameters); err != nil {`
- L165: `	res.Parameters = ps`
- L169: `func (g *GlazedParameterLayers) GatherParametersFromMap(`
- L172: `) (*fields.ParsedParameters, error) {`
- L173: `	ps := fields.NewParsedParameters()`
- L175: `	layers := []schema.Section{`
- L176: `		g.OutputParameterLayer,`
- L177: `		g.SelectParameterLayer,`
- L178: `		g.RenameParameterLayer,`
- L179: `		g.TemplateParameterLayer,`
- L180: `		g.FieldsFiltersParameterLayer,`
- L181: `		g.ReplaceParameterLayer,`
- L182: `		g.JqParameterLayer,`
- L183: `		g.SortParameterLayer,`
- L184: `		g.SkipLimitParameterLayer,`
- L187: `	for _, layer := range layers {`
- L188: `		ps_, err := layer.GetDefinitions().GatherParametersFromMap(m, onlyProvided, options...)`
- L200: `func (g *GlazedParameterLayers) InitializeDefaultsFromStruct(s interface{}) error {`
- L201: `	layers := []schema.Section{`
- L202: `		g.OutputParameterLayer,`
- L203: `		g.FieldsFiltersParameterLayer,`
- L204: `		g.SelectParameterLayer,`
- L205: `		g.TemplateParameterLayer,`
- L206: `		g.RenameParameterLayer,`
- L207: `		g.ReplaceParameterLayer,`
- L208: `		g.JqParameterLayer,`
- L209: `		g.SortParameterLayer,`
- L210: `		g.SkipLimitParameterLayer,`
- L213: `	for _, layer := range layers {`
- L214: `		if err := layer.InitializeDefaultsFromStruct(s); err != nil {`
- L221: `type GlazeParameterLayerOption func(*GlazedParameterLayers) error`
- L223: `func WithOutputParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L224: `	return func(g *GlazedParameterLayers) error {`
- L226: `			err := option(g.OutputParameterLayer.SectionImpl)`
- L235: `func WithSelectParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L236: `	return func(g *GlazedParameterLayers) error {`
- L238: `			err := option(g.SelectParameterLayer.SectionImpl)`
- L247: `func WithTemplateParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L248: `	return func(g *GlazedParameterLayers) error {`
- L250: `			err := option(g.TemplateParameterLayer.SectionImpl)`
- L259: `func WithRenameParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L260: `	return func(g *GlazedParameterLayers) error {`
- L262: `			err := option(g.RenameParameterLayer.SectionImpl)`
- L271: `func WithReplaceParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L272: `	return func(g *GlazedParameterLayers) error {`
- L274: `			err := option(g.ReplaceParameterLayer.SectionImpl)`
- L283: `func WithFieldsFiltersParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L284: `	return func(g *GlazedParameterLayers) error {`
- L286: `			err := option(g.FieldsFiltersParameterLayer.SectionImpl)`
- L295: `func WithJqParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L296: `	return func(g *GlazedParameterLayers) error {`
- L298: `			err := option(g.JqParameterLayer.SectionImpl)`
- L307: `func WithSortParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L308: `	return func(g *GlazedParameterLayers) error {`
- L310: `			err := option(g.SortParameterLayer.SectionImpl)`
- L319: `func WithSkipLimitParameterLayerOptions(options ...schema.SectionOption) GlazeParameterLayerOption {`
- L320: `	return func(g *GlazedParameterLayers) error {`
- L322: `			err := option(g.SkipLimitParameterLayer.SectionImpl)`
- L331: `func NewGlazedParameterLayers(options ...GlazeParameterLayerOption) (*GlazedParameterLayers, error) {`
- L332: `	fieldsFiltersParameterLayer, err := NewFieldsFiltersParameterLayer()`
- L336: `	outputParameterLayer, err := NewOutputParameterLayer()`
- L340: `	renameParameterLayer, err := NewRenameParameterLayer()`
- L344: `	replaceParameterLayer, err := NewReplaceParameterLayer()`
- L348: `	selectParameterLayer, err := NewSelectParameterLayer()`
- L352: `	templateParameterLayer, err := NewTemplateParameterLayer()`
- L356: `	jqParameterLayer, err := NewJqParameterLayer()`
- L360: `	sortParameterLayer, err := NewSortParameterLayer()`
- L364: `	skipLimitParameterLayer, err := NewSkipLimitParameterLayer()`
- L368: `	ret := &GlazedParameterLayers{`
- L369: `		FieldsFiltersParameterLayer: fieldsFiltersParameterLayer,`
- L370: `		OutputParameterLayer:        outputParameterLayer,`
- L371: `		RenameParameterLayer:        renameParameterLayer,`
- L372: `		ReplaceParameterLayer:       replaceParameterLayer,`
- L373: `		SelectParameterLayer:        selectParameterLayer,`
- L374: `		TemplateParameterLayer:      templateParameterLayer,`
- L375: `		JqParameterLayer:            jqParameterLayer,`
- L376: `		SortParameterLayer:          sortParameterLayer,`
- L377: `		SkipLimitParameterLayer:     skipLimitParameterLayer,`
- L390: `func SetupRowOutputFormatter(glazedLayer *values.SectionValues) (formatters.RowOutputFormatter, error) {`
- L391: `	outputSettings, err := NewOutputFormatterSettings(glazedLayer)`
- L404: `func SetupTableOutputFormatter(glazedLayer *values.SectionValues) (formatters.TableOutputFormatter, error) {`
- L405: `	selectSettings, err := NewSelectSettingsFromParameters(glazedLayer)`
- L410: `	outputSettings, err := NewOutputFormatterSettings(glazedLayer)`
- L447: `// DO(manuel, 2023-06-30) It would be good to used a parsedLayer here, if we ever refactor that part`
- L449: `	glazedLayer *values.SectionValues,`
- L455: `	templateSettings, err := NewTemplateSettings(glazedLayer)`
- L459: `	selectSettings, err := NewSelectSettingsFromParameters(glazedLayer)`
- L463: `	renameSettings, err := NewRenameSettingsFromParameters(glazedLayer)`
- L467: `	fieldsFilterSettings, err := NewFieldsFilterSettings(glazedLayer)`
- L471: `	replaceSettings, err := NewReplaceSettingsFromParameters(glazedLayer)`
- L475: `	jqSettings, err := NewJqSettingsFromParameters(glazedLayer)`
- L479: `	sortSettings, err := NewSortSettingsFromParameters(glazedLayer)`
- L483: `	outputSettings, err := NewOutputFormatterSettings(glazedLayer)`
- L487: `	skipLimitSettings, err := NewSkipLimitSettingsFromParameters(glazedLayer)`
- L545: `	// to the API that we currently use (which is a unordered hashmap, and parsed layers that lose the positioning)`
- L569: `	glazedLayer *values.SectionValues,`
- L573: `	rowOf, err := SetupRowOutputFormatter(glazedLayer)`
- L587: `		of, err := SetupTableOutputFormatter(glazedLayer)`

### `pkg/settings/settings_fields-filters.go`
- L27: `type FieldsFiltersParameterLayer struct {`
- L31: `var _ schema.CobraSection = &FieldsFiltersParameterLayer{}`
- L32: `var _ schema.Section = &FieldsFiltersParameterLayer{}`
- L34: `func (f *FieldsFiltersParameterLayer) Clone() schema.Section {`
- L35: `	return &FieldsFiltersParameterLayer{`
- L51: `func NewFieldsFiltersParameterLayer(options ...schema.SectionOption) (*FieldsFiltersParameterLayer, error) {`
- L52: `	ret := &FieldsFiltersParameterLayer{}`
- L53: `	layer, err := schema.NewSectionFromYAML(fieldsFiltersFlagsYaml, options...)`
- L55: `		return nil, errors.Wrap(err, "Failed to create fields and filters parameter layer")`
- L57: `	ret.SectionImpl = layer`
- L62: `func (f *FieldsFiltersParameterLayer) AddLayerToCobraCommand(cmd *cobra.Command) error {`
- L64: `	err := f.InitializeStructFromParameterDefaults(defaults)`
- L79: `	return f.SectionImpl.AddLayerToCobraCommand(cmd)`
- L82: `func (f *FieldsFiltersParameterLayer) ParseLayerFromCobraCommand(`
- L86: `	l, err := f.SectionImpl.ParseLayerFromCobraCommand(cmd, options...)`
- L93: `	// This means we'd have to store if a flag was changed in the parsed layer`
- L95: `		parsedFilter, ok := l.Parameters.Get("filter")`
- L100: `				return nil, errors.New("Failed to find default filter parameter definition")`
- L102: `			p := &fields.ParsedParameter{`
- L107: `				return nil, errors.Wrap(err, "Failed to update filter parameter")`
- L109: `			l.Parameters.Set("filter", p)`
- L113: `				return nil, errors.Wrap(err, "Failed to update filter parameter")`
- L121: `func NewFieldsFilterSettings(glazedLayer *values.SectionValues) (*FieldsFilterSettings, error) {`
- L123: `	err := glazedLayer.Parameters.InitializeStruct(s)`

### `pkg/settings/settings_jq.go`
- L21: `type JqParameterLayer struct {`
- L25: `func NewJqParameterLayer(options ...schema.SectionOption) (*JqParameterLayer, error) {`
- L26: `	ret := &JqParameterLayer{}`
- L27: `	layer, err := schema.NewSectionFromYAML(jqFlagsYaml, options...)`
- L29: `		return nil, errors.Wrap(err, "Failed to create jq parameter layer")`
- L31: `	ret.SectionImpl = layer`
- L35: `func (f *JqParameterLayer) Clone() schema.Section {`
- L36: `	return &JqParameterLayer{`
- L41: `func NewJqSettingsFromParameters(glazedLayer *values.SectionValues) (*JqSettings, error) {`
- L43: `	err := glazedLayer.Parameters.InitializeStruct(s)`
- L45: `		return nil, errors.Wrap(err, "Failed to initialize jq settings from parameters")`

### `pkg/settings/settings_output.go`
- L55: `type OutputParameterLayer struct {`
- L59: `func NewOutputParameterLayer(options ...schema.SectionOption) (*OutputParameterLayer, error) {`
- L60: `	ret := &OutputParameterLayer{}`
- L61: `	layer, err := schema.NewSectionFromYAML(outputFlagsYaml, options...)`
- L65: `	ret.SectionImpl = layer`
- L70: `func (f *OutputParameterLayer) Clone() schema.Section {`
- L71: `	return &OutputParameterLayer{`
- L76: `func NewOutputFormatterSettings(glazedLayer *values.SectionValues) (*OutputFormatterSettings, error) {`
- L78: `	err := glazedLayer.Parameters.InitializeStruct(s)`

### `pkg/settings/settings_rename.go`
- L57: `type RenameParameterLayer struct {`
- L61: `func NewRenameParameterLayer(options ...schema.SectionOption) (*RenameParameterLayer, error) {`
- L62: `	ret := &RenameParameterLayer{}`
- L63: `	layer, err := schema.NewSectionFromYAML(renameFlagsYaml, options...)`
- L65: `		return nil, errors.Wrap(err, "Failed to create rename parameter layer")`
- L67: `	ret.SectionImpl = layer`
- L71: `func (f *RenameParameterLayer) Clone() schema.Section {`
- L72: `	return &RenameParameterLayer{`
- L77: `func NewRenameSettingsFromParameters(glazedLayer *values.SectionValues) (*RenameSettings, error) {`
- L78: `	ps := glazedLayer.Parameters`

### `pkg/settings/settings_replace.go`
- L42: `type ReplaceParameterLayer struct {`
- L49: `func NewReplaceParameterLayer(options ...schema.SectionOption) (*ReplaceParameterLayer, error) {`
- L50: `	ret := &ReplaceParameterLayer{}`
- L51: `	layer, err := schema.NewSectionFromYAML(replaceFlagsYaml, options...)`
- L55: `	ret.SectionImpl = layer`
- L59: `func (f *ReplaceParameterLayer) Clone() schema.Section {`
- L60: `	return &ReplaceParameterLayer{`
- L65: `func NewReplaceSettingsFromParameters(glazedLayer *values.SectionValues) (*ReplaceSettings, error) {`
- L67: `	err := glazedLayer.Parameters.InitializeStruct(s)`
- L69: `		return nil, errors.Wrap(err, "failed to initialize replace settings from parameters")`

### `pkg/settings/settings_select.go`
- L21: `func NewSelectSettingsFromParameters(glazedLayer *values.SectionValues) (*SelectSettings, error) {`
- L23: `	err := glazedLayer.Parameters.InitializeStruct(s)`
- L25: `		return nil, errors.Wrap(err, "Failed to initialize select settings from parameters")`
- L39: `type SelectParameterLayer struct {`
- L43: `func NewSelectParameterLayer(options ...schema.SectionOption) (*SelectParameterLayer, error) {`
- L44: `	ret := &SelectParameterLayer{}`
- L45: `	layer, err := schema.NewSectionFromYAML(selectFlagsYaml, options...)`
- L47: `		return nil, errors.Wrap(err, "Failed to create select parameter layer")`
- L49: `	ret.SectionImpl = layer`
- L54: `func (f *SelectParameterLayer) Clone() schema.Section {`
- L55: `	return &SelectParameterLayer{`

### `pkg/settings/settings_skip_limit.go`
- L19: `func NewSkipLimitSettingsFromParameters(glazedLayer *values.SectionValues) (*SkipLimitSettings, error) {`
- L21: `	err := glazedLayer.Parameters.InitializeStruct(s)`
- L23: `		return nil, errors.Wrap(err, "Failed to initialize skipLimit settings from parameters")`
- L29: `type SkipLimitParameterLayer struct {`
- L33: `func NewSkipLimitParameterLayer(options ...schema.SectionOption) (*SkipLimitParameterLayer, error) {`
- L34: `	ret := &SkipLimitParameterLayer{}`
- L35: `	layer, err := schema.NewSectionFromYAML(skipLimitFlagsYaml, options...)`
- L37: `		return nil, errors.Wrap(err, "Failed to create skipLimit parameter layer")`
- L39: `	ret.SectionImpl = layer`
- L43: `func (f *SkipLimitParameterLayer) Clone() schema.Section {`
- L44: `	return &SkipLimitParameterLayer{`

### `pkg/settings/settings_sort.go`
- L20: `func NewSortSettingsFromParameters(glazedLayer *values.SectionValues) (*SortFlagsSettings, error) {`
- L22: `	err := glazedLayer.Parameters.InitializeStruct(s)`
- L24: `		return nil, errors.Wrap(err, "Failed to initialize sort settings from parameters")`
- L30: `type SortParameterLayer struct {`
- L34: `func NewSortParameterLayer(options ...schema.SectionOption) (*SortParameterLayer, error) {`
- L35: `	ret := &SortParameterLayer{}`
- L36: `	layer, err := schema.NewSectionFromYAML(sortFlagsYaml, options...)`
- L38: `		return nil, errors.Wrap(err, "Failed to create sort parameter layer")`
- L40: `	ret.SectionImpl = layer`
- L45: `func (f *SortParameterLayer) Clone() schema.Section {`
- L46: `	return &SortParameterLayer{`

### `pkg/settings/settings_template.go`
- L48: `type TemplateParameterLayer struct {`
- L52: `const GlazedTemplateLayerSlug = "glazed-template"`
- L54: `func NewTemplateParameterLayer(options ...schema.SectionOption) (*TemplateParameterLayer, error) {`
- L55: `	ret := &TemplateParameterLayer{}`
- L56: `	layer, err := schema.NewSectionFromYAML(templateFlagsYaml, options...)`
- L58: `		return nil, errors.Wrap(err, "Failed to create template parameter layer")`
- L60: `	ret.SectionImpl = layer`
- L65: `func (f *TemplateParameterLayer) Clone() schema.Section {`
- L66: `	return &TemplateParameterLayer{`
- L71: `func NewTemplateSettings(layer *values.SectionValues) (*TemplateSettings, error) {`
- L77: `	templateArgument, ok := layer.Parameters.GetValue("template").(string)`
- L81: `		v := layer.Parameters.GetValue("template-field")`
- L95: `	useRowTemplates, ok := layer.Parameters.GetValue("use-row-templates").(bool)`

### `pkg/settings/settings_template_test.go`
- L15: `	layer, err := NewTemplateParameterLayer()`
- L17: `	err = layer.InitializeDefaultsFromStruct(defaults)`
- L20: `	layers_ := schema.NewSchema(schema.WithSections(layer))`
- L21: `	parsedLayers := values.New()`
- L22: `	err = sources.Execute(layers_, parsedLayers,`
- L28: `	ps, ok := parsedLayers.Get(GlazedTemplateLayerSlug)`

### `ttmp/2025-07-29/test_defaults/test_defaults.go`
- L14: `	// Get default parameter layer`
- L15: `	defaultLayer, ok := cmd.Description().Layers.Get(schema.DefaultSlug)`
- L17: `		panic("default layer not found")`
- L20: `	// Create parsed layer with parameter values`
- L23: `		if _, exists := defaultLayer.GetDefinitions().Get(k); exists {`
- L24: `			options = append(options, values.WithParameterValue(k, v))`
- L28: `	parsedLayer, err := values.NewSectionValues(defaultLayer, options...)`
- L34: `	parsedLayers := values.New()`
- L35: `	parsedLayers.Set(schema.DefaultSlug, parsedLayer)`
- L38: `	err = cmd.RunIntoWriter(context.Background(), parsedLayers, &output)`

### `ttmp/2025-07-29/test_doc_example/test_doc_example.go`
- L32: `	// Execute with parameters`
- L39: `	// Get default parameter layer`
- L40: `	defaultLayer, ok := cmd.Description().Layers.Get(schema.DefaultSlug)`
- L42: `		panic("default layer not found")`
- L45: `	// Create parsed layer with parameter values`
- L48: `		if _, exists := defaultLayer.GetDefinitions().Get(k); exists {`
- L49: `			options = append(options, values.WithParameterValue(k, v))`
- L53: `	parsedLayer, err := values.NewSectionValues(defaultLayer, options...)`
- L59: `	parsedLayers := values.New()`
- L60: `	parsedLayers.Set(schema.DefaultSlug, parsedLayer)`
- L63: `	err = cmd.RunIntoWriter(context.Background(), parsedLayers, &output)`

### `ttmp/2025-07-29/test_template_api/test_template_api.go`
- L67: `	// Get the default layer`
- L68: `	defaultLayer, ok := cmd.Description().Layers.Get(schema.DefaultSlug)`
- L70: `		fmt.Printf("Default layer not found\n")`
- L74: `	// Prepare options for creating parsed layer`
- L77: `		if _, ok := defaultLayer.GetDefinitions().Get(k); ok {`
- L78: `			options = append(options, values.WithParameterValue(k, v))`
- L82: `	// Create a parsed layer with the values`
- L83: `	parsedLayer, err := values.NewSectionValues(defaultLayer, options...)`
- L85: `		fmt.Printf("Error creating parsed layer: %v\n", err)`
- L89: `	// Create parsed layers container`
- L90: `	parsedLayers := values.New()`
- L91: `	parsedLayers.Set(schema.DefaultSlug, parsedLayer)`
- L95: `	err = cmd.RunIntoWriter(context.Background(), parsedLayers, buf)`

### `ttmp/2025-08-05/signal-test/main.go`
- L40: `	parsedLayers *values.Values,`
- L44: `	if err := parsedLayers.InitializeStruct(schema.DefaultSlug, settings); err != nil {`
- L177: `	glazedLayer, err := settings.NewGlazedParameterLayers()`
- L182: `	commandSettingsLayer, err := cli.NewCommandSettingsLayer()`
- L241: `		cmds.WithLayersList(glazedLayer, commandSettingsLayer),`
- L269: `			ShortHelpLayers: []string{schema.DefaultSlug},`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/rename_glazed_api.go`
- L48: `	"github.com/go-go-golems/glazed/pkg/cmds/layers":                    "github.com/go-go-golems/glazed/pkg/cmds/schema",`
- L49: `	"github.com/go-go-golems/glazed/pkg/cmds/parameters":                "github.com/go-go-golems/glazed/pkg/cmds/fields",`
- L62: `	"github.com/go-go-golems/glazed/pkg/cmds/layers": {`
- L63: `		"ParameterLayer":        {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "Section"},`
- L64: `		"ParameterLayers":       {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "Schema"},`
- L65: `		"ParameterLayerImpl":    {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "SectionImpl"},`
- L66: `		"ParameterLayerOptions": {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "SectionOption"},`
- L67: `		"ParameterLayersOption": {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "SchemaOption"},`
- L68: `		"NewParameterLayer":     {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "NewSection"},`
- L69: `		"NewParameterLayers":    {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "NewSchema"},`
- L70: `		"WithLayers":            {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "WithSections"},`
- L71: `		"WithDefinitions":       {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/layers"], NewIdent: "WithFields"},`
- L78: `		"WithParameters":        {NewPkgPath: "github.com/go-go-golems/glazed/pkg/cmds/values", NewIdent: "WithParameters"},`
- L79: `		"WithParameterValue":    {NewPkgPath: "github.com/go-go-golems/glazed/pkg/cmds/values", NewIdent: "WithParameterValue"},`
- L81: `	"github.com/go-go-golems/glazed/pkg/cmds/parameters": {`
- L82: `		"ParameterDefinition":       {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/parameters"], NewIdent: "Definition"},`
- L83: `		"ParameterDefinitions":      {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/parameters"], NewIdent: "Definitions"},`
- L84: `		"ParameterDefinitionOption": {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/parameters"], NewIdent: "Option"},`
- L85: `		"NewParameterDefinition":    {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/parameters"], NewIdent: "New"},`
- L86: `		"NewParameterDefinitions":   {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/parameters"], NewIdent: "NewDefinitions"},`
- L95: `		"LoadParametersFromFile":      {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/middlewares"], NewIdent: "FromFile"},`
- L96: `		"LoadParametersFromFiles":     {NewPkgPath: oldToNewPkg["github.com/go-go-golems/glazed/pkg/cmds/middlewares"], NewIdent: "FromFiles"},`
- L224: `		// Special handling: ParameterType* => Type*`
- L225: `		if !found && pkgPath == "github.com/go-go-golems/glazed/pkg/cmds/parameters" && strings.HasPrefix(se.Sel.Name, "ParameterType") {`
- L226: `			suffix := strings.TrimPrefix(se.Sel.Name, "ParameterType")`
- L331: `	updated := strings.ReplaceAll(raw, "glazed.parameter", "glazed")`

## Files with content matches (other types)
### `CHANGELOG`
- L10: `- Parse Lua tables into Glazed parameter layers`

### `cmd/examples/config-custom-mapper/config.yaml`
- L1: `# Flat config structure - different from the default layer-based structure`

### `cmd/examples/config-pattern-mapper/mappings.yaml`
- L3: `    target_layer: "demo"`
- L6: `        target_parameter: "{env}-api-key"`

### `pinocchio/glazed/create-template-command.yaml`
- L66: `  The types of parameters that can be used for flags are:`
- L67: `  - ParameterTypeString: "string"`
- L68: `  - ParameterTypeStringFromFile: "stringFromFile" -> string`
- L69: `  - ParameterTypeObjectListFromFile: "objectListFromFile" -> []interface{}`
- L70: `  - ParameterTypeObjectFromFile: "objectFromFile" -> interface{}`
- L71: `  - ParameterTypeKeyValue: "keyValue" -> map[string]interface{}`
- L72: `  - ParameterTypeInteger: "int"`
- L73: `  - ParameterTypeFloat: "float"`
- L74: `  - ParameterTypeBool: "bool"`
- L75: `  - ParameterTypeDate: "date"`
- L76: `  - ParameterTypeStringList: "stringList"`
- L77: `  - ParameterTypeIntegerList: "intList"`
- L78: `  - ParameterTypeFloatList: "floatList"`
- L79: `  - ParameterTypeChoice: "choice" -> string`
- L80: `  - ParameterTypeChoiceList: "choiceList" -> []string`

### `pkg/cmds/fields/test-data/gather-fields.yaml`
- L3: `  parameterDefs:`
- L23: `  parameterDefs:`
- L40: `  parameterDefs:`
- L60: `  parameterDefs:`
- L79: `  parameterDefs:`
- L99: `  parameterDefs:`
- L117: `  parameterDefs:`
- L135: `  parameterDefs:`
- L151: `  parameterDefs:`
- L168: `  parameterDefs:`
- L184: `  parameterDefs:`
- L198: `  parameterDefs:`
- L217: `  parameterDefs:`
- L225: `  expectedError: "unknown parameter type foobar"`
- L229: `  parameterDefs:`
- L241: `  parameterDefs:`
- L253: `  parameterDefs:`
- L263: `- title: "Test with choice parameters"`
- L265: `  parameterDefs:`
- L279: `- title: "Test with valid choice parameter"`
- L281: `  parameterDefs:`
- L296: `- title: "Test with empty choice parameter"`
- L297: `  description: "Ensure that providing an empty string for a choice parameter results in an error."`
- L298: `  parameterDefs:`
- L313: `# - title: "Test list-type parameter"`
- L314: `#   description: "Ensure that the list-type parameter is correctly parsed"`
- L315: `#   parameterDefs:`
- L330: `# - title: "Test with empty list-type parameter"`
- L331: `#   description: "Ensure that an empty list is handled correctly for list-type parameters."`
- L332: `#   parameterDefs:`
- L342: `- title: "Test with mixed types in list-type parameter"`
- L344: `  parameterDefs:`
- L351: `  expectedError: "List-type parameter 'scores' contains invalid types, expected float list."`
- L353: `- title: "Test with single value for list-type parameter"`
- L354: `  description: "Ensure that a single value is handled correctly for list-type parameters."`
- L355: `  parameterDefs:`

### `pkg/cmds/fields/test-data/parameters_test.yaml`
- L1: `#  ParameterTypeString         ParameterType = "string"`
- L2: `#  ParameterTypeStringFromFile ParameterType = "stringFromFile"`
- L3: `#  ParameterTypeObjectListFromFile ParameterType = "objectListFromFile"`
- L4: `#  ParameterTypeObjectFromFile     ParameterType = "objectFromFile"`
- L5: `#  // ParameterTypeKeyValue signals either a string with comma separate key-value options, or when beginning with @, a file with key-value options`
- L6: `#  ParameterTypeKeyValue    ParameterType = "keyValue"`
- L7: `#  ParameterTypeInteger     ParameterType = "int"`
- L8: `#  ParameterTypeFloat       ParameterType = "float"`
- L9: `#  ParameterTypeBool        ParameterType = "bool"`
- L10: `#  ParameterTypeDate        ParameterType = "date"`
- L11: `#  ParameterTypeStringList  ParameterType = "stringList"`
- L12: `#  ParameterTypeIntegerList ParameterType = "intList"`
- L13: `#  ParameterTypeFloatList   ParameterType = "floatList"`
- L14: `#  ParameterTypeChoice      ParameterType = "choice"`
- L15: `#  ParameterTypeChoiceList  ParameterType = "choiceList"`

### `pkg/cmds/fields/test-data/parameters_validity_test.yaml`
- L1: `#  ParameterTypeString         ParameterType = "string"`
- L2: `#  ParameterTypeStringFromFile ParameterType = "stringFromFile"`
- L3: `#  ParameterTypeObjectListFromFile ParameterType = "objectListFromFile"`
- L4: `#  ParameterTypeObjectFromFile     ParameterType = "objectFromFile"`
- L5: `#  // ParameterTypeKeyValue signals either a string with comma separate key-value options, or when beginning with @, a file with key-value options`
- L6: `#  ParameterTypeKeyValue    ParameterType = "keyValue"`
- L7: `#  ParameterTypeInteger     ParameterType = "int"`
- L8: `#  ParameterTypeFloat       ParameterType = "float"`
- L9: `#  ParameterTypeBool        ParameterType = "bool"`
- L10: `#  ParameterTypeDate        ParameterType = "date"`
- L11: `#  ParameterTypeStringList  ParameterType = "stringList"`
- L12: `#  ParameterTypeIntegerList ParameterType = "intList"`
- L13: `#  ParameterTypeFloatList   ParameterType = "floatList"`
- L14: `#  ParameterTypeChoice      ParameterType = "choice"`
- L15: `#  ParameterTypeChoiceList  ParameterType = "choiceList"`

### `pkg/cmds/sources/tests/middlewares.yaml`
- L1: `- name: "Empty middlewares and parsedLayers"`
- L2: `  description: "Empty middlewares should result in empty parsed layers"`
- L3: `  parameterLayers: [ ]`
- L4: `  parsedLayers: [ ]`
- L5: `  expectedLayers: [ ]`
- L9: `- name: "Empty parsedLayers, set from defaults"`
- L10: `  description: "Only set from defaults middlewares, with empty parsed layers"`
- L11: `  parameterLayers: [ ]`
- L12: `  parsedLayers: [ ]`
- L13: `  expectedLayers: [ ]`
- L21: `- name: "Single parameter, set from defaults"`
- L22: `  description: "Only set from defaults middlewares, with single parameter"`
- L23: `  parameterLayers:`
- L24: `    - name: "layer1"`
- L29: `  parsedLayers: [ ]`
- L30: `  expectedLayers:`
- L31: `    - name: "layer1"`
- L45: `- name: "Single parameter, set from defaults and then update from map"`
- L46: `  description: "Set from defaults then map middlewares, with single parameter"`
- L47: `  parameterLayers:`
- L48: `    - name: "layer1"`
- L53: `  parsedLayers: [ ]`
- L54: `  expectedLayers:`
- L55: `    - name: "layer1"`
- L73: `        layer1:`

### `pkg/cmds/sources/tests/multi-update-from-map.yaml`
- L3: `    description: "Applying an empty sequence of update maps should not change ParameterLayers or ParsedLayers."`
- L4: `    parameterLayers: []`
- L5: `    parsedLayers: []`
- L6: `    expectedLayers: []`
- L12: `    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L13: `    parameterLayers:`
- L14: `      - name: "layer1"`
- L19: `    parsedLayers:`
- L20: `      - name: "layer1"`
- L21: `        parameters:`
- L24: `    expectedLayers:`
- L25: `      - name: "layer1"`
- L30: `      - layer1:`
- L35: `    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L36: `    parameterLayers:`
- L37: `      - name: "layer1"`
- L42: `    parsedLayers:`
- L43: `      - name: "layer1"`
- L44: `        parameters:`
- L47: `    expectedLayers:`
- L48: `      - name: "layer1"`
- L53: `      - layer1:`
- L58: `    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L59: `    parameterLayers:`
- L60: `      - name: "layer1"`
- L67: `    parsedLayers:`
- L68: `      - name: "layer1"`
- L69: `        parameters:`
- L74: `    expectedLayers:`
- L75: `      - name: "layer1"`
- L80: `      - layer1:`
- L85: `    description: "A single update map should correctly apply updates to the ParsedLayers."`
- L86: `    parameterLayers:`
- L87: `      - name: "layer1"`
- L96: `    parsedLayers:`
- L97: `      - name: "layer1"`
- L98: `        parameters:`
- L103: `    expectedLayers:`
- L104: `      - name: "layer1"`
- L109: `      - layer1:`
- L114: `    description: "Multiple update maps should apply updates in sequence to the ParsedLayers."`
- L115: `    parameterLayers:`
- L116: `      - name: "layer1"`
- L124: `    parsedLayers:`
- L125: `      - name: "layer1"`
- L126: `        parameters:`
- L131: `    expectedLayers:`
- L132: `      - name: "layer1"`
- L138: `      - layer1:`
- L141: `      - layer1:`
- L148: `    parameterLayers:`
- L149: `      - name: "layer1"`
- L154: `    parsedLayers:`
- L155: `      - name: "layer1"`
- L156: `    expectedLayers:`
- L157: `      - name: "layer1"`
- L162: `      - layer1:`
- L164: `      - layer1:`
- L167: `  # Test 5: Non-Existent Layers`
- L168: `  - name: "Non-Existent Layers"`
- L169: `    description: "Updates that reference non-existent layers should be ignored."`
- L170: `    parameterLayers:`
- L171: `      - name: "layer1"`
- L176: `    expectedLayers:`
- L179: `      - layer2: # This layer does not exist in parameterLayers`
- L182: `# Test 6: New Layers`
- L183: `- name: "New Layers"`
- L184: `  description: "Update maps that reference new layers should create those layers."`
- L185: `  parameterLayers:`
- L186: `    - name: "layer1"`
- L191: `    - name: "layer2"`
- L196: `  parsedLayers:`
- L197: `    - name: "layer1"`
- L198: `  expectedLayers:`
- L199: `    - name: "layer1"`
- L202: `    - name: "layer2"`
- L204: `        param1: "new-layer-value"`
- L207: `    - layer2:`
- L208: `        param1: "new-layer-value"`
- L210: `# Test 7: New inexistent layers`
- L211: `- name: "New inexistent layers"`
- L212: `  description: "Update maps that reference new layers should create those layers."`
- L213: `  parameterLayers:`
- L214: `    - name: "layer1"`
- L219: `    - name: "layer2"`
- L224: `  parsedLayers:`
- L225: `    - name: "layer1"`
- L226: `  expectedLayers:`
- L227: `    - name: "layer1"`
- L229: `        param1: "layer1-value"`
- L230: `    - name: "layer2"`
- L232: `        param1: "new-layer-value"`
- L235: `    - layer2:`
- L236: `        param1: "new-layer-value"`
- L238: `        param1: "inexistent-layer-value"`
- L239: `      layer1:`
- L240: `        param1: "layer1-value"`

### `pkg/cmds/sources/tests/set-from-defaults.yaml`
- L1: `- name: "Empty layers and parsedLayers"`
- L2: `  description: "Empty layers should result in empty parsed layers"`
- L3: `  parameterLayers: [ ]`
- L4: `  parsedLayers: [ ]`
- L5: `  expectedLayers: [ ]`
- L8: `- name: "Single layer with default"`
- L9: `  description: "Single layer with default values should result in a single layer with these values"`
- L10: `  parameterLayers:`
- L11: `    - name: "layer1"`
- L16: `  parsedLayers:`
- L17: `    - name: "layer1"`
- L18: `  expectedLayers:`
- L19: `    - name: "layer1"`
- L27: `- name: "Single layer with list type default"`
- L28: `  description: "Single layer with default values should result in a single layer with these values"`
- L29: `  parameterLayers:`
- L30: `    - name: "layer1"`
- L35: `  parsedLayers:`
- L36: `    - name: "layer1"`
- L37: `  expectedLayers:`
- L38: `    - name: "layer1"`
- L46: `- name: "Single layer with objectFromFile type default"`
- L47: `  description: "Single layer with default values should result in a single layer with these values"`
- L48: `  parameterLayers:`
- L49: `    - name: "layer1"`
- L56: `  parsedLayers:`
- L57: `    - name: "layer1"`
- L58: `  expectedLayers:`
- L59: `    - name: "layer1"`
- L65: `- name: "Single layer with objectListFromFile type default"`
- L66: `  description: "Single layer with default values should result in a single layer with these values"`
- L67: `  parameterLayers:`
- L68: `    - name: "layer1"`
- L77: `  parsedLayers:`
- L78: `    - name: "layer1"`
- L79: `  expectedLayers:`
- L80: `    - name: "layer1"`
- L96: `- name: "Layer with existing values"`
- L97: `  parameterLayers:`
- L98: `    - name: "layer1"`
- L106: `  parsedLayers:`
- L107: `    - name: "layer1"`
- L108: `      parameters:`
- L111: `  expectedLayers:`
- L112: `    - name: "layer1"`
- L118: `- name: "Multiple layers with defaults"`
- L119: `  description: "Multiple layers with defaults should result in multiple layers with these values"`
- L120: `  parameterLayers:`
- L121: `    - name: "layer1"`
- L129: `    - name: "layer2"`
- L134: `  parsedLayers:`
- L135: `    - name: "layer1"`
- L136: `      parameters: [ ]`
- L137: `    - name: "layer2"`
- L138: `      parameters: [ ]`
- L139: `  expectedLayers:`
- L140: `    - name: "layer1"`
- L144: `    - name: "layer2"`
- L149: `- name: "Multiple layers with defaults (no defined target layers, should be created)"`
- L150: `  description: "Multiple layers with defaults should result in multiple layers with these values"`
- L151: `  parameterLayers:`
- L152: `    - name: "layer1"`
- L160: `    - name: "layer2"`
- L165: `  parsedLayers: [ ]`
- L166: `  expectedLayers:`
- L167: `    - name: "layer1"`
- L171: `    - name: "layer2"`
- L176: `- name: "Layer with no default values"`
- L177: `  parameterLayers:`
- L178: `    - name: "layer1"`
- L184: `  parsedLayers:`
- L185: `    - name: "layer1"`
- L186: `      parameters: [ ]`
- L187: `  expectedLayers:`
- L188: `    - name: "layer1"`
- L192: `- name: "Layer with partially set values"`
- L193: `  parameterLayers:`
- L194: `    - name: "layer1"`
- L202: `  parsedLayers:`
- L203: `    - name: "layer1"`
- L204: `      parameters:`
- L207: `  expectedLayers:`
- L208: `    - name: "layer1"`
- L214: `- name: "Layer with invalid default values"`
- L215: `  parameterLayers:`
- L216: `    - name: "layer1"`
- L221: `  expectedLayers: [ ]`
- L224: `- name: "Layer with invalid default values"`
- L225: `  parameterLayers:`
- L226: `    - name: "layer1"`
- L232: `  expectedLayers: [ ]`
- L235: `- name: "Layer with required parameters without defaults"`
- L236: `  parameterLayers:`
- L237: `    - name: "layer1"`
- L242: `  parsedLayers:`
- L243: `    - name: "layer1"`
- L244: `      parameters: [ ]`
- L245: `  expectedLayers:`
- L246: `    - name: "layer1"`
- L250: `- name: "Layer with optional parameters without defaults"`
- L251: `  parameterLayers:`
- L252: `    - name: "layer1"`
- L256: `  parsedLayers:`
- L257: `    - name: "layer1"`
- L258: `      parameters: [ ]`
- L259: `  expectedLayers:`
- L260: `    - name: "layer1"`

### `pkg/cmds/sources/tests/update-from-map-as-default.yaml`
- L2: `  description: "Verify that calling UpdateFromMapAsDefault with an empty map does not alter parsedParameters."`
- L3: `  parameterLayers:`
- L4: `    - name: "layer1"`
- L15: `  parsedLayers:`
- L16: `    - name: "layer1"`
- L17: `      parameters:`
- L25: `  expectedLayers:`
- L26: `    - name: "layer1"`
- L33: `- name: "Test with non-empty input maps but empty parsedParameters"`
- L34: `  description: "Ensure that all default values from the input map are set in parsedParameters."`
- L35: `  parameterLayers:`
- L36: `    - name: "layer1"`
- L44: `  parsedLayers: []`
- L46: `    layer1:`
- L49: `  expectedLayers:`
- L50: `    - name: "layer1"`
- L56: `- name: "Test with existing values in parsedParameters"`
- L57: `  description: "Confirm that existing values in parsedParameters are not overwritten by the defaults in the input map."`
- L58: `  parameterLayers:`
- L59: `    - name: "layer1"`
- L67: `  parsedLayers:`
- L68: `    - name: "layer1"`
- L69: `      parameters:`
- L73: `    layer1:`
- L76: `  expectedLayers:`
- L77: `    - name: "layer1"`
- L84: `  description: "Check that only the non-existing keys in parsedParameters are updated with the default values from the input map."`
- L85: `  parameterLayers:`
- L86: `    - name: "layer1"`
- L94: `  parsedLayers:`
- L95: `    - name: "layer1"`
- L96: `      parameters:`
- L100: `    layer1:`
- L102: `  expectedLayers:`
- L103: `    - name: "layer1"`
- L110: `  description: "Ensure that none of the values in parsedParameters are changed when the input map contains all the same keys but with different values."`
- L111: `  parameterLayers:`
- L112: `    - name: "layer1"`
- L120: `  parsedLayers:`
- L121: `    - name: "layer1"`
- L122: `      parameters:`
- L128: `    layer1:`
- L131: `  expectedLayers:`
- L132: `    - name: "layer1"`
- L139: `  description: "Attempt to update parsedParameters with defaults of incorrect types and verify that it results in an error."`
- L140: `  parameterLayers:`
- L141: `    - name: "layer1"`
- L149: `  parsedLayers:`
- L150: `    - name: "layer1"`
- L151: `      parameters: []`
- L153: `    layer1:`
- L156: `  expectedLayers: []`
- L159: `- name: "Test with ParameterLayer not present in layers_"`
- L160: `  description: "Confirm that the middleware skips any layers not present in layers_ and does not throw an error."`
- L161: `  parameterLayers:`
- L162: `    - name: "layer1"`
- L167: `  parsedLayers: []`
- L169: `    layer2:  # This layer is not defined in parameterLayers`
- L171: `  expectedLayers: []`
- L174: `- name: "Test with ParameterDefinition choices"`
- L175: `  description: "When a parameter has specific choices, verify that defaults not in the choices do not get set and result in an error."`
- L176: `  parameterLayers:`
- L177: `    - name: "layer1"`
- L183: `  parsedLayers:`
- L184: `    - name: "layer1"`
- L185: `      parameters: []`
- L187: `    layer1:`
- L189: `  expectedLayers: []`
- L192: `- name: "Test with multiple layers"`
- L193: `  description: "Verify that the middleware correctly updates defaults across multiple layers without affecting already set parameters in any layer."`
- L194: `  parameterLayers:`
- L195: `    - name: "layer1"`
- L200: `    - name: "layer2"`
- L205: `  parsedLayers:`
- L206: `    - name: "layer1"`
- L207: `      parameters:`
- L210: `    - name: "layer2"`
- L211: `      parameters: []`
- L213: `    layer1:`
- L215: `    layer2:`
- L217: `  expectedLayers:`
- L218: `    - name: "layer1"`
- L221: `    - name: "layer2"`

### `pkg/cmds/sources/tests/update-from-map.yaml`
- L1: `- name: "Update single layer with valid map"`
- L2: `  description: "Updating a single layer with valid values should correctly merge these values"`
- L3: `  parameterLayers:`
- L4: `    - name: "layer1"`
- L10: `  parsedLayers:`
- L11: `    - name: "layer1"`
- L12: `      parameters:`
- L16: `    layer1:`
- L19: `  expectedLayers:`
- L20: `    - name: "layer1"`
- L26: `- name: "Update non-existent layer"`
- L27: `  description: "Updating a non-existent layer should be ignored and no error should be thrown"`
- L28: `  parameterLayers:`
- L29: `    - name: "layer1"`
- L33: `  parsedLayers:`
- L34: `    - name: "layer1"`
- L36: `    layer2:`
- L38: `  expectedLayers:`
- L39: `    - name: "layer1"`
- L43: `- name: "Invalid parameter type in update map"`
- L44: `  description: "An invalid parameter type in the update map should result in an error"`
- L45: `  parameterLayers:`
- L46: `    - name: "layer1"`
- L50: `  parsedLayers:`
- L51: `    - name: "layer1"`
- L53: `    layer1:`
- L55: `  expectedLayers: null`
- L59: `  description: "Updating with an empty map should leave the layers unchanged"`
- L60: `  parameterLayers:`
- L61: `    - name: "layer1"`
- L65: `  parsedLayers:`
- L66: `    - name: "layer1"`
- L67: `      parameters:`
- L71: `    layer1: {}`
- L72: `  expectedLayers:`
- L73: `    - name: "layer1"`
- L79: `  description: "Extra keys in the map that are not defined in the ParameterLayer are ignored"`
- L80: `  parameterLayers:`
- L81: `    - name: "layer1"`
- L85: `  parsedLayers:`
- L86: `    - name: "layer1"`
- L88: `    layer1:`
- L91: `  expectedLayers:`
- L92: `    - name: "layer1"`
- L99: `  parameterLayers:`
- L100: `    - name: "layer1"`
- L107: `  parsedLayers:`
- L108: `    - name: "layer1"`
- L110: `    layer1:`
- L112: `  expectedLayers: null`
- L115: `- name: "TestUpdateFromMapWithMultipleLayers"`
- L116: `  description: "Correctly updates parsedLayers for multiple layers"`
- L117: `  parameterLayers:`
- L118: `    - name: "layer1"`
- L122: `    - name: "layer2"`
- L126: `  parsedLayers:`
- L127: `    - name: "layer1"`
- L128: `    - name: "layer2"`
- L130: `    layer1:`
- L132: `    layer2:`
- L134: `  expectedLayers:`
- L135: `    - name: "layer1"`
- L138: `    - name: "layer2"`

### `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml`
- L1: `- name: "Blacklist Single Layer"`
- L2: `  description: "A single layer is blacklisted and should be removed from ParameterLayers."`
- L3: `  parameterLayers:`
- L4: `    - name: layer1`
- L9: `    - name: layer2`
- L14: `  parsedLayers: []`
- L16: `    layer1:`
- L19: `    - "layer1"`
- L22: `- name: "Blacklist Multiple Layers"`
- L23: `  description: "Multiple layers are blacklisted and should be removed from ParameterLayers."`
- L24: `  parameterLayers:`
- L25: `    - name: "layer1"`
- L30: `    - name: "layer2"`
- L35: `    - name: "layer3"`
- L40: `  expectedLayers:`
- L41: `    - name: layer2`
- L45: `    layer1:`
- L47: `    layer2:`
- L49: `    layer3:`
- L52: `    - "layer1"`
- L53: `    - "layer3"`
- L58: `  parameterLayers:`
- L59: `    - name: "layer1"`
- L64: `    - name: "layer2"`
- L69: `    - name: "layer3"`
- L74: `    - name: "layer4"`
- L79: `  parsedLayers: []`
- L81: `    layer2:`
- L83: `    layer4:`
- L86: `    - "layer1"`
- L87: `    - "layer3"`
- L89: `  expectedLayers:`
- L90: `    - name: layer1`
- L93: `    - name: layer2`
- L96: `    - name: layer3`
- L99: `    - name: layer4`
- L103: `    layer1:`
- L105: `    layer2:`
- L107: `    layer3:`
- L110: `    layer1:`
- L112: `    layer3:`
- L114: `    layer4:`
- L117: `- name: "Whitelist single layer"`
- L118: `  description: "A single layer is whitelisted and should be kept in ParameterLayers."`
- L119: `  parameterLayers:`
- L120: `    - name: layer1`
- L125: `    - name: layer2`
- L130: `  parsedLayers: []`
- L131: `  expectedLayers:`
- L132: `    - name: layer1`
- L136: `    layer1:`
- L139: `    - "layer1"`
- L142: `- name: "Whitelist multiple layers"`
- L143: `  description: "Multiple layers are whitelisted and should be kept in ParameterLayers."`
- L144: `  parameterLayers:`
- L145: `    - name: "layer1"`
- L150: `    - name: "layer2"`
- L155: `    - name: "layer3"`
- L160: `  expectedLayers:`
- L161: `    - name: layer1`
- L164: `    - name: layer3`
- L168: `    layer1:`
- L170: `    layer3:`
- L173: `    - "layer1"`
- L174: `    - "layer3"`
- L179: `  parameterLayers:`
- L180: `    - name: "layer1"`
- L185: `    - name: "layer2"`
- L190: `    - name: "layer3"`
- L195: `    - name: "layer4"`
- L200: `  parsedLayers: []`
- L202: `    layer1:`
- L204: `    layer3:`
- L207: `    - "layer1"`
- L208: `    - "layer3"`
- L210: `  expectedLayers:`
- L211: `    - name: layer1`
- L214: `    - name: layer2`
- L217: `    - name: layer3`
- L220: `    - name: layer4`
- L224: `    layer1:`
- L226: `    layer2:`
- L228: `    layer3:`
- L231: `    layer1:`
- L233: `    layer4:`

### `pkg/cmds/test-data/cobra/01-test-simple.yaml`
- L18: `    argumentParameters:`
- L23: `    flagParameters:`
- L28: `    argumentParameters:`
- L32: `    flagParameters:`

### `pkg/cmds/test-data/cobra/02-key-value.yaml`
- L13: `    flagParameters:`

### `pkg/cmds/test-data/cobra/03-string-from-file.yaml`
- L11: `    flagParameters:`
- L16: `    flagParameters:`

### `prompto/glazed/definitions`
- L3: `prompto get glazed/parameter-types`
- L5: `for i in CommandDescription ParameterDefinition ParameterLayer; do`

### `prompto/glazed/parameter-types`
- L3: `echo "// Here are the types that can be used to define parameters in glazed:"`
- L5: `echo "package github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L7: `oak go consts pkg/cmds/parameters/parameter-type.go`
- L9: `oak go definitions pkg/cmds/parameters/file.go --name "FileData" --definition-type struct,interface`

### `prompto/glazed/parameters`
- L3: `prompto get glazed/parameter-types`
- L6: `echo "Here are all the types and method signatures for manipulating parameters and parsed parameters in glazed (github.com/go-go-golems/glazed is the base package):"`
- L8: `echo "package github.com/go-go-golems/glazed/pkg/cmds/parameters"`
- L10: `oak go definitions --only-public pkg/cmds/parameters/parameters.go`
- L12: `oak go definitions --only-public pkg/cmds/parameters/parsed-parameter.go`
- L17: `echo "Here are all the types and method signatures for manipulating layers in glazed:"`
- L19: `echo "package layers"`
- L21: `oak go definitions --only-public pkg/cmds/layers/layer.go`
- L23: `oak go definitions --only-public pkg/cmds/layers/parsed-layer.go`

### `prompto/glazed/parameters-verbose`
- L4: `glaze help parameter-layers-and-parsed-layers 2>&1`
- L8: `glaze help parsing-parameters 2>&1`
- L13: `prompto get glazed/parameters`

### `ttmp/2024-10-13/create-command-docs.sh`
- L37: `instruct "Here is how parameters for commands work"`
- L40: `prompto get glazed/parameters-verbose`

### `ttmp/2025-11-03/validate-config-examples.sh`
- L28: `echo "=== config-single: invalid unknown layer ==="`
- L37: `echo "=== config-single: invalid unknown parameter ==="`
- L59: `echo "=== config-overlay: invalid base unknown layer ==="`
- L68: `echo "=== config-overlay: invalid env unknown parameter ==="`
- L90: `echo "=== config-pattern-mapper: invalid unknown dynamic parameter (staging) ==="`

### `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/scripts/01-smoke-test-simple-inference-profiles.sh`
- L91: `  # For these tests we expect the print-parsed-parameters output to include ai-chat as the first key.`
- L100: `    # Only capture the final resolved value line for the parameter (4-space indent),`
- L111: `    # Only capture the final resolved value line for the parameter (4-space indent),`
- L147: `        go run "./cmd/examples/simple-inference" simple-inference --print-parsed-parameters "$@" 2>&1`
- L198: `        go run "./cmd/examples/simple-inference" simple-inference --print-parsed-parameters "hello" 2>&1`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/02-doc-deprecation-scan.json`
- L5: `    "pkg/cmds/layers import",`
- L6: `    "pkg/cmds/parameters import",`
- L8: `    "layers.ParameterLayer",`
- L9: `    "layers.ParameterLayers",`
- L10: `    "ParameterLayer",`
- L11: `    "ParameterLayers",`
- L12: `    "ParsedLayer",`
- L13: `    "ParsedLayers",`
- L14: `    "parameters.ParameterDefinition",`
- L15: `    "parameters.ParameterDefinitions",`
- L16: `    "ParameterDefinition",`
- L17: `    "ParameterDefinitions",`
- L18: `    "ParameterType",`
- L21: `    "CobraParameterLayer",`
- L27: `    "LoadParametersFromFile",`
- L28: `    "LoadParametersFromFiles",`
- L52: `          "label": "pkg/cmds/layers import",`
- L53: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L55: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L58: `          "label": "pkg/cmds/layers import",`
- L59: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L61: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L64: `          "label": "pkg/cmds/layers import",`
- L65: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L67: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L70: `          "label": "pkg/cmds/parameters import",`
- L71: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L73: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L76: `          "label": "pkg/cmds/parameters import",`
- L77: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L79: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L82: `          "label": "pkg/cmds/parameters import",`
- L83: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L85: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L89: `        "pkg/cmds/layers import": 3,`
- L90: `        "pkg/cmds/parameters import": 3`
- L97: `          "label": "ParameterDefinition",`
- L98: `          "pattern": "\\bParameterDefinition\\b",`
- L100: `          "text": "map it to the ParameterDefinition the Command uses, and create a YAML file with the default values."`
- L104: `        "ParameterDefinition": 1`
- L243: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/07-load-parameters-from-json.md",`
- L248: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/08-file-parameter-type.md",`
- L251: `          "label": "ParameterType",`
- L252: `          "pattern": "\\bParameterType\\w*\\b",`
- L254: `          "text": "## The `file` ParameterType"`
- L258: `        "ParameterType": 1`
- L265: `          "label": "ParameterDefinition",`
- L266: `          "pattern": "\\bParameterDefinition\\b",`
- L268: `          "text": "params []*ParameterDefinition,"`
- L271: `          "label": "ParameterDefinition",`
- L272: `          "pattern": "\\bParameterDefinition\\b",`
- L274: `          "text": "- `params`: a slice of `*ParameterDefinition` representing the parameter definitions."`
- L277: `          "label": "ParameterDefinition",`
- L278: `          "pattern": "\\bParameterDefinition\\b",`
- L280: `          "text": "params := []*ParameterDefinition{"`
- L283: `          "label": "ParameterType",`
- L284: `          "pattern": "\\bParameterType\\w*\\b",`
- L286: `          "text": "{Name: \"verbose\", ShortFlag: \"v\", Type: ParameterTypeBool},"`
- L289: `          "label": "ParameterType",`
- L290: `          "pattern": "\\bParameterType\\w*\\b",`
- L292: `          "text": "{Name: \"output\", ShortFlag: \"o\", Type: ParameterTypeString},"`
- L296: `        "ParameterDefinition": 3,`
- L297: `        "ParameterType": 2`
- L314: `          "label": "LoadParametersFromFile",`
- L315: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L317: `          "text": "For advanced use cases, combine profile middleware with additional config files using `LoadParametersFromFile` or `LoadParametersFromFiles`:"`
- L320: `          "label": "LoadParametersFromFiles",`
- L321: `          "pattern": "\\bLoadParametersFromFiles\\b",`
- L323: `          "text": "For advanced use cases, combine profile middleware with additional config files using `LoadParametersFromFile` or `LoadParametersFromFiles`:"`
- L327: `        "LoadParametersFromFile": 1,`
- L328: `        "LoadParametersFromFiles": 1`
- L332: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/13-layers-and-parsed-layers.md",`
- L335: `          "label": "ParameterLayer",`
- L336: `          "pattern": "\\bParameterLayer\\b",`
- L338: `          "text": "1. **ParameterLayer**: An interface that groups parameter definitions and provides metadata."`
- L341: `          "label": "ParameterLayer",`
- L342: `          "pattern": "\\bParameterLayer\\b",`
- L344: `          "text": "2. **ParameterLayers**: A collection of ParameterLayer objects."`
- L347: `          "label": "ParameterLayer",`
- L348: `          "pattern": "\\bParameterLayer\\b",`
- L350: `          "text": "`ParameterLayer` interface."`
- L353: `          "label": "ParameterLayer",`
- L354: `          "pattern": "\\bParameterLayer\\b",`
- L356: `          "text": "parameterLayers.ForEach(func(key string, p ParameterLayer) {"`
- L359: `          "label": "ParameterLayer",`
- L360: `          "pattern": "\\bParameterLayer\\b",`
- L362: `          "text": "err := parameterLayers.ForEachE(func(key string, p ParameterLayer) error {"`
- L365: `          "label": "ParameterLayer",`
- L366: `          "pattern": "\\bParameterLayer\\b",`
- L368: `          "text": "arguments, configuration files, or environment variables) using a ParameterLayer"`
- L371: `          "label": "ParameterLayer",`
- L372: `          "pattern": "\\bParameterLayer\\b",`
- L374: `          "text": "1. **Layer**: A reference to the original ParameterLayer used for parsing."`
- L377: `          "label": "ParameterLayers",`
- L378: `          "pattern": "\\bParameterLayers\\b",`
- L380: `          "text": "2. **ParameterLayers**: A collection of ParameterLayer objects."`
- L383: `          "label": "ParameterLayers",`
- L384: `          "pattern": "\\bParameterLayers\\b",`
- L386: `          "text": "### Creating ParameterLayers"`
- L389: `          "label": "ParameterLayers",`
- L390: `          "pattern": "\\bParameterLayers\\b",`
- L392: `          "text": "Create a new ParameterLayers containing only the specified layers:"`
- L395: `          "label": "ParameterLayers",`
- L396: `          "pattern": "\\bParameterLayers\\b",`
- L398: `          "text": "Merge two ParameterLayers collections:"`
- L401: `          "label": "ParameterLayers",`
- L402: `          "pattern": "\\bParameterLayers\\b",`
- L404: `          "text": "Create a deep copy of ParameterLayers:"`
- L407: `          "label": "ParameterLayers",`
- L408: `          "pattern": "\\bParameterLayers\\b",`
- L410: `          "text": "- **Middleware Structure**: Each middleware processes parameters before and/or after calling the next handler in the chain. They work with `ParameterLayers` and `ParsedLayers` to manage parameter definitions and values."`
- L413: `          "label": "ParsedLayer",`
- L414: `          "pattern": "\\bParsedLayer\\b",`
- L416: `          "text": "A ParsedLayer is the result of parsing input data (such as command-line"`
- L419: `          "label": "ParsedLayer",`
- L420: `          "pattern": "\\bParsedLayer\\b",`
- L422: `          "text": "ParsedLayers is a collection of ParsedLayer objects, typically representing all the layers used in a command or application."`
- L425: `          "label": "ParsedLayer",`
- L426: `          "pattern": "\\bParsedLayer\\b",`
- L428: `          "text": "### Creating a ParsedLayer"`
- L431: `          "label": "ParsedLayer",`
- L432: `          "pattern": "\\bParsedLayer\\b",`
- L434: `          "text": "parsedLayers.ForEach(func(k string, v *ParsedLayer) {"`
- L437: `          "label": "ParsedLayer",`
- L438: `          "pattern": "\\bParsedLayer\\b",`
- L440: `          "text": "err := parsedLayers.ForEachE(func(k string, v *ParsedLayer) error {"`
- L443: `          "label": "ParsedLayer",`
- L444: `          "pattern": "\\bParsedLayer\\b",`
- L446: `          "text": "Get an existing ParsedLayer or create a new one if it doesn't exist:"`
- L449: `          "label": "ParsedLayers",`
- L450: `          "pattern": "\\bParsedLayers\\b",`
- L452: `          "text": "ParsedLayers is a collection of ParsedLayer objects, typically representing all the layers used in a command or application."`
- L455: `          "label": "ParsedLayers",`
- L456: `          "pattern": "\\bParsedLayers\\b",`
- L458: `          "text": "### Usage of ParsedLayers"`
- L461: `          "label": "ParsedLayers",`
- L462: `          "pattern": "\\bParsedLayers\\b",`
- L464: `          "text": "ParsedLayers are primarily used to:"`
- L467: `          "label": "ParsedLayers",`
- L468: `          "pattern": "\\bParsedLayers\\b",`
- L470: `          "text": "### Creating ParsedLayers"`
- L473: `          "label": "ParsedLayers",`
- L474: `          "pattern": "\\bParsedLayers\\b",`
- L476: `          "text": "### Initializing Structs from ParsedLayers"`
- L479: `          "label": "ParsedLayers",`
- L480: `          "pattern": "\\bParsedLayers\\b",`
- L482: `          "text": "### Merging ParsedLayers"`
- L485: `          "label": "ParsedLayers",`
- L486: `          "pattern": "\\bParsedLayers\\b",`
- L488: `          "text": "Create a deep copy of ParsedLayers:"`
- L491: `          "label": "ParsedLayers",`
- L492: `          "pattern": "\\bParsedLayers\\b",`
- L494: `          "text": "- **Middleware Structure**: Each middleware processes parameters before and/or after calling the next handler in the chain. They work with `ParameterLayers` and `ParsedLayers` to manage parameter definitions and values."`
- L497: `          "label": "ParameterDefinition",`
- L498: `          "pattern": "\\bParameterDefinition\\b",`
- L500: `          "text": "A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status."`
- L503: `          "label": "ParameterDefinition",`
- L504: `          "pattern": "\\bParameterDefinition\\b",`
- L506: `          "text": "- The original ParameterDefinition"`
- L512: `          "text": "You can add parameters to an existing layer using the `AddFlags` method:"`
- L518: `          "text": "layer.AddFlags("`
- L524: `          "text": "4. **ParseFromCobraCommand**: Parses parameter values from a Cobra command, typically used for CLI applications."`
- L536: `          "text": "1. **SetFromDefaults**: Populates parameters with their default values if no value exists."`
- L539: `          "label": "LoadParametersFromFile",`
- L540: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L542: `          "text": "3. **LoadParametersFromFile / LoadParametersFromFiles**: Load parameters from JSON or YAML files."`
- L545: `          "label": "LoadParametersFromFiles",`
- L546: `          "pattern": "\\bLoadParametersFromFiles\\b",`
- L548: `          "text": "3. **LoadParametersFromFile / LoadParametersFromFiles**: Load parameters from JSON or YAML files."`
- L554: `          "text": "- **Source Tracking**: Use `WithParseStepSource` to track where parameter values originate."`
- L558: `        "ParameterLayer": 7,`
- L559: `        "ParameterLayers": 6,`
- L560: `        "ParsedLayer": 6,`
- L561: `        "ParsedLayers": 8,`
- L562: `        "ParameterDefinition": 2,`
- L567: `        "LoadParametersFromFile": 1,`
- L568: `        "LoadParametersFromFiles": 1,`
- L583: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/16-adding-parameter-types.md",`
- L586: `          "label": "ParameterDefinition",`
- L587: `          "pattern": "\\bParameterDefinition\\b",`
- L589: `          "text": "func (p *ParameterDefinition) ParseParameter(v []string, options ...ParseStepOption) (*ParsedParameter, error) {"`
- L592: `          "label": "ParameterDefinition",`
- L593: `          "pattern": "\\bParameterDefinition\\b",`
- L595: `          "text": "func (p *ParameterDefinition) ParseFromReader(f io.Reader, filename string, options ...ParseStepOption) (*ParsedParameter, error) {"`
- L598: `          "label": "ParameterDefinition",`
- L599: `          "pattern": "\\bParameterDefinition\\b",`
- L601: `          "text": "func (p *ParameterDefinition) CheckValueValidity(v interface{}) (interface{}, error) {"`
- L604: `          "label": "ParameterDefinition",`
- L605: `          "pattern": "\\bParameterDefinition\\b",`
- L607: `          "text": "func (p *ParameterDefinition) InitializeValueToEmptyValue(value reflect.Value) error {"`
- L610: `          "label": "ParameterDefinition",`
- L611: `          "pattern": "\\bParameterDefinition\\b",`
- L613: `          "text": "func (p *ParameterDefinition) SetValueFromInterface(value reflect.Value, v interface{}) error {"`
- L616: `          "label": "ParameterDefinition",`
- L617: `          "pattern": "\\bParameterDefinition\\b",`
- L619: `          "text": "pd := &ParameterDefinition{"`
- L622: `          "label": "ParameterDefinitions",`
- L623: `          "pattern": "\\bParameterDefinitions\\b",`
- L625: `          "text": "func (ps *ParameterDefinitions) AddToCobraCommand(cmd *cobra.Command) error {"`
- L628: `          "label": "ParameterDefinitions",`
- L629: `          "pattern": "\\bParameterDefinitions\\b",`
- L631: `          "text": "func (ps *ParameterDefinitions) SetupCobraCompletions(cmd *cobra.Command) error {"`
- L634: `          "label": "ParameterType",`
- L635: `          "pattern": "\\bParameterType\\w*\\b",`
- L637: `          "text": "ParameterTypeCredentials ParameterType = \"credentials\""`
- L640: `          "label": "ParameterType",`
- L641: `          "pattern": "\\bParameterType\\w*\\b",`
- L643: `          "text": "func (p ParameterType) IsList() bool {"`
- L646: `          "label": "ParameterType",`
- L647: `          "pattern": "\\bParameterType\\w*\\b",`
- L649: `          "text": "case ParameterTypeCredentials:"`
- L652: `          "label": "ParameterType",`
- L653: `          "pattern": "\\bParameterType\\w*\\b",`
- L655: `          "text": "case ParameterTypeCredentials:"`
- L658: `          "label": "ParameterType",`
- L659: `          "pattern": "\\bParameterType\\w*\\b",`
- L661: `          "text": "case ParameterTypeCredentials:"`
- L664: `          "label": "ParameterType",`
- L665: `          "pattern": "\\bParameterType\\w*\\b",`
- L667: `          "text": "case ParameterTypeCredentials:"`
- L670: `          "label": "ParameterType",`
- L671: `          "pattern": "\\bParameterType\\w*\\b",`
- L673: `          "text": "case ParameterTypeCredentials:"`
- L676: `          "label": "ParameterType",`
- L677: `          "pattern": "\\bParameterType\\w*\\b",`
- L679: `          "text": "case ParameterTypeCredentials:"`
- L682: `          "label": "ParameterType",`
- L683: `          "pattern": "\\bParameterType\\w*\\b",`
- L685: `          "text": "case ParameterTypeCredentials:"`
- L688: `          "label": "ParameterType",`
- L689: `          "pattern": "\\bParameterType\\w*\\b",`
- L691: `          "text": "case ParameterTypeCredentials:"`
- L694: `          "label": "ParameterType",`
- L695: `          "pattern": "\\bParameterType\\w*\\b",`
- L697: `          "text": "func RenderValue(parameterType ParameterType, value interface{}) (string, error) {"`
- L700: `          "label": "ParameterType",`
- L701: `          "pattern": "\\bParameterType\\w*\\b",`
- L703: `          "text": "case ParameterTypeCredentials:"`
- L706: `          "label": "ParameterType",`
- L707: `          "pattern": "\\bParameterType\\w*\\b",`
- L709: `          "text": "Add a field to the `ParameterTypesSettings` struct:"`
- L712: `          "label": "ParameterType",`
- L713: `          "pattern": "\\bParameterType\\w*\\b",`
- L715: `          "text": "type ParameterTypesSettings struct {"`
- L718: `          "label": "ParameterType",`
- L719: `          "pattern": "\\bParameterType\\w*\\b",`
- L721: `          "text": "Type: ParameterTypeCredentials,"`
- L724: `          "label": "ParameterType",`
- L725: `          "pattern": "\\bParameterType\\w*\\b",`
- L727: `          "text": "ParameterTypeCredentials ParameterType = \"credentials\""`
- L730: `          "label": "ParameterType",`
- L731: `          "pattern": "\\bParameterType\\w*\\b",`
- L733: `          "text": "func (p ParameterType) IsKeyValue() bool {"`
- L736: `          "label": "ParameterType",`
- L737: `          "pattern": "\\bParameterType\\w*\\b",`
- L739: `          "text": "case ParameterTypeKeyValue, ParameterTypeCredentials:"`
- L742: `          "label": "ParameterType",`
- L743: `          "pattern": "\\bParameterType\\w*\\b",`
- L745: `          "text": "1. **Consistent naming**: Use the pattern `ParameterType<Name>` for constants"`
- L749: `        "ParameterDefinition": 6,`
- L750: `        "ParameterDefinitions": 2,`
- L751: `        "ParameterType": 19`
- L755: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/16-parsing-parameters.md",`
- L758: `          "label": "pkg/cmds/parameters import",`
- L759: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L761: `          "text": "import \"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L764: `          "label": "ParameterDefinition",`
- L765: `          "pattern": "\\bParameterDefinition\\b",`
- L767: `          "text": "### ParameterDefinition"`
- L770: `          "label": "ParameterDefinition",`
- L771: `          "pattern": "\\bParameterDefinition\\b",`
- L773: `          "text": "A `ParameterDefinition` defines a parameter's properties, including name, type, default value, choices, and required status."`
- L776: `          "label": "ParameterDefinition",`
- L777: `          "pattern": "\\bParameterDefinition\\b",`
- L779: `          "text": "type ParameterDefinition struct {"`
- L782: `          "label": "ParameterDefinition",`
- L783: `          "pattern": "\\bParameterDefinition\\b",`
- L785: `          "text": "`ParameterDefinitions` is an ordered map of `ParameterDefinition` instances, indexed by name."`
- L788: `          "label": "ParameterDefinition",`
- L789: `          "pattern": "\\bParameterDefinition\\b",`
- L791: `          "text": "*orderedmap.OrderedMap[string, *ParameterDefinition]"`
- L794: `          "label": "ParameterDefinition",`
- L795: `          "pattern": "\\bParameterDefinition\\b",`
- L797: `          "text": "A `ParsedParameter` contains the parsed value, its `ParameterDefinition`, and a log of parsing steps."`
- L800: `          "label": "ParameterDefinition",`
- L801: `          "pattern": "\\bParameterDefinition\\b",`
- L803: `          "text": "ParameterDefinition *ParameterDefinition"`
- L806: `          "label": "ParameterDefinition",`
- L807: `          "pattern": "\\bParameterDefinition\\b",`
- L809: `          "text": "Define parameters using `ParameterDefinition`, specifying name, type, and options like default values or choices."`
- L812: `          "label": "ParameterDefinitions",`
- L813: `          "pattern": "\\bParameterDefinitions\\b",`
- L815: `          "text": "### ParameterDefinitions"`
- L818: `          "label": "ParameterDefinitions",`
- L819: `          "pattern": "\\bParameterDefinitions\\b",`
- L821: `          "text": "`ParameterDefinitions` is an ordered map of `ParameterDefinition` instances, indexed by name."`
- L824: `          "label": "ParameterDefinitions",`
- L825: `          "pattern": "\\bParameterDefinitions\\b",`
- L827: `          "text": "type ParameterDefinitions struct {"`
- L830: `          "label": "ParameterType",`
- L831: `          "pattern": "\\bParameterType\\w*\\b",`
- L833: `          "text": "Type       ParameterType `yaml:\"type\"`"`
- L837: `        "pkg/cmds/parameters import": 1,`
- L838: `        "ParameterDefinition": 8,`
- L839: `        "ParameterDefinitions": 3,`
- L840: `        "ParameterType": 1`
- L852: `          "label": "ParsedLayer",`
- L853: `          "pattern": "\\bParsedLayer\\b",`
- L855: `          "text": "Parses a Lua table into a ParsedLayer."`
- L858: `          "label": "ParsedLayers",`
- L859: `          "pattern": "\\bParsedLayers\\b",`
- L861: `          "text": "Middleware to parse nested Lua tables into ParsedLayers."`
- L864: `          "label": "ParsedLayers",`
- L865: `          "pattern": "\\bParsedLayers\\b",`
- L867: `          "text": "Parses a nested Lua table into ParsedLayers."`
- L871: `        "ParsedLayer": 1,`
- L872: `        "ParsedLayers": 2`
- L889: `          "label": "pkg/cmds/layers import",`
- L890: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L892: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L895: `          "label": "pkg/cmds/parameters import",`
- L896: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L898: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L907: `          "label": "ParameterLayer",`
- L908: `          "pattern": "\\bParameterLayer\\b",`
- L910: `          "text": "The foundation of Glazed's parameter system is the `ParameterLayer`. Before we can use middlewares, we need to define our parameter structure. This example shows how to create a layer that matches the architectural concepts discussed earlier:"`
- L913: `          "label": "ParameterLayers",`
- L914: `          "pattern": "\\bParameterLayers\\b",`
- L916: `          "text": "### Relationship between ParameterLayers and ParsedLayers"`
- L919: `          "label": "ParameterLayers",`
- L920: `          "pattern": "\\bParameterLayers\\b",`
- L922: `          "text": "- **ParameterLayers**: These are collections of parameter definitions. They define the structure and metadata of parameters, such as their names, types, and default values."`
- L925: `          "label": "ParameterLayers",`
- L926: `          "pattern": "\\bParameterLayers\\b",`
- L928: `          "text": "- `ParameterLayers`: Contains parameter definitions"`
- L931: `          "label": "ParsedLayers",`
- L932: `          "pattern": "\\bParsedLayers\\b",`
- L934: `          "text": "### Relationship between ParameterLayers and ParsedLayers"`
- L937: `          "label": "ParsedLayers",`
- L938: `          "pattern": "\\bParsedLayers\\b",`
- L940: `          "text": "- **ParsedLayers**: These are collections of parsed parameter values. They store the actual values obtained from various sources like command-line arguments, environment variables, or configuration files."`
- L943: `          "label": "ParsedLayers",`
- L944: `          "pattern": "\\bParsedLayers\\b",`
- L946: `          "text": "- `ParsedLayers`: Stores the actual parameter values"`
- L949: `          "label": "ParsedLayers",`
- L950: `          "pattern": "\\bParsedLayers\\b",`
- L952: `          "text": "- Creation of empty ParsedLayers to store results"`
- L970: `          "text": "ExecuteMiddlewares(layers, parsedLayers,"`
- L976: `          "text": "ExecuteMiddlewares(layers, parsedLayers,"`
- L1048: `          "text": "Use `SetFromDefaults` to populate parameters with their default values:"`
- L1066: `          "text": "The `SetFromDefaults` middleware demonstrates the basic middleware pattern of processing parameters after the next handler:"`
- L1069: `          "label": "LoadParametersFromFile",`
- L1070: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1072: `          "text": "- LoadParametersFromFile"`
- L1075: `          "label": "LoadParametersFromFile",`
- L1076: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1078: `          "text": "LoadParametersFromFile(\"config.yaml\"),"`
- L1081: `          "label": "LoadParametersFromFile",`
- L1082: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1084: `          "text": "1. LoadParametersFromFile"`
- L1087: `          "label": "LoadParametersFromFile",`
- L1088: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1090: `          "text": "Load parameters from JSON or YAML files using `LoadParametersFromFile`:"`
- L1093: `          "label": "LoadParametersFromFile",`
- L1094: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1096: `          "text": "By default, `LoadParametersFromFile` expects the config file to have this structure:"`
- L1099: `          "label": "LoadParametersFromFile",`
- L1100: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1102: `          "text": "LoadParametersFromFile(),    // More specific"`
- L1105: `          "label": "LoadParametersFromFile",`
- L1106: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1108: `          "text": "if commandSettings.LoadParametersFromFile != \"\" {"`
- L1111: `          "label": "LoadParametersFromFile",`
- L1112: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1114: `          "text": "sources.FromFile(commandSettings.LoadParametersFromFile))"`
- L1124: `        "pkg/cmds/layers import": 1,`
- L1125: `        "pkg/cmds/parameters import": 1,`
- L1127: `        "ParameterLayer": 1,`
- L1128: `        "ParameterLayers": 3,`
- L1129: `        "ParsedLayers": 4,`
- L1134: `        "LoadParametersFromFile": 8,`
- L1142: `          "label": "pkg/cmds/parameters import",`
- L1143: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1145: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1149: `        "pkg/cmds/parameters import": 1`
- L1161: `          "label": "pkg/cmds/layers import",`
- L1162: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1164: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1167: `          "label": "pkg/cmds/layers import",`
- L1168: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1170: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1173: `          "label": "pkg/cmds/layers import",`
- L1174: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1176: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1179: `          "label": "pkg/cmds/layers import",`
- L1180: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1182: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1185: `          "label": "pkg/cmds/parameters import",`
- L1186: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1188: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1239: `          "label": "LoadParametersFromFile",`
- L1240: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1242: `          "text": "- Using the Mapper: Wire into `LoadParametersFromFile`"`
- L1245: `          "label": "LoadParametersFromFile",`
- L1246: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1248: `          "text": "// Use with LoadParametersFromFile"`
- L1251: `          "label": "LoadParametersFromFile",`
- L1252: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1254: `          "text": "// Use with LoadParametersFromFile"`
- L1258: `        "pkg/cmds/layers import": 4,`
- L1259: `        "pkg/cmds/parameters import": 1,`
- L1261: `        "LoadParametersFromFile": 3`
- L1268: `          "label": "pkg/cmds/layers import",`
- L1269: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1271: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1274: `          "label": "pkg/cmds/layers import",`
- L1275: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1277: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1280: `          "label": "pkg/cmds/layers import",`
- L1281: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1283: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1286: `          "label": "pkg/cmds/layers import",`
- L1287: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1289: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1292: `          "label": "pkg/cmds/layers import",`
- L1293: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1295: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1298: `          "label": "pkg/cmds/layers import",`
- L1299: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1301: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1304: `          "label": "pkg/cmds/layers import",`
- L1305: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1307: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1310: `          "label": "pkg/cmds/layers import",`
- L1311: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1313: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1316: `          "label": "pkg/cmds/parameters import",`
- L1317: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1319: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1322: `          "label": "pkg/cmds/parameters import",`
- L1323: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1325: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1328: `          "label": "pkg/cmds/parameters import",`
- L1329: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1331: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1334: `          "label": "pkg/cmds/parameters import",`
- L1335: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1337: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1361: `          "text": "Use `github.com/go-go-golems/glazed/pkg/cmds/middlewares/patternmapper` to declare mapping rules and pass the mapper to `LoadParametersFromFile`."`
- L1388: `          "label": "LoadParametersFromFile",`
- L1389: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1391: `          "text": "Use `github.com/go-go-golems/glazed/pkg/cmds/middlewares/patternmapper` to declare mapping rules and pass the mapper to `LoadParametersFromFile`."`
- L1394: `          "label": "LoadParametersFromFiles",`
- L1395: `          "pattern": "\\bLoadParametersFromFiles\\b",`
- L1397: `          "text": "Legacy Viper-based middlewares like `GatherFlagsFromViper` and per-command `--load-parameters-from-file` are deprecated. Prefer config middlewares (`LoadParametersFromFiles`) with resolvers and `--config-file`."`
- L1401: `        "pkg/cmds/layers import": 8,`
- L1402: `        "pkg/cmds/parameters import": 4,`
- L1404: `        "LoadParametersFromFile": 1,`
- L1405: `        "LoadParametersFromFiles": 1`
- L1412: `          "label": "pkg/cmds/layers import",`
- L1413: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1415: `          "text": "- `github.com/go-go-golems/glazed/pkg/cmds/layers`: Parameter layering system"`
- L1418: `          "label": "pkg/cmds/parameters import",`
- L1419: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1421: `          "text": "- `github.com/go-go-golems/glazed/pkg/cmds/parameters`: Parameter types and definitions"`
- L1424: `          "label": "ParsedLayers",`
- L1425: `          "pattern": "\\bParsedLayers\\b",`
- L1427: `          "text": "\u2502  Parameters  \u2502          \u2502 ParsedLayers    \u2502"`
- L1430: `          "label": "ParsedLayers",`
- L1431: `          "pattern": "\\bParsedLayers\\b",`
- L1433: `          "text": "5. **ParsedLayers**: Runtime values after collecting from CLI flags, environment, config files, and defaults"`
- L1436: `          "label": "ParameterType",`
- L1437: `          "pattern": "\\bParameterType\\w*\\b",`
- L1439: `          "text": "Glazed treats command-line parameters as more than just strings. They are typed objects with built-in validation, default values, and help text. This approach shifts the burden of parsing and validation from the command's business logic to the framework itself. By defining a parameter's type (e.g., `ParameterTypeInteger`, `ParameterTypeDate`, `ParameterTypeFile`), you get automatic error handling and a more robust and user-friendly CLI."`
- L1442: `          "label": "ParameterType",`
- L1443: `          "pattern": "\\bParameterType\\w*\\b",`
- L1445: `          "text": "**`ParameterTypeString`**: The workhorse for text inputs - names, descriptions, URLs"`
- L1448: `          "label": "ParameterType",`
- L1449: `          "pattern": "\\bParameterType\\w*\\b",`
- L1451: `          "text": "**`ParameterTypeSecret`**: Like strings, but values are masked in help and logs (perfect for passwords, API keys)"`
- L1454: `          "label": "ParameterType",`
- L1455: `          "pattern": "\\bParameterType\\w*\\b",`
- L1457: `          "text": "**`ParameterTypeInteger`**: Whole numbers with automatic range validation"`
- L1460: `          "label": "ParameterType",`
- L1461: `          "pattern": "\\bParameterType\\w*\\b",`
- L1463: `          "text": "**`ParameterTypeFloat`**: Decimal numbers for measurements, percentages, ratios"`
- L1466: `          "label": "ParameterType",`
- L1467: `          "pattern": "\\bParameterType\\w*\\b",`
- L1469: `          "text": "**`ParameterTypeBool`**: True/false flags that work with `--flag` and `--no-flag` patterns"`
- L1472: `          "label": "ParameterType",`
- L1473: `          "pattern": "\\bParameterType\\w*\\b",`
- L1475: `          "text": "**`ParameterTypeDate`**: Intelligent date parsing that handles multiple formats"`
- L1478: `          "label": "ParameterType",`
- L1479: `          "pattern": "\\bParameterType\\w*\\b",`
- L1481: `          "text": "**`ParameterTypeStringList`**: Multiple values like `--tag web --tag api --tag production`"`
- L1484: `          "label": "ParameterType",`
- L1485: `          "pattern": "\\bParameterType\\w*\\b",`
- L1487: `          "text": "**`ParameterTypeIntegerList`**: Lists of numbers for ports, IDs, quantities"`
- L1490: `          "label": "ParameterType",`
- L1491: `          "pattern": "\\bParameterType\\w*\\b",`
- L1493: `          "text": "**`ParameterTypeFloatList`**: Multiple decimal values for coordinates, measurements"`
- L1496: `          "label": "ParameterType",`
- L1497: `          "pattern": "\\bParameterType\\w*\\b",`
- L1499: `          "text": "**`ParameterTypeChoice`**: Single selection from predefined options (with tab completion!)"`
- L1502: `          "label": "ParameterType",`
- L1503: `          "pattern": "\\bParameterType\\w*\\b",`
- L1505: `          "text": "**`ParameterTypeChoiceList`**: Multiple selections from predefined options"`
- L1508: `          "label": "ParameterType",`
- L1509: `          "pattern": "\\bParameterType\\w*\\b",`
- L1511: `          "text": "**`ParameterTypeFile`**: File paths with existence validation and tab completion"`
- L1514: `          "label": "ParameterType",`
- L1515: `          "pattern": "\\bParameterType\\w*\\b",`
- L1517: `          "text": "**`ParameterTypeFileList`**: Multiple file paths"`
- L1520: `          "label": "ParameterType",`
- L1521: `          "pattern": "\\bParameterType\\w*\\b",`
- L1523: `          "text": "**`ParameterTypeStringFromFile`**: Read text content from a file (useful for large inputs)"`
- L1526: `          "label": "ParameterType",`
- L1527: `          "pattern": "\\bParameterType\\w*\\b",`
- L1529: `          "text": "**`ParameterTypeStringListFromFile`**: Read line-separated lists from files"`
- L1532: `          "label": "ParameterType",`
- L1533: `          "pattern": "\\bParameterType\\w*\\b",`
- L1535: `          "text": "**`ParameterTypeKeyValue`**: Map-like inputs: `--env DATABASE_URL=postgres://... --env DEBUG=true`"`
- L1539: `        "pkg/cmds/layers import": 1,`
- L1540: `        "pkg/cmds/parameters import": 1,`
- L1541: `        "ParsedLayers": 2,`
- L1542: `        "ParameterType": 17`
- L1551: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/layers-guide.md",`
- L1554: `          "label": "pkg/cmds/layers import",`
- L1555: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1557: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1560: `          "label": "pkg/cmds/parameters import",`
- L1561: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1563: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1569: `          "text": "extendedDbLayer.AddFlags("`
- L1575: `          "text": "b.layer.AddFlags("`
- L1581: `          "text": "b.layer.AddFlags("`
- L1587: `          "text": "b.layer.AddFlags("`
- L1593: `          "text": "advancedLayer.AddFlags("`
- L1599: `          "text": "layer.AddFlags("`
- L1605: `          "text": "layer.AddFlags("`
- L1611: `          "text": "layer.AddFlags("`
- L1617: `          "text": "layer.AddFlags("`
- L1621: `        "pkg/cmds/layers import": 1,`
- L1622: `        "pkg/cmds/parameters import": 1,`
- L1627: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/topics/logging-layer.md",`
- L1650: `          "label": "ParameterDefinition",`
- L1651: `          "pattern": "\\bParameterDefinition\\b",`
- L1653: `          "text": "- `ParameterDefinition`: This struct is used to define the parameters (flags or arguments) that the command takes. It"`
- L1657: `        "ParameterDefinition": 1`
- L1681: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/doc/tutorials/custom-layer.md",`
- L1684: `          "label": "pkg/cmds/layers import",`
- L1685: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1687: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1690: `          "label": "pkg/cmds/layers import",`
- L1691: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1693: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1696: `          "label": "pkg/cmds/layers import",`
- L1697: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1699: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1702: `          "label": "pkg/cmds/parameters import",`
- L1703: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1705: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1708: `          "label": "pkg/cmds/parameters import",`
- L1709: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1711: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1715: `        "pkg/cmds/layers import": 3,`
- L1716: `        "pkg/cmds/parameters import": 2`
- L1723: `          "label": "pkg/cmds/layers import",`
- L1724: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1726: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1729: `          "label": "pkg/cmds/layers import",`
- L1730: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1732: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/layers\""`
- L1735: `          "label": "pkg/cmds/parameters import",`
- L1736: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1738: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1741: `          "label": "pkg/cmds/parameters import",`
- L1742: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1744: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1747: `          "label": "pkg/cmds/parameters import",`
- L1748: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1750: `          "text": "\"github.com/go-go-golems/glazed/pkg/cmds/parameters\""`
- L1795: `          "label": "LoadParametersFromFile",`
- L1796: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1798: `          "text": "1. **Config File Loading**: Replace `GatherFlagsFromViper()` and `GatherFlagsFromCustomViper()` with `LoadParametersFromFile()` or `LoadParametersFromFiles()`"`
- L1801: `          "label": "LoadParametersFromFile",`
- L1802: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1804: `          "text": "### After: Using LoadParametersFromFile"`
- L1807: `          "label": "LoadParametersFromFile",`
- L1808: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1810: `          "text": "For applications with a single config file, use `LoadParametersFromFile`:"`
- L1813: `          "label": "LoadParametersFromFile",`
- L1814: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L1816: `          "text": "// Use with LoadParametersFromFile"`
- L1819: `          "label": "LoadParametersFromFiles",`
- L1820: `          "pattern": "\\bLoadParametersFromFiles\\b",`
- L1822: `          "text": "1. **Config File Loading**: Replace `GatherFlagsFromViper()` and `GatherFlagsFromCustomViper()` with `LoadParametersFromFile()` or `LoadParametersFromFiles()`"`
- L1825: `          "label": "LoadParametersFromFiles",`
- L1826: `          "pattern": "\\bLoadParametersFromFiles\\b",`
- L1828: `          "text": "For applications that compose configuration from multiple files, use `LoadParametersFromFiles`:"`
- L1831: `          "label": "LoadParametersFromFiles",`
- L1832: `          "pattern": "\\bLoadParametersFromFiles\\b",`
- L1834: `          "text": "### After: Using LoadParametersFromFiles"`
- L1837: `          "label": "LoadParametersFromFiles",`
- L1838: `          "pattern": "\\bLoadParametersFromFiles\\b",`
- L1840: `          "text": "2. Check config file order in `LoadParametersFromFiles` (low \u2192 high)"`
- L1844: `        "pkg/cmds/layers import": 2,`
- L1845: `        "pkg/cmds/parameters import": 3,`
- L1848: `        "LoadParametersFromFile": 4,`
- L1849: `        "LoadParametersFromFiles": 4`
- L1856: `          "label": "pkg/cmds/layers import",`
- L1857: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/layers",`
- L1859: `          "text": "- `github.com/go-go-golems/glazed/pkg/cmds/layers`"`
- L1862: `          "label": "pkg/cmds/parameters import",`
- L1863: `          "pattern": "github\\.com/go-go-golems/glazed/pkg/cmds/parameters",`
- L1865: `          "text": "- `github.com/go-go-golems/glazed/pkg/cmds/parameters`"`
- L1874: `          "label": "layers.ParameterLayer",`
- L1875: `          "pattern": "layers\\.ParameterLayer",`
- L1877: `          "text": "- `pkg/cmds/layers.ParameterLayer` \u2192 `pkg/cmds/schema.Section`"`
- L1880: `          "label": "layers.ParameterLayer",`
- L1881: `          "pattern": "layers\\.ParameterLayer",`
- L1883: `          "text": "- `pkg/cmds/layers.ParameterLayers` \u2192 `pkg/cmds/schema.Schema`"`
- L1886: `          "label": "layers.ParameterLayer",`
- L1887: `          "pattern": "layers\\.ParameterLayer",`
- L1889: `          "text": "- `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`)."`
- L1892: `          "label": "layers.ParameterLayer",`
- L1893: `          "pattern": "layers\\.ParameterLayer",`
- L1895: `          "text": "- `layers.ParameterLayer` interface methods now use `*fields.Definition` / `*fields.Definitions`:"`
- L1898: `          "label": "layers.ParameterLayers",`
- L1899: `          "pattern": "layers\\.ParameterLayers",`
- L1901: `          "text": "- `pkg/cmds/layers.ParameterLayers` \u2192 `pkg/cmds/schema.Schema`"`
- L1904: `          "label": "layers.ParameterLayers",`
- L1905: `          "pattern": "layers\\.ParameterLayers",`
- L1907: `          "text": "- `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`)."`
- L1910: `          "label": "ParameterLayer",`
- L1911: `          "pattern": "\\bParameterLayer\\b",`
- L1913: `          "text": "- `pkg/cmds/layers.ParameterLayer` \u2192 `pkg/cmds/schema.Section`"`
- L1916: `          "label": "ParameterLayer",`
- L1917: `          "pattern": "\\bParameterLayer\\b",`
- L1919: `          "text": "- `layers.ParameterLayer` interface methods now use `*fields.Definition` / `*fields.Definitions`:"`
- L1922: `          "label": "ParameterLayers",`
- L1923: `          "pattern": "\\bParameterLayers\\b",`
- L1925: `          "text": "- `pkg/cmds/layers.ParameterLayers` \u2192 `pkg/cmds/schema.Schema`"`
- L1928: `          "label": "ParameterLayers",`
- L1929: `          "pattern": "\\bParameterLayers\\b",`
- L1931: `          "text": "- `cmds.CommandDescription.Layers` is now `*schema.Schema` (was `*layers.ParameterLayers`)."`
- L1934: `          "label": "ParsedLayer",`
- L1935: `          "pattern": "\\bParsedLayer\\b",`
- L1937: `          "text": "- `pkg/cmds/layers.ParsedLayer` \u2192 `pkg/cmds/values.SectionValues`"`
- L1940: `          "label": "ParsedLayers",`
- L1941: `          "pattern": "\\bParsedLayers\\b",`
- L1943: `          "text": "- `pkg/cmds/layers.ParsedLayers` \u2192 `pkg/cmds/values.Values`"`
- L1946: `          "label": "ParsedLayers",`
- L1947: `          "pattern": "\\bParsedLayers\\b",`
- L1949: `          "text": "\u2026and it still satisfies interfaces that mention `*layers.ParsedLayers`, because `values.Values` is an alias for `layers.ParsedLayers`."`
- L1952: `          "label": "ParsedLayers",`
- L1953: `          "pattern": "\\bParsedLayers\\b",`
- L1955: `          "text": "func (c *MyCmd) Run(ctx context.Context, parsedLayers *layers.ParsedLayers) error {"`
- L1958: `          "label": "parameters.ParameterDefinition",`
- L1959: `          "pattern": "parameters\\.ParameterDefinition",`
- L1961: `          "text": "- `pkg/cmds/parameters.ParameterDefinition` \u2192 `pkg/cmds/fields.Definition`"`
- L1964: `          "label": "parameters.ParameterDefinition",`
- L1965: `          "pattern": "parameters\\.ParameterDefinition",`
- L1967: `          "text": "- `pkg/cmds/parameters.ParameterDefinitions` \u2192 `pkg/cmds/fields.Definitions`"`
- L1970: `          "label": "parameters.ParameterDefinitions",`
- L1971: `          "pattern": "parameters\\.ParameterDefinitions",`
- L1973: `          "text": "- `pkg/cmds/parameters.ParameterDefinitions` \u2192 `pkg/cmds/fields.Definitions`"`
- L1976: `          "label": "ParameterDefinition",`
- L1977: `          "pattern": "\\bParameterDefinition\\b",`
- L1979: `          "text": "- `pkg/cmds/parameters.ParameterDefinition` \u2192 `pkg/cmds/fields.Definition`"`
- L1982: `          "label": "ParameterDefinitions",`
- L1983: `          "pattern": "\\bParameterDefinitions\\b",`
- L1985: `          "text": "- `pkg/cmds/parameters.ParameterDefinitions` \u2192 `pkg/cmds/fields.Definitions`"`
- L1988: `          "label": "ParameterType",`
- L1989: `          "pattern": "\\bParameterType\\w*\\b",`
- L1991: `          "text": "- `pkg/cmds/parameters.ParameterType*` \u2192 `pkg/cmds/fields.Type*`"`
- L1994: `          "label": "ParameterType",`
- L1995: `          "pattern": "\\bParameterType\\w*\\b",`
- L1997: `          "text": "parameters.NewParameterDefinition(\"limit\", parameters.ParameterTypeInteger, parameters.WithDefault(10))"`
- L2000: `          "label": "ParameterType",`
- L2001: `          "pattern": "\\bParameterType\\w*\\b",`
- L2003: `          "text": "parameters.NewParameterDefinition(\"api-key\", parameters.ParameterTypeString),"`
- L2012: `          "label": "CobraParameterLayer",`
- L2013: `          "pattern": "\\bCobraParameterLayer\\b",`
- L2015: `          "text": "- Cobra-only plumbing: attaching layers to Cobra uses `layers.CobraParameterLayer`."`
- L2054: `          "label": "LoadParametersFromFile",`
- L2055: `          "pattern": "\\bLoadParametersFromFile\\b",`
- L2057: `          "text": "- `middlewares.LoadParametersFromFile(s)` \u2192 `sources.FromFile` / `sources.FromFiles`"`
- L2063: `          "text": "- `parameters.WithParseStepSource(...)` \u2192 `sources.WithSource(...)`"`
- L2073: `        "pkg/cmds/layers import": 1,`
- L2074: `        "pkg/cmds/parameters import": 1,`
- L2076: `        "layers.ParameterLayer": 4,`
- L2077: `        "layers.ParameterLayers": 2,`
- L2078: `        "ParameterLayer": 2,`
- L2079: `        "ParameterLayers": 2,`
- L2080: `        "ParsedLayer": 1,`
- L2081: `        "ParsedLayers": 3,`
- L2082: `        "parameters.ParameterDefinition": 2,`
- L2083: `        "parameters.ParameterDefinitions": 1,`
- L2084: `        "ParameterDefinition": 1,`
- L2085: `        "ParameterDefinitions": 1,`
- L2086: `        "ParameterType": 3,`
- L2088: `        "CobraParameterLayer": 1,`
- L2094: `        "LoadParametersFromFile": 1,`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/analysis_queries.sql`
- L28: `-- Find diff hunks that mention ParsedLayers (signature shifts).`
- L31: `where hunk_text like '%ParsedLayers%'`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/doc_deprecation_scan.py`
- L15: `    ("pkg/cmds/layers import", r"github\.com/go-go-golems/glazed/pkg/cmds/layers"),`
- L16: `    ("pkg/cmds/parameters import", r"github\.com/go-go-golems/glazed/pkg/cmds/parameters"),`
- L18: `    ("layers.ParameterLayer", r"layers\.ParameterLayer"),`
- L19: `    ("layers.ParameterLayers", r"layers\.ParameterLayers"),`
- L20: `    ("ParameterLayer", r"\bParameterLayer\b"),`
- L21: `    ("ParameterLayers", r"\bParameterLayers\b"),`
- L22: `    ("ParsedLayer", r"\bParsedLayer\b"),`
- L23: `    ("ParsedLayers", r"\bParsedLayers\b"),`
- L24: `    ("parameters.ParameterDefinition", r"parameters\.ParameterDefinition"),`
- L25: `    ("parameters.ParameterDefinitions", r"parameters\.ParameterDefinitions"),`
- L26: `    ("ParameterDefinition", r"\bParameterDefinition\b"),`
- L27: `    ("ParameterDefinitions", r"\bParameterDefinitions\b"),`
- L28: `    ("ParameterType", r"\bParameterType\w*\b"),`
- L31: `    ("CobraParameterLayer", r"\bCobraParameterLayer\b"),`
- L37: `    ("LoadParametersFromFile", r"\bLoadParametersFromFile\b"),`
- L38: `    ("LoadParametersFromFiles", r"\bLoadParametersFromFiles\b"),`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/various/git-diff-origin-main-summary.json`
- L91: `      "name": "WithParameterValue"`
- L98: `      "name": "WithParameters"`
- L101: `      "path": "pkg/settings/glazed_layer.go",`

### `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/various/rename-glazed-api-report.json`
- L56: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/cmd/examples/parameter-types/main.go",`
- L204: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/fields/gather-parameters.go",`
- L208: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/fields/gather-parameters_test.go",`
- L220: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/fields/parameter-type.go",`
- L224: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/fields/parameters.go",`
- L228: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/fields/parameters_from_defaults_test.go",`
- L232: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/fields/parameters_test.go",`
- L244: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/fields/parsed-parameter.go",`
- L304: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/logging/layer.go",`
- L328: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/schema/layer-impl.go",`
- L332: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/schema/layer-impl_test.go",`
- L336: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/schema/layer.go",`
- L340: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/schema/layer_test.go",`
- L364: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/sources/layers.go",`
- L368: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/sources/load-parameters-from-json.go",`
- L451: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/values/parsed-layer.go",`
- L455: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/cmds/values/parsed-layer_test.go",`
- L951: `      "path": "/home/manuel/workspaces/2026-02-02/refactor-glazed-names/glazed/pkg/settings/glazed_layer.go",`

### `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/analysis/02-examples-rename-report.json`
- L53: `      "path": "cmd/examples/parameter-types/main.go",`

### `ttmp/vocabulary.yaml`
- L10: `    - slug: layers`
- L11: `      description: Layered schemas (ParameterLayers) and grouping concepts`
- L12: `    - slug: parameters`
- L13: `      description: Parameter/flag/arg definitions and parsing`
- L31: `      description: Runner and ParseCommandParameters seams`
- L33: `      description: Built-in settings layers (output, formatting, etc.)`

## Full file index (all files)
| Path | Type | Size (bytes) | parameter? | layer? | glazed.parameter? |
| --- | --- | ---: | :---: | :---: | :---: |
| `.git` | text | 94 |  |  |  |
| `.git-commit-message.yaml` | text | 186 |  |  |  |
| `.github/dependabot.yml` | text | 479 |  |  |  |
| `.github/workflows/codeql-analysis.yml` | text | 549 |  |  |  |
| `.github/workflows/dependency-scanning.yml` | text | 1418 |  |  |  |
| `.github/workflows/lint.yml` | text | 696 |  |  |  |
| `.github/workflows/push.yml` | text | 411 |  |  |  |
| `.github/workflows/release.yaml` | text | 3321 |  |  |  |
| `.github/workflows/secret-scanning.yml` | text | 488 |  |  |  |
| `.gitignore` | text | 43 |  |  |  |
| `.golangci.yml` | text | 939 |  |  |  |
| `.goreleaser.yaml` | text | 2861 |  |  |  |
| `.idea/.gitignore` | text | 176 |  |  |  |
| `.idea/dd-cli.iml` | text | 445 |  |  |  |
| `.idea/git_toolbox_prj.xml` | text | 480 |  |  |  |
| `.idea/golinter.xml` | text | 650 |  |  |  |
| `.idea/markdown.xml` | text | 185 |  |  |  |
| `.idea/misc.xml` | text | 178 |  |  |  |
| `.idea/modules.xml` | text | 395 |  |  |  |
| `.idea/vcs.xml` | text | 167 |  |  |  |
| `.ttmp.yaml` | text | 122 |  |  |  |
| `AGENT.md` | text | 2922 |  | Y |  |
| `CHANGELOG` | text | 712 | Y | Y |  |
| `LICENSE` | text | 1072 |  |  |  |
| `Makefile` | text | 1490 |  |  |  |
| `README.md` | text | 6997 | Y | Y |  |
| `changelog.md` | text | 2950 | Y | Y |  |
| `cmd/examples/appconfig-parser/main.go` | text | 2230 |  | Y |  |
| `cmd/examples/appconfig-profiles/main.go` | text | 4261 |  | Y |  |
| `cmd/examples/config-custom-mapper/config.yaml` | text | 225 |  | Y |  |
| `cmd/examples/config-custom-mapper/main.go` | text | 5918 | Y | Y |  |
| `cmd/examples/config-overlay/base.yaml` | text | 39 |  |  |  |
| `cmd/examples/config-overlay/env.yaml` | text | 44 |  |  |  |
| `cmd/examples/config-overlay/local.yaml` | text | 41 |  |  |  |
| `cmd/examples/config-overlay/main.go` | text | 4386 | Y | Y |  |
| `cmd/examples/config-pattern-mapper/README.md` | text | 3543 | Y | Y |  |
| `cmd/examples/config-pattern-mapper/config-ex1.yaml` | text | 62 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-ex2.yaml` | text | 75 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-ex3.yaml` | text | 78 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-ex4.yaml` | text | 116 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-ex6.yaml` | text | 49 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-ex7.yaml` | text | 118 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-ex8.yaml` | text | 46 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-example.yaml` | text | 122 |  |  |  |
| `cmd/examples/config-pattern-mapper/config-invalid-staging.yaml` | text | 71 |  |  |  |
| `cmd/examples/config-pattern-mapper/main.go` | text | 8745 | Y | Y |  |
| `cmd/examples/config-pattern-mapper/mappings.yaml` | text | 158 | Y | Y |  |
| `cmd/examples/config-single/config.yaml` | text | 43 |  |  |  |
| `cmd/examples/config-single/main.go` | text | 4169 | Y | Y |  |
| `cmd/examples/help-system/README.md` | text | 1642 |  |  |  |
| `cmd/examples/help-system/docs/configuration-topic.md` | text | 1104 |  |  |  |
| `cmd/examples/help-system/docs/data-pipeline-application.md` | text | 1884 |  |  |  |
| `cmd/examples/help-system/docs/database-tutorial.md` | text | 895 |  |  |  |
| `cmd/examples/help-system/docs/json-example.md` | text | 662 |  |  |  |
| `cmd/examples/help-system/main.go` | text | 4581 |  |  |  |
| `cmd/examples/markdown-code-blocks/main.go` | text | 1461 |  |  |  |
| `cmd/examples/markdown-code-blocks/test.md` | text | 136 |  |  |  |
| `cmd/examples/middlewares-config-env/config.yaml` | text | 47 |  |  |  |
| `cmd/examples/middlewares-config-env/main.go` | text | 2524 | Y | Y |  |
| `cmd/examples/new-api-build-first-command/README.md` | text | 521 |  |  |  |
| `cmd/examples/new-api-build-first-command/main.go` | text | 4514 |  | Y |  |
| `cmd/examples/new-api-dual-mode/README.md` | text | 507 |  |  |  |
| `cmd/examples/new-api-dual-mode/main.go` | text | 2719 |  |  |  |
| `cmd/examples/overlay-override/base.override.yaml` | text | 49 |  |  |  |
| `cmd/examples/overlay-override/base.yaml` | text | 45 |  |  |  |
| `cmd/examples/overlay-override/main.go` | text | 2672 |  | Y |  |
| `cmd/examples/parameter-types/README.md` | text | 3037 | Y |  |  |
| `cmd/examples/parameter-types/config.yaml` | text | 130 |  |  |  |
| `cmd/examples/parameter-types/main.go` | text | 12527 | Y | Y |  |
| `cmd/examples/parameter-types/sample-lines.txt` | text | 30 |  |  |  |
| `cmd/examples/parameter-types/sample-list.json` | text | 168 |  |  |  |
| `cmd/examples/parameter-types/sample-text.txt` | text | 151 | Y |  |  |
| `cmd/examples/parameter-types/sample.json` | text | 78 |  |  |  |
| `cmd/examples/parameter-types/sample.yaml` | text | 157 |  |  |  |
| `cmd/examples/parameter-types/simple-config.yaml` | text | 39 |  |  |  |
| `cmd/examples/refactor-new-packages/README.md` | text | 2944 |  |  |  |
| `cmd/examples/refactor-new-packages/main.go` | text | 5775 | Y | Y |  |
| `cmd/examples/register-cobra/README.md` | text | 2405 |  |  |  |
| `cmd/examples/register-cobra/main.go` | text | 6799 |  |  |  |
| `cmd/examples/sources-example/config.yaml` | text | 66 |  |  |  |
| `cmd/examples/sources-example/main.go` | text | 5226 |  | Y |  |
| `cmd/glaze/cmds/csv.go` | text | 3286 | Y | Y |  |
| `cmd/glaze/cmds/docs.go` | text | 2119 | Y | Y |  |
| `cmd/glaze/cmds/example.go` | text | 2583 | Y | Y |  |
| `cmd/glaze/cmds/html/cmds.go` | text | 2946 |  | Y |  |
| `cmd/glaze/cmds/html/parse.go` | text | 5172 |  |  |  |
| `cmd/glaze/cmds/html/parse_test.go` | text | 8063 |  |  |  |
| `cmd/glaze/cmds/json.go` | text | 4736 | Y | Y |  |
| `cmd/glaze/cmds/markdown.go` | text | 11410 |  | Y |  |
| `cmd/glaze/cmds/yaml.go` | text | 3691 | Y | Y |  |
| `cmd/glaze/main.go` | text | 2082 |  | Y |  |
| `dist/linux_amd64/artifacts.json` | text | 2614 |  |  |  |
| `dist/linux_amd64/config.yaml` | text | 6951 |  |  |  |
| `dist/linux_amd64/deb/glaze_amd64v1/lintian` | text | 79 |  |  |  |
| `dist/linux_amd64/glaze-linux_linux_amd64_v1/glaze` | binary | 35503760 |  |  |  |
| `dist/linux_amd64/glaze_0.7.15-next_linux_amd64.deb` | binary | 12615728 |  |  |  |
| `dist/linux_amd64/glaze_0.7.15-next_linux_amd64.rpm` | binary | 13110887 |  |  |  |
| `dist/linux_amd64/glaze_0.7.15-next_linux_amd64.tar.gz` | binary | 12586444 |  |  |  |
| `dist/linux_amd64/metadata.json` | text | 274 |  |  |  |
| `doc/licenses/APACHE-LICENSE` | text | 10140 |  |  |  |
| `doc/vhs/demo.sh` | text | 1678 |  |  |  |
| `doc/vhs/demo.tape` | text | 2889 |  |  |  |
| `doc/vhs/doc-demo.tape` | text | 302 |  |  |  |
| `go.mod` | text | 5210 |  |  |  |
| `go.sum` | text | 24888 |  |  |  |
| `lefthook.yml` | text | 325 |  |  |  |
| `misc/broken.yaml` | text | 97 |  |  |  |
| `misc/broken2.yaml` | text | 63 |  |  |  |
| `misc/description.html` | text | 14767 |  |  |  |
| `misc/json-parameters-from-json.json` | text | 28 |  |  |  |
| `misc/rename-employees.yaml` | text | 91 |  |  |  |
| `misc/rename.yaml` | text | 69 |  |  |  |
| `misc/replace.yaml` | text | 194 |  |  |  |
| `misc/template-field-object.yaml` | text | 119 |  |  |  |
| `misc/template-field-row.yaml` | text | 52 |  |  |  |
| `misc/template-file-example.tmpl.md` | text | 104 |  |  |  |
| `misc/template-file-example2.tmpl.md` | text | 125 |  |  |  |
| `misc/test-data/1.json` | text | 93 |  |  |  |
| `misc/test-data/1.yaml` | text | 49 |  |  |  |
| `misc/test-data/2.json` | text | 100 |  |  |  |
| `misc/test-data/2.yaml` | text | 56 |  |  |  |
| `misc/test-data/3.json` | text | 48 |  |  |  |
| `misc/test-data/3.yaml` | text | 26 |  |  |  |
| `misc/test-data/book.json` | text | 57 |  |  |  |
| `misc/test-data/books.json` | text | 2643 |  |  |  |
| `misc/test-data/code.md` | text | 51 |  |  |  |
| `misc/test-data/duplicates.json` | text | 266 |  |  |  |
| `misc/test-data/employees.csv` | text | 423 |  |  |  |
| `misc/test-data/rows.json` | text | 316 |  |  |  |
| `misc/test-data/rows.yaml` | text | 173 |  |  |  |
| `misc/test-data/sort.json` | text | 402 |  |  |  |
| `misc/test-data/test.yaml` | text | 171 |  |  |  |
| `misc/test-data/unsanitized-json.json` | text | 5039 |  |  |  |
| `misc/test-data/unsanitized-yaml.md` | text | 2083 |  |  |  |
| `pinocchio/glazed/create-help.yaml` | text | 5150 |  |  |  |
| `pinocchio/glazed/create-template-command.yaml` | text | 3041 | Y |  |  |
| `pkg/appconfig/doc.go` | text | 452 | Y | Y |  |
| `pkg/appconfig/options.go` | text | 9903 |  | Y |  |
| `pkg/appconfig/parser.go` | text | 3854 | Y | Y |  |
| `pkg/appconfig/parser_test.go` | text | 5647 |  | Y |  |
| `pkg/appconfig/profile_test.go` | text | 7876 |  | Y |  |
| `pkg/cli/cli.go` | text | 3021 | Y | Y |  |
| `pkg/cli/cliopatra/capture.go` | text | 2870 | Y | Y |  |
| `pkg/cli/cliopatra/capture_test.go` | text | 5815 | Y | Y |  |
| `pkg/cli/cliopatra/program.go` | text | 11530 | Y | Y |  |
| `pkg/cli/cobra-parser.go` | text | 11362 | Y | Y |  |
| `pkg/cli/cobra.go` | text | 16440 | Y | Y |  |
| `pkg/cli/helpers.go` | text | 3081 | Y | Y |  |
| `pkg/cmds/alias/alias.go` | text | 4869 |  | Y |  |
| `pkg/cmds/cmds.go` | text | 11475 | Y | Y |  |
| `pkg/cmds/cobra_test.go` | text | 19018 | Y | Y |  |
| `pkg/cmds/doc.go` | text | 1415 |  |  |  |
| `pkg/cmds/fields/cobra.go` | text | 16151 | Y |  |  |
| `pkg/cmds/fields/cobra_test.go` | text | 83 |  |  |  |
| `pkg/cmds/fields/errors.go` | text | 245 | Y |  |  |
| `pkg/cmds/fields/file.go` | text | 4325 |  |  |  |
| `pkg/cmds/fields/file_test.go` | text | 2908 |  |  |  |
| `pkg/cmds/fields/gather-arguments.go` | text | 2055 | Y |  |  |
| `pkg/cmds/fields/gather-arguments_test.go` | text | 13810 | Y |  |  |
| `pkg/cmds/fields/gather-parameters.go` | text | 2446 | Y |  |  |
| `pkg/cmds/fields/gather-parameters_test.go` | text | 1357 | Y |  |  |
| `pkg/cmds/fields/initialize-struct.go` | text | 15478 | Y |  |  |
| `pkg/cmds/fields/initialize-struct_test.go` | text | 20318 | Y |  |  |
| `pkg/cmds/fields/parameter-type.go` | text | 3638 | Y |  |  |
| `pkg/cmds/fields/parameters.go` | text | 22832 | Y |  |  |
| `pkg/cmds/fields/parameters_from_defaults_test.go` | text | 11652 | Y |  |  |
| `pkg/cmds/fields/parameters_test.go` | text | 31729 | Y |  |  |
| `pkg/cmds/fields/parse.go` | text | 18654 | Y |  |  |
| `pkg/cmds/fields/parse_test.go` | text | 32831 | Y |  |  |
| `pkg/cmds/fields/parsed-parameter.go` | text | 9163 | Y |  |  |
| `pkg/cmds/fields/render.go` | text | 3567 |  |  |  |
| `pkg/cmds/fields/render_test.go` | text | 2542 |  |  |  |
| `pkg/cmds/fields/serialize.go` | text | 2248 | Y |  |  |
| `pkg/cmds/fields/strings.go` | text | 4790 | Y |  |  |
| `pkg/cmds/fields/strings_test.go` | text | 15675 | Y |  |  |
| `pkg/cmds/fields/test-data/gather-fields.yaml` | text | 9883 | Y |  |  |
| `pkg/cmds/fields/test-data/object.json` | text | 43 |  |  |  |
| `pkg/cmds/fields/test-data/object2.json` | text | 43 |  |  |  |
| `pkg/cmds/fields/test-data/object3.yaml` | text | 30 |  |  |  |
| `pkg/cmds/fields/test-data/objectList.json` | text | 116 |  |  |  |
| `pkg/cmds/fields/test-data/objectList2.yaml` | text | 116 |  |  |  |
| `pkg/cmds/fields/test-data/objectList3.csv` | text | 48 |  |  |  |
| `pkg/cmds/fields/test-data/parameters_test.yaml` | text | 5983 | Y |  |  |
| `pkg/cmds/fields/test-data/parameters_validity_test.yaml` | text | 6147 | Y |  |  |
| `pkg/cmds/fields/test-data/string.txt` | text | 8 |  |  |  |
| `pkg/cmds/fields/test-data/string2.txt` | text | 8 |  |  |  |
| `pkg/cmds/fields/test-data/stringList.csv` | text | 30 |  |  |  |
| `pkg/cmds/fields/test-data/stringList2.csv` | text | 30 |  |  |  |
| `pkg/cmds/fields/test-data/types.yaml` | text | 1204 |  |  |  |
| `pkg/cmds/fields/viper.go` | text | 3183 | Y |  |  |
| `pkg/cmds/helpers/test-helpers.go` | text | 10658 | Y | Y |  |
| `pkg/cmds/json-schema.go` | text | 5447 | Y |  |  |
| `pkg/cmds/layout/layout.go` | text | 2067 | Y | Y |  |
| `pkg/cmds/loaders/loaders.go` | text | 6639 |  |  |  |
| `pkg/cmds/loaders/multi-loader.go` | text | 3972 |  |  |  |
| `pkg/cmds/logging/README.md` | text | 1056 | Y | Y |  |
| `pkg/cmds/logging/init-early.go` | text | 4414 |  | Y |  |
| `pkg/cmds/logging/init-logging.go` | text | 3400 | Y |  |  |
| `pkg/cmds/logging/init.go` | text | 6553 |  | Y |  |
| `pkg/cmds/logging/layer.go` | text | 5795 | Y | Y |  |
| `pkg/cmds/logging/logstash_writer.go` | text | 2991 |  |  |  |
| `pkg/cmds/runner/run.go` | text | 5855 | Y | Y |  |
| `pkg/cmds/schema/cobra.go` | text | 465 |  | Y |  |
| `pkg/cmds/schema/cobra_flag_groups.go` | text | 11684 | Y | Y |  |
| `pkg/cmds/schema/errors.go` | text | 316 | Y | Y |  |
| `pkg/cmds/schema/layer-impl.go` | text | 7752 | Y | Y |  |
| `pkg/cmds/schema/layer-impl_test.go` | text | 1728 | Y | Y |  |
| `pkg/cmds/schema/layer.go` | text | 4611 | Y | Y |  |
| `pkg/cmds/schema/layer_test.go` | text | 7851 | Y | Y |  |
| `pkg/cmds/schema/serialize.go` | text | 2447 | Y | Y |  |
| `pkg/cmds/schema/wrappers.go` | text | 1409 | Y | Y |  |
| `pkg/cmds/sources/cobra.go` | text | 7583 | Y | Y |  |
| `pkg/cmds/sources/config-mapper-interface.go` | text | 478 |  | Y |  |
| `pkg/cmds/sources/custom-profiles_test.go` | text | 6922 | Y | Y |  |
| `pkg/cmds/sources/layers.go` | text | 4951 | Y | Y |  |
| `pkg/cmds/sources/load-parameters-from-json.go` | text | 5383 | Y | Y |  |
| `pkg/cmds/sources/middlewares.go` | text | 2613 | Y | Y |  |
| `pkg/cmds/sources/middlewares_test.go` | text | 7307 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/exports.go` | text | 917 | Y |  |  |
| `pkg/cmds/sources/patternmapper/loader.go` | text | 3329 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/pattern_mapper.go` | text | 22868 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/pattern_mapper_builder.go` | text | 1857 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/pattern_mapper_edge_cases_test.go` | text | 14811 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/pattern_mapper_loader_test.go` | text | 3166 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/pattern_mapper_orderedmap_test.go` | text | 1709 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/pattern_mapper_proposals_test.go` | text | 10995 | Y | Y |  |
| `pkg/cmds/sources/patternmapper/pattern_mapper_test.go` | text | 15852 | Y | Y |  |
| `pkg/cmds/sources/profiles.go` | text | 6894 | Y | Y |  |
| `pkg/cmds/sources/tests/middlewares.yaml` | text | 2017 | Y | Y |  |
| `pkg/cmds/sources/tests/multi-update-from-map.yaml` | text | 6458 | Y | Y |  |
| `pkg/cmds/sources/tests/set-from-defaults.yaml` | text | 6464 | Y | Y |  |
| `pkg/cmds/sources/tests/update-from-map-as-default.yaml` | text | 6193 | Y | Y |  |
| `pkg/cmds/sources/tests/update-from-map.yaml` | text | 3349 | Y | Y |  |
| `pkg/cmds/sources/tests/wrap-with-restricted-layers.yaml` | text | 5280 | Y | Y |  |
| `pkg/cmds/sources/update.go` | text | 7886 | Y | Y |  |
| `pkg/cmds/sources/update_test.go` | text | 3806 | Y | Y |  |
| `pkg/cmds/sources/whitelist.go` | text | 8467 | Y | Y |  |
| `pkg/cmds/template.go` | text | 3151 |  | Y |  |
| `pkg/cmds/test-data/cobra/01-test-simple.yaml` | text | 887 | Y |  |  |
| `pkg/cmds/test-data/cobra/02-key-value.yaml` | text | 292 | Y |  |  |
| `pkg/cmds/test-data/cobra/03-string-from-file.yaml` | text | 354 | Y |  |  |
| `pkg/cmds/test-data/inputs/01-string-from-file.txt` | text | 8 |  |  |  |
| `pkg/cmds/values/parsed-layer.go` | text | 8205 | Y | Y |  |
| `pkg/cmds/values/parsed-layer_test.go` | text | 13624 | Y | Y |  |
| `pkg/cmds/values/serialize_parsed.go` | text | 3044 | Y | Y |  |
| `pkg/cmds/values/test_helpers_test.go` | text | 1526 | Y | Y |  |
| `pkg/codegen/glazed.go` | text | 2504 | Y |  |  |
| `pkg/codegen/helpers.go` | text | 10008 |  |  |  |
| `pkg/codegen/helpers_test.go` | text | 6751 |  |  |  |
| `pkg/config/cobra-config-command.go` | text | 6679 |  |  |  |
| `pkg/config/editor.go` | text | 3082 | Y |  |  |
| `pkg/config/resolve.go` | text | 1320 |  |  |  |
| `pkg/doc/applications/01-exposing-a-simple-sql-table.md` | text | 537 |  |  |  |
| `pkg/doc/applications/02-iterating-over-a-column-in-shell.md` | text | 1201 |  |  |  |
| `pkg/doc/applications/03-user-store-command.md` | text | 13061 | Y | Y |  |
| `pkg/doc/doc.go` | text | 223 |  |  |  |
| `pkg/doc/examples/cliopatra/cliopatra.md` | text | 1900 | Y |  |  |
| `pkg/doc/examples/filter/remove-duplicates.md` | text | 1025 |  |  |  |
| `pkg/doc/examples/help/help-example-1.md` | text | 3225 |  |  |  |
| `pkg/doc/examples/help/help-example-2.md` | text | 362 |  |  |  |
| `pkg/doc/examples/jq/01-jq-replace.md` | text | 1730 |  |  |  |
| `pkg/doc/examples/jq/02-jq-filter.md` | text | 1215 |  |  |  |
| `pkg/doc/examples/output/multiple-output-file.md` | text | 2633 |  |  |  |
| `pkg/doc/examples/output/sql-output.md` | text | 2741 |  |  |  |
| `pkg/doc/examples/regex-filters/regex-filters.md` | text | 4760 |  |  |  |
| `pkg/doc/examples/rename/01-rename-column.md` | text | 1158 |  |  |  |
| `pkg/doc/examples/rename/02-rename-regexps.md` | text | 1645 |  |  |  |
| `pkg/doc/examples/rename/03-rename-yaml.md` | text | 1173 |  |  |  |
| `pkg/doc/examples/replace/replace-add-fields.md` | text | 963 |  |  |  |
| `pkg/doc/examples/select/select-example-1.md` | text | 518 |  |  |  |
| `pkg/doc/examples/select/select-example-2.md` | text | 563 |  |  |  |
| `pkg/doc/examples/skip-limit/01-skip-limit.md` | text | 1754 |  |  |  |
| `pkg/doc/examples/sort/01-sort-by.md` | text | 891 |  |  |  |
| `pkg/doc/examples/templates/templates-example-1.md` | text | 1065 |  |  |  |
| `pkg/doc/examples/templates/templates-example-2.md` | text | 844 |  |  |  |
| `pkg/doc/examples/templates/templates-example-3.md` | text | 1631 |  |  |  |
| `pkg/doc/examples/yaml/yaml-sanitize.md` | text | 1018 |  |  |  |
| `pkg/doc/topics/00-documentation-guidelines.md` | text | 8860 |  |  |  |
| `pkg/doc/topics/01-help-system.md` | text | 11457 | Y |  |  |
| `pkg/doc/topics/02-markdown-style.md` | text | 1503 |  |  |  |
| `pkg/doc/topics/03-templates.md` | text | 9280 | Y |  |  |
| `pkg/doc/topics/04-flag-groups.md` | text | 1287 |  |  |  |
| `pkg/doc/topics/05-table-format.md` | text | 5760 |  |  |  |
| `pkg/doc/topics/06-usage-string.md` | text | 2423 | Y |  |  |
| `pkg/doc/topics/07-load-parameters-from-json.md` | text | 3048 | Y | Y |  |
| `pkg/doc/topics/08-file-parameter-type.md` | text | 3151 | Y |  |  |
| `pkg/doc/topics/09-gather-flags-from-string-list.md` | text | 3361 | Y |  |  |
| `pkg/doc/topics/10-template-command.md` | text | 4610 | Y | Y |  |
| `pkg/doc/topics/11-markdown-code-blocks.md` | text | 3568 |  |  |  |
| `pkg/doc/topics/12-profiles-use-code.md` | text | 9419 | Y | Y |  |
| `pkg/doc/topics/13-layers-and-parsed-layers.md` | text | 11014 | Y | Y |  |
| `pkg/doc/topics/14-writing-help-entries.md` | text | 7984 |  |  |  |
| `pkg/doc/topics/15-profiles.md` | text | 4746 | Y | Y |  |
| `pkg/doc/topics/16-adding-parameter-types.md` | text | 18787 | Y |  |  |
| `pkg/doc/topics/16-parsing-parameters.md` | text | 5611 | Y |  |  |
| `pkg/doc/topics/17-processor.md` | text | 6370 |  |  |  |
| `pkg/doc/topics/18-lua.md` | text | 5435 | Y | Y |  |
| `pkg/doc/topics/19-writing-yaml-commands.md` | text | 5917 | Y | Y |  |
| `pkg/doc/topics/20-using-multi-loader.md` | text | 4442 |  |  |  |
| `pkg/doc/topics/21-cmds-middlewares.md` | text | 28234 | Y | Y |  |
| `pkg/doc/topics/22-command-loaders.md` | text | 16034 | Y | Y |  |
| `pkg/doc/topics/22-templating-helpers.md` | text | 6458 | Y |  |  |
| `pkg/doc/topics/23-pattern-based-config-mapping.md` | text | 18017 | Y | Y |  |
| `pkg/doc/topics/24-config-files.md` | text | 16485 | Y | Y |  |
| `pkg/doc/topics/commands-reference.md` | text | 36575 | Y | Y |  |
| `pkg/doc/topics/how-to-write-good-documentation-pages.md` | text | 13384 | Y |  |  |
| `pkg/doc/topics/layers-guide.md` | text | 52519 | Y | Y |  |
| `pkg/doc/topics/logging-layer.md` | text | 11480 | Y | Y |  |
| `pkg/doc/topics/simple-query-dsl.md` | text | 3027 |  |  |  |
| `pkg/doc/topics/user-query-dsl.md` | text | 14398 |  |  |  |
| `pkg/doc/topics/using-the-query-api.md` | text | 22337 | Y | Y |  |
| `pkg/doc/tutorials/01-a-simple-table-cli.md` | text | 3493 | Y | Y |  |
| `pkg/doc/tutorials/02-a-simple-help-system.md` | text | 511 |  |  |  |
| `pkg/doc/tutorials/04-lua.md` | text | 4349 | Y | Y |  |
| `pkg/doc/tutorials/05-build-first-command.md` | text | 30488 | Y | Y |  |
| `pkg/doc/tutorials/config-files-quickstart.md` | text | 7139 | Y | Y |  |
| `pkg/doc/tutorials/custom-layer.md` | text | 33443 | Y | Y |  |
| `pkg/doc/tutorials/migrating-from-viper-to-config-files.md` | text | 25768 | Y | Y |  |
| `pkg/doc/tutorials/migrating-to-facade-packages.md` | text | 8184 | Y | Y |  |
| `pkg/formatters/codec_test.go` | text | 1498 |  |  |  |
| `pkg/formatters/csv/csv.go` | text | 5990 |  |  |  |
| `pkg/formatters/csv/csv_test.go` | text | 1160 |  |  |  |
| `pkg/formatters/excel/excel.go` | text | 3781 |  |  |  |
| `pkg/formatters/formatter.go` | text | 3074 |  |  |  |
| `pkg/formatters/json/json.go` | text | 4419 |  |  |  |
| `pkg/formatters/json/json_test.go` | text | 1108 |  |  |  |
| `pkg/formatters/simple/simple.go` | text | 2934 |  |  |  |
| `pkg/formatters/sql/sql.go` | text | 4525 |  |  |  |
| `pkg/formatters/sql/sql_test.go` | text | 6828 |  |  |  |
| `pkg/formatters/table/style.go` | text | 10660 |  |  |  |
| `pkg/formatters/table/style_test.go` | text | 627 |  |  |  |
| `pkg/formatters/table/table.go` | text | 9164 |  |  |  |
| `pkg/formatters/table/table_test.go` | text | 923 |  |  |  |
| `pkg/formatters/template/template.go` | text | 3936 |  |  |  |
| `pkg/formatters/template/template_test.go` | text | 1165 |  |  |  |
| `pkg/formatters/yaml/yaml.go` | text | 3750 |  |  |  |
| `pkg/formatters/yaml/yaml_test.go` | text | 1100 |  |  |  |
| `pkg/help/cmd/cobra.go` | text | 17344 |  | Y |  |
| `pkg/help/cmd/templates/cobra-help.tmpl` | text | 319 |  |  |  |
| `pkg/help/cmd/templates/cobra-short-help.tmpl` | text | 472 |  |  |  |
| `pkg/help/cmd/templates/cobra-usage.tmpl` | text | 2385 |  |  |  |
| `pkg/help/cmd/templates/help-list.tmpl` | text | 762 |  |  |  |
| `pkg/help/cmd/templates/help-long-section-list.tmpl` | text | 669 |  |  |  |
| `pkg/help/cmd/templates/help-short-section-list.tmpl` | text | 1684 |  |  |  |
| `pkg/help/cmd/templates/help-short-topic.tmpl` | text | 204 |  |  |  |
| `pkg/help/cmd/templates/help-topic.tmpl` | text | 65 |  |  |  |
| `pkg/help/cmd/ui.go` | text | 2621 |  |  |  |
| `pkg/help/dsl/compiler.go` | text | 4632 |  |  |  |
| `pkg/help/dsl/dsl.go` | text | 3717 |  |  |  |
| `pkg/help/dsl/dsl_test.go` | text | 13572 |  |  |  |
| `pkg/help/dsl/example_test.go` | text | 1592 |  |  |  |
| `pkg/help/dsl/lexer.go` | text | 5481 |  |  |  |
| `pkg/help/dsl/new_features_test.go` | text | 7360 |  |  |  |
| `pkg/help/dsl/parser.go` | text | 6612 |  |  |  |
| `pkg/help/dsl_bridge.go` | text | 6543 |  |  |  |
| `pkg/help/dsl_bridge_test.go` | text | 3593 |  |  |  |
| `pkg/help/example_store_usage.go` | text | 3350 |  |  |  |
| `pkg/help/help.go` | text | 12934 | Y |  |  |
| `pkg/help/model/section.go` | text | 3941 |  |  |  |
| `pkg/help/query.go` | text | 9662 |  |  |  |
| `pkg/help/query_store_test.go` | text | 3387 |  |  |  |
| `pkg/help/query_test.go` | text | 4105 |  |  |  |
| `pkg/help/render.go` | text | 5822 |  |  |  |
| `pkg/help/store/README.md` | text | 6416 |  | Y |  |
| `pkg/help/store/compat.go` | text | 5225 |  | Y |  |
| `pkg/help/store/example_test.go` | text | 6402 |  |  |  |
| `pkg/help/store/fts5.go` | text | 2031 |  |  |  |
| `pkg/help/store/loader.go` | text | 7887 |  |  |  |
| `pkg/help/store/loader_test.go` | text | 10715 |  |  |  |
| `pkg/help/store/nofts.go` | text | 225 |  |  |  |
| `pkg/help/store/query.go` | text | 8960 |  |  |  |
| `pkg/help/store/query_fts5.go` | text | 277 |  |  |  |
| `pkg/help/store/query_nofts.go` | text | 336 |  |  |  |
| `pkg/help/store/query_test.go` | text | 14752 |  |  |  |
| `pkg/help/store/store.go` | text | 10378 |  |  |  |
| `pkg/help/store/store_test.go` | text | 7838 |  |  |  |
| `pkg/help/ui/model.go` | text | 19914 |  |  |  |
| `pkg/help/ui/model_test.go` | text | 3325 |  |  |  |
| `pkg/helpers/assert/assert.go` | text | 1639 |  |  |  |
| `pkg/helpers/capture-output.go` | text | 907 |  |  |  |
| `pkg/helpers/cast/cast.go` | text | 7869 |  |  |  |
| `pkg/helpers/cast/interface.go` | text | 2718 |  |  |  |
| `pkg/helpers/cast/map.go` | text | 1451 |  |  |  |
| `pkg/helpers/cast/normalize.go` | text | 2143 |  |  |  |
| `pkg/helpers/cast/string.go` | text | 1829 |  |  |  |
| `pkg/helpers/cast/string_test.go` | text | 5942 |  |  |  |
| `pkg/helpers/compare/compare.go` | text | 761 |  |  |  |
| `pkg/helpers/compare/compare_test.go` | text | 1666 |  |  |  |
| `pkg/helpers/compare/remove_duplicates.go` | text | 269 |  |  |  |
| `pkg/helpers/csv/csv.go` | text | 1676 |  |  |  |
| `pkg/helpers/files/file_formats.go` | text | 1547 |  |  |  |
| `pkg/helpers/files/files.go` | text | 1611 |  |  |  |
| `pkg/helpers/files/temp-files.go` | text | 3182 |  |  |  |
| `pkg/helpers/files/temp-files_test.go` | text | 4102 |  |  |  |
| `pkg/helpers/json/extract.go` | text | 1948 |  |  |  |
| `pkg/helpers/list/list.go` | text | 495 |  |  |  |
| `pkg/helpers/list/list_test.go` | text | 564 |  |  |  |
| `pkg/helpers/maps/maps.go` | text | 3785 | Y |  |  |
| `pkg/helpers/markdown/markdown.go` | text | 5682 | Y |  |  |
| `pkg/helpers/markdown/markdown_test.go` | text | 7314 |  |  |  |
| `pkg/helpers/reflect/reflect.go` | text | 16202 |  |  |  |
| `pkg/helpers/reflect/reflect_test.go` | text | 28428 |  |  |  |
| `pkg/helpers/strings/code.go` | text | 6491 |  |  |  |
| `pkg/helpers/strings/strings.go` | text | 1623 |  |  |  |
| `pkg/helpers/strings/strings_test.go` | text | 642 |  |  |  |
| `pkg/helpers/templating/templating.go` | text | 22801 | Y |  |  |
| `pkg/helpers/templating/templating_test.go` | text | 1337 |  |  |  |
| `pkg/helpers/templating/test-templates/inner.tmpl` | text | 19 |  |  |  |
| `pkg/helpers/templating/test-templates/layouts/main.tmpl` | text | 66 |  |  |  |
| `pkg/helpers/templating/test-templates/partials/partial.tmpl` | text | 7 |  |  |  |
| `pkg/helpers/yaml/yaml.go` | text | 3219 |  |  |  |
| `pkg/helpers/yaml/yaml_test.go` | text | 3040 |  |  |  |
| `pkg/lua/cmds.go` | text | 7914 | Y | Y |  |
| `pkg/lua/lua.go` | text | 14126 | Y | Y |  |
| `pkg/middlewares/TUTORIAL.md` | text | 8870 |  |  |  |
| `pkg/middlewares/jq.go` | text | 3393 |  |  |  |
| `pkg/middlewares/jq_test.go` | text | 4182 |  |  |  |
| `pkg/middlewares/mod.go` | text | 680 |  |  |  |
| `pkg/middlewares/object/template.go` | text | 1816 |  |  |  |
| `pkg/middlewares/processor.go` | text | 4810 |  |  |  |
| `pkg/middlewares/row/add-field.go` | text | 814 |  |  |  |
| `pkg/middlewares/row/add-field_test.go` | text | 1843 |  |  |  |
| `pkg/middlewares/row/fields-filter.go` | text | 5721 |  |  |  |
| `pkg/middlewares/row/fields-filter_test.go` | text | 4841 |  |  |  |
| `pkg/middlewares/row/flatten-object.go` | text | 1766 |  |  |  |
| `pkg/middlewares/row/flatten-object_test.go` | text | 2944 |  |  |  |
| `pkg/middlewares/row/lambda.go` | text | 664 |  |  |  |
| `pkg/middlewares/row/output.go` | text | 3777 |  |  |  |
| `pkg/middlewares/row/remove-duplicates.go` | text | 1008 |  |  |  |
| `pkg/middlewares/row/remove-duplicates_test.go` | text | 4870 |  |  |  |
| `pkg/middlewares/row/remove-nulls.go` | text | 726 |  |  |  |
| `pkg/middlewares/row/rename-columns.go` | text | 4006 |  |  |  |
| `pkg/middlewares/row/rename-columns_test.go` | text | 7780 |  |  |  |
| `pkg/middlewares/row/reorder-column.go` | text | 1535 |  |  |  |
| `pkg/middlewares/row/reorder-column_test.go` | text | 2297 |  |  |  |
| `pkg/middlewares/row/replace.go` | text | 6501 |  |  |  |
| `pkg/middlewares/row/replace_test.go` | text | 9070 |  |  |  |
| `pkg/middlewares/row/skip-limit.go` | text | 626 |  |  |  |
| `pkg/middlewares/row/skip-limit_test.go` | text | 3730 |  |  |  |
| `pkg/middlewares/row/sort-columns.go` | text | 727 |  |  |  |
| `pkg/middlewares/row/sort-columns_test.go` | text | 624 |  |  |  |
| `pkg/middlewares/row/template.go` | text | 3206 |  |  |  |
| `pkg/middlewares/row/template_test.go` | text | 2991 |  |  |  |
| `pkg/middlewares/table/null.go` | text | 403 |  |  |  |
| `pkg/middlewares/table/output.go` | text | 2088 |  |  |  |
| `pkg/middlewares/table/sortby.go` | text | 1880 |  |  |  |
| `pkg/middlewares/table/sortby_test.go` | text | 5462 |  |  |  |
| `pkg/settings/flags/fields-filters.yaml` | text | 1154 |  |  |  |
| `pkg/settings/flags/jq.yaml` | text | 832 |  |  |  |
| `pkg/settings/flags/output.yaml` | text | 2872 |  |  |  |
| `pkg/settings/flags/rename.yaml` | text | 483 |  |  |  |
| `pkg/settings/flags/replace.yaml` | text | 339 |  |  |  |
| `pkg/settings/flags/select.yaml` | text | 510 |  |  |  |
| `pkg/settings/flags/skip-limit.yaml` | text | 339 |  |  |  |
| `pkg/settings/flags/sort.yaml` | text | 255 |  |  |  |
| `pkg/settings/flags/template.yaml` | text | 571 |  |  |  |
| `pkg/settings/glazed_layer.go` | text | 17493 | Y | Y |  |
| `pkg/settings/settings_fields-filters.go` | text | 5268 | Y | Y |  |
| `pkg/settings/settings_jq.go` | text | 2034 | Y | Y |  |
| `pkg/settings/settings_output.go` | text | 9546 | Y | Y |  |
| `pkg/settings/settings_rename.go` | text | 3378 | Y | Y |  |
| `pkg/settings/settings_replace.go` | text | 1720 | Y | Y |  |
| `pkg/settings/settings_select.go` | text | 1500 | Y | Y |  |
| `pkg/settings/settings_skip_limit.go` | text | 1237 | Y | Y |  |
| `pkg/settings/settings_sort.go` | text | 1441 | Y | Y |  |
| `pkg/settings/settings_template.go` | text | 2927 | Y | Y |  |
| `pkg/settings/settings_template_test.go` | text | 2331 | Y | Y |  |
| `pkg/tools.go` | text | 79 |  |  |  |
| `pkg/types/mod.go` | text | 3516 |  |  |  |
| `pkg/types/table.go` | text | 1261 |  |  |  |
| `pkg/types/table_test.go` | text | 908 |  |  |  |
| `prompto/glazed/command` | text | 159 |  |  |  |
| `prompto/glazed/command-description.md` | text | 7712 | Y | Y |  |
| `prompto/glazed/create-application-tutorial.md` | text | 10862 | Y | Y |  |
| `prompto/glazed/create-yaml-command.md` | text | 11518 | Y | Y |  |
| `prompto/glazed/definitions` | text | 211 | Y | Y |  |
| `prompto/glazed/main.md` | text | 3905 |  | Y |  |
| `prompto/glazed/middlewares` | text | 440 |  |  |  |
| `prompto/glazed/parameter-types` | text | 333 | Y |  |  |
| `prompto/glazed/parameters` | text | 736 | Y | Y |  |
| `prompto/glazed/parameters-verbose` | text | 232 | Y | Y |  |
| `prompto/glazed/processor` | text | 303 |  |  |  |
| `prompto/glazed/tests/middlewares` | text | 520 |  |  |  |
| `prompto/glazed/using-commands` | text | 48 |  |  |  |
| `prompto/glazed/writing-help-entries` | text | 57 |  |  |  |
| `test_ui.sh` | text | 710 |  |  |  |
| `ttmp/.docmgrignore` | text | 60 |  |  |  |
| `ttmp/2024-08-24/bubble-table-pagination.md` | text | 4879 |  |  |  |
| `ttmp/2024-08-24/bubble-tea-guidelines.md` | text | 71 |  |  |  |
| `ttmp/2024-10-13/create-command-docs.sh` | text | 1626 | Y |  |  |
| `ttmp/2025-07-03/01-guide-for-the-new-intern-to-implement-the-new-sqlite-help-query-system.md` | text | 3925 |  |  |  |
| `ttmp/2025-07-12/DOCUMENTATION_STYLE_GUIDE.md` | text | 7441 | Y | Y |  |
| `ttmp/2025-07-29/01-analysis-of-the-cobra-creation-api.md` | text | 7992 |  |  |  |
| `ttmp/2025-07-29/01-review-commands-reference-document.md` | text | 6050 | Y | Y |  |
| `ttmp/2025-07-29/02-plan-for-cleaning-up-the-dual-command-creation-api.md` | text | 4699 | Y | Y |  |
| `ttmp/2025-07-29/02-review-10-template-command.md` | text | 5186 | Y | Y |  |
| `ttmp/2025-07-29/03-oracle-review-of-the-create-command-tutorial.md` | text | 6280 | Y | Y |  |
| `ttmp/2025-07-29/04-review-of-the-dual-command-cobra-parser-options-refactor.md` | text | 6953 | Y | Y |  |
| `ttmp/2025-07-29/test-template.yaml` | text | 315 |  |  |  |
| `ttmp/2025-07-29/test_defaults/test_defaults.go` | text | 1776 | Y | Y |  |
| `ttmp/2025-07-29/test_doc_example/test_doc_example.go` | text | 1611 | Y | Y |  |
| `ttmp/2025-07-29/test_template_api/test_template_api.go` | text | 2664 | Y | Y |  |
| `ttmp/2025-08-05/01-research-the-context-cancellation-bug-in-glazed.md` | text | 7865 |  |  |  |
| `ttmp/2025-08-05/02-signal-cancellation-test-results.md` | text | 8738 |  | Y |  |
| `ttmp/2025-08-05/signal-test/main.go` | text | 8135 | Y | Y |  |
| `ttmp/2025-08-05/signal-test/signal-test` | binary | 47757864 |  |  |  |
| `ttmp/2025-10-29/01-how-to-remove-viper-from-glazed-applications.md` | text | 22238 | Y | Y |  |
| `ttmp/2025-10-29/02-multi-config-overlays-design.md` | text | 6736 | Y | Y |  |
| `ttmp/2025-10-29/03-generic-config-mapping-design.md` | text | 30475 | Y | Y |  |
| `ttmp/2025-10-29/04-config-mapping-debate.md` | text | 51100 | Y | Y |  |
| `ttmp/2025-10-29/05-config-mapping-review-and-recommendations.md` | text | 17551 | Y | Y |  |
| `ttmp/2025-10-29/06-implementation-summary.md` | text | 8117 | Y | Y |  |
| `ttmp/2025-10-29/07-additional-tests-and-docs.md` | text | 8858 | Y | Y |  |
| `ttmp/2025-10-29/11-debate-around-the-actual-mapper-implementation.md` | text | 48972 | Y | Y |  |
| `ttmp/2025-10-29/12-sober-proposals-from-mapper-debate.md` | text | 9070 | Y | Y |  |
| `ttmp/2025-11-03/01-validating-config-file-validity.md` | text | 11381 | Y | Y |  |
| `ttmp/2025-11-03/validate-config-examples.sh` | text | 3346 | Y | Y |  |
| `ttmp/2025-11-04/01-presidential-debate-to-review-the-config-file-feature-diff.md` | text | 23205 | Y | Y |  |
| `ttmp/2025-11-04/02-config-file-feature-code-review.md` | text | 32716 | Y | Y |  |
| `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/README.md` | text | 765 |  |  |  |
| `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/analysis/01-analysis-environment-parsing-in-glazed.md` | text | 1265 | Y | Y |  |
| `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/changelog.md` | text | 946 | Y |  |  |
| `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/index.md` | text | 2151 | Y |  |  |
| `ttmp/2025/11/18/MEN-20251119-fix-environment-variable-parsing-in-glazed/tasks.md` | text | 425 |  | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/README.md` | text | 767 |  |  |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/analysis/01-glazed-parameter-parsing-architecture-analysis.md` | text | 16889 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/changelog.md` | text | 3175 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/design-doc/01-design-struct-first-configparser-api-on-top-of-glazed.md` | text | 14454 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/design-doc/02-design-appconfig-module-register-layers-and-parse.md` | text | 7945 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/index.md` | text | 3754 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/01-diary.md` | text | 19932 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/02-research-brainstorm-new-config-api-diary.md` | text | 45786 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/03-colleague-quiz-cleanup-merge.md` | text | 9881 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/04-diary-appconfig-module-design-redo.md` | text | 10016 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/reference/05-diary-appconfig-parser-implementation.md` | text | 14372 | Y | Y |  |
| `ttmp/2025/12/15/CONFIG-PARSER-001--simplified-config-parser-api-for-glazed/tasks.md` | text | 3380 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/README.md` | text | 798 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/analysis/01-option-a-implementation-plan-schema-field-values-renaming-transitional-api.md` | text | 13097 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/brainstorm/01-brainstorm-renaming-layers-parameters-api-for-clarity.md` | text | 11618 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/changelog.md` | text | 242 |  |  |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/01-debate-round-1-option-a-naming-api-design-schema-fields-values-sources.md` | text | 9990 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-composer-metadata.md` | text | 2599 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/debate/02-debate-round-1-independent-composer-analysis.md` | text | 26851 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/diary/01-diary-layer-parameter-renaming-work.md` | text | 2777 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/index.md` | text | 1673 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/reference/01-debate-prep-candidates-and-questions-for-renaming-layers-parameters.md` | text | 9558 | Y | Y |  |
| `ttmp/2025/12/16/GLAZED-LAYER-RENAMING--rename-parameterlayer-parsedlayers-parameterdefinition-for-clarity/tasks.md` | text | 337 |  | Y |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/README.md` | text | 813 |  |  |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/changelog.md` | text | 2576 |  |  |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/design-doc/01-design-wrapper-packages-schema-fields-values-sources.md` | text | 9967 | Y | Y |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/diary/01-diary.md` | text | 16369 | Y | Y |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/docs/01-building-commands-with-new-api.md` | text | 26176 | Y | Y |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/index.md` | text | 2605 | Y | Y |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/planning/01-implementation-plan-wrapper-packages-example-program.md` | text | 7017 | Y | Y |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/planning/02-implementation-tracking-wrapper-packages-progress.md` | text | 3716 | Y |  |  |
| `ttmp/2025/12/17/001-REFACTOR-NEW-PACKAGES--refactor-add-schema-fields-values-sources-wrapper-packages-example-program/tasks.md` | text | 686 |  |  |  |
| `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/README.md` | text | 787 |  |  |  |
| `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/analysis/01-profile-settings-resolving-circular-dependency-between-profile-selection-and-profile-loading.md` | text | 11116 | Y | Y |  |
| `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/changelog.md` | text | 1009 |  |  |  |
| `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/index.md` | text | 2102 |  | Y |  |
| `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/reference/01-diary.md` | text | 12128 | Y | Y |  |
| `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/scripts/01-smoke-test-simple-inference-profiles.sh` | text | 9460 | Y |  |  |
| `ttmp/2025/12/18/001-GET-PROFILE-SETTINGS--get-profile-settings-after-defaults-env-flags-config/tasks.md` | text | 1584 |  | Y |  |
| `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/README.md` | text | 798 |  |  |  |
| `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/analysis/01-profiles-documentation-audit-update-plan.md` | text | 317 |  |  |  |
| `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/changelog.md` | text | 631 | Y |  |  |
| `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/index.md` | text | 1685 |  |  |  |
| `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/reference/01-diary.md` | text | 1771 |  |  |  |
| `ttmp/2025/12/18/002-DOCS-PROFILES--document-profile-loading-profiles-yaml-in-glazed-fix-geppetto-docs/tasks.md` | text | 1801 | Y | Y |  |
| `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/README.md` | text | 791 |  |  |  |
| `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/analysis/01-profile-helpers-refactor-proposal-bootstrap-parse-middleware-builder.md` | text | 6922 | Y | Y |  |
| `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/changelog.md` | text | 189 |  |  |  |
| `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/index.md` | text | 1957 | Y | Y |  |
| `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/reference/01-diary.md` | text | 1925 | Y | Y |  |
| `ttmp/2025/12/18/003-ADD-PROFILE-HELPERS--add-reusable-profile-settings-bootstrap-helpers-to-glazed/tasks.md` | text | 1072 |  | Y |  |
| `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/README.md` | text | 824 | Y | Y |  |
| `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/analysis/01-analysis-parameterlayer-to-pflag-flagset-conversion-for-early-logging.md` | text | 13463 | Y | Y |  |
| `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/changelog.md` | text | 808 | Y | Y |  |
| `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/index.md` | text | 1450 | Y | Y |  |
| `ttmp/2025/12/18/REFACTOR-EARLY-LOGGING-PARSE--refactor-early-logging-flag-parsing-to-use-parameterlayer-pflag-flagset-conversion/tasks.md` | text | 40 |  |  |  |
| `ttmp/2025/12/28/004-PROFILE-DEFAULT-NAME--honor-default-profile-name-in-missing-file-semantics/README.md` | text | 787 |  |  |  |
| `ttmp/2025/12/28/004-PROFILE-DEFAULT-NAME--honor-default-profile-name-in-missing-file-semantics/changelog.md` | text | 168 |  |  |  |
| `ttmp/2025/12/28/004-PROFILE-DEFAULT-NAME--honor-default-profile-name-in-missing-file-semantics/design-doc/01-default-profile-missing-file-analysis.md` | text | 2707 |  |  |  |
| `ttmp/2025/12/28/004-PROFILE-DEFAULT-NAME--honor-default-profile-name-in-missing-file-semantics/index.md` | text | 1612 |  |  |  |
| `ttmp/2025/12/28/004-PROFILE-DEFAULT-NAME--honor-default-profile-name-in-missing-file-semantics/reference/01-diary.md` | text | 2657 |  |  |  |
| `ttmp/2025/12/28/004-PROFILE-DEFAULT-NAME--honor-default-profile-name-in-missing-file-semantics/reference/02-report.md` | text | 1361 |  |  |  |
| `ttmp/2025/12/28/004-PROFILE-DEFAULT-NAME--honor-default-profile-name-in-missing-file-semantics/tasks.md` | text | 40 |  |  |  |
| `ttmp/2026/01/19/MO-GLAZE-001-UPDATE-DOCS--update-docs-examples-for-new-schema-fields-values-sources-api/README.md` | text | 931 |  |  |  |
| `ttmp/2026/01/19/MO-GLAZE-001-UPDATE-DOCS--update-docs-examples-for-new-schema-fields-values-sources-api/changelog.md` | text | 773 |  |  |  |
| `ttmp/2026/01/19/MO-GLAZE-001-UPDATE-DOCS--update-docs-examples-for-new-schema-fields-values-sources-api/diary/01-diary.md` | text | 8753 | Y | Y |  |
| `ttmp/2026/01/19/MO-GLAZE-001-UPDATE-DOCS--update-docs-examples-for-new-schema-fields-values-sources-api/index.md` | text | 1718 |  |  |  |
| `ttmp/2026/01/19/MO-GLAZE-001-UPDATE-DOCS--update-docs-examples-for-new-schema-fields-values-sources-api/tasks.md` | text | 40 |  |  |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/README.md` | text | 913 |  |  |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/01-documentation-deprecation-audit-layers-parameters-schema-fields-values-sources.md` | text | 51512 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/02-doc-deprecation-scan.json` | text | 76520 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/analysis/03-naming-options-and-rename-audit.md` | text | 18606 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/changelog.md` | text | 1114 |  |  |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/design-doc/01-no-return-rename-removing-alias-facades-and-migration-tool.md` | text | 9899 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/diary/01-diary.md` | text | 29227 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/index.md` | text | 1163 |  |  |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/reference/01-api-change-analysis-origin-main-head.md` | text | 5762 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/README.md` | text | 1222 |  |  |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/analysis_queries.sql` | text | 879 |  | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/doc_deprecation_scan.py` | text | 3814 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/import_git_diff_to_sqlite.py` | text | 16338 |  |  |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/scripts/rename_glazed_api.go` | text | 12278 | Y | Y | Y |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/tasks.md` | text | 898 |  | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/various/git-diff-origin-main-summary.json` | text | 3049 | Y | Y |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/various/git-diff-origin-main.sqlite` | binary | 1462272 |  |  |  |
| `ttmp/2026/02/02/GL-001-ADD-MIGRATION-DOCS--add-migration-docs-for-glazed-api-changes/various/rename-glazed-api-report.json` | text | 38651 | Y | Y |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/README.md` | text | 888 |  |  |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/analysis/01-exhaustive-parameter-layer-audit.md` | text | 343 | Y | Y |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/analysis/02-examples-rename-report.json` | text | 1525 | Y |  |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/changelog.md` | text | 1285 | Y | Y |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/design-doc/01-further-cleanup-and-renaming-plan.md` | text | 9821 | Y | Y |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/index.md` | text | 1795 | Y | Y |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/reference/01-diary.md` | text | 9886 | Y | Y | Y |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/sources/01-glazed-cleanup-notes.md` | text | 13416 | Y | Y |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/tasks.md` | text | 717 | Y | Y |  |
| `ttmp/2026/02/02/GL-002-FURTHER-CLEANUP--further-cleanup-and-renaming/various/01-parameter-layer-mentions.txt` | text | 531783 | Y | Y |  |
| `ttmp/_guidelines/code-review.md` | text | 779 |  |  |  |
| `ttmp/_guidelines/design-doc.md` | text | 846 |  |  |  |
| `ttmp/_guidelines/index.md` | text | 846 |  |  |  |
| `ttmp/_guidelines/log.md` | text | 516 |  |  |  |
| `ttmp/_guidelines/playbook.md` | text | 612 |  |  |  |
| `ttmp/_guidelines/reference.md` | text | 734 |  |  |  |
| `ttmp/_guidelines/script.md` | text | 621 | Y |  |  |
| `ttmp/_guidelines/skill.md` | text | 1720 |  |  |  |
| `ttmp/_guidelines/task-list.md` | text | 592 |  |  |  |
| `ttmp/_guidelines/tutorial.md` | text | 695 |  |  |  |
| `ttmp/_guidelines/workflow-docmgr-diary-git.md` | text | 7511 |  |  |  |
| `ttmp/_guidelines/working-note.md` | text | 636 |  |  |  |
| `ttmp/_templates/code-review.md` | text | 681 |  |  |  |
| `ttmp/_templates/design-doc.md` | text | 881 |  |  |  |
| `ttmp/_templates/index.md` | text | 981 |  |  |  |
| `ttmp/_templates/log.md` | text | 404 |  |  |  |
| `ttmp/_templates/playbook.md` | text | 565 |  |  |  |
| `ttmp/_templates/reference.md` | text | 608 |  |  |  |
| `ttmp/_templates/script.md` | text | 456 |  |  |  |
| `ttmp/_templates/skill.md` | text | 882 |  |  |  |
| `ttmp/_templates/task-list.md` | text | 376 |  |  |  |
| `ttmp/_templates/tutorial.md` | text | 685 |  |  |  |
| `ttmp/_templates/working-note.md` | text | 483 |  |  |  |
| `ttmp/vocabulary.yaml` | text | 3355 | Y | Y |  |
