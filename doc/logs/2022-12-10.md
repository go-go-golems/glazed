# Log 2022-12-10

Today, I finished up the --list flag for commands.

I am continuing to write out the documentation page for the help system,
but I'm really starting to feel the need for integration tests (and unit tests)
for all the functionality that I'm adding, and that is what I will focus on today.

I will probably start by building out cliopatra and keeping a list of command line 
flags to test for.

## Styled rendering

Currently glamour kind of blindly renders out at 80 columns with color, whatever the terminal 
or pipe might be.

https://github.com/wesen/glazed/issues/38

## Rendering out demo.gif 

I wonder if it would be fun to render out gifs for command line usage inside the markdown,
but it's probably easiest to just render out markdown for nwo (and more accessible!).

So cliopatra could take an input yaml, and render out a markdown of the description and
usage of the example.

## Help system should render out in json

Furthermore, in terms of keeping things structured into structured,
we should make the help system meta, in that it could use libglazed to render its information
in a structured format.

This can also be used to fill custom templates (we could have a collection of them) 
for not only creating a dynamic API for say, a help site (with search, for example),
but also to render out a static version of the site.

## Having command docs as markdown file makes it easy to extend CLI doc

In contrast to having to edit the code to add documentation to a command line app,
having the pages for a CLI help system in markdown in the repository makes it easy
for people to add examples and further documentation by editing the file on github 
directly, or an actual wiki (because we can embed the files from a submodule checkout
of the wiki into the CLI).

## Adding developer customazibility

Since the main goal of glazed is widespread adoption of rich CLI data handling
and help practices, there are two things to be balanced:

On the one hand, it should provide a quick and opinionated to get things going quickly
and remove the cognitive burden on the developer. 

On the other hand, we should provide developers who want to do more custom work
APIs that allow them to save a lot of effort by reusing the functionality that has
already been built as part of the opioninated approach.

I tried to delve into using middlewares for the data processing, which i'm not sure is 
the greatest design. For the help system, I want to bank more on using templates,
but I'm again not sure if that is enough, or if people need to be able to 
add their own hooks.

I think the solution is in both case to provide a decent `interface` (and I mean
interface in the golang sense) for the components that I already use internally
to make it easier for people to provide completely different implemntations.

Because go templates use so much introspection, there is a lot of duck typing that 
can be done there. I think getting the design right from the beginning is not
realistic, and while I should give it some thought and not be completely oblivious,
proper APIs will arise once I start writing more tools that actually use glazed.
